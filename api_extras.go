
/*
 * API Documentation
 *
 * Source of truth and network automation platform
 *
 * API version: 2.2.5 (2.2)
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package go-nautobot

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ExtrasApiService service
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasComputedFieldsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasComputedFieldsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasComputedFieldsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasComputedFieldsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasComputedFieldsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ComputedField
*/

type ExtrasApiExtrasComputedFieldsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasComputedFieldsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableComputedFieldRequest, localVarOptionals *ExtrasApiExtrasComputedFieldsBulkPartialUpdateOpts) ([]ComputedField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ComputedField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ComputedField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasComputedFieldsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ComputedField
*/

type ExtrasApiExtrasComputedFieldsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasComputedFieldsBulkUpdate(ctx context.Context, body []BulkWritableComputedFieldRequest, localVarOptionals *ExtrasApiExtrasComputedFieldsBulkUpdateOpts) ([]ComputedField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ComputedField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ComputedField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasComputedFieldsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ComputedField
*/

type ExtrasApiExtrasComputedFieldsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasComputedFieldsCreate(ctx context.Context, body ComputedFieldRequest, localVarOptionals *ExtrasApiExtrasComputedFieldsCreateOpts) (ComputedField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ComputedField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ComputedField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this computed field.
 * @param optional nil or *ExtrasApiExtrasComputedFieldsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasComputedFieldsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasComputedFieldsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasComputedFieldsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasComputedFieldsListOpts - Optional Parameters:
     * @param "ContentType" (optional.String) - 
     * @param "ContentTypeN" (optional.String) - 
     * @param "FallbackValue" (optional.Interface of []string) - 
     * @param "FallbackValueIc" (optional.Interface of []string) - 
     * @param "FallbackValueIe" (optional.Interface of []string) - 
     * @param "FallbackValueIew" (optional.Interface of []string) - 
     * @param "FallbackValueIre" (optional.Interface of []string) - 
     * @param "FallbackValueIsw" (optional.Interface of []string) - 
     * @param "FallbackValueN" (optional.Interface of []string) - 
     * @param "FallbackValueNic" (optional.Interface of []string) - 
     * @param "FallbackValueNie" (optional.Interface of []string) - 
     * @param "FallbackValueNiew" (optional.Interface of []string) - 
     * @param "FallbackValueNire" (optional.Interface of []string) - 
     * @param "FallbackValueNisw" (optional.Interface of []string) - 
     * @param "FallbackValueNre" (optional.Interface of []string) - 
     * @param "FallbackValueRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Key" (optional.Interface of []string) - 
     * @param "KeyIc" (optional.Interface of []string) - 
     * @param "KeyIe" (optional.Interface of []string) - 
     * @param "KeyIew" (optional.Interface of []string) - 
     * @param "KeyIre" (optional.Interface of []string) - 
     * @param "KeyIsw" (optional.Interface of []string) - 
     * @param "KeyN" (optional.Interface of []string) - 
     * @param "KeyNic" (optional.Interface of []string) - 
     * @param "KeyNie" (optional.Interface of []string) - 
     * @param "KeyNiew" (optional.Interface of []string) - 
     * @param "KeyNire" (optional.Interface of []string) - 
     * @param "KeyNisw" (optional.Interface of []string) - 
     * @param "KeyNre" (optional.Interface of []string) - 
     * @param "KeyRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Template" (optional.Interface of []string) - 
     * @param "TemplateIc" (optional.Interface of []string) - 
     * @param "TemplateIe" (optional.Interface of []string) - 
     * @param "TemplateIew" (optional.Interface of []string) - 
     * @param "TemplateIre" (optional.Interface of []string) - 
     * @param "TemplateIsw" (optional.Interface of []string) - 
     * @param "TemplateN" (optional.Interface of []string) - 
     * @param "TemplateNic" (optional.Interface of []string) - 
     * @param "TemplateNie" (optional.Interface of []string) - 
     * @param "TemplateNiew" (optional.Interface of []string) - 
     * @param "TemplateNire" (optional.Interface of []string) - 
     * @param "TemplateNisw" (optional.Interface of []string) - 
     * @param "TemplateNre" (optional.Interface of []string) - 
     * @param "TemplateRe" (optional.Interface of []string) - 
     * @param "Weight" (optional.Interface of []int32) - 
     * @param "WeightGt" (optional.Interface of []int32) - 
     * @param "WeightGte" (optional.Interface of []int32) - 
     * @param "WeightLt" (optional.Interface of []int32) - 
     * @param "WeightLte" (optional.Interface of []int32) - 
     * @param "WeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedComputedFieldList
*/

type ExtrasApiExtrasComputedFieldsListOpts struct {
    ContentType optional.String
    ContentTypeN optional.String
    FallbackValue optional.Interface
    FallbackValueIc optional.Interface
    FallbackValueIe optional.Interface
    FallbackValueIew optional.Interface
    FallbackValueIre optional.Interface
    FallbackValueIsw optional.Interface
    FallbackValueN optional.Interface
    FallbackValueNic optional.Interface
    FallbackValueNie optional.Interface
    FallbackValueNiew optional.Interface
    FallbackValueNire optional.Interface
    FallbackValueNisw optional.Interface
    FallbackValueNre optional.Interface
    FallbackValueRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Key optional.Interface
    KeyIc optional.Interface
    KeyIe optional.Interface
    KeyIew optional.Interface
    KeyIre optional.Interface
    KeyIsw optional.Interface
    KeyN optional.Interface
    KeyNic optional.Interface
    KeyNie optional.Interface
    KeyNiew optional.Interface
    KeyNire optional.Interface
    KeyNisw optional.Interface
    KeyNre optional.Interface
    KeyRe optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Template optional.Interface
    TemplateIc optional.Interface
    TemplateIe optional.Interface
    TemplateIew optional.Interface
    TemplateIre optional.Interface
    TemplateIsw optional.Interface
    TemplateN optional.Interface
    TemplateNic optional.Interface
    TemplateNie optional.Interface
    TemplateNiew optional.Interface
    TemplateNire optional.Interface
    TemplateNisw optional.Interface
    TemplateNre optional.Interface
    TemplateRe optional.Interface
    Weight optional.Interface
    WeightGt optional.Interface
    WeightGte optional.Interface
    WeightLt optional.Interface
    WeightLte optional.Interface
    WeightN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasComputedFieldsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasComputedFieldsListOpts) (PaginatedComputedFieldList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedComputedFieldList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentType.IsSet() {
		localVarQueryParams.Add("content_type", parameterToString(localVarOptionals.ContentType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeN.IsSet() {
		localVarQueryParams.Add("content_type__n", parameterToString(localVarOptionals.ContentTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValue.IsSet() {
		localVarQueryParams.Add("fallback_value", parameterToString(localVarOptionals.FallbackValue.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueIc.IsSet() {
		localVarQueryParams.Add("fallback_value__ic", parameterToString(localVarOptionals.FallbackValueIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueIe.IsSet() {
		localVarQueryParams.Add("fallback_value__ie", parameterToString(localVarOptionals.FallbackValueIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueIew.IsSet() {
		localVarQueryParams.Add("fallback_value__iew", parameterToString(localVarOptionals.FallbackValueIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueIre.IsSet() {
		localVarQueryParams.Add("fallback_value__ire", parameterToString(localVarOptionals.FallbackValueIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueIsw.IsSet() {
		localVarQueryParams.Add("fallback_value__isw", parameterToString(localVarOptionals.FallbackValueIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueN.IsSet() {
		localVarQueryParams.Add("fallback_value__n", parameterToString(localVarOptionals.FallbackValueN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueNic.IsSet() {
		localVarQueryParams.Add("fallback_value__nic", parameterToString(localVarOptionals.FallbackValueNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueNie.IsSet() {
		localVarQueryParams.Add("fallback_value__nie", parameterToString(localVarOptionals.FallbackValueNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueNiew.IsSet() {
		localVarQueryParams.Add("fallback_value__niew", parameterToString(localVarOptionals.FallbackValueNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueNire.IsSet() {
		localVarQueryParams.Add("fallback_value__nire", parameterToString(localVarOptionals.FallbackValueNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueNisw.IsSet() {
		localVarQueryParams.Add("fallback_value__nisw", parameterToString(localVarOptionals.FallbackValueNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueNre.IsSet() {
		localVarQueryParams.Add("fallback_value__nre", parameterToString(localVarOptionals.FallbackValueNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FallbackValueRe.IsSet() {
		localVarQueryParams.Add("fallback_value__re", parameterToString(localVarOptionals.FallbackValueRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Key.IsSet() {
		localVarQueryParams.Add("key", parameterToString(localVarOptionals.Key.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIc.IsSet() {
		localVarQueryParams.Add("key__ic", parameterToString(localVarOptionals.KeyIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIe.IsSet() {
		localVarQueryParams.Add("key__ie", parameterToString(localVarOptionals.KeyIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIew.IsSet() {
		localVarQueryParams.Add("key__iew", parameterToString(localVarOptionals.KeyIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIre.IsSet() {
		localVarQueryParams.Add("key__ire", parameterToString(localVarOptionals.KeyIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIsw.IsSet() {
		localVarQueryParams.Add("key__isw", parameterToString(localVarOptionals.KeyIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyN.IsSet() {
		localVarQueryParams.Add("key__n", parameterToString(localVarOptionals.KeyN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNic.IsSet() {
		localVarQueryParams.Add("key__nic", parameterToString(localVarOptionals.KeyNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNie.IsSet() {
		localVarQueryParams.Add("key__nie", parameterToString(localVarOptionals.KeyNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNiew.IsSet() {
		localVarQueryParams.Add("key__niew", parameterToString(localVarOptionals.KeyNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNire.IsSet() {
		localVarQueryParams.Add("key__nire", parameterToString(localVarOptionals.KeyNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNisw.IsSet() {
		localVarQueryParams.Add("key__nisw", parameterToString(localVarOptionals.KeyNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNre.IsSet() {
		localVarQueryParams.Add("key__nre", parameterToString(localVarOptionals.KeyNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyRe.IsSet() {
		localVarQueryParams.Add("key__re", parameterToString(localVarOptionals.KeyRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Template.IsSet() {
		localVarQueryParams.Add("template", parameterToString(localVarOptionals.Template.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateIc.IsSet() {
		localVarQueryParams.Add("template__ic", parameterToString(localVarOptionals.TemplateIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateIe.IsSet() {
		localVarQueryParams.Add("template__ie", parameterToString(localVarOptionals.TemplateIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateIew.IsSet() {
		localVarQueryParams.Add("template__iew", parameterToString(localVarOptionals.TemplateIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateIre.IsSet() {
		localVarQueryParams.Add("template__ire", parameterToString(localVarOptionals.TemplateIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateIsw.IsSet() {
		localVarQueryParams.Add("template__isw", parameterToString(localVarOptionals.TemplateIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateN.IsSet() {
		localVarQueryParams.Add("template__n", parameterToString(localVarOptionals.TemplateN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateNic.IsSet() {
		localVarQueryParams.Add("template__nic", parameterToString(localVarOptionals.TemplateNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateNie.IsSet() {
		localVarQueryParams.Add("template__nie", parameterToString(localVarOptionals.TemplateNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateNiew.IsSet() {
		localVarQueryParams.Add("template__niew", parameterToString(localVarOptionals.TemplateNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateNire.IsSet() {
		localVarQueryParams.Add("template__nire", parameterToString(localVarOptionals.TemplateNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateNisw.IsSet() {
		localVarQueryParams.Add("template__nisw", parameterToString(localVarOptionals.TemplateNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateNre.IsSet() {
		localVarQueryParams.Add("template__nre", parameterToString(localVarOptionals.TemplateNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateRe.IsSet() {
		localVarQueryParams.Add("template__re", parameterToString(localVarOptionals.TemplateRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Weight.IsSet() {
		localVarQueryParams.Add("weight", parameterToString(localVarOptionals.Weight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGt.IsSet() {
		localVarQueryParams.Add("weight__gt", parameterToString(localVarOptionals.WeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGte.IsSet() {
		localVarQueryParams.Add("weight__gte", parameterToString(localVarOptionals.WeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLt.IsSet() {
		localVarQueryParams.Add("weight__lt", parameterToString(localVarOptionals.WeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLte.IsSet() {
		localVarQueryParams.Add("weight__lte", parameterToString(localVarOptionals.WeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightN.IsSet() {
		localVarQueryParams.Add("weight__n", parameterToString(localVarOptionals.WeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedComputedFieldList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this computed field.
 * @param optional nil or *ExtrasApiExtrasComputedFieldsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasComputedFieldsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasComputedFieldsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasComputedFieldsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this computed field.
 * @param optional nil or *ExtrasApiExtrasComputedFieldsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasComputedFieldsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasComputedFieldsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasComputedFieldsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this computed field.
 * @param optional nil or *ExtrasApiExtrasComputedFieldsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedComputedFieldRequest) - 
     * @param "Format" (optional.String) - 
@return ComputedField
*/

type ExtrasApiExtrasComputedFieldsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasComputedFieldsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasComputedFieldsPartialUpdateOpts) (ComputedField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ComputedField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ComputedField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this computed field.
 * @param optional nil or *ExtrasApiExtrasComputedFieldsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ComputedField
*/

type ExtrasApiExtrasComputedFieldsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasComputedFieldsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasComputedFieldsRetrieveOpts) (ComputedField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ComputedField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ComputedField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this computed field.
 * @param optional nil or *ExtrasApiExtrasComputedFieldsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ComputedField
*/

type ExtrasApiExtrasComputedFieldsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasComputedFieldsUpdate(ctx context.Context, body ComputedFieldRequest, id string, localVarOptionals *ExtrasApiExtrasComputedFieldsUpdateOpts) (ComputedField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ComputedField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/computed-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ComputedField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of config context schema objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasConfigContextSchemasBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasConfigContextSchemasBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of config context schema objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConfigContextSchema
*/

type ExtrasApiExtrasConfigContextSchemasBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableConfigContextSchemaRequest, localVarOptionals *ExtrasApiExtrasConfigContextSchemasBulkPartialUpdateOpts) ([]ConfigContextSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConfigContextSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConfigContextSchema
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of config context schema objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConfigContextSchema
*/

type ExtrasApiExtrasConfigContextSchemasBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasBulkUpdate(ctx context.Context, body []BulkWritableConfigContextSchemaRequest, localVarOptionals *ExtrasApiExtrasConfigContextSchemasBulkUpdateOpts) ([]ConfigContextSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConfigContextSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConfigContextSchema
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more config context schema objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConfigContextSchema
*/

type ExtrasApiExtrasConfigContextSchemasCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasCreate(ctx context.Context, body ConfigContextSchemaRequest, localVarOptionals *ExtrasApiExtrasConfigContextSchemasCreateOpts) (ConfigContextSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContextSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ConfigContextSchema
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a config context schema object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this config context schema.
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasConfigContextSchemasDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasConfigContextSchemasDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of config context schema objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "OwnerContentType" (optional.String) - 
     * @param "OwnerContentTypeIsnull" (optional.Bool) - 
     * @param "OwnerContentTypeN" (optional.String) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedConfigContextSchemaList
*/

type ExtrasApiExtrasConfigContextSchemasListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    OwnerContentType optional.String
    OwnerContentTypeIsnull optional.Bool
    OwnerContentTypeN optional.String
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasList(ctx context.Context, localVarOptionals *ExtrasApiExtrasConfigContextSchemasListOpts) (PaginatedConfigContextSchemaList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedConfigContextSchemaList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentType.IsSet() {
		localVarQueryParams.Add("owner_content_type", parameterToString(localVarOptionals.OwnerContentType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentTypeIsnull.IsSet() {
		localVarQueryParams.Add("owner_content_type__isnull", parameterToString(localVarOptionals.OwnerContentTypeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentTypeN.IsSet() {
		localVarQueryParams.Add("owner_content_type__n", parameterToString(localVarOptionals.OwnerContentTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedConfigContextSchemaList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this config context schema.
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasConfigContextSchemasNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasConfigContextSchemasNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this config context schema.
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasConfigContextSchemasNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasConfigContextSchemasNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a config context schema object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this config context schema.
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedConfigContextSchemaRequest) - 
     * @param "Format" (optional.String) - 
@return ConfigContextSchema
*/

type ExtrasApiExtrasConfigContextSchemasPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasConfigContextSchemasPartialUpdateOpts) (ConfigContextSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContextSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContextSchema
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a config context schema object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this config context schema.
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ConfigContextSchema
*/

type ExtrasApiExtrasConfigContextSchemasRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasConfigContextSchemasRetrieveOpts) (ConfigContextSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContextSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContextSchema
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a config context schema object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this config context schema.
 * @param optional nil or *ExtrasApiExtrasConfigContextSchemasUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConfigContextSchema
*/

type ExtrasApiExtrasConfigContextSchemasUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextSchemasUpdate(ctx context.Context, body ConfigContextSchemaRequest, id string, localVarOptionals *ExtrasApiExtrasConfigContextSchemasUpdateOpts) (ConfigContextSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContextSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-context-schemas/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContextSchema
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of config context objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasConfigContextsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasConfigContextsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasConfigContextsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of config context objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasConfigContextsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConfigContext
*/

type ExtrasApiExtrasConfigContextsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableConfigContextRequest, localVarOptionals *ExtrasApiExtrasConfigContextsBulkPartialUpdateOpts) ([]ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of config context objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasConfigContextsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConfigContext
*/

type ExtrasApiExtrasConfigContextsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextsBulkUpdate(ctx context.Context, body []BulkWritableConfigContextRequest, localVarOptionals *ExtrasApiExtrasConfigContextsBulkUpdateOpts) ([]ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more config context objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasConfigContextsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConfigContext
*/

type ExtrasApiExtrasConfigContextsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextsCreate(ctx context.Context, body ConfigContextRequest, localVarOptionals *ExtrasApiExtrasConfigContextsCreateOpts) (ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a config context object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this config context.
 * @param optional nil or *ExtrasApiExtrasConfigContextsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasConfigContextsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasConfigContextsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of config context objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasConfigContextsListOpts - Optional Parameters:
     * @param "ClusterGroup" (optional.Interface of []string) - 
     * @param "ClusterGroupN" (optional.Interface of []string) - 
     * @param "ClusterGroupId" (optional.Interface of []string) -  Cluster group (ID) - Deprecated (use cluster_group filter)
     * @param "ClusterGroupIdN" (optional.Interface of []string) -  Cluster group (ID) - Deprecated (use cluster_group filter)
     * @param "ClusterId" (optional.Interface of []string) -  Cluster (ID)
     * @param "ClusterIdN" (optional.Interface of []string) -  Cluster (ID)
     * @param "DeviceRedundancyGroup" (optional.Interface of []string) - 
     * @param "DeviceRedundancyGroupN" (optional.Interface of []string) - 
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "DeviceTypeId" (optional.Interface of []string) -  Device Type (ID) - Deprecated (use device_type filter)
     * @param "DeviceTypeIdN" (optional.Interface of []string) -  Device Type (ID) - Deprecated (use device_type filter)
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "IsActive" (optional.Bool) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "LocationId" (optional.Interface of []string) -  Location (ID) - Deprecated (use location filter)
     * @param "LocationIdN" (optional.Interface of []string) -  Location (ID) - Deprecated (use location filter)
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "OwnerContentType" (optional.String) - 
     * @param "OwnerContentTypeIsnull" (optional.Bool) - 
     * @param "OwnerContentTypeN" (optional.String) - 
     * @param "OwnerObjectId" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIc" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIe" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIew" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIre" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIsnull" (optional.Bool) - 
     * @param "OwnerObjectIdIsw" (optional.Interface of []string) - 
     * @param "OwnerObjectIdN" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNic" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNie" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNiew" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNire" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNisw" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNre" (optional.Interface of []string) - 
     * @param "OwnerObjectIdRe" (optional.Interface of []string) - 
     * @param "Platform" (optional.Interface of []string) - 
     * @param "PlatformN" (optional.Interface of []string) - 
     * @param "PlatformId" (optional.Interface of []string) -  Platform (ID) - Deprecated (use platform filter)
     * @param "PlatformIdN" (optional.Interface of []string) -  Platform (ID) - Deprecated (use platform filter)
     * @param "Q" (optional.String) -  Search
     * @param "Role" (optional.Interface of []string) - 
     * @param "RoleN" (optional.Interface of []string) - 
     * @param "Schema" (optional.Interface of []string) - 
     * @param "SchemaIsnull" (optional.Bool) - 
     * @param "SchemaN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tag" (optional.Interface of []string) -  Tag (name)
     * @param "TagN" (optional.Interface of []string) -  Tag (name)
     * @param "Tenant" (optional.Interface of []string) - 
     * @param "TenantN" (optional.Interface of []string) - 
     * @param "TenantGroup" (optional.Interface of []string) - 
     * @param "TenantGroupN" (optional.Interface of []string) - 
     * @param "TenantGroupId" (optional.Interface of []string) -  Tenant group (ID) - Deprecated (use tenant_group filter)
     * @param "TenantGroupIdN" (optional.Interface of []string) -  Tenant group (ID) - Deprecated (use tenant_group filter)
     * @param "TenantId" (optional.Interface of []string) -  Tenant (ID) - Deprecated (use tenant filter)
     * @param "TenantIdN" (optional.Interface of []string) -  Tenant (ID) - Deprecated (use tenant filter)
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedConfigContextList
*/

type ExtrasApiExtrasConfigContextsListOpts struct {
    ClusterGroup optional.Interface
    ClusterGroupN optional.Interface
    ClusterGroupId optional.Interface
    ClusterGroupIdN optional.Interface
    ClusterId optional.Interface
    ClusterIdN optional.Interface
    DeviceRedundancyGroup optional.Interface
    DeviceRedundancyGroupN optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    DeviceTypeId optional.Interface
    DeviceTypeIdN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    IsActive optional.Bool
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    LocationId optional.Interface
    LocationIdN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    OwnerContentType optional.String
    OwnerContentTypeIsnull optional.Bool
    OwnerContentTypeN optional.String
    OwnerObjectId optional.Interface
    OwnerObjectIdIc optional.Interface
    OwnerObjectIdIe optional.Interface
    OwnerObjectIdIew optional.Interface
    OwnerObjectIdIre optional.Interface
    OwnerObjectIdIsnull optional.Bool
    OwnerObjectIdIsw optional.Interface
    OwnerObjectIdN optional.Interface
    OwnerObjectIdNic optional.Interface
    OwnerObjectIdNie optional.Interface
    OwnerObjectIdNiew optional.Interface
    OwnerObjectIdNire optional.Interface
    OwnerObjectIdNisw optional.Interface
    OwnerObjectIdNre optional.Interface
    OwnerObjectIdRe optional.Interface
    Platform optional.Interface
    PlatformN optional.Interface
    PlatformId optional.Interface
    PlatformIdN optional.Interface
    Q optional.String
    Role optional.Interface
    RoleN optional.Interface
    Schema optional.Interface
    SchemaIsnull optional.Bool
    SchemaN optional.Interface
    Sort optional.String
    Tag optional.Interface
    TagN optional.Interface
    Tenant optional.Interface
    TenantN optional.Interface
    TenantGroup optional.Interface
    TenantGroupN optional.Interface
    TenantGroupId optional.Interface
    TenantGroupIdN optional.Interface
    TenantId optional.Interface
    TenantIdN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasConfigContextsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasConfigContextsListOpts) (PaginatedConfigContextList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedConfigContextList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ClusterGroup.IsSet() {
		localVarQueryParams.Add("cluster_group", parameterToString(localVarOptionals.ClusterGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterGroupN.IsSet() {
		localVarQueryParams.Add("cluster_group__n", parameterToString(localVarOptionals.ClusterGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterGroupId.IsSet() {
		localVarQueryParams.Add("cluster_group_id", parameterToString(localVarOptionals.ClusterGroupId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterGroupIdN.IsSet() {
		localVarQueryParams.Add("cluster_group_id__n", parameterToString(localVarOptionals.ClusterGroupIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterId.IsSet() {
		localVarQueryParams.Add("cluster_id", parameterToString(localVarOptionals.ClusterId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterIdN.IsSet() {
		localVarQueryParams.Add("cluster_id__n", parameterToString(localVarOptionals.ClusterIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroup.IsSet() {
		localVarQueryParams.Add("device_redundancy_group", parameterToString(localVarOptionals.DeviceRedundancyGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupN.IsSet() {
		localVarQueryParams.Add("device_redundancy_group__n", parameterToString(localVarOptionals.DeviceRedundancyGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeId.IsSet() {
		localVarQueryParams.Add("device_type_id", parameterToString(localVarOptionals.DeviceTypeId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeIdN.IsSet() {
		localVarQueryParams.Add("device_type_id__n", parameterToString(localVarOptionals.DeviceTypeIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsActive.IsSet() {
		localVarQueryParams.Add("is_active", parameterToString(localVarOptionals.IsActive.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationId.IsSet() {
		localVarQueryParams.Add("location_id", parameterToString(localVarOptionals.LocationId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationIdN.IsSet() {
		localVarQueryParams.Add("location_id__n", parameterToString(localVarOptionals.LocationIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentType.IsSet() {
		localVarQueryParams.Add("owner_content_type", parameterToString(localVarOptionals.OwnerContentType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentTypeIsnull.IsSet() {
		localVarQueryParams.Add("owner_content_type__isnull", parameterToString(localVarOptionals.OwnerContentTypeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentTypeN.IsSet() {
		localVarQueryParams.Add("owner_content_type__n", parameterToString(localVarOptionals.OwnerContentTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectId.IsSet() {
		localVarQueryParams.Add("owner_object_id", parameterToString(localVarOptionals.OwnerObjectId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIc.IsSet() {
		localVarQueryParams.Add("owner_object_id__ic", parameterToString(localVarOptionals.OwnerObjectIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIe.IsSet() {
		localVarQueryParams.Add("owner_object_id__ie", parameterToString(localVarOptionals.OwnerObjectIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIew.IsSet() {
		localVarQueryParams.Add("owner_object_id__iew", parameterToString(localVarOptionals.OwnerObjectIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIre.IsSet() {
		localVarQueryParams.Add("owner_object_id__ire", parameterToString(localVarOptionals.OwnerObjectIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIsnull.IsSet() {
		localVarQueryParams.Add("owner_object_id__isnull", parameterToString(localVarOptionals.OwnerObjectIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIsw.IsSet() {
		localVarQueryParams.Add("owner_object_id__isw", parameterToString(localVarOptionals.OwnerObjectIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdN.IsSet() {
		localVarQueryParams.Add("owner_object_id__n", parameterToString(localVarOptionals.OwnerObjectIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNic.IsSet() {
		localVarQueryParams.Add("owner_object_id__nic", parameterToString(localVarOptionals.OwnerObjectIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNie.IsSet() {
		localVarQueryParams.Add("owner_object_id__nie", parameterToString(localVarOptionals.OwnerObjectIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNiew.IsSet() {
		localVarQueryParams.Add("owner_object_id__niew", parameterToString(localVarOptionals.OwnerObjectIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNire.IsSet() {
		localVarQueryParams.Add("owner_object_id__nire", parameterToString(localVarOptionals.OwnerObjectIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNisw.IsSet() {
		localVarQueryParams.Add("owner_object_id__nisw", parameterToString(localVarOptionals.OwnerObjectIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNre.IsSet() {
		localVarQueryParams.Add("owner_object_id__nre", parameterToString(localVarOptionals.OwnerObjectIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdRe.IsSet() {
		localVarQueryParams.Add("owner_object_id__re", parameterToString(localVarOptionals.OwnerObjectIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Platform.IsSet() {
		localVarQueryParams.Add("platform", parameterToString(localVarOptionals.Platform.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformN.IsSet() {
		localVarQueryParams.Add("platform__n", parameterToString(localVarOptionals.PlatformN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformId.IsSet() {
		localVarQueryParams.Add("platform_id", parameterToString(localVarOptionals.PlatformId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformIdN.IsSet() {
		localVarQueryParams.Add("platform_id__n", parameterToString(localVarOptionals.PlatformIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Role.IsSet() {
		localVarQueryParams.Add("role", parameterToString(localVarOptionals.Role.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RoleN.IsSet() {
		localVarQueryParams.Add("role__n", parameterToString(localVarOptionals.RoleN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Schema.IsSet() {
		localVarQueryParams.Add("schema", parameterToString(localVarOptionals.Schema.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SchemaIsnull.IsSet() {
		localVarQueryParams.Add("schema__isnull", parameterToString(localVarOptionals.SchemaIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SchemaN.IsSet() {
		localVarQueryParams.Add("schema__n", parameterToString(localVarOptionals.SchemaN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagN.IsSet() {
		localVarQueryParams.Add("tag__n", parameterToString(localVarOptionals.TagN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupId.IsSet() {
		localVarQueryParams.Add("tenant_group_id", parameterToString(localVarOptionals.TenantGroupId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIdN.IsSet() {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(localVarOptionals.TenantGroupIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdN.IsSet() {
		localVarQueryParams.Add("tenant_id__n", parameterToString(localVarOptionals.TenantIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedConfigContextList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this config context.
 * @param optional nil or *ExtrasApiExtrasConfigContextsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasConfigContextsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasConfigContextsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this config context.
 * @param optional nil or *ExtrasApiExtrasConfigContextsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasConfigContextsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasConfigContextsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasConfigContextsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a config context object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this config context.
 * @param optional nil or *ExtrasApiExtrasConfigContextsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedConfigContextRequest) - 
     * @param "Format" (optional.String) - 
@return ConfigContext
*/

type ExtrasApiExtrasConfigContextsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasConfigContextsPartialUpdateOpts) (ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a config context object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this config context.
 * @param optional nil or *ExtrasApiExtrasConfigContextsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ConfigContext
*/

type ExtrasApiExtrasConfigContextsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasConfigContextsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasConfigContextsRetrieveOpts) (ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a config context object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this config context.
 * @param optional nil or *ExtrasApiExtrasConfigContextsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConfigContext
*/

type ExtrasApiExtrasConfigContextsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasConfigContextsUpdate(ctx context.Context, body ConfigContextRequest, id string, localVarOptionals *ExtrasApiExtrasConfigContextsUpdateOpts) (ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of contact association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasContactAssociationsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasContactAssociationsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactAssociationsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasContactAssociationsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of contact association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasContactAssociationsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ContactAssociation
*/

type ExtrasApiExtrasContactAssociationsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactAssociationsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableContactAssociationRequest, localVarOptionals *ExtrasApiExtrasContactAssociationsBulkPartialUpdateOpts) ([]ContactAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ContactAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ContactAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of contact association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasContactAssociationsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ContactAssociation
*/

type ExtrasApiExtrasContactAssociationsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactAssociationsBulkUpdate(ctx context.Context, body []BulkWritableContactAssociationRequest, localVarOptionals *ExtrasApiExtrasContactAssociationsBulkUpdateOpts) ([]ContactAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ContactAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ContactAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more contact association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasContactAssociationsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ContactAssociation
*/

type ExtrasApiExtrasContactAssociationsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactAssociationsCreate(ctx context.Context, body ContactAssociationRequest, localVarOptionals *ExtrasApiExtrasContactAssociationsCreateOpts) (ContactAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ContactAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ContactAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a contact association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this contact association.
 * @param optional nil or *ExtrasApiExtrasContactAssociationsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasContactAssociationsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactAssociationsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasContactAssociationsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of contact association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasContactAssociationsListOpts - Optional Parameters:
     * @param "AssociatedObjectId" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdIc" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdIe" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdIew" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdIre" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdIsw" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdN" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdNic" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdNie" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdNiew" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdNire" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdNisw" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdNre" (optional.Interface of []string) - 
     * @param "AssociatedObjectIdRe" (optional.Interface of []string) - 
     * @param "AssociatedObjectType" (optional.String) - 
     * @param "AssociatedObjectTypeIsnull" (optional.Bool) - 
     * @param "AssociatedObjectTypeN" (optional.String) - 
     * @param "Contact" (optional.Interface of []string) - 
     * @param "ContactIsnull" (optional.Bool) - 
     * @param "ContactN" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Role" (optional.Interface of []string) - 
     * @param "RoleN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Team" (optional.Interface of []string) - 
     * @param "TeamIsnull" (optional.Bool) - 
     * @param "TeamN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedContactAssociationList
*/

type ExtrasApiExtrasContactAssociationsListOpts struct {
    AssociatedObjectId optional.Interface
    AssociatedObjectIdIc optional.Interface
    AssociatedObjectIdIe optional.Interface
    AssociatedObjectIdIew optional.Interface
    AssociatedObjectIdIre optional.Interface
    AssociatedObjectIdIsw optional.Interface
    AssociatedObjectIdN optional.Interface
    AssociatedObjectIdNic optional.Interface
    AssociatedObjectIdNie optional.Interface
    AssociatedObjectIdNiew optional.Interface
    AssociatedObjectIdNire optional.Interface
    AssociatedObjectIdNisw optional.Interface
    AssociatedObjectIdNre optional.Interface
    AssociatedObjectIdRe optional.Interface
    AssociatedObjectType optional.String
    AssociatedObjectTypeIsnull optional.Bool
    AssociatedObjectTypeN optional.String
    Contact optional.Interface
    ContactIsnull optional.Bool
    ContactN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Role optional.Interface
    RoleN optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Team optional.Interface
    TeamIsnull optional.Bool
    TeamN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasContactAssociationsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasContactAssociationsListOpts) (PaginatedContactAssociationList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedContactAssociationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AssociatedObjectId.IsSet() {
		localVarQueryParams.Add("associated_object_id", parameterToString(localVarOptionals.AssociatedObjectId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdIc.IsSet() {
		localVarQueryParams.Add("associated_object_id__ic", parameterToString(localVarOptionals.AssociatedObjectIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdIe.IsSet() {
		localVarQueryParams.Add("associated_object_id__ie", parameterToString(localVarOptionals.AssociatedObjectIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdIew.IsSet() {
		localVarQueryParams.Add("associated_object_id__iew", parameterToString(localVarOptionals.AssociatedObjectIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdIre.IsSet() {
		localVarQueryParams.Add("associated_object_id__ire", parameterToString(localVarOptionals.AssociatedObjectIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdIsw.IsSet() {
		localVarQueryParams.Add("associated_object_id__isw", parameterToString(localVarOptionals.AssociatedObjectIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdN.IsSet() {
		localVarQueryParams.Add("associated_object_id__n", parameterToString(localVarOptionals.AssociatedObjectIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdNic.IsSet() {
		localVarQueryParams.Add("associated_object_id__nic", parameterToString(localVarOptionals.AssociatedObjectIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdNie.IsSet() {
		localVarQueryParams.Add("associated_object_id__nie", parameterToString(localVarOptionals.AssociatedObjectIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdNiew.IsSet() {
		localVarQueryParams.Add("associated_object_id__niew", parameterToString(localVarOptionals.AssociatedObjectIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdNire.IsSet() {
		localVarQueryParams.Add("associated_object_id__nire", parameterToString(localVarOptionals.AssociatedObjectIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdNisw.IsSet() {
		localVarQueryParams.Add("associated_object_id__nisw", parameterToString(localVarOptionals.AssociatedObjectIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdNre.IsSet() {
		localVarQueryParams.Add("associated_object_id__nre", parameterToString(localVarOptionals.AssociatedObjectIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectIdRe.IsSet() {
		localVarQueryParams.Add("associated_object_id__re", parameterToString(localVarOptionals.AssociatedObjectIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectType.IsSet() {
		localVarQueryParams.Add("associated_object_type", parameterToString(localVarOptionals.AssociatedObjectType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectTypeIsnull.IsSet() {
		localVarQueryParams.Add("associated_object_type__isnull", parameterToString(localVarOptionals.AssociatedObjectTypeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssociatedObjectTypeN.IsSet() {
		localVarQueryParams.Add("associated_object_type__n", parameterToString(localVarOptionals.AssociatedObjectTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Contact.IsSet() {
		localVarQueryParams.Add("contact", parameterToString(localVarOptionals.Contact.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactIsnull.IsSet() {
		localVarQueryParams.Add("contact__isnull", parameterToString(localVarOptionals.ContactIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContactN.IsSet() {
		localVarQueryParams.Add("contact__n", parameterToString(localVarOptionals.ContactN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Role.IsSet() {
		localVarQueryParams.Add("role", parameterToString(localVarOptionals.Role.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RoleN.IsSet() {
		localVarQueryParams.Add("role__n", parameterToString(localVarOptionals.RoleN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Team.IsSet() {
		localVarQueryParams.Add("team", parameterToString(localVarOptionals.Team.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TeamIsnull.IsSet() {
		localVarQueryParams.Add("team__isnull", parameterToString(localVarOptionals.TeamIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TeamN.IsSet() {
		localVarQueryParams.Add("team__n", parameterToString(localVarOptionals.TeamN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedContactAssociationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this contact association.
 * @param optional nil or *ExtrasApiExtrasContactAssociationsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasContactAssociationsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactAssociationsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasContactAssociationsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this contact association.
 * @param optional nil or *ExtrasApiExtrasContactAssociationsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasContactAssociationsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasContactAssociationsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasContactAssociationsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a contact association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this contact association.
 * @param optional nil or *ExtrasApiExtrasContactAssociationsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedContactAssociationRequest) - 
     * @param "Format" (optional.String) - 
@return ContactAssociation
*/

type ExtrasApiExtrasContactAssociationsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactAssociationsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasContactAssociationsPartialUpdateOpts) (ContactAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ContactAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ContactAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a contact association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this contact association.
 * @param optional nil or *ExtrasApiExtrasContactAssociationsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ContactAssociation
*/

type ExtrasApiExtrasContactAssociationsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasContactAssociationsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasContactAssociationsRetrieveOpts) (ContactAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ContactAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ContactAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a contact association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this contact association.
 * @param optional nil or *ExtrasApiExtrasContactAssociationsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ContactAssociation
*/

type ExtrasApiExtrasContactAssociationsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactAssociationsUpdate(ctx context.Context, body ContactAssociationRequest, id string, localVarOptionals *ExtrasApiExtrasContactAssociationsUpdateOpts) (ContactAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ContactAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contact-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ContactAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of contact objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasContactsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasContactsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasContactsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of contact objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasContactsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Contact
*/

type ExtrasApiExtrasContactsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableContactRequest, localVarOptionals *ExtrasApiExtrasContactsBulkPartialUpdateOpts) ([]Contact, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Contact
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Contact
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of contact objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasContactsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Contact
*/

type ExtrasApiExtrasContactsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactsBulkUpdate(ctx context.Context, body []BulkWritableContactRequest, localVarOptionals *ExtrasApiExtrasContactsBulkUpdateOpts) ([]Contact, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Contact
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Contact
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more contact objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasContactsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Contact
*/

type ExtrasApiExtrasContactsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactsCreate(ctx context.Context, body ContactRequest, localVarOptionals *ExtrasApiExtrasContactsCreateOpts) (Contact, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Contact
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Contact
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a contact object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this contact.
 * @param optional nil or *ExtrasApiExtrasContactsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasContactsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasContactsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of contact objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasContactsListOpts - Optional Parameters:
     * @param "Address" (optional.Interface of []string) - 
     * @param "AddressIc" (optional.Interface of []string) - 
     * @param "AddressIe" (optional.Interface of []string) - 
     * @param "AddressIew" (optional.Interface of []string) - 
     * @param "AddressIre" (optional.Interface of []string) - 
     * @param "AddressIsw" (optional.Interface of []string) - 
     * @param "AddressN" (optional.Interface of []string) - 
     * @param "AddressNic" (optional.Interface of []string) - 
     * @param "AddressNie" (optional.Interface of []string) - 
     * @param "AddressNiew" (optional.Interface of []string) - 
     * @param "AddressNire" (optional.Interface of []string) - 
     * @param "AddressNisw" (optional.Interface of []string) - 
     * @param "AddressNre" (optional.Interface of []string) - 
     * @param "AddressRe" (optional.Interface of []string) - 
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Email" (optional.Interface of []string) - 
     * @param "EmailIc" (optional.Interface of []string) - 
     * @param "EmailIe" (optional.Interface of []string) - 
     * @param "EmailIew" (optional.Interface of []string) - 
     * @param "EmailIre" (optional.Interface of []string) - 
     * @param "EmailIsw" (optional.Interface of []string) - 
     * @param "EmailN" (optional.Interface of []string) - 
     * @param "EmailNic" (optional.Interface of []string) - 
     * @param "EmailNie" (optional.Interface of []string) - 
     * @param "EmailNiew" (optional.Interface of []string) - 
     * @param "EmailNire" (optional.Interface of []string) - 
     * @param "EmailNisw" (optional.Interface of []string) - 
     * @param "EmailNre" (optional.Interface of []string) - 
     * @param "EmailRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Phone" (optional.Interface of []string) - 
     * @param "PhoneIc" (optional.Interface of []string) - 
     * @param "PhoneIe" (optional.Interface of []string) - 
     * @param "PhoneIew" (optional.Interface of []string) - 
     * @param "PhoneIre" (optional.Interface of []string) - 
     * @param "PhoneIsw" (optional.Interface of []string) - 
     * @param "PhoneN" (optional.Interface of []string) - 
     * @param "PhoneNic" (optional.Interface of []string) - 
     * @param "PhoneNie" (optional.Interface of []string) - 
     * @param "PhoneNiew" (optional.Interface of []string) - 
     * @param "PhoneNire" (optional.Interface of []string) - 
     * @param "PhoneNisw" (optional.Interface of []string) - 
     * @param "PhoneNre" (optional.Interface of []string) - 
     * @param "PhoneRe" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "SimilarToLocationData" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedContactList
*/

type ExtrasApiExtrasContactsListOpts struct {
    Address optional.Interface
    AddressIc optional.Interface
    AddressIe optional.Interface
    AddressIew optional.Interface
    AddressIre optional.Interface
    AddressIsw optional.Interface
    AddressN optional.Interface
    AddressNic optional.Interface
    AddressNie optional.Interface
    AddressNiew optional.Interface
    AddressNire optional.Interface
    AddressNisw optional.Interface
    AddressNre optional.Interface
    AddressRe optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Email optional.Interface
    EmailIc optional.Interface
    EmailIe optional.Interface
    EmailIew optional.Interface
    EmailIre optional.Interface
    EmailIsw optional.Interface
    EmailN optional.Interface
    EmailNic optional.Interface
    EmailNie optional.Interface
    EmailNiew optional.Interface
    EmailNire optional.Interface
    EmailNisw optional.Interface
    EmailNre optional.Interface
    EmailRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Phone optional.Interface
    PhoneIc optional.Interface
    PhoneIe optional.Interface
    PhoneIew optional.Interface
    PhoneIre optional.Interface
    PhoneIsw optional.Interface
    PhoneN optional.Interface
    PhoneNic optional.Interface
    PhoneNie optional.Interface
    PhoneNiew optional.Interface
    PhoneNire optional.Interface
    PhoneNisw optional.Interface
    PhoneNre optional.Interface
    PhoneRe optional.Interface
    Q optional.String
    SimilarToLocationData optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasContactsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasContactsListOpts) (PaginatedContactList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedContactList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Address.IsSet() {
		localVarQueryParams.Add("address", parameterToString(localVarOptionals.Address.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIc.IsSet() {
		localVarQueryParams.Add("address__ic", parameterToString(localVarOptionals.AddressIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIe.IsSet() {
		localVarQueryParams.Add("address__ie", parameterToString(localVarOptionals.AddressIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIew.IsSet() {
		localVarQueryParams.Add("address__iew", parameterToString(localVarOptionals.AddressIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIre.IsSet() {
		localVarQueryParams.Add("address__ire", parameterToString(localVarOptionals.AddressIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIsw.IsSet() {
		localVarQueryParams.Add("address__isw", parameterToString(localVarOptionals.AddressIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressN.IsSet() {
		localVarQueryParams.Add("address__n", parameterToString(localVarOptionals.AddressN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNic.IsSet() {
		localVarQueryParams.Add("address__nic", parameterToString(localVarOptionals.AddressNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNie.IsSet() {
		localVarQueryParams.Add("address__nie", parameterToString(localVarOptionals.AddressNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNiew.IsSet() {
		localVarQueryParams.Add("address__niew", parameterToString(localVarOptionals.AddressNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNire.IsSet() {
		localVarQueryParams.Add("address__nire", parameterToString(localVarOptionals.AddressNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNisw.IsSet() {
		localVarQueryParams.Add("address__nisw", parameterToString(localVarOptionals.AddressNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNre.IsSet() {
		localVarQueryParams.Add("address__nre", parameterToString(localVarOptionals.AddressNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressRe.IsSet() {
		localVarQueryParams.Add("address__re", parameterToString(localVarOptionals.AddressRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarQueryParams.Add("email", parameterToString(localVarOptionals.Email.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIc.IsSet() {
		localVarQueryParams.Add("email__ic", parameterToString(localVarOptionals.EmailIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIe.IsSet() {
		localVarQueryParams.Add("email__ie", parameterToString(localVarOptionals.EmailIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIew.IsSet() {
		localVarQueryParams.Add("email__iew", parameterToString(localVarOptionals.EmailIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIre.IsSet() {
		localVarQueryParams.Add("email__ire", parameterToString(localVarOptionals.EmailIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIsw.IsSet() {
		localVarQueryParams.Add("email__isw", parameterToString(localVarOptionals.EmailIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailN.IsSet() {
		localVarQueryParams.Add("email__n", parameterToString(localVarOptionals.EmailN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNic.IsSet() {
		localVarQueryParams.Add("email__nic", parameterToString(localVarOptionals.EmailNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNie.IsSet() {
		localVarQueryParams.Add("email__nie", parameterToString(localVarOptionals.EmailNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNiew.IsSet() {
		localVarQueryParams.Add("email__niew", parameterToString(localVarOptionals.EmailNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNire.IsSet() {
		localVarQueryParams.Add("email__nire", parameterToString(localVarOptionals.EmailNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNisw.IsSet() {
		localVarQueryParams.Add("email__nisw", parameterToString(localVarOptionals.EmailNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNre.IsSet() {
		localVarQueryParams.Add("email__nre", parameterToString(localVarOptionals.EmailNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailRe.IsSet() {
		localVarQueryParams.Add("email__re", parameterToString(localVarOptionals.EmailRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Phone.IsSet() {
		localVarQueryParams.Add("phone", parameterToString(localVarOptionals.Phone.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIc.IsSet() {
		localVarQueryParams.Add("phone__ic", parameterToString(localVarOptionals.PhoneIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIe.IsSet() {
		localVarQueryParams.Add("phone__ie", parameterToString(localVarOptionals.PhoneIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIew.IsSet() {
		localVarQueryParams.Add("phone__iew", parameterToString(localVarOptionals.PhoneIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIre.IsSet() {
		localVarQueryParams.Add("phone__ire", parameterToString(localVarOptionals.PhoneIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIsw.IsSet() {
		localVarQueryParams.Add("phone__isw", parameterToString(localVarOptionals.PhoneIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneN.IsSet() {
		localVarQueryParams.Add("phone__n", parameterToString(localVarOptionals.PhoneN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNic.IsSet() {
		localVarQueryParams.Add("phone__nic", parameterToString(localVarOptionals.PhoneNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNie.IsSet() {
		localVarQueryParams.Add("phone__nie", parameterToString(localVarOptionals.PhoneNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNiew.IsSet() {
		localVarQueryParams.Add("phone__niew", parameterToString(localVarOptionals.PhoneNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNire.IsSet() {
		localVarQueryParams.Add("phone__nire", parameterToString(localVarOptionals.PhoneNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNisw.IsSet() {
		localVarQueryParams.Add("phone__nisw", parameterToString(localVarOptionals.PhoneNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNre.IsSet() {
		localVarQueryParams.Add("phone__nre", parameterToString(localVarOptionals.PhoneNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneRe.IsSet() {
		localVarQueryParams.Add("phone__re", parameterToString(localVarOptionals.PhoneRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SimilarToLocationData.IsSet() {
		localVarQueryParams.Add("similar_to_location_data", parameterToString(localVarOptionals.SimilarToLocationData.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedContactList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this contact.
 * @param optional nil or *ExtrasApiExtrasContactsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasContactsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasContactsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this contact.
 * @param optional nil or *ExtrasApiExtrasContactsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasContactsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasContactsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasContactsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a contact object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this contact.
 * @param optional nil or *ExtrasApiExtrasContactsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedContactRequest) - 
     * @param "Format" (optional.String) - 
@return Contact
*/

type ExtrasApiExtrasContactsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasContactsPartialUpdateOpts) (Contact, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Contact
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Contact
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a contact object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this contact.
 * @param optional nil or *ExtrasApiExtrasContactsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Contact
*/

type ExtrasApiExtrasContactsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasContactsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasContactsRetrieveOpts) (Contact, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Contact
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Contact
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a contact object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this contact.
 * @param optional nil or *ExtrasApiExtrasContactsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Contact
*/

type ExtrasApiExtrasContactsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasContactsUpdate(ctx context.Context, body ContactRequest, id string, localVarOptionals *ExtrasApiExtrasContactsUpdateOpts) (Contact, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Contact
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/contacts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Contact
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Read-only list of ContentTypes. Limit results to ContentTypes pertinent to Nautobot objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasContentTypesListOpts - Optional Parameters:
     * @param "AppLabel" (optional.Interface of []string) - 
     * @param "AppLabelIc" (optional.Interface of []string) - 
     * @param "AppLabelIe" (optional.Interface of []string) - 
     * @param "AppLabelIew" (optional.Interface of []string) - 
     * @param "AppLabelIre" (optional.Interface of []string) - 
     * @param "AppLabelIsw" (optional.Interface of []string) - 
     * @param "AppLabelN" (optional.Interface of []string) - 
     * @param "AppLabelNic" (optional.Interface of []string) - 
     * @param "AppLabelNie" (optional.Interface of []string) - 
     * @param "AppLabelNiew" (optional.Interface of []string) - 
     * @param "AppLabelNire" (optional.Interface of []string) - 
     * @param "AppLabelNisw" (optional.Interface of []string) - 
     * @param "AppLabelNre" (optional.Interface of []string) - 
     * @param "AppLabelRe" (optional.Interface of []string) - 
     * @param "CanAdd" (optional.Bool) -  User can add objects of this type
     * @param "CanChange" (optional.Bool) -  User can change objects of this type
     * @param "CanDelete" (optional.Bool) -  User can delete objects of this type
     * @param "CanView" (optional.Bool) -  User can view objects of this type
     * @param "Format" (optional.String) - 
     * @param "HasSerializer" (optional.Bool) -  A REST API serializer exists for this type
     * @param "Id" (optional.Interface of []int32) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdGt" (optional.Interface of []int32) - 
     * @param "IdGte" (optional.Interface of []int32) - 
     * @param "IdLt" (optional.Interface of []int32) - 
     * @param "IdLte" (optional.Interface of []int32) - 
     * @param "IdN" (optional.Interface of []int32) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Model" (optional.Interface of []string) - 
     * @param "ModelIc" (optional.Interface of []string) - 
     * @param "ModelIe" (optional.Interface of []string) - 
     * @param "ModelIew" (optional.Interface of []string) - 
     * @param "ModelIre" (optional.Interface of []string) - 
     * @param "ModelIsw" (optional.Interface of []string) - 
     * @param "ModelN" (optional.Interface of []string) - 
     * @param "ModelNic" (optional.Interface of []string) - 
     * @param "ModelNie" (optional.Interface of []string) - 
     * @param "ModelNiew" (optional.Interface of []string) - 
     * @param "ModelNire" (optional.Interface of []string) - 
     * @param "ModelNisw" (optional.Interface of []string) - 
     * @param "ModelNre" (optional.Interface of []string) - 
     * @param "ModelRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedContentTypeList
*/

type ExtrasApiExtrasContentTypesListOpts struct {
    AppLabel optional.Interface
    AppLabelIc optional.Interface
    AppLabelIe optional.Interface
    AppLabelIew optional.Interface
    AppLabelIre optional.Interface
    AppLabelIsw optional.Interface
    AppLabelN optional.Interface
    AppLabelNic optional.Interface
    AppLabelNie optional.Interface
    AppLabelNiew optional.Interface
    AppLabelNire optional.Interface
    AppLabelNisw optional.Interface
    AppLabelNre optional.Interface
    AppLabelRe optional.Interface
    CanAdd optional.Bool
    CanChange optional.Bool
    CanDelete optional.Bool
    CanView optional.Bool
    Format optional.String
    HasSerializer optional.Bool
    Id optional.Interface
    IdGt optional.Interface
    IdGte optional.Interface
    IdLt optional.Interface
    IdLte optional.Interface
    IdN optional.Interface
    Limit optional.Int32
    Model optional.Interface
    ModelIc optional.Interface
    ModelIe optional.Interface
    ModelIew optional.Interface
    ModelIre optional.Interface
    ModelIsw optional.Interface
    ModelN optional.Interface
    ModelNic optional.Interface
    ModelNie optional.Interface
    ModelNiew optional.Interface
    ModelNire optional.Interface
    ModelNisw optional.Interface
    ModelNre optional.Interface
    ModelRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasContentTypesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasContentTypesListOpts) (PaginatedContentTypeList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedContentTypeList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/content-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AppLabel.IsSet() {
		localVarQueryParams.Add("app_label", parameterToString(localVarOptionals.AppLabel.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelIc.IsSet() {
		localVarQueryParams.Add("app_label__ic", parameterToString(localVarOptionals.AppLabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelIe.IsSet() {
		localVarQueryParams.Add("app_label__ie", parameterToString(localVarOptionals.AppLabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelIew.IsSet() {
		localVarQueryParams.Add("app_label__iew", parameterToString(localVarOptionals.AppLabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelIre.IsSet() {
		localVarQueryParams.Add("app_label__ire", parameterToString(localVarOptionals.AppLabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelIsw.IsSet() {
		localVarQueryParams.Add("app_label__isw", parameterToString(localVarOptionals.AppLabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelN.IsSet() {
		localVarQueryParams.Add("app_label__n", parameterToString(localVarOptionals.AppLabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelNic.IsSet() {
		localVarQueryParams.Add("app_label__nic", parameterToString(localVarOptionals.AppLabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelNie.IsSet() {
		localVarQueryParams.Add("app_label__nie", parameterToString(localVarOptionals.AppLabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelNiew.IsSet() {
		localVarQueryParams.Add("app_label__niew", parameterToString(localVarOptionals.AppLabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelNire.IsSet() {
		localVarQueryParams.Add("app_label__nire", parameterToString(localVarOptionals.AppLabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelNisw.IsSet() {
		localVarQueryParams.Add("app_label__nisw", parameterToString(localVarOptionals.AppLabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelNre.IsSet() {
		localVarQueryParams.Add("app_label__nre", parameterToString(localVarOptionals.AppLabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AppLabelRe.IsSet() {
		localVarQueryParams.Add("app_label__re", parameterToString(localVarOptionals.AppLabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CanAdd.IsSet() {
		localVarQueryParams.Add("can_add", parameterToString(localVarOptionals.CanAdd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CanChange.IsSet() {
		localVarQueryParams.Add("can_change", parameterToString(localVarOptionals.CanChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CanDelete.IsSet() {
		localVarQueryParams.Add("can_delete", parameterToString(localVarOptionals.CanDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CanView.IsSet() {
		localVarQueryParams.Add("can_view", parameterToString(localVarOptionals.CanView.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSerializer.IsSet() {
		localVarQueryParams.Add("has_serializer", parameterToString(localVarOptionals.HasSerializer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdGt.IsSet() {
		localVarQueryParams.Add("id__gt", parameterToString(localVarOptionals.IdGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdGte.IsSet() {
		localVarQueryParams.Add("id__gte", parameterToString(localVarOptionals.IdGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdLt.IsSet() {
		localVarQueryParams.Add("id__lt", parameterToString(localVarOptionals.IdLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdLte.IsSet() {
		localVarQueryParams.Add("id__lte", parameterToString(localVarOptionals.IdLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Model.IsSet() {
		localVarQueryParams.Add("model", parameterToString(localVarOptionals.Model.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIc.IsSet() {
		localVarQueryParams.Add("model__ic", parameterToString(localVarOptionals.ModelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIe.IsSet() {
		localVarQueryParams.Add("model__ie", parameterToString(localVarOptionals.ModelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIew.IsSet() {
		localVarQueryParams.Add("model__iew", parameterToString(localVarOptionals.ModelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIre.IsSet() {
		localVarQueryParams.Add("model__ire", parameterToString(localVarOptionals.ModelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIsw.IsSet() {
		localVarQueryParams.Add("model__isw", parameterToString(localVarOptionals.ModelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelN.IsSet() {
		localVarQueryParams.Add("model__n", parameterToString(localVarOptionals.ModelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNic.IsSet() {
		localVarQueryParams.Add("model__nic", parameterToString(localVarOptionals.ModelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNie.IsSet() {
		localVarQueryParams.Add("model__nie", parameterToString(localVarOptionals.ModelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNiew.IsSet() {
		localVarQueryParams.Add("model__niew", parameterToString(localVarOptionals.ModelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNire.IsSet() {
		localVarQueryParams.Add("model__nire", parameterToString(localVarOptionals.ModelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNisw.IsSet() {
		localVarQueryParams.Add("model__nisw", parameterToString(localVarOptionals.ModelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNre.IsSet() {
		localVarQueryParams.Add("model__nre", parameterToString(localVarOptionals.ModelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelRe.IsSet() {
		localVarQueryParams.Add("model__re", parameterToString(localVarOptionals.ModelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedContentTypeList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Read-only list of ContentTypes. Limit results to ContentTypes pertinent to Nautobot objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this content type.
 * @param optional nil or *ExtrasApiExtrasContentTypesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ContentType
*/

type ExtrasApiExtrasContentTypesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasContentTypesRetrieve(ctx context.Context, id int32, localVarOptionals *ExtrasApiExtrasContentTypesRetrieveOpts) (ContentType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ContentType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/content-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ContentType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of custom field choice objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasCustomFieldChoicesBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of custom field choice objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CustomFieldChoice
*/

type ExtrasApiExtrasCustomFieldChoicesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableCustomFieldChoiceRequest, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesBulkPartialUpdateOpts) ([]CustomFieldChoice, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CustomFieldChoice
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CustomFieldChoice
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of custom field choice objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CustomFieldChoice
*/

type ExtrasApiExtrasCustomFieldChoicesBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesBulkUpdate(ctx context.Context, body []BulkWritableCustomFieldChoiceRequest, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesBulkUpdateOpts) ([]CustomFieldChoice, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CustomFieldChoice
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CustomFieldChoice
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more custom field choice objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CustomFieldChoice
*/

type ExtrasApiExtrasCustomFieldChoicesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesCreate(ctx context.Context, body CustomFieldChoiceRequest, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesCreateOpts) (CustomFieldChoice, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomFieldChoice
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v CustomFieldChoice
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a custom field choice object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom field choice.
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasCustomFieldChoicesDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of custom field choice objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesListOpts - Optional Parameters:
     * @param "CustomField" (optional.Interface of []string) - 
     * @param "CustomFieldN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Value" (optional.Interface of []string) - 
     * @param "ValueIc" (optional.Interface of []string) - 
     * @param "ValueIe" (optional.Interface of []string) - 
     * @param "ValueIew" (optional.Interface of []string) - 
     * @param "ValueIre" (optional.Interface of []string) - 
     * @param "ValueIsw" (optional.Interface of []string) - 
     * @param "ValueN" (optional.Interface of []string) - 
     * @param "ValueNic" (optional.Interface of []string) - 
     * @param "ValueNie" (optional.Interface of []string) - 
     * @param "ValueNiew" (optional.Interface of []string) - 
     * @param "ValueNire" (optional.Interface of []string) - 
     * @param "ValueNisw" (optional.Interface of []string) - 
     * @param "ValueNre" (optional.Interface of []string) - 
     * @param "ValueRe" (optional.Interface of []string) - 
     * @param "Weight" (optional.Interface of []int32) - 
     * @param "WeightGt" (optional.Interface of []int32) - 
     * @param "WeightGte" (optional.Interface of []int32) - 
     * @param "WeightLt" (optional.Interface of []int32) - 
     * @param "WeightLte" (optional.Interface of []int32) - 
     * @param "WeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCustomFieldChoiceList
*/

type ExtrasApiExtrasCustomFieldChoicesListOpts struct {
    CustomField optional.Interface
    CustomFieldN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Value optional.Interface
    ValueIc optional.Interface
    ValueIe optional.Interface
    ValueIew optional.Interface
    ValueIre optional.Interface
    ValueIsw optional.Interface
    ValueN optional.Interface
    ValueNic optional.Interface
    ValueNie optional.Interface
    ValueNiew optional.Interface
    ValueNire optional.Interface
    ValueNisw optional.Interface
    ValueNre optional.Interface
    ValueRe optional.Interface
    Weight optional.Interface
    WeightGt optional.Interface
    WeightGte optional.Interface
    WeightLt optional.Interface
    WeightLte optional.Interface
    WeightN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesListOpts) (PaginatedCustomFieldChoiceList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCustomFieldChoiceList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CustomField.IsSet() {
		localVarQueryParams.Add("custom_field", parameterToString(localVarOptionals.CustomField.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldN.IsSet() {
		localVarQueryParams.Add("custom_field__n", parameterToString(localVarOptionals.CustomFieldN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarQueryParams.Add("value", parameterToString(localVarOptionals.Value.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueIc.IsSet() {
		localVarQueryParams.Add("value__ic", parameterToString(localVarOptionals.ValueIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueIe.IsSet() {
		localVarQueryParams.Add("value__ie", parameterToString(localVarOptionals.ValueIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueIew.IsSet() {
		localVarQueryParams.Add("value__iew", parameterToString(localVarOptionals.ValueIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueIre.IsSet() {
		localVarQueryParams.Add("value__ire", parameterToString(localVarOptionals.ValueIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueIsw.IsSet() {
		localVarQueryParams.Add("value__isw", parameterToString(localVarOptionals.ValueIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueN.IsSet() {
		localVarQueryParams.Add("value__n", parameterToString(localVarOptionals.ValueN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueNic.IsSet() {
		localVarQueryParams.Add("value__nic", parameterToString(localVarOptionals.ValueNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueNie.IsSet() {
		localVarQueryParams.Add("value__nie", parameterToString(localVarOptionals.ValueNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueNiew.IsSet() {
		localVarQueryParams.Add("value__niew", parameterToString(localVarOptionals.ValueNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueNire.IsSet() {
		localVarQueryParams.Add("value__nire", parameterToString(localVarOptionals.ValueNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueNisw.IsSet() {
		localVarQueryParams.Add("value__nisw", parameterToString(localVarOptionals.ValueNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueNre.IsSet() {
		localVarQueryParams.Add("value__nre", parameterToString(localVarOptionals.ValueNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ValueRe.IsSet() {
		localVarQueryParams.Add("value__re", parameterToString(localVarOptionals.ValueRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Weight.IsSet() {
		localVarQueryParams.Add("weight", parameterToString(localVarOptionals.Weight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGt.IsSet() {
		localVarQueryParams.Add("weight__gt", parameterToString(localVarOptionals.WeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGte.IsSet() {
		localVarQueryParams.Add("weight__gte", parameterToString(localVarOptionals.WeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLt.IsSet() {
		localVarQueryParams.Add("weight__lt", parameterToString(localVarOptionals.WeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLte.IsSet() {
		localVarQueryParams.Add("weight__lte", parameterToString(localVarOptionals.WeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightN.IsSet() {
		localVarQueryParams.Add("weight__n", parameterToString(localVarOptionals.WeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCustomFieldChoiceList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a custom field choice object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom field choice.
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedCustomFieldChoiceRequest) - 
     * @param "Format" (optional.String) - 
@return CustomFieldChoice
*/

type ExtrasApiExtrasCustomFieldChoicesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesPartialUpdateOpts) (CustomFieldChoice, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomFieldChoice
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomFieldChoice
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a custom field choice object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom field choice.
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return CustomFieldChoice
*/

type ExtrasApiExtrasCustomFieldChoicesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesRetrieveOpts) (CustomFieldChoice, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomFieldChoice
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomFieldChoice
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a custom field choice object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this custom field choice.
 * @param optional nil or *ExtrasApiExtrasCustomFieldChoicesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CustomFieldChoice
*/

type ExtrasApiExtrasCustomFieldChoicesUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldChoicesUpdate(ctx context.Context, body CustomFieldChoiceRequest, id string, localVarOptionals *ExtrasApiExtrasCustomFieldChoicesUpdateOpts) (CustomFieldChoice, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomFieldChoice
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-field-choices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomFieldChoice
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of custom field objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomFieldsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasCustomFieldsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasCustomFieldsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of custom field objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomFieldsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CustomField
*/

type ExtrasApiExtrasCustomFieldsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableCustomFieldRequest, localVarOptionals *ExtrasApiExtrasCustomFieldsBulkPartialUpdateOpts) ([]CustomField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CustomField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CustomField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of custom field objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomFieldsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CustomField
*/

type ExtrasApiExtrasCustomFieldsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldsBulkUpdate(ctx context.Context, body []BulkWritableCustomFieldRequest, localVarOptionals *ExtrasApiExtrasCustomFieldsBulkUpdateOpts) ([]CustomField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CustomField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CustomField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more custom field objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomFieldsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CustomField
*/

type ExtrasApiExtrasCustomFieldsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldsCreate(ctx context.Context, body WritableCustomFieldRequest, localVarOptionals *ExtrasApiExtrasCustomFieldsCreateOpts) (CustomField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v CustomField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a custom field object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom field.
 * @param optional nil or *ExtrasApiExtrasCustomFieldsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasCustomFieldsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomFieldsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of custom field objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasCustomFieldsListOpts - Optional Parameters:
     * @param "ContentTypes" (optional.Interface of []int32) - 
     * @param "ContentTypesIc" (optional.Interface of []int32) - 
     * @param "ContentTypesIe" (optional.Interface of []int32) - 
     * @param "ContentTypesIew" (optional.Interface of []int32) - 
     * @param "ContentTypesIre" (optional.Interface of []int32) - 
     * @param "ContentTypesIsw" (optional.Interface of []int32) - 
     * @param "ContentTypesN" (optional.Interface of []int32) - 
     * @param "ContentTypesNic" (optional.Interface of []int32) - 
     * @param "ContentTypesNie" (optional.Interface of []int32) - 
     * @param "ContentTypesNiew" (optional.Interface of []int32) - 
     * @param "ContentTypesNire" (optional.Interface of []int32) - 
     * @param "ContentTypesNisw" (optional.Interface of []int32) - 
     * @param "ContentTypesNre" (optional.Interface of []int32) - 
     * @param "ContentTypesRe" (optional.Interface of []int32) - 
     * @param "FilterLogic" (optional.Interface of []string) -  Loose matches any instance of a given string; Exact matches the entire field.
     * @param "FilterLogicIc" (optional.Interface of []string) - 
     * @param "FilterLogicIe" (optional.Interface of []string) - 
     * @param "FilterLogicIew" (optional.Interface of []string) - 
     * @param "FilterLogicIre" (optional.Interface of []string) - 
     * @param "FilterLogicIsw" (optional.Interface of []string) - 
     * @param "FilterLogicN" (optional.Interface of []string) -  Loose matches any instance of a given string; Exact matches the entire field.
     * @param "FilterLogicNic" (optional.Interface of []string) - 
     * @param "FilterLogicNie" (optional.Interface of []string) - 
     * @param "FilterLogicNiew" (optional.Interface of []string) - 
     * @param "FilterLogicNire" (optional.Interface of []string) - 
     * @param "FilterLogicNisw" (optional.Interface of []string) - 
     * @param "FilterLogicNre" (optional.Interface of []string) - 
     * @param "FilterLogicRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Required" (optional.Bool) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Weight" (optional.Interface of []int32) - 
     * @param "WeightGt" (optional.Interface of []int32) - 
     * @param "WeightGte" (optional.Interface of []int32) - 
     * @param "WeightLt" (optional.Interface of []int32) - 
     * @param "WeightLte" (optional.Interface of []int32) - 
     * @param "WeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCustomFieldList
*/

type ExtrasApiExtrasCustomFieldsListOpts struct {
    ContentTypes optional.Interface
    ContentTypesIc optional.Interface
    ContentTypesIe optional.Interface
    ContentTypesIew optional.Interface
    ContentTypesIre optional.Interface
    ContentTypesIsw optional.Interface
    ContentTypesN optional.Interface
    ContentTypesNic optional.Interface
    ContentTypesNie optional.Interface
    ContentTypesNiew optional.Interface
    ContentTypesNire optional.Interface
    ContentTypesNisw optional.Interface
    ContentTypesNre optional.Interface
    ContentTypesRe optional.Interface
    FilterLogic optional.Interface
    FilterLogicIc optional.Interface
    FilterLogicIe optional.Interface
    FilterLogicIew optional.Interface
    FilterLogicIre optional.Interface
    FilterLogicIsw optional.Interface
    FilterLogicN optional.Interface
    FilterLogicNic optional.Interface
    FilterLogicNie optional.Interface
    FilterLogicNiew optional.Interface
    FilterLogicNire optional.Interface
    FilterLogicNisw optional.Interface
    FilterLogicNre optional.Interface
    FilterLogicRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Required optional.Bool
    Sort optional.String
    Weight optional.Interface
    WeightGt optional.Interface
    WeightGte optional.Interface
    WeightLt optional.Interface
    WeightLte optional.Interface
    WeightN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasCustomFieldsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasCustomFieldsListOpts) (PaginatedCustomFieldList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCustomFieldList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentTypes.IsSet() {
		localVarQueryParams.Add("content_types", parameterToString(localVarOptionals.ContentTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIc.IsSet() {
		localVarQueryParams.Add("content_types__ic", parameterToString(localVarOptionals.ContentTypesIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIe.IsSet() {
		localVarQueryParams.Add("content_types__ie", parameterToString(localVarOptionals.ContentTypesIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIew.IsSet() {
		localVarQueryParams.Add("content_types__iew", parameterToString(localVarOptionals.ContentTypesIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIre.IsSet() {
		localVarQueryParams.Add("content_types__ire", parameterToString(localVarOptionals.ContentTypesIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIsw.IsSet() {
		localVarQueryParams.Add("content_types__isw", parameterToString(localVarOptionals.ContentTypesIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesN.IsSet() {
		localVarQueryParams.Add("content_types__n", parameterToString(localVarOptionals.ContentTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNic.IsSet() {
		localVarQueryParams.Add("content_types__nic", parameterToString(localVarOptionals.ContentTypesNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNie.IsSet() {
		localVarQueryParams.Add("content_types__nie", parameterToString(localVarOptionals.ContentTypesNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNiew.IsSet() {
		localVarQueryParams.Add("content_types__niew", parameterToString(localVarOptionals.ContentTypesNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNire.IsSet() {
		localVarQueryParams.Add("content_types__nire", parameterToString(localVarOptionals.ContentTypesNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNisw.IsSet() {
		localVarQueryParams.Add("content_types__nisw", parameterToString(localVarOptionals.ContentTypesNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNre.IsSet() {
		localVarQueryParams.Add("content_types__nre", parameterToString(localVarOptionals.ContentTypesNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesRe.IsSet() {
		localVarQueryParams.Add("content_types__re", parameterToString(localVarOptionals.ContentTypesRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogic.IsSet() {
		localVarQueryParams.Add("filter_logic", parameterToString(localVarOptionals.FilterLogic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicIc.IsSet() {
		localVarQueryParams.Add("filter_logic__ic", parameterToString(localVarOptionals.FilterLogicIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicIe.IsSet() {
		localVarQueryParams.Add("filter_logic__ie", parameterToString(localVarOptionals.FilterLogicIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicIew.IsSet() {
		localVarQueryParams.Add("filter_logic__iew", parameterToString(localVarOptionals.FilterLogicIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicIre.IsSet() {
		localVarQueryParams.Add("filter_logic__ire", parameterToString(localVarOptionals.FilterLogicIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicIsw.IsSet() {
		localVarQueryParams.Add("filter_logic__isw", parameterToString(localVarOptionals.FilterLogicIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicN.IsSet() {
		localVarQueryParams.Add("filter_logic__n", parameterToString(localVarOptionals.FilterLogicN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicNic.IsSet() {
		localVarQueryParams.Add("filter_logic__nic", parameterToString(localVarOptionals.FilterLogicNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicNie.IsSet() {
		localVarQueryParams.Add("filter_logic__nie", parameterToString(localVarOptionals.FilterLogicNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicNiew.IsSet() {
		localVarQueryParams.Add("filter_logic__niew", parameterToString(localVarOptionals.FilterLogicNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicNire.IsSet() {
		localVarQueryParams.Add("filter_logic__nire", parameterToString(localVarOptionals.FilterLogicNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicNisw.IsSet() {
		localVarQueryParams.Add("filter_logic__nisw", parameterToString(localVarOptionals.FilterLogicNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicNre.IsSet() {
		localVarQueryParams.Add("filter_logic__nre", parameterToString(localVarOptionals.FilterLogicNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterLogicRe.IsSet() {
		localVarQueryParams.Add("filter_logic__re", parameterToString(localVarOptionals.FilterLogicRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Required.IsSet() {
		localVarQueryParams.Add("required", parameterToString(localVarOptionals.Required.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Weight.IsSet() {
		localVarQueryParams.Add("weight", parameterToString(localVarOptionals.Weight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGt.IsSet() {
		localVarQueryParams.Add("weight__gt", parameterToString(localVarOptionals.WeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGte.IsSet() {
		localVarQueryParams.Add("weight__gte", parameterToString(localVarOptionals.WeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLt.IsSet() {
		localVarQueryParams.Add("weight__lt", parameterToString(localVarOptionals.WeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLte.IsSet() {
		localVarQueryParams.Add("weight__lte", parameterToString(localVarOptionals.WeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightN.IsSet() {
		localVarQueryParams.Add("weight__n", parameterToString(localVarOptionals.WeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCustomFieldList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this custom field.
 * @param optional nil or *ExtrasApiExtrasCustomFieldsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasCustomFieldsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasCustomFieldsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom field.
 * @param optional nil or *ExtrasApiExtrasCustomFieldsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasCustomFieldsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasCustomFieldsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomFieldsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a custom field object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom field.
 * @param optional nil or *ExtrasApiExtrasCustomFieldsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableCustomFieldRequest) - 
     * @param "Format" (optional.String) - 
@return CustomField
*/

type ExtrasApiExtrasCustomFieldsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomFieldsPartialUpdateOpts) (CustomField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a custom field object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom field.
 * @param optional nil or *ExtrasApiExtrasCustomFieldsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return CustomField
*/

type ExtrasApiExtrasCustomFieldsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasCustomFieldsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomFieldsRetrieveOpts) (CustomField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a custom field object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this custom field.
 * @param optional nil or *ExtrasApiExtrasCustomFieldsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CustomField
*/

type ExtrasApiExtrasCustomFieldsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomFieldsUpdate(ctx context.Context, body WritableCustomFieldRequest, id string, localVarOptionals *ExtrasApiExtrasCustomFieldsUpdateOpts) (CustomField, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomField
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-fields/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomField
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomLinksBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasCustomLinksBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomLinksBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasCustomLinksBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomLinksBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CustomLink
*/

type ExtrasApiExtrasCustomLinksBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomLinksBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableCustomLinkRequest, localVarOptionals *ExtrasApiExtrasCustomLinksBulkPartialUpdateOpts) ([]CustomLink, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CustomLink
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CustomLink
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomLinksBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CustomLink
*/

type ExtrasApiExtrasCustomLinksBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomLinksBulkUpdate(ctx context.Context, body []BulkWritableCustomLinkRequest, localVarOptionals *ExtrasApiExtrasCustomLinksBulkUpdateOpts) ([]CustomLink, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CustomLink
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CustomLink
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasCustomLinksCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CustomLink
*/

type ExtrasApiExtrasCustomLinksCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomLinksCreate(ctx context.Context, body CustomLinkRequest, localVarOptionals *ExtrasApiExtrasCustomLinksCreateOpts) (CustomLink, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomLink
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v CustomLink
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom link.
 * @param optional nil or *ExtrasApiExtrasCustomLinksDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasCustomLinksDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomLinksDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomLinksDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasCustomLinksListOpts - Optional Parameters:
     * @param "ButtonClass" (optional.Interface of []string) -  The class of the first link in a group will be used for the dropdown button
     * @param "ButtonClassIc" (optional.Interface of []string) - 
     * @param "ButtonClassIe" (optional.Interface of []string) - 
     * @param "ButtonClassIew" (optional.Interface of []string) - 
     * @param "ButtonClassIre" (optional.Interface of []string) - 
     * @param "ButtonClassIsw" (optional.Interface of []string) - 
     * @param "ButtonClassN" (optional.Interface of []string) -  The class of the first link in a group will be used for the dropdown button
     * @param "ButtonClassNic" (optional.Interface of []string) - 
     * @param "ButtonClassNie" (optional.Interface of []string) - 
     * @param "ButtonClassNiew" (optional.Interface of []string) - 
     * @param "ButtonClassNire" (optional.Interface of []string) - 
     * @param "ButtonClassNisw" (optional.Interface of []string) - 
     * @param "ButtonClassNre" (optional.Interface of []string) - 
     * @param "ButtonClassRe" (optional.Interface of []string) - 
     * @param "ContentType" (optional.String) - 
     * @param "ContentTypeN" (optional.String) - 
     * @param "Format" (optional.String) - 
     * @param "GroupName" (optional.Interface of []string) - 
     * @param "GroupNameIc" (optional.Interface of []string) - 
     * @param "GroupNameIe" (optional.Interface of []string) - 
     * @param "GroupNameIew" (optional.Interface of []string) - 
     * @param "GroupNameIre" (optional.Interface of []string) - 
     * @param "GroupNameIsw" (optional.Interface of []string) - 
     * @param "GroupNameN" (optional.Interface of []string) - 
     * @param "GroupNameNic" (optional.Interface of []string) - 
     * @param "GroupNameNie" (optional.Interface of []string) - 
     * @param "GroupNameNiew" (optional.Interface of []string) - 
     * @param "GroupNameNire" (optional.Interface of []string) - 
     * @param "GroupNameNisw" (optional.Interface of []string) - 
     * @param "GroupNameNre" (optional.Interface of []string) - 
     * @param "GroupNameRe" (optional.Interface of []string) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "NewWindow" (optional.Bool) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "TargetUrl" (optional.Interface of []string) - 
     * @param "TargetUrlIc" (optional.Interface of []string) - 
     * @param "TargetUrlIe" (optional.Interface of []string) - 
     * @param "TargetUrlIew" (optional.Interface of []string) - 
     * @param "TargetUrlIre" (optional.Interface of []string) - 
     * @param "TargetUrlIsw" (optional.Interface of []string) - 
     * @param "TargetUrlN" (optional.Interface of []string) - 
     * @param "TargetUrlNic" (optional.Interface of []string) - 
     * @param "TargetUrlNie" (optional.Interface of []string) - 
     * @param "TargetUrlNiew" (optional.Interface of []string) - 
     * @param "TargetUrlNire" (optional.Interface of []string) - 
     * @param "TargetUrlNisw" (optional.Interface of []string) - 
     * @param "TargetUrlNre" (optional.Interface of []string) - 
     * @param "TargetUrlRe" (optional.Interface of []string) - 
     * @param "Text" (optional.Interface of []string) - 
     * @param "TextIc" (optional.Interface of []string) - 
     * @param "TextIe" (optional.Interface of []string) - 
     * @param "TextIew" (optional.Interface of []string) - 
     * @param "TextIre" (optional.Interface of []string) - 
     * @param "TextIsw" (optional.Interface of []string) - 
     * @param "TextN" (optional.Interface of []string) - 
     * @param "TextNic" (optional.Interface of []string) - 
     * @param "TextNie" (optional.Interface of []string) - 
     * @param "TextNiew" (optional.Interface of []string) - 
     * @param "TextNire" (optional.Interface of []string) - 
     * @param "TextNisw" (optional.Interface of []string) - 
     * @param "TextNre" (optional.Interface of []string) - 
     * @param "TextRe" (optional.Interface of []string) - 
     * @param "Weight" (optional.Interface of []int32) - 
     * @param "WeightGt" (optional.Interface of []int32) - 
     * @param "WeightGte" (optional.Interface of []int32) - 
     * @param "WeightLt" (optional.Interface of []int32) - 
     * @param "WeightLte" (optional.Interface of []int32) - 
     * @param "WeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCustomLinkList
*/

type ExtrasApiExtrasCustomLinksListOpts struct {
    ButtonClass optional.Interface
    ButtonClassIc optional.Interface
    ButtonClassIe optional.Interface
    ButtonClassIew optional.Interface
    ButtonClassIre optional.Interface
    ButtonClassIsw optional.Interface
    ButtonClassN optional.Interface
    ButtonClassNic optional.Interface
    ButtonClassNie optional.Interface
    ButtonClassNiew optional.Interface
    ButtonClassNire optional.Interface
    ButtonClassNisw optional.Interface
    ButtonClassNre optional.Interface
    ButtonClassRe optional.Interface
    ContentType optional.String
    ContentTypeN optional.String
    Format optional.String
    GroupName optional.Interface
    GroupNameIc optional.Interface
    GroupNameIe optional.Interface
    GroupNameIew optional.Interface
    GroupNameIre optional.Interface
    GroupNameIsw optional.Interface
    GroupNameN optional.Interface
    GroupNameNic optional.Interface
    GroupNameNie optional.Interface
    GroupNameNiew optional.Interface
    GroupNameNire optional.Interface
    GroupNameNisw optional.Interface
    GroupNameNre optional.Interface
    GroupNameRe optional.Interface
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    NewWindow optional.Bool
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    TargetUrl optional.Interface
    TargetUrlIc optional.Interface
    TargetUrlIe optional.Interface
    TargetUrlIew optional.Interface
    TargetUrlIre optional.Interface
    TargetUrlIsw optional.Interface
    TargetUrlN optional.Interface
    TargetUrlNic optional.Interface
    TargetUrlNie optional.Interface
    TargetUrlNiew optional.Interface
    TargetUrlNire optional.Interface
    TargetUrlNisw optional.Interface
    TargetUrlNre optional.Interface
    TargetUrlRe optional.Interface
    Text optional.Interface
    TextIc optional.Interface
    TextIe optional.Interface
    TextIew optional.Interface
    TextIre optional.Interface
    TextIsw optional.Interface
    TextN optional.Interface
    TextNic optional.Interface
    TextNie optional.Interface
    TextNiew optional.Interface
    TextNire optional.Interface
    TextNisw optional.Interface
    TextNre optional.Interface
    TextRe optional.Interface
    Weight optional.Interface
    WeightGt optional.Interface
    WeightGte optional.Interface
    WeightLt optional.Interface
    WeightLte optional.Interface
    WeightN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasCustomLinksList(ctx context.Context, localVarOptionals *ExtrasApiExtrasCustomLinksListOpts) (PaginatedCustomLinkList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCustomLinkList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ButtonClass.IsSet() {
		localVarQueryParams.Add("button_class", parameterToString(localVarOptionals.ButtonClass.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIc.IsSet() {
		localVarQueryParams.Add("button_class__ic", parameterToString(localVarOptionals.ButtonClassIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIe.IsSet() {
		localVarQueryParams.Add("button_class__ie", parameterToString(localVarOptionals.ButtonClassIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIew.IsSet() {
		localVarQueryParams.Add("button_class__iew", parameterToString(localVarOptionals.ButtonClassIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIre.IsSet() {
		localVarQueryParams.Add("button_class__ire", parameterToString(localVarOptionals.ButtonClassIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIsw.IsSet() {
		localVarQueryParams.Add("button_class__isw", parameterToString(localVarOptionals.ButtonClassIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassN.IsSet() {
		localVarQueryParams.Add("button_class__n", parameterToString(localVarOptionals.ButtonClassN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNic.IsSet() {
		localVarQueryParams.Add("button_class__nic", parameterToString(localVarOptionals.ButtonClassNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNie.IsSet() {
		localVarQueryParams.Add("button_class__nie", parameterToString(localVarOptionals.ButtonClassNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNiew.IsSet() {
		localVarQueryParams.Add("button_class__niew", parameterToString(localVarOptionals.ButtonClassNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNire.IsSet() {
		localVarQueryParams.Add("button_class__nire", parameterToString(localVarOptionals.ButtonClassNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNisw.IsSet() {
		localVarQueryParams.Add("button_class__nisw", parameterToString(localVarOptionals.ButtonClassNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNre.IsSet() {
		localVarQueryParams.Add("button_class__nre", parameterToString(localVarOptionals.ButtonClassNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassRe.IsSet() {
		localVarQueryParams.Add("button_class__re", parameterToString(localVarOptionals.ButtonClassRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentType.IsSet() {
		localVarQueryParams.Add("content_type", parameterToString(localVarOptionals.ContentType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeN.IsSet() {
		localVarQueryParams.Add("content_type__n", parameterToString(localVarOptionals.ContentTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupName.IsSet() {
		localVarQueryParams.Add("group_name", parameterToString(localVarOptionals.GroupName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIc.IsSet() {
		localVarQueryParams.Add("group_name__ic", parameterToString(localVarOptionals.GroupNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIe.IsSet() {
		localVarQueryParams.Add("group_name__ie", parameterToString(localVarOptionals.GroupNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIew.IsSet() {
		localVarQueryParams.Add("group_name__iew", parameterToString(localVarOptionals.GroupNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIre.IsSet() {
		localVarQueryParams.Add("group_name__ire", parameterToString(localVarOptionals.GroupNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIsw.IsSet() {
		localVarQueryParams.Add("group_name__isw", parameterToString(localVarOptionals.GroupNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameN.IsSet() {
		localVarQueryParams.Add("group_name__n", parameterToString(localVarOptionals.GroupNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNic.IsSet() {
		localVarQueryParams.Add("group_name__nic", parameterToString(localVarOptionals.GroupNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNie.IsSet() {
		localVarQueryParams.Add("group_name__nie", parameterToString(localVarOptionals.GroupNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNiew.IsSet() {
		localVarQueryParams.Add("group_name__niew", parameterToString(localVarOptionals.GroupNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNire.IsSet() {
		localVarQueryParams.Add("group_name__nire", parameterToString(localVarOptionals.GroupNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNisw.IsSet() {
		localVarQueryParams.Add("group_name__nisw", parameterToString(localVarOptionals.GroupNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNre.IsSet() {
		localVarQueryParams.Add("group_name__nre", parameterToString(localVarOptionals.GroupNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameRe.IsSet() {
		localVarQueryParams.Add("group_name__re", parameterToString(localVarOptionals.GroupNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NewWindow.IsSet() {
		localVarQueryParams.Add("new_window", parameterToString(localVarOptionals.NewWindow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrl.IsSet() {
		localVarQueryParams.Add("target_url", parameterToString(localVarOptionals.TargetUrl.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlIc.IsSet() {
		localVarQueryParams.Add("target_url__ic", parameterToString(localVarOptionals.TargetUrlIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlIe.IsSet() {
		localVarQueryParams.Add("target_url__ie", parameterToString(localVarOptionals.TargetUrlIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlIew.IsSet() {
		localVarQueryParams.Add("target_url__iew", parameterToString(localVarOptionals.TargetUrlIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlIre.IsSet() {
		localVarQueryParams.Add("target_url__ire", parameterToString(localVarOptionals.TargetUrlIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlIsw.IsSet() {
		localVarQueryParams.Add("target_url__isw", parameterToString(localVarOptionals.TargetUrlIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlN.IsSet() {
		localVarQueryParams.Add("target_url__n", parameterToString(localVarOptionals.TargetUrlN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlNic.IsSet() {
		localVarQueryParams.Add("target_url__nic", parameterToString(localVarOptionals.TargetUrlNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlNie.IsSet() {
		localVarQueryParams.Add("target_url__nie", parameterToString(localVarOptionals.TargetUrlNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlNiew.IsSet() {
		localVarQueryParams.Add("target_url__niew", parameterToString(localVarOptionals.TargetUrlNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlNire.IsSet() {
		localVarQueryParams.Add("target_url__nire", parameterToString(localVarOptionals.TargetUrlNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlNisw.IsSet() {
		localVarQueryParams.Add("target_url__nisw", parameterToString(localVarOptionals.TargetUrlNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlNre.IsSet() {
		localVarQueryParams.Add("target_url__nre", parameterToString(localVarOptionals.TargetUrlNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUrlRe.IsSet() {
		localVarQueryParams.Add("target_url__re", parameterToString(localVarOptionals.TargetUrlRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Text.IsSet() {
		localVarQueryParams.Add("text", parameterToString(localVarOptionals.Text.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIc.IsSet() {
		localVarQueryParams.Add("text__ic", parameterToString(localVarOptionals.TextIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIe.IsSet() {
		localVarQueryParams.Add("text__ie", parameterToString(localVarOptionals.TextIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIew.IsSet() {
		localVarQueryParams.Add("text__iew", parameterToString(localVarOptionals.TextIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIre.IsSet() {
		localVarQueryParams.Add("text__ire", parameterToString(localVarOptionals.TextIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIsw.IsSet() {
		localVarQueryParams.Add("text__isw", parameterToString(localVarOptionals.TextIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextN.IsSet() {
		localVarQueryParams.Add("text__n", parameterToString(localVarOptionals.TextN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNic.IsSet() {
		localVarQueryParams.Add("text__nic", parameterToString(localVarOptionals.TextNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNie.IsSet() {
		localVarQueryParams.Add("text__nie", parameterToString(localVarOptionals.TextNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNiew.IsSet() {
		localVarQueryParams.Add("text__niew", parameterToString(localVarOptionals.TextNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNire.IsSet() {
		localVarQueryParams.Add("text__nire", parameterToString(localVarOptionals.TextNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNisw.IsSet() {
		localVarQueryParams.Add("text__nisw", parameterToString(localVarOptionals.TextNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNre.IsSet() {
		localVarQueryParams.Add("text__nre", parameterToString(localVarOptionals.TextNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextRe.IsSet() {
		localVarQueryParams.Add("text__re", parameterToString(localVarOptionals.TextRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Weight.IsSet() {
		localVarQueryParams.Add("weight", parameterToString(localVarOptionals.Weight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGt.IsSet() {
		localVarQueryParams.Add("weight__gt", parameterToString(localVarOptionals.WeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGte.IsSet() {
		localVarQueryParams.Add("weight__gte", parameterToString(localVarOptionals.WeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLt.IsSet() {
		localVarQueryParams.Add("weight__lt", parameterToString(localVarOptionals.WeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLte.IsSet() {
		localVarQueryParams.Add("weight__lte", parameterToString(localVarOptionals.WeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightN.IsSet() {
		localVarQueryParams.Add("weight__n", parameterToString(localVarOptionals.WeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCustomLinkList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this custom link.
 * @param optional nil or *ExtrasApiExtrasCustomLinksNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasCustomLinksNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomLinksNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasCustomLinksNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom link.
 * @param optional nil or *ExtrasApiExtrasCustomLinksNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasCustomLinksNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasCustomLinksNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomLinksNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom link.
 * @param optional nil or *ExtrasApiExtrasCustomLinksPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedCustomLinkRequest) - 
     * @param "Format" (optional.String) - 
@return CustomLink
*/

type ExtrasApiExtrasCustomLinksPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomLinksPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomLinksPartialUpdateOpts) (CustomLink, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomLink
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomLink
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this custom link.
 * @param optional nil or *ExtrasApiExtrasCustomLinksRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return CustomLink
*/

type ExtrasApiExtrasCustomLinksRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasCustomLinksRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasCustomLinksRetrieveOpts) (CustomLink, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomLink
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomLink
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this custom link.
 * @param optional nil or *ExtrasApiExtrasCustomLinksUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CustomLink
*/

type ExtrasApiExtrasCustomLinksUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasCustomLinksUpdate(ctx context.Context, body CustomLinkRequest, id string, localVarOptionals *ExtrasApiExtrasCustomLinksUpdateOpts) (CustomLink, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomLink
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/custom-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomLink
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasDynamicGroupMembershipsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DynamicGroupMembership
*/

type ExtrasApiExtrasDynamicGroupMembershipsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDynamicGroupMembershipRequest, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsBulkPartialUpdateOpts) ([]DynamicGroupMembership, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DynamicGroupMembership
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DynamicGroupMembership
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DynamicGroupMembership
*/

type ExtrasApiExtrasDynamicGroupMembershipsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsBulkUpdate(ctx context.Context, body []BulkWritableDynamicGroupMembershipRequest, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsBulkUpdateOpts) ([]DynamicGroupMembership, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DynamicGroupMembership
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DynamicGroupMembership
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DynamicGroupMembership
*/

type ExtrasApiExtrasDynamicGroupMembershipsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsCreate(ctx context.Context, body DynamicGroupMembershipRequest, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsCreateOpts) (DynamicGroupMembership, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroupMembership
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v DynamicGroupMembership
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this dynamic group membership.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasDynamicGroupMembershipsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Group" (optional.Interface of []string) - 
     * @param "GroupN" (optional.Interface of []string) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Operator" (optional.Interface of []string) - 
     * @param "OperatorIc" (optional.Interface of []string) - 
     * @param "OperatorIe" (optional.Interface of []string) - 
     * @param "OperatorIew" (optional.Interface of []string) - 
     * @param "OperatorIre" (optional.Interface of []string) - 
     * @param "OperatorIsw" (optional.Interface of []string) - 
     * @param "OperatorN" (optional.Interface of []string) - 
     * @param "OperatorNic" (optional.Interface of []string) - 
     * @param "OperatorNie" (optional.Interface of []string) - 
     * @param "OperatorNiew" (optional.Interface of []string) - 
     * @param "OperatorNire" (optional.Interface of []string) - 
     * @param "OperatorNisw" (optional.Interface of []string) - 
     * @param "OperatorNre" (optional.Interface of []string) - 
     * @param "OperatorRe" (optional.Interface of []string) - 
     * @param "ParentGroup" (optional.Interface of []string) - 
     * @param "ParentGroupN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Weight" (optional.Interface of []int32) - 
     * @param "WeightGt" (optional.Interface of []int32) - 
     * @param "WeightGte" (optional.Interface of []int32) - 
     * @param "WeightLt" (optional.Interface of []int32) - 
     * @param "WeightLte" (optional.Interface of []int32) - 
     * @param "WeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDynamicGroupMembershipList
*/

type ExtrasApiExtrasDynamicGroupMembershipsListOpts struct {
    Created optional.Interface
    Format optional.String
    Group optional.Interface
    GroupN optional.Interface
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Operator optional.Interface
    OperatorIc optional.Interface
    OperatorIe optional.Interface
    OperatorIew optional.Interface
    OperatorIre optional.Interface
    OperatorIsw optional.Interface
    OperatorN optional.Interface
    OperatorNic optional.Interface
    OperatorNie optional.Interface
    OperatorNiew optional.Interface
    OperatorNire optional.Interface
    OperatorNisw optional.Interface
    OperatorNre optional.Interface
    OperatorRe optional.Interface
    ParentGroup optional.Interface
    ParentGroupN optional.Interface
    Q optional.String
    Sort optional.String
    Weight optional.Interface
    WeightGt optional.Interface
    WeightGte optional.Interface
    WeightLt optional.Interface
    WeightLte optional.Interface
    WeightN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsListOpts) (PaginatedDynamicGroupMembershipList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDynamicGroupMembershipList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Group.IsSet() {
		localVarQueryParams.Add("group", parameterToString(localVarOptionals.Group.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupN.IsSet() {
		localVarQueryParams.Add("group__n", parameterToString(localVarOptionals.GroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Operator.IsSet() {
		localVarQueryParams.Add("operator", parameterToString(localVarOptionals.Operator.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorIc.IsSet() {
		localVarQueryParams.Add("operator__ic", parameterToString(localVarOptionals.OperatorIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorIe.IsSet() {
		localVarQueryParams.Add("operator__ie", parameterToString(localVarOptionals.OperatorIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorIew.IsSet() {
		localVarQueryParams.Add("operator__iew", parameterToString(localVarOptionals.OperatorIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorIre.IsSet() {
		localVarQueryParams.Add("operator__ire", parameterToString(localVarOptionals.OperatorIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorIsw.IsSet() {
		localVarQueryParams.Add("operator__isw", parameterToString(localVarOptionals.OperatorIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorN.IsSet() {
		localVarQueryParams.Add("operator__n", parameterToString(localVarOptionals.OperatorN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorNic.IsSet() {
		localVarQueryParams.Add("operator__nic", parameterToString(localVarOptionals.OperatorNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorNie.IsSet() {
		localVarQueryParams.Add("operator__nie", parameterToString(localVarOptionals.OperatorNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorNiew.IsSet() {
		localVarQueryParams.Add("operator__niew", parameterToString(localVarOptionals.OperatorNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorNire.IsSet() {
		localVarQueryParams.Add("operator__nire", parameterToString(localVarOptionals.OperatorNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorNisw.IsSet() {
		localVarQueryParams.Add("operator__nisw", parameterToString(localVarOptionals.OperatorNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorNre.IsSet() {
		localVarQueryParams.Add("operator__nre", parameterToString(localVarOptionals.OperatorNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OperatorRe.IsSet() {
		localVarQueryParams.Add("operator__re", parameterToString(localVarOptionals.OperatorRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentGroup.IsSet() {
		localVarQueryParams.Add("parent_group", parameterToString(localVarOptionals.ParentGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentGroupN.IsSet() {
		localVarQueryParams.Add("parent_group__n", parameterToString(localVarOptionals.ParentGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Weight.IsSet() {
		localVarQueryParams.Add("weight", parameterToString(localVarOptionals.Weight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGt.IsSet() {
		localVarQueryParams.Add("weight__gt", parameterToString(localVarOptionals.WeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGte.IsSet() {
		localVarQueryParams.Add("weight__gte", parameterToString(localVarOptionals.WeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLt.IsSet() {
		localVarQueryParams.Add("weight__lt", parameterToString(localVarOptionals.WeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLte.IsSet() {
		localVarQueryParams.Add("weight__lte", parameterToString(localVarOptionals.WeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightN.IsSet() {
		localVarQueryParams.Add("weight__n", parameterToString(localVarOptionals.WeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDynamicGroupMembershipList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this dynamic group membership.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedDynamicGroupMembershipRequest) - 
     * @param "Format" (optional.String) - 
@return DynamicGroupMembership
*/

type ExtrasApiExtrasDynamicGroupMembershipsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsPartialUpdateOpts) (DynamicGroupMembership, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroupMembership
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DynamicGroupMembership
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this dynamic group membership.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DynamicGroupMembership
*/

type ExtrasApiExtrasDynamicGroupMembershipsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsRetrieveOpts) (DynamicGroupMembership, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroupMembership
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DynamicGroupMembership
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this dynamic group membership.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupMembershipsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DynamicGroupMembership
*/

type ExtrasApiExtrasDynamicGroupMembershipsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupMembershipsUpdate(ctx context.Context, body DynamicGroupMembershipRequest, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupMembershipsUpdateOpts) (DynamicGroupMembership, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroupMembership
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-group-memberships/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DynamicGroupMembership
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasDynamicGroupsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasDynamicGroupsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DynamicGroup
*/

type ExtrasApiExtrasDynamicGroupsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDynamicGroupRequest, localVarOptionals *ExtrasApiExtrasDynamicGroupsBulkPartialUpdateOpts) ([]DynamicGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DynamicGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DynamicGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DynamicGroup
*/

type ExtrasApiExtrasDynamicGroupsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupsBulkUpdate(ctx context.Context, body []BulkWritableDynamicGroupRequest, localVarOptionals *ExtrasApiExtrasDynamicGroupsBulkUpdateOpts) ([]DynamicGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DynamicGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DynamicGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DynamicGroup
*/

type ExtrasApiExtrasDynamicGroupsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupsCreate(ctx context.Context, body DynamicGroupRequest, localVarOptionals *ExtrasApiExtrasDynamicGroupsCreateOpts) (DynamicGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v DynamicGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this dynamic group.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasDynamicGroupsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsListOpts - Optional Parameters:
     * @param "ContentType" (optional.Interface of []int32) - 
     * @param "ContentTypeN" (optional.Interface of []int32) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDynamicGroupList
*/

type ExtrasApiExtrasDynamicGroupsListOpts struct {
    ContentType optional.Interface
    ContentTypeN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasDynamicGroupsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasDynamicGroupsListOpts) (PaginatedDynamicGroupList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDynamicGroupList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentType.IsSet() {
		localVarQueryParams.Add("content_type", parameterToString(localVarOptionals.ContentType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeN.IsSet() {
		localVarQueryParams.Add("content_type__n", parameterToString(localVarOptionals.ContentTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDynamicGroupList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
List the member objects of this dynamic group.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this dynamic group.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsMembersRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DynamicGroup
*/

type ExtrasApiExtrasDynamicGroupsMembersRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasDynamicGroupsMembersRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupsMembersRetrieveOpts) (DynamicGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/{id}/members/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DynamicGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this dynamic group.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasDynamicGroupsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this dynamic group.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasDynamicGroupsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasDynamicGroupsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this dynamic group.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedDynamicGroupRequest) - 
     * @param "Format" (optional.String) - 
@return DynamicGroup
*/

type ExtrasApiExtrasDynamicGroupsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupsPartialUpdateOpts) (DynamicGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DynamicGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this dynamic group.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DynamicGroup
*/

type ExtrasApiExtrasDynamicGroupsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasDynamicGroupsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupsRetrieveOpts) (DynamicGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DynamicGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this dynamic group.
 * @param optional nil or *ExtrasApiExtrasDynamicGroupsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DynamicGroup
*/

type ExtrasApiExtrasDynamicGroupsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasDynamicGroupsUpdate(ctx context.Context, body DynamicGroupRequest, id string, localVarOptionals *ExtrasApiExtrasDynamicGroupsUpdateOpts) (DynamicGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DynamicGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/dynamic-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DynamicGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of export template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasExportTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasExportTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExportTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasExportTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of export template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasExportTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ExportTemplate
*/

type ExtrasApiExtrasExportTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExportTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableExportTemplateRequest, localVarOptionals *ExtrasApiExtrasExportTemplatesBulkPartialUpdateOpts) ([]ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of export template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasExportTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ExportTemplate
*/

type ExtrasApiExtrasExportTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExportTemplatesBulkUpdate(ctx context.Context, body []BulkWritableExportTemplateRequest, localVarOptionals *ExtrasApiExtrasExportTemplatesBulkUpdateOpts) ([]ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more export template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasExportTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ExportTemplate
*/

type ExtrasApiExtrasExportTemplatesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExportTemplatesCreate(ctx context.Context, body ExportTemplateRequest, localVarOptionals *ExtrasApiExtrasExportTemplatesCreateOpts) (ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a export template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this export template.
 * @param optional nil or *ExtrasApiExtrasExportTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasExportTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExportTemplatesDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasExportTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of export template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasExportTemplatesListOpts - Optional Parameters:
     * @param "ContentType" (optional.String) - 
     * @param "ContentTypeN" (optional.String) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "OwnerContentType" (optional.String) - 
     * @param "OwnerContentTypeIsnull" (optional.Bool) - 
     * @param "OwnerContentTypeN" (optional.String) - 
     * @param "OwnerObjectId" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIc" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIe" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIew" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIre" (optional.Interface of []string) - 
     * @param "OwnerObjectIdIsnull" (optional.Bool) - 
     * @param "OwnerObjectIdIsw" (optional.Interface of []string) - 
     * @param "OwnerObjectIdN" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNic" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNie" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNiew" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNire" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNisw" (optional.Interface of []string) - 
     * @param "OwnerObjectIdNre" (optional.Interface of []string) - 
     * @param "OwnerObjectIdRe" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedExportTemplateList
*/

type ExtrasApiExtrasExportTemplatesListOpts struct {
    ContentType optional.String
    ContentTypeN optional.String
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    OwnerContentType optional.String
    OwnerContentTypeIsnull optional.Bool
    OwnerContentTypeN optional.String
    OwnerObjectId optional.Interface
    OwnerObjectIdIc optional.Interface
    OwnerObjectIdIe optional.Interface
    OwnerObjectIdIew optional.Interface
    OwnerObjectIdIre optional.Interface
    OwnerObjectIdIsnull optional.Bool
    OwnerObjectIdIsw optional.Interface
    OwnerObjectIdN optional.Interface
    OwnerObjectIdNic optional.Interface
    OwnerObjectIdNie optional.Interface
    OwnerObjectIdNiew optional.Interface
    OwnerObjectIdNire optional.Interface
    OwnerObjectIdNisw optional.Interface
    OwnerObjectIdNre optional.Interface
    OwnerObjectIdRe optional.Interface
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasExportTemplatesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasExportTemplatesListOpts) (PaginatedExportTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedExportTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentType.IsSet() {
		localVarQueryParams.Add("content_type", parameterToString(localVarOptionals.ContentType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeN.IsSet() {
		localVarQueryParams.Add("content_type__n", parameterToString(localVarOptionals.ContentTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentType.IsSet() {
		localVarQueryParams.Add("owner_content_type", parameterToString(localVarOptionals.OwnerContentType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentTypeIsnull.IsSet() {
		localVarQueryParams.Add("owner_content_type__isnull", parameterToString(localVarOptionals.OwnerContentTypeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerContentTypeN.IsSet() {
		localVarQueryParams.Add("owner_content_type__n", parameterToString(localVarOptionals.OwnerContentTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectId.IsSet() {
		localVarQueryParams.Add("owner_object_id", parameterToString(localVarOptionals.OwnerObjectId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIc.IsSet() {
		localVarQueryParams.Add("owner_object_id__ic", parameterToString(localVarOptionals.OwnerObjectIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIe.IsSet() {
		localVarQueryParams.Add("owner_object_id__ie", parameterToString(localVarOptionals.OwnerObjectIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIew.IsSet() {
		localVarQueryParams.Add("owner_object_id__iew", parameterToString(localVarOptionals.OwnerObjectIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIre.IsSet() {
		localVarQueryParams.Add("owner_object_id__ire", parameterToString(localVarOptionals.OwnerObjectIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIsnull.IsSet() {
		localVarQueryParams.Add("owner_object_id__isnull", parameterToString(localVarOptionals.OwnerObjectIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdIsw.IsSet() {
		localVarQueryParams.Add("owner_object_id__isw", parameterToString(localVarOptionals.OwnerObjectIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdN.IsSet() {
		localVarQueryParams.Add("owner_object_id__n", parameterToString(localVarOptionals.OwnerObjectIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNic.IsSet() {
		localVarQueryParams.Add("owner_object_id__nic", parameterToString(localVarOptionals.OwnerObjectIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNie.IsSet() {
		localVarQueryParams.Add("owner_object_id__nie", parameterToString(localVarOptionals.OwnerObjectIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNiew.IsSet() {
		localVarQueryParams.Add("owner_object_id__niew", parameterToString(localVarOptionals.OwnerObjectIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNire.IsSet() {
		localVarQueryParams.Add("owner_object_id__nire", parameterToString(localVarOptionals.OwnerObjectIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNisw.IsSet() {
		localVarQueryParams.Add("owner_object_id__nisw", parameterToString(localVarOptionals.OwnerObjectIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdNre.IsSet() {
		localVarQueryParams.Add("owner_object_id__nre", parameterToString(localVarOptionals.OwnerObjectIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerObjectIdRe.IsSet() {
		localVarQueryParams.Add("owner_object_id__re", parameterToString(localVarOptionals.OwnerObjectIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedExportTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this export template.
 * @param optional nil or *ExtrasApiExtrasExportTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasExportTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExportTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasExportTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this export template.
 * @param optional nil or *ExtrasApiExtrasExportTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasExportTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasExportTemplatesNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasExportTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a export template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this export template.
 * @param optional nil or *ExtrasApiExtrasExportTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedExportTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return ExportTemplate
*/

type ExtrasApiExtrasExportTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExportTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasExportTemplatesPartialUpdateOpts) (ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a export template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this export template.
 * @param optional nil or *ExtrasApiExtrasExportTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ExportTemplate
*/

type ExtrasApiExtrasExportTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasExportTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasExportTemplatesRetrieveOpts) (ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a export template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this export template.
 * @param optional nil or *ExtrasApiExtrasExportTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ExportTemplate
*/

type ExtrasApiExtrasExportTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExportTemplatesUpdate(ctx context.Context, body ExportTemplateRequest, id string, localVarOptionals *ExtrasApiExtrasExportTemplatesUpdateOpts) (ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of external integration objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasExternalIntegrationsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasExternalIntegrationsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of external integration objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ExternalIntegration
*/

type ExtrasApiExtrasExternalIntegrationsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableExternalIntegrationRequest, localVarOptionals *ExtrasApiExtrasExternalIntegrationsBulkPartialUpdateOpts) ([]ExternalIntegration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ExternalIntegration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ExternalIntegration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of external integration objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ExternalIntegration
*/

type ExtrasApiExtrasExternalIntegrationsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsBulkUpdate(ctx context.Context, body []BulkWritableExternalIntegrationRequest, localVarOptionals *ExtrasApiExtrasExternalIntegrationsBulkUpdateOpts) ([]ExternalIntegration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ExternalIntegration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ExternalIntegration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more external integration objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ExternalIntegration
*/

type ExtrasApiExtrasExternalIntegrationsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsCreate(ctx context.Context, body ExternalIntegrationRequest, localVarOptionals *ExtrasApiExtrasExternalIntegrationsCreateOpts) (ExternalIntegration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExternalIntegration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ExternalIntegration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a external integration object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this external integration.
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasExternalIntegrationsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasExternalIntegrationsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of external integration objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsListOpts - Optional Parameters:
     * @param "CaFilePath" (optional.Interface of []string) - 
     * @param "CaFilePathIc" (optional.Interface of []string) - 
     * @param "CaFilePathIe" (optional.Interface of []string) - 
     * @param "CaFilePathIew" (optional.Interface of []string) - 
     * @param "CaFilePathIre" (optional.Interface of []string) - 
     * @param "CaFilePathIsw" (optional.Interface of []string) - 
     * @param "CaFilePathN" (optional.Interface of []string) - 
     * @param "CaFilePathNic" (optional.Interface of []string) - 
     * @param "CaFilePathNie" (optional.Interface of []string) - 
     * @param "CaFilePathNiew" (optional.Interface of []string) - 
     * @param "CaFilePathNire" (optional.Interface of []string) - 
     * @param "CaFilePathNisw" (optional.Interface of []string) - 
     * @param "CaFilePathNre" (optional.Interface of []string) - 
     * @param "CaFilePathRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "ExtraConfig" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasSecretsGroup" (optional.Bool) -  Has secrets group
     * @param "Headers" (optional.Interface of []string) - 
     * @param "HttpMethod" (optional.Interface of []string) - 
     * @param "HttpMethodIc" (optional.Interface of []string) - 
     * @param "HttpMethodIe" (optional.Interface of []string) - 
     * @param "HttpMethodIew" (optional.Interface of []string) - 
     * @param "HttpMethodIre" (optional.Interface of []string) - 
     * @param "HttpMethodIsw" (optional.Interface of []string) - 
     * @param "HttpMethodN" (optional.Interface of []string) - 
     * @param "HttpMethodNic" (optional.Interface of []string) - 
     * @param "HttpMethodNie" (optional.Interface of []string) - 
     * @param "HttpMethodNiew" (optional.Interface of []string) - 
     * @param "HttpMethodNire" (optional.Interface of []string) - 
     * @param "HttpMethodNisw" (optional.Interface of []string) - 
     * @param "HttpMethodNre" (optional.Interface of []string) - 
     * @param "HttpMethodRe" (optional.Interface of []string) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "RemoteUrl" (optional.Interface of []string) - 
     * @param "RemoteUrlIc" (optional.Interface of []string) - 
     * @param "RemoteUrlIe" (optional.Interface of []string) - 
     * @param "RemoteUrlIew" (optional.Interface of []string) - 
     * @param "RemoteUrlIre" (optional.Interface of []string) - 
     * @param "RemoteUrlIsw" (optional.Interface of []string) - 
     * @param "RemoteUrlN" (optional.Interface of []string) - 
     * @param "RemoteUrlNic" (optional.Interface of []string) - 
     * @param "RemoteUrlNie" (optional.Interface of []string) - 
     * @param "RemoteUrlNiew" (optional.Interface of []string) - 
     * @param "RemoteUrlNire" (optional.Interface of []string) - 
     * @param "RemoteUrlNisw" (optional.Interface of []string) - 
     * @param "RemoteUrlNre" (optional.Interface of []string) - 
     * @param "RemoteUrlRe" (optional.Interface of []string) - 
     * @param "SecretsGroup" (optional.Interface of []string) - 
     * @param "SecretsGroupIsnull" (optional.Bool) - 
     * @param "SecretsGroupN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Timeout" (optional.Interface of []int32) - 
     * @param "TimeoutGt" (optional.Interface of []int32) - 
     * @param "TimeoutGte" (optional.Interface of []int32) - 
     * @param "TimeoutLt" (optional.Interface of []int32) - 
     * @param "TimeoutLte" (optional.Interface of []int32) - 
     * @param "TimeoutN" (optional.Interface of []int32) - 
     * @param "VerifySsl" (optional.Bool) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedExternalIntegrationList
*/

type ExtrasApiExtrasExternalIntegrationsListOpts struct {
    CaFilePath optional.Interface
    CaFilePathIc optional.Interface
    CaFilePathIe optional.Interface
    CaFilePathIew optional.Interface
    CaFilePathIre optional.Interface
    CaFilePathIsw optional.Interface
    CaFilePathN optional.Interface
    CaFilePathNic optional.Interface
    CaFilePathNie optional.Interface
    CaFilePathNiew optional.Interface
    CaFilePathNire optional.Interface
    CaFilePathNisw optional.Interface
    CaFilePathNre optional.Interface
    CaFilePathRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    ExtraConfig optional.Interface
    Format optional.String
    HasSecretsGroup optional.Bool
    Headers optional.Interface
    HttpMethod optional.Interface
    HttpMethodIc optional.Interface
    HttpMethodIe optional.Interface
    HttpMethodIew optional.Interface
    HttpMethodIre optional.Interface
    HttpMethodIsw optional.Interface
    HttpMethodN optional.Interface
    HttpMethodNic optional.Interface
    HttpMethodNie optional.Interface
    HttpMethodNiew optional.Interface
    HttpMethodNire optional.Interface
    HttpMethodNisw optional.Interface
    HttpMethodNre optional.Interface
    HttpMethodRe optional.Interface
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    RemoteUrl optional.Interface
    RemoteUrlIc optional.Interface
    RemoteUrlIe optional.Interface
    RemoteUrlIew optional.Interface
    RemoteUrlIre optional.Interface
    RemoteUrlIsw optional.Interface
    RemoteUrlN optional.Interface
    RemoteUrlNic optional.Interface
    RemoteUrlNie optional.Interface
    RemoteUrlNiew optional.Interface
    RemoteUrlNire optional.Interface
    RemoteUrlNisw optional.Interface
    RemoteUrlNre optional.Interface
    RemoteUrlRe optional.Interface
    SecretsGroup optional.Interface
    SecretsGroupIsnull optional.Bool
    SecretsGroupN optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Timeout optional.Interface
    TimeoutGt optional.Interface
    TimeoutGte optional.Interface
    TimeoutLt optional.Interface
    TimeoutLte optional.Interface
    TimeoutN optional.Interface
    VerifySsl optional.Bool
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasExternalIntegrationsListOpts) (PaginatedExternalIntegrationList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedExternalIntegrationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CaFilePath.IsSet() {
		localVarQueryParams.Add("ca_file_path", parameterToString(localVarOptionals.CaFilePath.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathIc.IsSet() {
		localVarQueryParams.Add("ca_file_path__ic", parameterToString(localVarOptionals.CaFilePathIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathIe.IsSet() {
		localVarQueryParams.Add("ca_file_path__ie", parameterToString(localVarOptionals.CaFilePathIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathIew.IsSet() {
		localVarQueryParams.Add("ca_file_path__iew", parameterToString(localVarOptionals.CaFilePathIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathIre.IsSet() {
		localVarQueryParams.Add("ca_file_path__ire", parameterToString(localVarOptionals.CaFilePathIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathIsw.IsSet() {
		localVarQueryParams.Add("ca_file_path__isw", parameterToString(localVarOptionals.CaFilePathIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathN.IsSet() {
		localVarQueryParams.Add("ca_file_path__n", parameterToString(localVarOptionals.CaFilePathN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathNic.IsSet() {
		localVarQueryParams.Add("ca_file_path__nic", parameterToString(localVarOptionals.CaFilePathNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathNie.IsSet() {
		localVarQueryParams.Add("ca_file_path__nie", parameterToString(localVarOptionals.CaFilePathNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathNiew.IsSet() {
		localVarQueryParams.Add("ca_file_path__niew", parameterToString(localVarOptionals.CaFilePathNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathNire.IsSet() {
		localVarQueryParams.Add("ca_file_path__nire", parameterToString(localVarOptionals.CaFilePathNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathNisw.IsSet() {
		localVarQueryParams.Add("ca_file_path__nisw", parameterToString(localVarOptionals.CaFilePathNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathNre.IsSet() {
		localVarQueryParams.Add("ca_file_path__nre", parameterToString(localVarOptionals.CaFilePathNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CaFilePathRe.IsSet() {
		localVarQueryParams.Add("ca_file_path__re", parameterToString(localVarOptionals.CaFilePathRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExtraConfig.IsSet() {
		localVarQueryParams.Add("extra_config", parameterToString(localVarOptionals.ExtraConfig.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSecretsGroup.IsSet() {
		localVarQueryParams.Add("has_secrets_group", parameterToString(localVarOptionals.HasSecretsGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Headers.IsSet() {
		localVarQueryParams.Add("headers", parameterToString(localVarOptionals.Headers.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethod.IsSet() {
		localVarQueryParams.Add("http_method", parameterToString(localVarOptionals.HttpMethod.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodIc.IsSet() {
		localVarQueryParams.Add("http_method__ic", parameterToString(localVarOptionals.HttpMethodIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodIe.IsSet() {
		localVarQueryParams.Add("http_method__ie", parameterToString(localVarOptionals.HttpMethodIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodIew.IsSet() {
		localVarQueryParams.Add("http_method__iew", parameterToString(localVarOptionals.HttpMethodIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodIre.IsSet() {
		localVarQueryParams.Add("http_method__ire", parameterToString(localVarOptionals.HttpMethodIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodIsw.IsSet() {
		localVarQueryParams.Add("http_method__isw", parameterToString(localVarOptionals.HttpMethodIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodN.IsSet() {
		localVarQueryParams.Add("http_method__n", parameterToString(localVarOptionals.HttpMethodN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodNic.IsSet() {
		localVarQueryParams.Add("http_method__nic", parameterToString(localVarOptionals.HttpMethodNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodNie.IsSet() {
		localVarQueryParams.Add("http_method__nie", parameterToString(localVarOptionals.HttpMethodNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodNiew.IsSet() {
		localVarQueryParams.Add("http_method__niew", parameterToString(localVarOptionals.HttpMethodNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodNire.IsSet() {
		localVarQueryParams.Add("http_method__nire", parameterToString(localVarOptionals.HttpMethodNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodNisw.IsSet() {
		localVarQueryParams.Add("http_method__nisw", parameterToString(localVarOptionals.HttpMethodNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodNre.IsSet() {
		localVarQueryParams.Add("http_method__nre", parameterToString(localVarOptionals.HttpMethodNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HttpMethodRe.IsSet() {
		localVarQueryParams.Add("http_method__re", parameterToString(localVarOptionals.HttpMethodRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrl.IsSet() {
		localVarQueryParams.Add("remote_url", parameterToString(localVarOptionals.RemoteUrl.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIc.IsSet() {
		localVarQueryParams.Add("remote_url__ic", parameterToString(localVarOptionals.RemoteUrlIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIe.IsSet() {
		localVarQueryParams.Add("remote_url__ie", parameterToString(localVarOptionals.RemoteUrlIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIew.IsSet() {
		localVarQueryParams.Add("remote_url__iew", parameterToString(localVarOptionals.RemoteUrlIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIre.IsSet() {
		localVarQueryParams.Add("remote_url__ire", parameterToString(localVarOptionals.RemoteUrlIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIsw.IsSet() {
		localVarQueryParams.Add("remote_url__isw", parameterToString(localVarOptionals.RemoteUrlIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlN.IsSet() {
		localVarQueryParams.Add("remote_url__n", parameterToString(localVarOptionals.RemoteUrlN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNic.IsSet() {
		localVarQueryParams.Add("remote_url__nic", parameterToString(localVarOptionals.RemoteUrlNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNie.IsSet() {
		localVarQueryParams.Add("remote_url__nie", parameterToString(localVarOptionals.RemoteUrlNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNiew.IsSet() {
		localVarQueryParams.Add("remote_url__niew", parameterToString(localVarOptionals.RemoteUrlNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNire.IsSet() {
		localVarQueryParams.Add("remote_url__nire", parameterToString(localVarOptionals.RemoteUrlNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNisw.IsSet() {
		localVarQueryParams.Add("remote_url__nisw", parameterToString(localVarOptionals.RemoteUrlNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNre.IsSet() {
		localVarQueryParams.Add("remote_url__nre", parameterToString(localVarOptionals.RemoteUrlNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlRe.IsSet() {
		localVarQueryParams.Add("remote_url__re", parameterToString(localVarOptionals.RemoteUrlRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroup.IsSet() {
		localVarQueryParams.Add("secrets_group", parameterToString(localVarOptionals.SecretsGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupIsnull.IsSet() {
		localVarQueryParams.Add("secrets_group__isnull", parameterToString(localVarOptionals.SecretsGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupN.IsSet() {
		localVarQueryParams.Add("secrets_group__n", parameterToString(localVarOptionals.SecretsGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeoutGt.IsSet() {
		localVarQueryParams.Add("timeout__gt", parameterToString(localVarOptionals.TimeoutGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeoutGte.IsSet() {
		localVarQueryParams.Add("timeout__gte", parameterToString(localVarOptionals.TimeoutGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeoutLt.IsSet() {
		localVarQueryParams.Add("timeout__lt", parameterToString(localVarOptionals.TimeoutLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeoutLte.IsSet() {
		localVarQueryParams.Add("timeout__lte", parameterToString(localVarOptionals.TimeoutLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeoutN.IsSet() {
		localVarQueryParams.Add("timeout__n", parameterToString(localVarOptionals.TimeoutN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VerifySsl.IsSet() {
		localVarQueryParams.Add("verify_ssl", parameterToString(localVarOptionals.VerifySsl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedExternalIntegrationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this external integration.
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasExternalIntegrationsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasExternalIntegrationsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this external integration.
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasExternalIntegrationsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasExternalIntegrationsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a external integration object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this external integration.
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedExternalIntegrationRequest) - 
     * @param "Format" (optional.String) - 
@return ExternalIntegration
*/

type ExtrasApiExtrasExternalIntegrationsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasExternalIntegrationsPartialUpdateOpts) (ExternalIntegration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExternalIntegration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ExternalIntegration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a external integration object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this external integration.
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ExternalIntegration
*/

type ExtrasApiExtrasExternalIntegrationsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasExternalIntegrationsRetrieveOpts) (ExternalIntegration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExternalIntegration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ExternalIntegration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a external integration object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this external integration.
 * @param optional nil or *ExtrasApiExtrasExternalIntegrationsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ExternalIntegration
*/

type ExtrasApiExtrasExternalIntegrationsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasExternalIntegrationsUpdate(ctx context.Context, body ExternalIntegrationRequest, id string, localVarOptionals *ExtrasApiExtrasExternalIntegrationsUpdateOpts) (ExternalIntegration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExternalIntegration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/external-integrations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ExternalIntegration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Download the specified FileProxy.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this file proxy.
 * @param optional nil or *ExtrasApiExtrasFileProxiesDownloadRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return *os.File
*/

type ExtrasApiExtrasFileProxiesDownloadRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasFileProxiesDownloadRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasFileProxiesDownloadRetrieveOpts) (*os.File, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/file-proxies/{id}/download/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of file proxy objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasFileProxiesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Job" (optional.Interface of []string) - 
     * @param "JobIsnull" (optional.Bool) - 
     * @param "JobN" (optional.Interface of []string) - 
     * @param "JobResultId" (optional.Interface of []string) -  Job Result (ID)
     * @param "JobResultIdIsnull" (optional.Bool) - 
     * @param "JobResultIdN" (optional.Interface of []string) -  Job Result (ID)
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "UploadedAt" (optional.Interface of []time.Time) - 
     * @param "UploadedAtGt" (optional.Interface of []time.Time) - 
     * @param "UploadedAtGte" (optional.Interface of []time.Time) - 
     * @param "UploadedAtLt" (optional.Interface of []time.Time) - 
     * @param "UploadedAtLte" (optional.Interface of []time.Time) - 
     * @param "UploadedAtN" (optional.Interface of []time.Time) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedFileProxyList
*/

type ExtrasApiExtrasFileProxiesListOpts struct {
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Job optional.Interface
    JobIsnull optional.Bool
    JobN optional.Interface
    JobResultId optional.Interface
    JobResultIdIsnull optional.Bool
    JobResultIdN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    UploadedAt optional.Interface
    UploadedAtGt optional.Interface
    UploadedAtGte optional.Interface
    UploadedAtLt optional.Interface
    UploadedAtLte optional.Interface
    UploadedAtN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasFileProxiesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasFileProxiesListOpts) (PaginatedFileProxyList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedFileProxyList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/file-proxies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Job.IsSet() {
		localVarQueryParams.Add("job", parameterToString(localVarOptionals.Job.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobIsnull.IsSet() {
		localVarQueryParams.Add("job__isnull", parameterToString(localVarOptionals.JobIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobN.IsSet() {
		localVarQueryParams.Add("job__n", parameterToString(localVarOptionals.JobN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobResultId.IsSet() {
		localVarQueryParams.Add("job_result_id", parameterToString(localVarOptionals.JobResultId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobResultIdIsnull.IsSet() {
		localVarQueryParams.Add("job_result_id__isnull", parameterToString(localVarOptionals.JobResultIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobResultIdN.IsSet() {
		localVarQueryParams.Add("job_result_id__n", parameterToString(localVarOptionals.JobResultIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UploadedAt.IsSet() {
		localVarQueryParams.Add("uploaded_at", parameterToString(localVarOptionals.UploadedAt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UploadedAtGt.IsSet() {
		localVarQueryParams.Add("uploaded_at__gt", parameterToString(localVarOptionals.UploadedAtGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UploadedAtGte.IsSet() {
		localVarQueryParams.Add("uploaded_at__gte", parameterToString(localVarOptionals.UploadedAtGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UploadedAtLt.IsSet() {
		localVarQueryParams.Add("uploaded_at__lt", parameterToString(localVarOptionals.UploadedAtLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UploadedAtLte.IsSet() {
		localVarQueryParams.Add("uploaded_at__lte", parameterToString(localVarOptionals.UploadedAtLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UploadedAtN.IsSet() {
		localVarQueryParams.Add("uploaded_at__n", parameterToString(localVarOptionals.UploadedAtN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedFileProxyList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a file proxy object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this file proxy.
 * @param optional nil or *ExtrasApiExtrasFileProxiesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return FileProxy
*/

type ExtrasApiExtrasFileProxiesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasFileProxiesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasFileProxiesRetrieveOpts) (FileProxy, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FileProxy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/file-proxies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FileProxy
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasGitRepositoriesBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasGitRepositoriesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []GitRepository
*/

type ExtrasApiExtrasGitRepositoriesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableGitRepositoryRequest, localVarOptionals *ExtrasApiExtrasGitRepositoriesBulkPartialUpdateOpts) ([]GitRepository, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []GitRepository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []GitRepository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []GitRepository
*/

type ExtrasApiExtrasGitRepositoriesBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesBulkUpdate(ctx context.Context, body []BulkWritableGitRepositoryRequest, localVarOptionals *ExtrasApiExtrasGitRepositoriesBulkUpdateOpts) ([]GitRepository, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []GitRepository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []GitRepository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return GitRepository
*/

type ExtrasApiExtrasGitRepositoriesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesCreate(ctx context.Context, body GitRepositoryRequest, localVarOptionals *ExtrasApiExtrasGitRepositoriesCreateOpts) (GitRepository, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GitRepository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v GitRepository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this Git repository.
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasGitRepositoriesDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGitRepositoriesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesListOpts - Optional Parameters:
     * @param "Branch" (optional.Interface of []string) - 
     * @param "BranchIc" (optional.Interface of []string) - 
     * @param "BranchIe" (optional.Interface of []string) - 
     * @param "BranchIew" (optional.Interface of []string) - 
     * @param "BranchIre" (optional.Interface of []string) - 
     * @param "BranchIsw" (optional.Interface of []string) - 
     * @param "BranchN" (optional.Interface of []string) - 
     * @param "BranchNic" (optional.Interface of []string) - 
     * @param "BranchNie" (optional.Interface of []string) - 
     * @param "BranchNiew" (optional.Interface of []string) - 
     * @param "BranchNire" (optional.Interface of []string) - 
     * @param "BranchNisw" (optional.Interface of []string) - 
     * @param "BranchNre" (optional.Interface of []string) - 
     * @param "BranchRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "ProvidedContents" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "RemoteUrl" (optional.Interface of []string) - 
     * @param "RemoteUrlIc" (optional.Interface of []string) - 
     * @param "RemoteUrlIe" (optional.Interface of []string) - 
     * @param "RemoteUrlIew" (optional.Interface of []string) - 
     * @param "RemoteUrlIre" (optional.Interface of []string) - 
     * @param "RemoteUrlIsw" (optional.Interface of []string) - 
     * @param "RemoteUrlN" (optional.Interface of []string) - 
     * @param "RemoteUrlNic" (optional.Interface of []string) - 
     * @param "RemoteUrlNie" (optional.Interface of []string) - 
     * @param "RemoteUrlNiew" (optional.Interface of []string) - 
     * @param "RemoteUrlNire" (optional.Interface of []string) - 
     * @param "RemoteUrlNisw" (optional.Interface of []string) - 
     * @param "RemoteUrlNre" (optional.Interface of []string) - 
     * @param "RemoteUrlRe" (optional.Interface of []string) - 
     * @param "SecretsGroup" (optional.Interface of []string) - 
     * @param "SecretsGroupIsnull" (optional.Bool) - 
     * @param "SecretsGroupN" (optional.Interface of []string) - 
     * @param "SecretsGroupId" (optional.Interface of []string) -  Secrets group (ID) - Deprecated (use secrets_group filter)
     * @param "SecretsGroupIdIsnull" (optional.Bool) - 
     * @param "SecretsGroupIdN" (optional.Interface of []string) -  Secrets group (ID) - Deprecated (use secrets_group filter)
     * @param "Slug" (optional.Interface of []string) - 
     * @param "SlugIc" (optional.Interface of []string) - 
     * @param "SlugIe" (optional.Interface of []string) - 
     * @param "SlugIew" (optional.Interface of []string) - 
     * @param "SlugIre" (optional.Interface of []string) - 
     * @param "SlugIsw" (optional.Interface of []string) - 
     * @param "SlugN" (optional.Interface of []string) - 
     * @param "SlugNic" (optional.Interface of []string) - 
     * @param "SlugNie" (optional.Interface of []string) - 
     * @param "SlugNiew" (optional.Interface of []string) - 
     * @param "SlugNire" (optional.Interface of []string) - 
     * @param "SlugNisw" (optional.Interface of []string) - 
     * @param "SlugNre" (optional.Interface of []string) - 
     * @param "SlugRe" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedGitRepositoryList
*/

type ExtrasApiExtrasGitRepositoriesListOpts struct {
    Branch optional.Interface
    BranchIc optional.Interface
    BranchIe optional.Interface
    BranchIew optional.Interface
    BranchIre optional.Interface
    BranchIsw optional.Interface
    BranchN optional.Interface
    BranchNic optional.Interface
    BranchNie optional.Interface
    BranchNiew optional.Interface
    BranchNire optional.Interface
    BranchNisw optional.Interface
    BranchNre optional.Interface
    BranchRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    ProvidedContents optional.Interface
    Q optional.String
    RemoteUrl optional.Interface
    RemoteUrlIc optional.Interface
    RemoteUrlIe optional.Interface
    RemoteUrlIew optional.Interface
    RemoteUrlIre optional.Interface
    RemoteUrlIsw optional.Interface
    RemoteUrlN optional.Interface
    RemoteUrlNic optional.Interface
    RemoteUrlNie optional.Interface
    RemoteUrlNiew optional.Interface
    RemoteUrlNire optional.Interface
    RemoteUrlNisw optional.Interface
    RemoteUrlNre optional.Interface
    RemoteUrlRe optional.Interface
    SecretsGroup optional.Interface
    SecretsGroupIsnull optional.Bool
    SecretsGroupN optional.Interface
    SecretsGroupId optional.Interface
    SecretsGroupIdIsnull optional.Bool
    SecretsGroupIdN optional.Interface
    Slug optional.Interface
    SlugIc optional.Interface
    SlugIe optional.Interface
    SlugIew optional.Interface
    SlugIre optional.Interface
    SlugIsw optional.Interface
    SlugN optional.Interface
    SlugNic optional.Interface
    SlugNie optional.Interface
    SlugNiew optional.Interface
    SlugNire optional.Interface
    SlugNisw optional.Interface
    SlugNre optional.Interface
    SlugRe optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasGitRepositoriesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasGitRepositoriesListOpts) (PaginatedGitRepositoryList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedGitRepositoryList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Branch.IsSet() {
		localVarQueryParams.Add("branch", parameterToString(localVarOptionals.Branch.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchIc.IsSet() {
		localVarQueryParams.Add("branch__ic", parameterToString(localVarOptionals.BranchIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchIe.IsSet() {
		localVarQueryParams.Add("branch__ie", parameterToString(localVarOptionals.BranchIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchIew.IsSet() {
		localVarQueryParams.Add("branch__iew", parameterToString(localVarOptionals.BranchIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchIre.IsSet() {
		localVarQueryParams.Add("branch__ire", parameterToString(localVarOptionals.BranchIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchIsw.IsSet() {
		localVarQueryParams.Add("branch__isw", parameterToString(localVarOptionals.BranchIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchN.IsSet() {
		localVarQueryParams.Add("branch__n", parameterToString(localVarOptionals.BranchN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchNic.IsSet() {
		localVarQueryParams.Add("branch__nic", parameterToString(localVarOptionals.BranchNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchNie.IsSet() {
		localVarQueryParams.Add("branch__nie", parameterToString(localVarOptionals.BranchNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchNiew.IsSet() {
		localVarQueryParams.Add("branch__niew", parameterToString(localVarOptionals.BranchNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchNire.IsSet() {
		localVarQueryParams.Add("branch__nire", parameterToString(localVarOptionals.BranchNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchNisw.IsSet() {
		localVarQueryParams.Add("branch__nisw", parameterToString(localVarOptionals.BranchNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchNre.IsSet() {
		localVarQueryParams.Add("branch__nre", parameterToString(localVarOptionals.BranchNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BranchRe.IsSet() {
		localVarQueryParams.Add("branch__re", parameterToString(localVarOptionals.BranchRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProvidedContents.IsSet() {
		localVarQueryParams.Add("provided_contents", parameterToString(localVarOptionals.ProvidedContents.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrl.IsSet() {
		localVarQueryParams.Add("remote_url", parameterToString(localVarOptionals.RemoteUrl.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIc.IsSet() {
		localVarQueryParams.Add("remote_url__ic", parameterToString(localVarOptionals.RemoteUrlIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIe.IsSet() {
		localVarQueryParams.Add("remote_url__ie", parameterToString(localVarOptionals.RemoteUrlIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIew.IsSet() {
		localVarQueryParams.Add("remote_url__iew", parameterToString(localVarOptionals.RemoteUrlIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIre.IsSet() {
		localVarQueryParams.Add("remote_url__ire", parameterToString(localVarOptionals.RemoteUrlIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlIsw.IsSet() {
		localVarQueryParams.Add("remote_url__isw", parameterToString(localVarOptionals.RemoteUrlIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlN.IsSet() {
		localVarQueryParams.Add("remote_url__n", parameterToString(localVarOptionals.RemoteUrlN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNic.IsSet() {
		localVarQueryParams.Add("remote_url__nic", parameterToString(localVarOptionals.RemoteUrlNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNie.IsSet() {
		localVarQueryParams.Add("remote_url__nie", parameterToString(localVarOptionals.RemoteUrlNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNiew.IsSet() {
		localVarQueryParams.Add("remote_url__niew", parameterToString(localVarOptionals.RemoteUrlNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNire.IsSet() {
		localVarQueryParams.Add("remote_url__nire", parameterToString(localVarOptionals.RemoteUrlNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNisw.IsSet() {
		localVarQueryParams.Add("remote_url__nisw", parameterToString(localVarOptionals.RemoteUrlNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlNre.IsSet() {
		localVarQueryParams.Add("remote_url__nre", parameterToString(localVarOptionals.RemoteUrlNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteUrlRe.IsSet() {
		localVarQueryParams.Add("remote_url__re", parameterToString(localVarOptionals.RemoteUrlRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroup.IsSet() {
		localVarQueryParams.Add("secrets_group", parameterToString(localVarOptionals.SecretsGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupIsnull.IsSet() {
		localVarQueryParams.Add("secrets_group__isnull", parameterToString(localVarOptionals.SecretsGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupN.IsSet() {
		localVarQueryParams.Add("secrets_group__n", parameterToString(localVarOptionals.SecretsGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupId.IsSet() {
		localVarQueryParams.Add("secrets_group_id", parameterToString(localVarOptionals.SecretsGroupId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupIdIsnull.IsSet() {
		localVarQueryParams.Add("secrets_group_id__isnull", parameterToString(localVarOptionals.SecretsGroupIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupIdN.IsSet() {
		localVarQueryParams.Add("secrets_group_id__n", parameterToString(localVarOptionals.SecretsGroupIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Slug.IsSet() {
		localVarQueryParams.Add("slug", parameterToString(localVarOptionals.Slug.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIc.IsSet() {
		localVarQueryParams.Add("slug__ic", parameterToString(localVarOptionals.SlugIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIe.IsSet() {
		localVarQueryParams.Add("slug__ie", parameterToString(localVarOptionals.SlugIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIew.IsSet() {
		localVarQueryParams.Add("slug__iew", parameterToString(localVarOptionals.SlugIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIre.IsSet() {
		localVarQueryParams.Add("slug__ire", parameterToString(localVarOptionals.SlugIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIsw.IsSet() {
		localVarQueryParams.Add("slug__isw", parameterToString(localVarOptionals.SlugIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugN.IsSet() {
		localVarQueryParams.Add("slug__n", parameterToString(localVarOptionals.SlugN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNic.IsSet() {
		localVarQueryParams.Add("slug__nic", parameterToString(localVarOptionals.SlugNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNie.IsSet() {
		localVarQueryParams.Add("slug__nie", parameterToString(localVarOptionals.SlugNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNiew.IsSet() {
		localVarQueryParams.Add("slug__niew", parameterToString(localVarOptionals.SlugNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNire.IsSet() {
		localVarQueryParams.Add("slug__nire", parameterToString(localVarOptionals.SlugNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNisw.IsSet() {
		localVarQueryParams.Add("slug__nisw", parameterToString(localVarOptionals.SlugNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNre.IsSet() {
		localVarQueryParams.Add("slug__nre", parameterToString(localVarOptionals.SlugNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SlugRe.IsSet() {
		localVarQueryParams.Add("slug__re", parameterToString(localVarOptionals.SlugRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedGitRepositoryList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this Git repository.
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasGitRepositoriesNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasGitRepositoriesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this Git repository.
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasGitRepositoriesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasGitRepositoriesNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGitRepositoriesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this Git repository.
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedGitRepositoryRequest) - 
     * @param "Format" (optional.String) - 
@return GitRepository
*/

type ExtrasApiExtrasGitRepositoriesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGitRepositoriesPartialUpdateOpts) (GitRepository, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GitRepository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GitRepository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this Git repository.
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return GitRepository
*/

type ExtrasApiExtrasGitRepositoriesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasGitRepositoriesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGitRepositoriesRetrieveOpts) (GitRepository, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GitRepository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GitRepository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Enqueue pull git repository and refresh data.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this Git repository.
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesSyncCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return GitRepository
*/

type ExtrasApiExtrasGitRepositoriesSyncCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesSyncCreate(ctx context.Context, body GitRepositoryRequest, id string, localVarOptionals *ExtrasApiExtrasGitRepositoriesSyncCreateOpts) (GitRepository, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GitRepository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/{id}/sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GitRepository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage the use of Git repositories as external data sources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this Git repository.
 * @param optional nil or *ExtrasApiExtrasGitRepositoriesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return GitRepository
*/

type ExtrasApiExtrasGitRepositoriesUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGitRepositoriesUpdate(ctx context.Context, body GitRepositoryRequest, id string, localVarOptionals *ExtrasApiExtrasGitRepositoriesUpdateOpts) (GitRepository, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GitRepository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/git-repositories/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GitRepository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of GraphQL query objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasGraphqlQueriesBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasGraphqlQueriesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of GraphQL query objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []GraphQlQuery
*/

type ExtrasApiExtrasGraphqlQueriesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableGraphQlQueryRequest, localVarOptionals *ExtrasApiExtrasGraphqlQueriesBulkPartialUpdateOpts) ([]GraphQlQuery, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []GraphQlQuery
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []GraphQlQuery
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of GraphQL query objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []GraphQlQuery
*/

type ExtrasApiExtrasGraphqlQueriesBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesBulkUpdate(ctx context.Context, body []BulkWritableGraphQlQueryRequest, localVarOptionals *ExtrasApiExtrasGraphqlQueriesBulkUpdateOpts) ([]GraphQlQuery, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []GraphQlQuery
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []GraphQlQuery
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more GraphQL query objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return GraphQlQuery
*/

type ExtrasApiExtrasGraphqlQueriesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesCreate(ctx context.Context, body GraphQlQueryRequest, localVarOptionals *ExtrasApiExtrasGraphqlQueriesCreateOpts) (GraphQlQuery, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GraphQlQuery
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v GraphQlQuery
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a GraphQL query object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this GraphQL query.
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasGraphqlQueriesDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGraphqlQueriesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of GraphQL query objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedGraphQlQueryList
*/

type ExtrasApiExtrasGraphqlQueriesListOpts struct {
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasGraphqlQueriesListOpts) (PaginatedGraphQlQueryList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedGraphQlQueryList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedGraphQlQueryList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this GraphQL query.
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasGraphqlQueriesNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasGraphqlQueriesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this GraphQL query.
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasGraphqlQueriesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGraphqlQueriesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a GraphQL query object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this GraphQL query.
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedGraphQlQueryRequest) - 
     * @param "Format" (optional.String) - 
@return GraphQlQuery
*/

type ExtrasApiExtrasGraphqlQueriesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGraphqlQueriesPartialUpdateOpts) (GraphQlQuery, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GraphQlQuery
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GraphQlQuery
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a GraphQL query object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this GraphQL query.
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return GraphQlQuery
*/

type ExtrasApiExtrasGraphqlQueriesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGraphqlQueriesRetrieveOpts) (GraphQlQuery, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GraphQlQuery
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GraphQlQuery
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more GraphQL query objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this GraphQL query.
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesRunCreateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of GraphQlQueryInputRequest) - 
     * @param "Format" (optional.String) - 
@return GraphQlQueryOutput
*/

type ExtrasApiExtrasGraphqlQueriesRunCreateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesRunCreate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasGraphqlQueriesRunCreateOpts) (GraphQlQueryOutput, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GraphQlQueryOutput
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/{id}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GraphQlQueryOutput
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a GraphQL query object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this GraphQL query.
 * @param optional nil or *ExtrasApiExtrasGraphqlQueriesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return GraphQlQuery
*/

type ExtrasApiExtrasGraphqlQueriesUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasGraphqlQueriesUpdate(ctx context.Context, body GraphQlQueryRequest, id string, localVarOptionals *ExtrasApiExtrasGraphqlQueriesUpdateOpts) (GraphQlQuery, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GraphQlQuery
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphql-queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GraphQlQuery
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of image attachment objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasImageAttachmentsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasImageAttachmentsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasImageAttachmentsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of image attachment objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ImageAttachment
*/

type ExtrasApiExtrasImageAttachmentsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasImageAttachmentsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableImageAttachmentRequest, localVarOptionals *ExtrasApiExtrasImageAttachmentsBulkPartialUpdateOpts) ([]ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of image attachment objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ImageAttachment
*/

type ExtrasApiExtrasImageAttachmentsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasImageAttachmentsBulkUpdate(ctx context.Context, body []BulkWritableImageAttachmentRequest, localVarOptionals *ExtrasApiExtrasImageAttachmentsBulkUpdateOpts) ([]ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more image attachment objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ImageAttachment
*/

type ExtrasApiExtrasImageAttachmentsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasImageAttachmentsCreate(ctx context.Context, body ImageAttachmentRequest, localVarOptionals *ExtrasApiExtrasImageAttachmentsCreateOpts) (ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a image attachment object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this image attachment.
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasImageAttachmentsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasImageAttachmentsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasImageAttachmentsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of image attachment objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsListOpts - Optional Parameters:
     * @param "ContentType" (optional.String) - 
     * @param "ContentTypeN" (optional.String) - 
     * @param "ContentTypeId" (optional.Int32) - 
     * @param "ContentTypeIdN" (optional.Int32) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "ObjectId" (optional.Interface of []string) - 
     * @param "ObjectIdIc" (optional.Interface of []string) - 
     * @param "ObjectIdIe" (optional.Interface of []string) - 
     * @param "ObjectIdIew" (optional.Interface of []string) - 
     * @param "ObjectIdIre" (optional.Interface of []string) - 
     * @param "ObjectIdIsw" (optional.Interface of []string) - 
     * @param "ObjectIdN" (optional.Interface of []string) - 
     * @param "ObjectIdNic" (optional.Interface of []string) - 
     * @param "ObjectIdNie" (optional.Interface of []string) - 
     * @param "ObjectIdNiew" (optional.Interface of []string) - 
     * @param "ObjectIdNire" (optional.Interface of []string) - 
     * @param "ObjectIdNisw" (optional.Interface of []string) - 
     * @param "ObjectIdNre" (optional.Interface of []string) - 
     * @param "ObjectIdRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedImageAttachmentList
*/

type ExtrasApiExtrasImageAttachmentsListOpts struct {
    ContentType optional.String
    ContentTypeN optional.String
    ContentTypeId optional.Int32
    ContentTypeIdN optional.Int32
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    ObjectId optional.Interface
    ObjectIdIc optional.Interface
    ObjectIdIe optional.Interface
    ObjectIdIew optional.Interface
    ObjectIdIre optional.Interface
    ObjectIdIsw optional.Interface
    ObjectIdN optional.Interface
    ObjectIdNic optional.Interface
    ObjectIdNie optional.Interface
    ObjectIdNiew optional.Interface
    ObjectIdNire optional.Interface
    ObjectIdNisw optional.Interface
    ObjectIdNre optional.Interface
    ObjectIdRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasImageAttachmentsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasImageAttachmentsListOpts) (PaginatedImageAttachmentList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedImageAttachmentList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentType.IsSet() {
		localVarQueryParams.Add("content_type", parameterToString(localVarOptionals.ContentType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeN.IsSet() {
		localVarQueryParams.Add("content_type__n", parameterToString(localVarOptionals.ContentTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeId.IsSet() {
		localVarQueryParams.Add("content_type_id", parameterToString(localVarOptionals.ContentTypeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeIdN.IsSet() {
		localVarQueryParams.Add("content_type_id__n", parameterToString(localVarOptionals.ContentTypeIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectId.IsSet() {
		localVarQueryParams.Add("object_id", parameterToString(localVarOptionals.ObjectId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdIc.IsSet() {
		localVarQueryParams.Add("object_id__ic", parameterToString(localVarOptionals.ObjectIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdIe.IsSet() {
		localVarQueryParams.Add("object_id__ie", parameterToString(localVarOptionals.ObjectIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdIew.IsSet() {
		localVarQueryParams.Add("object_id__iew", parameterToString(localVarOptionals.ObjectIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdIre.IsSet() {
		localVarQueryParams.Add("object_id__ire", parameterToString(localVarOptionals.ObjectIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdIsw.IsSet() {
		localVarQueryParams.Add("object_id__isw", parameterToString(localVarOptionals.ObjectIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdN.IsSet() {
		localVarQueryParams.Add("object_id__n", parameterToString(localVarOptionals.ObjectIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdNic.IsSet() {
		localVarQueryParams.Add("object_id__nic", parameterToString(localVarOptionals.ObjectIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdNie.IsSet() {
		localVarQueryParams.Add("object_id__nie", parameterToString(localVarOptionals.ObjectIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdNiew.IsSet() {
		localVarQueryParams.Add("object_id__niew", parameterToString(localVarOptionals.ObjectIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdNire.IsSet() {
		localVarQueryParams.Add("object_id__nire", parameterToString(localVarOptionals.ObjectIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdNisw.IsSet() {
		localVarQueryParams.Add("object_id__nisw", parameterToString(localVarOptionals.ObjectIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdNre.IsSet() {
		localVarQueryParams.Add("object_id__nre", parameterToString(localVarOptionals.ObjectIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectIdRe.IsSet() {
		localVarQueryParams.Add("object_id__re", parameterToString(localVarOptionals.ObjectIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedImageAttachmentList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a image attachment object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this image attachment.
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedImageAttachmentRequest) - 
     * @param "Format" (optional.String) - 
@return ImageAttachment
*/

type ExtrasApiExtrasImageAttachmentsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasImageAttachmentsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasImageAttachmentsPartialUpdateOpts) (ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a image attachment object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this image attachment.
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ImageAttachment
*/

type ExtrasApiExtrasImageAttachmentsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasImageAttachmentsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasImageAttachmentsRetrieveOpts) (ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a image attachment object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this image attachment.
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ImageAttachment
*/

type ExtrasApiExtrasImageAttachmentsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasImageAttachmentsUpdate(ctx context.Context, body ImageAttachmentRequest, id string, localVarOptionals *ExtrasApiExtrasImageAttachmentsUpdateOpts) (ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobButtonsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobButtonsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobButtonsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasJobButtonsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobButtonsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []JobButton
*/

type ExtrasApiExtrasJobButtonsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobButtonsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableJobButtonRequest, localVarOptionals *ExtrasApiExtrasJobButtonsBulkPartialUpdateOpts) ([]JobButton, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []JobButton
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []JobButton
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobButtonsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []JobButton
*/

type ExtrasApiExtrasJobButtonsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobButtonsBulkUpdate(ctx context.Context, body []BulkWritableJobButtonRequest, localVarOptionals *ExtrasApiExtrasJobButtonsBulkUpdateOpts) ([]JobButton, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []JobButton
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []JobButton
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobButtonsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return JobButton
*/

type ExtrasApiExtrasJobButtonsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobButtonsCreate(ctx context.Context, body JobButtonRequest, localVarOptionals *ExtrasApiExtrasJobButtonsCreateOpts) (JobButton, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobButton
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v JobButton
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job button.
 * @param optional nil or *ExtrasApiExtrasJobButtonsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobButtonsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobButtonsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobButtonsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasJobButtonsListOpts - Optional Parameters:
     * @param "ButtonClass" (optional.Interface of []string) - 
     * @param "ButtonClassIc" (optional.Interface of []string) - 
     * @param "ButtonClassIe" (optional.Interface of []string) - 
     * @param "ButtonClassIew" (optional.Interface of []string) - 
     * @param "ButtonClassIre" (optional.Interface of []string) - 
     * @param "ButtonClassIsw" (optional.Interface of []string) - 
     * @param "ButtonClassN" (optional.Interface of []string) - 
     * @param "ButtonClassNic" (optional.Interface of []string) - 
     * @param "ButtonClassNie" (optional.Interface of []string) - 
     * @param "ButtonClassNiew" (optional.Interface of []string) - 
     * @param "ButtonClassNire" (optional.Interface of []string) - 
     * @param "ButtonClassNisw" (optional.Interface of []string) - 
     * @param "ButtonClassNre" (optional.Interface of []string) - 
     * @param "ButtonClassRe" (optional.Interface of []string) - 
     * @param "Confirmation" (optional.Bool) - 
     * @param "ContentTypes" (optional.String) - 
     * @param "ContentTypesIc" (optional.String) - 
     * @param "ContentTypesIe" (optional.String) - 
     * @param "ContentTypesIew" (optional.String) - 
     * @param "ContentTypesIre" (optional.String) - 
     * @param "ContentTypesIsw" (optional.String) - 
     * @param "ContentTypesN" (optional.String) - 
     * @param "ContentTypesNic" (optional.String) - 
     * @param "ContentTypesNie" (optional.String) - 
     * @param "ContentTypesNiew" (optional.String) - 
     * @param "ContentTypesNire" (optional.String) - 
     * @param "ContentTypesNisw" (optional.String) - 
     * @param "ContentTypesNre" (optional.String) - 
     * @param "ContentTypesRe" (optional.String) - 
     * @param "Format" (optional.String) - 
     * @param "GroupName" (optional.Interface of []string) - 
     * @param "GroupNameIc" (optional.Interface of []string) - 
     * @param "GroupNameIe" (optional.Interface of []string) - 
     * @param "GroupNameIew" (optional.Interface of []string) - 
     * @param "GroupNameIre" (optional.Interface of []string) - 
     * @param "GroupNameIsw" (optional.Interface of []string) - 
     * @param "GroupNameN" (optional.Interface of []string) - 
     * @param "GroupNameNic" (optional.Interface of []string) - 
     * @param "GroupNameNie" (optional.Interface of []string) - 
     * @param "GroupNameNiew" (optional.Interface of []string) - 
     * @param "GroupNameNire" (optional.Interface of []string) - 
     * @param "GroupNameNisw" (optional.Interface of []string) - 
     * @param "GroupNameNre" (optional.Interface of []string) - 
     * @param "GroupNameRe" (optional.Interface of []string) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Job" (optional.Interface of []string) - 
     * @param "JobN" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Text" (optional.Interface of []string) - 
     * @param "TextIc" (optional.Interface of []string) - 
     * @param "TextIe" (optional.Interface of []string) - 
     * @param "TextIew" (optional.Interface of []string) - 
     * @param "TextIre" (optional.Interface of []string) - 
     * @param "TextIsw" (optional.Interface of []string) - 
     * @param "TextN" (optional.Interface of []string) - 
     * @param "TextNic" (optional.Interface of []string) - 
     * @param "TextNie" (optional.Interface of []string) - 
     * @param "TextNiew" (optional.Interface of []string) - 
     * @param "TextNire" (optional.Interface of []string) - 
     * @param "TextNisw" (optional.Interface of []string) - 
     * @param "TextNre" (optional.Interface of []string) - 
     * @param "TextRe" (optional.Interface of []string) - 
     * @param "Weight" (optional.Interface of []int32) - 
     * @param "WeightGt" (optional.Interface of []int32) - 
     * @param "WeightGte" (optional.Interface of []int32) - 
     * @param "WeightLt" (optional.Interface of []int32) - 
     * @param "WeightLte" (optional.Interface of []int32) - 
     * @param "WeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedJobButtonList
*/

type ExtrasApiExtrasJobButtonsListOpts struct {
    ButtonClass optional.Interface
    ButtonClassIc optional.Interface
    ButtonClassIe optional.Interface
    ButtonClassIew optional.Interface
    ButtonClassIre optional.Interface
    ButtonClassIsw optional.Interface
    ButtonClassN optional.Interface
    ButtonClassNic optional.Interface
    ButtonClassNie optional.Interface
    ButtonClassNiew optional.Interface
    ButtonClassNire optional.Interface
    ButtonClassNisw optional.Interface
    ButtonClassNre optional.Interface
    ButtonClassRe optional.Interface
    Confirmation optional.Bool
    ContentTypes optional.String
    ContentTypesIc optional.String
    ContentTypesIe optional.String
    ContentTypesIew optional.String
    ContentTypesIre optional.String
    ContentTypesIsw optional.String
    ContentTypesN optional.String
    ContentTypesNic optional.String
    ContentTypesNie optional.String
    ContentTypesNiew optional.String
    ContentTypesNire optional.String
    ContentTypesNisw optional.String
    ContentTypesNre optional.String
    ContentTypesRe optional.String
    Format optional.String
    GroupName optional.Interface
    GroupNameIc optional.Interface
    GroupNameIe optional.Interface
    GroupNameIew optional.Interface
    GroupNameIre optional.Interface
    GroupNameIsw optional.Interface
    GroupNameN optional.Interface
    GroupNameNic optional.Interface
    GroupNameNie optional.Interface
    GroupNameNiew optional.Interface
    GroupNameNire optional.Interface
    GroupNameNisw optional.Interface
    GroupNameNre optional.Interface
    GroupNameRe optional.Interface
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Job optional.Interface
    JobN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Text optional.Interface
    TextIc optional.Interface
    TextIe optional.Interface
    TextIew optional.Interface
    TextIre optional.Interface
    TextIsw optional.Interface
    TextN optional.Interface
    TextNic optional.Interface
    TextNie optional.Interface
    TextNiew optional.Interface
    TextNire optional.Interface
    TextNisw optional.Interface
    TextNre optional.Interface
    TextRe optional.Interface
    Weight optional.Interface
    WeightGt optional.Interface
    WeightGte optional.Interface
    WeightLt optional.Interface
    WeightLte optional.Interface
    WeightN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobButtonsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasJobButtonsListOpts) (PaginatedJobButtonList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedJobButtonList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ButtonClass.IsSet() {
		localVarQueryParams.Add("button_class", parameterToString(localVarOptionals.ButtonClass.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIc.IsSet() {
		localVarQueryParams.Add("button_class__ic", parameterToString(localVarOptionals.ButtonClassIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIe.IsSet() {
		localVarQueryParams.Add("button_class__ie", parameterToString(localVarOptionals.ButtonClassIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIew.IsSet() {
		localVarQueryParams.Add("button_class__iew", parameterToString(localVarOptionals.ButtonClassIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIre.IsSet() {
		localVarQueryParams.Add("button_class__ire", parameterToString(localVarOptionals.ButtonClassIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassIsw.IsSet() {
		localVarQueryParams.Add("button_class__isw", parameterToString(localVarOptionals.ButtonClassIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassN.IsSet() {
		localVarQueryParams.Add("button_class__n", parameterToString(localVarOptionals.ButtonClassN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNic.IsSet() {
		localVarQueryParams.Add("button_class__nic", parameterToString(localVarOptionals.ButtonClassNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNie.IsSet() {
		localVarQueryParams.Add("button_class__nie", parameterToString(localVarOptionals.ButtonClassNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNiew.IsSet() {
		localVarQueryParams.Add("button_class__niew", parameterToString(localVarOptionals.ButtonClassNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNire.IsSet() {
		localVarQueryParams.Add("button_class__nire", parameterToString(localVarOptionals.ButtonClassNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNisw.IsSet() {
		localVarQueryParams.Add("button_class__nisw", parameterToString(localVarOptionals.ButtonClassNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassNre.IsSet() {
		localVarQueryParams.Add("button_class__nre", parameterToString(localVarOptionals.ButtonClassNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ButtonClassRe.IsSet() {
		localVarQueryParams.Add("button_class__re", parameterToString(localVarOptionals.ButtonClassRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Confirmation.IsSet() {
		localVarQueryParams.Add("confirmation", parameterToString(localVarOptionals.Confirmation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypes.IsSet() {
		localVarQueryParams.Add("content_types", parameterToString(localVarOptionals.ContentTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIc.IsSet() {
		localVarQueryParams.Add("content_types__ic", parameterToString(localVarOptionals.ContentTypesIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIe.IsSet() {
		localVarQueryParams.Add("content_types__ie", parameterToString(localVarOptionals.ContentTypesIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIew.IsSet() {
		localVarQueryParams.Add("content_types__iew", parameterToString(localVarOptionals.ContentTypesIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIre.IsSet() {
		localVarQueryParams.Add("content_types__ire", parameterToString(localVarOptionals.ContentTypesIre.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIsw.IsSet() {
		localVarQueryParams.Add("content_types__isw", parameterToString(localVarOptionals.ContentTypesIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesN.IsSet() {
		localVarQueryParams.Add("content_types__n", parameterToString(localVarOptionals.ContentTypesN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNic.IsSet() {
		localVarQueryParams.Add("content_types__nic", parameterToString(localVarOptionals.ContentTypesNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNie.IsSet() {
		localVarQueryParams.Add("content_types__nie", parameterToString(localVarOptionals.ContentTypesNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNiew.IsSet() {
		localVarQueryParams.Add("content_types__niew", parameterToString(localVarOptionals.ContentTypesNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNire.IsSet() {
		localVarQueryParams.Add("content_types__nire", parameterToString(localVarOptionals.ContentTypesNire.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNisw.IsSet() {
		localVarQueryParams.Add("content_types__nisw", parameterToString(localVarOptionals.ContentTypesNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNre.IsSet() {
		localVarQueryParams.Add("content_types__nre", parameterToString(localVarOptionals.ContentTypesNre.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesRe.IsSet() {
		localVarQueryParams.Add("content_types__re", parameterToString(localVarOptionals.ContentTypesRe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupName.IsSet() {
		localVarQueryParams.Add("group_name", parameterToString(localVarOptionals.GroupName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIc.IsSet() {
		localVarQueryParams.Add("group_name__ic", parameterToString(localVarOptionals.GroupNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIe.IsSet() {
		localVarQueryParams.Add("group_name__ie", parameterToString(localVarOptionals.GroupNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIew.IsSet() {
		localVarQueryParams.Add("group_name__iew", parameterToString(localVarOptionals.GroupNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIre.IsSet() {
		localVarQueryParams.Add("group_name__ire", parameterToString(localVarOptionals.GroupNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameIsw.IsSet() {
		localVarQueryParams.Add("group_name__isw", parameterToString(localVarOptionals.GroupNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameN.IsSet() {
		localVarQueryParams.Add("group_name__n", parameterToString(localVarOptionals.GroupNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNic.IsSet() {
		localVarQueryParams.Add("group_name__nic", parameterToString(localVarOptionals.GroupNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNie.IsSet() {
		localVarQueryParams.Add("group_name__nie", parameterToString(localVarOptionals.GroupNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNiew.IsSet() {
		localVarQueryParams.Add("group_name__niew", parameterToString(localVarOptionals.GroupNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNire.IsSet() {
		localVarQueryParams.Add("group_name__nire", parameterToString(localVarOptionals.GroupNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNisw.IsSet() {
		localVarQueryParams.Add("group_name__nisw", parameterToString(localVarOptionals.GroupNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameNre.IsSet() {
		localVarQueryParams.Add("group_name__nre", parameterToString(localVarOptionals.GroupNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupNameRe.IsSet() {
		localVarQueryParams.Add("group_name__re", parameterToString(localVarOptionals.GroupNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Job.IsSet() {
		localVarQueryParams.Add("job", parameterToString(localVarOptionals.Job.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobN.IsSet() {
		localVarQueryParams.Add("job__n", parameterToString(localVarOptionals.JobN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Text.IsSet() {
		localVarQueryParams.Add("text", parameterToString(localVarOptionals.Text.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIc.IsSet() {
		localVarQueryParams.Add("text__ic", parameterToString(localVarOptionals.TextIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIe.IsSet() {
		localVarQueryParams.Add("text__ie", parameterToString(localVarOptionals.TextIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIew.IsSet() {
		localVarQueryParams.Add("text__iew", parameterToString(localVarOptionals.TextIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIre.IsSet() {
		localVarQueryParams.Add("text__ire", parameterToString(localVarOptionals.TextIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextIsw.IsSet() {
		localVarQueryParams.Add("text__isw", parameterToString(localVarOptionals.TextIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextN.IsSet() {
		localVarQueryParams.Add("text__n", parameterToString(localVarOptionals.TextN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNic.IsSet() {
		localVarQueryParams.Add("text__nic", parameterToString(localVarOptionals.TextNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNie.IsSet() {
		localVarQueryParams.Add("text__nie", parameterToString(localVarOptionals.TextNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNiew.IsSet() {
		localVarQueryParams.Add("text__niew", parameterToString(localVarOptionals.TextNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNire.IsSet() {
		localVarQueryParams.Add("text__nire", parameterToString(localVarOptionals.TextNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNisw.IsSet() {
		localVarQueryParams.Add("text__nisw", parameterToString(localVarOptionals.TextNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextNre.IsSet() {
		localVarQueryParams.Add("text__nre", parameterToString(localVarOptionals.TextNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TextRe.IsSet() {
		localVarQueryParams.Add("text__re", parameterToString(localVarOptionals.TextRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Weight.IsSet() {
		localVarQueryParams.Add("weight", parameterToString(localVarOptionals.Weight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGt.IsSet() {
		localVarQueryParams.Add("weight__gt", parameterToString(localVarOptionals.WeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGte.IsSet() {
		localVarQueryParams.Add("weight__gte", parameterToString(localVarOptionals.WeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLt.IsSet() {
		localVarQueryParams.Add("weight__lt", parameterToString(localVarOptionals.WeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLte.IsSet() {
		localVarQueryParams.Add("weight__lte", parameterToString(localVarOptionals.WeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightN.IsSet() {
		localVarQueryParams.Add("weight__n", parameterToString(localVarOptionals.WeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedJobButtonList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this job button.
 * @param optional nil or *ExtrasApiExtrasJobButtonsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasJobButtonsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobButtonsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasJobButtonsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job button.
 * @param optional nil or *ExtrasApiExtrasJobButtonsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasJobButtonsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobButtonsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobButtonsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job button.
 * @param optional nil or *ExtrasApiExtrasJobButtonsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedJobButtonRequest) - 
     * @param "Format" (optional.String) - 
@return JobButton
*/

type ExtrasApiExtrasJobButtonsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobButtonsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobButtonsPartialUpdateOpts) (JobButton, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobButton
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobButton
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job button.
 * @param optional nil or *ExtrasApiExtrasJobButtonsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return JobButton
*/

type ExtrasApiExtrasJobButtonsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobButtonsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobButtonsRetrieveOpts) (JobButton, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobButton
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobButton
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this job button.
 * @param optional nil or *ExtrasApiExtrasJobButtonsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return JobButton
*/

type ExtrasApiExtrasJobButtonsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobButtonsUpdate(ctx context.Context, body JobButtonRequest, id string, localVarOptionals *ExtrasApiExtrasJobButtonsUpdateOpts) (JobButton, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobButton
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-buttons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobButton
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobHooksBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobHooksBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobHooksBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasJobHooksBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobHooksBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []JobHook
*/

type ExtrasApiExtrasJobHooksBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobHooksBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableJobHookRequest, localVarOptionals *ExtrasApiExtrasJobHooksBulkPartialUpdateOpts) ([]JobHook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []JobHook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []JobHook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobHooksBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []JobHook
*/

type ExtrasApiExtrasJobHooksBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobHooksBulkUpdate(ctx context.Context, body []BulkWritableJobHookRequest, localVarOptionals *ExtrasApiExtrasJobHooksBulkUpdateOpts) ([]JobHook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []JobHook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []JobHook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobHooksCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return JobHook
*/

type ExtrasApiExtrasJobHooksCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobHooksCreate(ctx context.Context, body JobHookRequest, localVarOptionals *ExtrasApiExtrasJobHooksCreateOpts) (JobHook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobHook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v JobHook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job hook.
 * @param optional nil or *ExtrasApiExtrasJobHooksDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobHooksDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobHooksDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobHooksDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasJobHooksListOpts - Optional Parameters:
     * @param "ContentTypes" (optional.Interface of []int32) - 
     * @param "ContentTypesIc" (optional.Interface of []int32) - 
     * @param "ContentTypesIe" (optional.Interface of []int32) - 
     * @param "ContentTypesIew" (optional.Interface of []int32) - 
     * @param "ContentTypesIre" (optional.Interface of []int32) - 
     * @param "ContentTypesIsw" (optional.Interface of []int32) - 
     * @param "ContentTypesN" (optional.Interface of []int32) - 
     * @param "ContentTypesNic" (optional.Interface of []int32) - 
     * @param "ContentTypesNie" (optional.Interface of []int32) - 
     * @param "ContentTypesNiew" (optional.Interface of []int32) - 
     * @param "ContentTypesNire" (optional.Interface of []int32) - 
     * @param "ContentTypesNisw" (optional.Interface of []int32) - 
     * @param "ContentTypesNre" (optional.Interface of []int32) - 
     * @param "ContentTypesRe" (optional.Interface of []int32) - 
     * @param "Enabled" (optional.Bool) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Job" (optional.Interface of []string) - 
     * @param "JobN" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "TypeCreate" (optional.Bool) - 
     * @param "TypeDelete" (optional.Bool) - 
     * @param "TypeUpdate" (optional.Bool) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedJobHookList
*/

type ExtrasApiExtrasJobHooksListOpts struct {
    ContentTypes optional.Interface
    ContentTypesIc optional.Interface
    ContentTypesIe optional.Interface
    ContentTypesIew optional.Interface
    ContentTypesIre optional.Interface
    ContentTypesIsw optional.Interface
    ContentTypesN optional.Interface
    ContentTypesNic optional.Interface
    ContentTypesNie optional.Interface
    ContentTypesNiew optional.Interface
    ContentTypesNire optional.Interface
    ContentTypesNisw optional.Interface
    ContentTypesNre optional.Interface
    ContentTypesRe optional.Interface
    Enabled optional.Bool
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Job optional.Interface
    JobN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    TypeCreate optional.Bool
    TypeDelete optional.Bool
    TypeUpdate optional.Bool
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobHooksList(ctx context.Context, localVarOptionals *ExtrasApiExtrasJobHooksListOpts) (PaginatedJobHookList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedJobHookList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentTypes.IsSet() {
		localVarQueryParams.Add("content_types", parameterToString(localVarOptionals.ContentTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIc.IsSet() {
		localVarQueryParams.Add("content_types__ic", parameterToString(localVarOptionals.ContentTypesIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIe.IsSet() {
		localVarQueryParams.Add("content_types__ie", parameterToString(localVarOptionals.ContentTypesIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIew.IsSet() {
		localVarQueryParams.Add("content_types__iew", parameterToString(localVarOptionals.ContentTypesIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIre.IsSet() {
		localVarQueryParams.Add("content_types__ire", parameterToString(localVarOptionals.ContentTypesIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIsw.IsSet() {
		localVarQueryParams.Add("content_types__isw", parameterToString(localVarOptionals.ContentTypesIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesN.IsSet() {
		localVarQueryParams.Add("content_types__n", parameterToString(localVarOptionals.ContentTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNic.IsSet() {
		localVarQueryParams.Add("content_types__nic", parameterToString(localVarOptionals.ContentTypesNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNie.IsSet() {
		localVarQueryParams.Add("content_types__nie", parameterToString(localVarOptionals.ContentTypesNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNiew.IsSet() {
		localVarQueryParams.Add("content_types__niew", parameterToString(localVarOptionals.ContentTypesNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNire.IsSet() {
		localVarQueryParams.Add("content_types__nire", parameterToString(localVarOptionals.ContentTypesNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNisw.IsSet() {
		localVarQueryParams.Add("content_types__nisw", parameterToString(localVarOptionals.ContentTypesNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNre.IsSet() {
		localVarQueryParams.Add("content_types__nre", parameterToString(localVarOptionals.ContentTypesNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesRe.IsSet() {
		localVarQueryParams.Add("content_types__re", parameterToString(localVarOptionals.ContentTypesRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Job.IsSet() {
		localVarQueryParams.Add("job", parameterToString(localVarOptionals.Job.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobN.IsSet() {
		localVarQueryParams.Add("job__n", parameterToString(localVarOptionals.JobN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TypeCreate.IsSet() {
		localVarQueryParams.Add("type_create", parameterToString(localVarOptionals.TypeCreate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TypeDelete.IsSet() {
		localVarQueryParams.Add("type_delete", parameterToString(localVarOptionals.TypeDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TypeUpdate.IsSet() {
		localVarQueryParams.Add("type_update", parameterToString(localVarOptionals.TypeUpdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedJobHookList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this job hook.
 * @param optional nil or *ExtrasApiExtrasJobHooksNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasJobHooksNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobHooksNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasJobHooksNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job hook.
 * @param optional nil or *ExtrasApiExtrasJobHooksNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasJobHooksNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobHooksNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobHooksNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job hook.
 * @param optional nil or *ExtrasApiExtrasJobHooksPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedJobHookRequest) - 
     * @param "Format" (optional.String) - 
@return JobHook
*/

type ExtrasApiExtrasJobHooksPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobHooksPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobHooksPartialUpdateOpts) (JobHook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobHook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobHook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job hook.
 * @param optional nil or *ExtrasApiExtrasJobHooksRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return JobHook
*/

type ExtrasApiExtrasJobHooksRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobHooksRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobHooksRetrieveOpts) (JobHook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobHook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobHook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this job hook.
 * @param optional nil or *ExtrasApiExtrasJobHooksUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return JobHook
*/

type ExtrasApiExtrasJobHooksUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobHooksUpdate(ctx context.Context, body JobHookRequest, id string, localVarOptionals *ExtrasApiExtrasJobHooksUpdateOpts) (JobHook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobHook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-hooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobHook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job log entries.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasJobLogsListOpts - Optional Parameters:
     * @param "AbsoluteUrl" (optional.Interface of []string) - 
     * @param "AbsoluteUrlIc" (optional.Interface of []string) - 
     * @param "AbsoluteUrlIe" (optional.Interface of []string) - 
     * @param "AbsoluteUrlIew" (optional.Interface of []string) - 
     * @param "AbsoluteUrlIre" (optional.Interface of []string) - 
     * @param "AbsoluteUrlIsw" (optional.Interface of []string) - 
     * @param "AbsoluteUrlN" (optional.Interface of []string) - 
     * @param "AbsoluteUrlNic" (optional.Interface of []string) - 
     * @param "AbsoluteUrlNie" (optional.Interface of []string) - 
     * @param "AbsoluteUrlNiew" (optional.Interface of []string) - 
     * @param "AbsoluteUrlNire" (optional.Interface of []string) - 
     * @param "AbsoluteUrlNisw" (optional.Interface of []string) - 
     * @param "AbsoluteUrlNre" (optional.Interface of []string) - 
     * @param "AbsoluteUrlRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Grouping" (optional.Interface of []string) - 
     * @param "GroupingIc" (optional.Interface of []string) - 
     * @param "GroupingIe" (optional.Interface of []string) - 
     * @param "GroupingIew" (optional.Interface of []string) - 
     * @param "GroupingIre" (optional.Interface of []string) - 
     * @param "GroupingIsw" (optional.Interface of []string) - 
     * @param "GroupingN" (optional.Interface of []string) - 
     * @param "GroupingNic" (optional.Interface of []string) - 
     * @param "GroupingNie" (optional.Interface of []string) - 
     * @param "GroupingNiew" (optional.Interface of []string) - 
     * @param "GroupingNire" (optional.Interface of []string) - 
     * @param "GroupingNisw" (optional.Interface of []string) - 
     * @param "GroupingNre" (optional.Interface of []string) - 
     * @param "GroupingRe" (optional.Interface of []string) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "JobResult" (optional.Interface of string) - 
     * @param "JobResultN" (optional.Interface of string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "LogLevel" (optional.Interface of []string) - 
     * @param "LogLevelIc" (optional.Interface of []string) - 
     * @param "LogLevelIe" (optional.Interface of []string) - 
     * @param "LogLevelIew" (optional.Interface of []string) - 
     * @param "LogLevelIre" (optional.Interface of []string) - 
     * @param "LogLevelIsw" (optional.Interface of []string) - 
     * @param "LogLevelN" (optional.Interface of []string) - 
     * @param "LogLevelNic" (optional.Interface of []string) - 
     * @param "LogLevelNie" (optional.Interface of []string) - 
     * @param "LogLevelNiew" (optional.Interface of []string) - 
     * @param "LogLevelNire" (optional.Interface of []string) - 
     * @param "LogLevelNisw" (optional.Interface of []string) - 
     * @param "LogLevelNre" (optional.Interface of []string) - 
     * @param "LogLevelRe" (optional.Interface of []string) - 
     * @param "LogObject" (optional.Interface of []string) - 
     * @param "LogObjectIc" (optional.Interface of []string) - 
     * @param "LogObjectIe" (optional.Interface of []string) - 
     * @param "LogObjectIew" (optional.Interface of []string) - 
     * @param "LogObjectIre" (optional.Interface of []string) - 
     * @param "LogObjectIsw" (optional.Interface of []string) - 
     * @param "LogObjectN" (optional.Interface of []string) - 
     * @param "LogObjectNic" (optional.Interface of []string) - 
     * @param "LogObjectNie" (optional.Interface of []string) - 
     * @param "LogObjectNiew" (optional.Interface of []string) - 
     * @param "LogObjectNire" (optional.Interface of []string) - 
     * @param "LogObjectNisw" (optional.Interface of []string) - 
     * @param "LogObjectNre" (optional.Interface of []string) - 
     * @param "LogObjectRe" (optional.Interface of []string) - 
     * @param "Message" (optional.Interface of []string) - 
     * @param "MessageIc" (optional.Interface of []string) - 
     * @param "MessageIe" (optional.Interface of []string) - 
     * @param "MessageIew" (optional.Interface of []string) - 
     * @param "MessageIre" (optional.Interface of []string) - 
     * @param "MessageIsw" (optional.Interface of []string) - 
     * @param "MessageN" (optional.Interface of []string) - 
     * @param "MessageNic" (optional.Interface of []string) - 
     * @param "MessageNie" (optional.Interface of []string) - 
     * @param "MessageNiew" (optional.Interface of []string) - 
     * @param "MessageNire" (optional.Interface of []string) - 
     * @param "MessageNisw" (optional.Interface of []string) - 
     * @param "MessageNre" (optional.Interface of []string) - 
     * @param "MessageRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedJobLogEntryList
*/

type ExtrasApiExtrasJobLogsListOpts struct {
    AbsoluteUrl optional.Interface
    AbsoluteUrlIc optional.Interface
    AbsoluteUrlIe optional.Interface
    AbsoluteUrlIew optional.Interface
    AbsoluteUrlIre optional.Interface
    AbsoluteUrlIsw optional.Interface
    AbsoluteUrlN optional.Interface
    AbsoluteUrlNic optional.Interface
    AbsoluteUrlNie optional.Interface
    AbsoluteUrlNiew optional.Interface
    AbsoluteUrlNire optional.Interface
    AbsoluteUrlNisw optional.Interface
    AbsoluteUrlNre optional.Interface
    AbsoluteUrlRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Grouping optional.Interface
    GroupingIc optional.Interface
    GroupingIe optional.Interface
    GroupingIew optional.Interface
    GroupingIre optional.Interface
    GroupingIsw optional.Interface
    GroupingN optional.Interface
    GroupingNic optional.Interface
    GroupingNie optional.Interface
    GroupingNiew optional.Interface
    GroupingNire optional.Interface
    GroupingNisw optional.Interface
    GroupingNre optional.Interface
    GroupingRe optional.Interface
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    JobResult optional.Interface
    JobResultN optional.Interface
    Limit optional.Int32
    LogLevel optional.Interface
    LogLevelIc optional.Interface
    LogLevelIe optional.Interface
    LogLevelIew optional.Interface
    LogLevelIre optional.Interface
    LogLevelIsw optional.Interface
    LogLevelN optional.Interface
    LogLevelNic optional.Interface
    LogLevelNie optional.Interface
    LogLevelNiew optional.Interface
    LogLevelNire optional.Interface
    LogLevelNisw optional.Interface
    LogLevelNre optional.Interface
    LogLevelRe optional.Interface
    LogObject optional.Interface
    LogObjectIc optional.Interface
    LogObjectIe optional.Interface
    LogObjectIew optional.Interface
    LogObjectIre optional.Interface
    LogObjectIsw optional.Interface
    LogObjectN optional.Interface
    LogObjectNic optional.Interface
    LogObjectNie optional.Interface
    LogObjectNiew optional.Interface
    LogObjectNire optional.Interface
    LogObjectNisw optional.Interface
    LogObjectNre optional.Interface
    LogObjectRe optional.Interface
    Message optional.Interface
    MessageIc optional.Interface
    MessageIe optional.Interface
    MessageIew optional.Interface
    MessageIre optional.Interface
    MessageIsw optional.Interface
    MessageN optional.Interface
    MessageNic optional.Interface
    MessageNie optional.Interface
    MessageNiew optional.Interface
    MessageNire optional.Interface
    MessageNisw optional.Interface
    MessageNre optional.Interface
    MessageRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobLogsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasJobLogsListOpts) (PaginatedJobLogEntryList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedJobLogEntryList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-logs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AbsoluteUrl.IsSet() {
		localVarQueryParams.Add("absolute_url", parameterToString(localVarOptionals.AbsoluteUrl.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlIc.IsSet() {
		localVarQueryParams.Add("absolute_url__ic", parameterToString(localVarOptionals.AbsoluteUrlIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlIe.IsSet() {
		localVarQueryParams.Add("absolute_url__ie", parameterToString(localVarOptionals.AbsoluteUrlIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlIew.IsSet() {
		localVarQueryParams.Add("absolute_url__iew", parameterToString(localVarOptionals.AbsoluteUrlIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlIre.IsSet() {
		localVarQueryParams.Add("absolute_url__ire", parameterToString(localVarOptionals.AbsoluteUrlIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlIsw.IsSet() {
		localVarQueryParams.Add("absolute_url__isw", parameterToString(localVarOptionals.AbsoluteUrlIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlN.IsSet() {
		localVarQueryParams.Add("absolute_url__n", parameterToString(localVarOptionals.AbsoluteUrlN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlNic.IsSet() {
		localVarQueryParams.Add("absolute_url__nic", parameterToString(localVarOptionals.AbsoluteUrlNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlNie.IsSet() {
		localVarQueryParams.Add("absolute_url__nie", parameterToString(localVarOptionals.AbsoluteUrlNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlNiew.IsSet() {
		localVarQueryParams.Add("absolute_url__niew", parameterToString(localVarOptionals.AbsoluteUrlNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlNire.IsSet() {
		localVarQueryParams.Add("absolute_url__nire", parameterToString(localVarOptionals.AbsoluteUrlNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlNisw.IsSet() {
		localVarQueryParams.Add("absolute_url__nisw", parameterToString(localVarOptionals.AbsoluteUrlNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlNre.IsSet() {
		localVarQueryParams.Add("absolute_url__nre", parameterToString(localVarOptionals.AbsoluteUrlNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AbsoluteUrlRe.IsSet() {
		localVarQueryParams.Add("absolute_url__re", parameterToString(localVarOptionals.AbsoluteUrlRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIc.IsSet() {
		localVarQueryParams.Add("grouping__ic", parameterToString(localVarOptionals.GroupingIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIe.IsSet() {
		localVarQueryParams.Add("grouping__ie", parameterToString(localVarOptionals.GroupingIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIew.IsSet() {
		localVarQueryParams.Add("grouping__iew", parameterToString(localVarOptionals.GroupingIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIre.IsSet() {
		localVarQueryParams.Add("grouping__ire", parameterToString(localVarOptionals.GroupingIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIsw.IsSet() {
		localVarQueryParams.Add("grouping__isw", parameterToString(localVarOptionals.GroupingIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingN.IsSet() {
		localVarQueryParams.Add("grouping__n", parameterToString(localVarOptionals.GroupingN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNic.IsSet() {
		localVarQueryParams.Add("grouping__nic", parameterToString(localVarOptionals.GroupingNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNie.IsSet() {
		localVarQueryParams.Add("grouping__nie", parameterToString(localVarOptionals.GroupingNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNiew.IsSet() {
		localVarQueryParams.Add("grouping__niew", parameterToString(localVarOptionals.GroupingNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNire.IsSet() {
		localVarQueryParams.Add("grouping__nire", parameterToString(localVarOptionals.GroupingNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNisw.IsSet() {
		localVarQueryParams.Add("grouping__nisw", parameterToString(localVarOptionals.GroupingNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNre.IsSet() {
		localVarQueryParams.Add("grouping__nre", parameterToString(localVarOptionals.GroupingNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingRe.IsSet() {
		localVarQueryParams.Add("grouping__re", parameterToString(localVarOptionals.GroupingRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobResult.IsSet() {
		localVarQueryParams.Add("job_result", parameterToString(localVarOptionals.JobResult.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobResultN.IsSet() {
		localVarQueryParams.Add("job_result__n", parameterToString(localVarOptionals.JobResultN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevel.IsSet() {
		localVarQueryParams.Add("log_level", parameterToString(localVarOptionals.LogLevel.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelIc.IsSet() {
		localVarQueryParams.Add("log_level__ic", parameterToString(localVarOptionals.LogLevelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelIe.IsSet() {
		localVarQueryParams.Add("log_level__ie", parameterToString(localVarOptionals.LogLevelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelIew.IsSet() {
		localVarQueryParams.Add("log_level__iew", parameterToString(localVarOptionals.LogLevelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelIre.IsSet() {
		localVarQueryParams.Add("log_level__ire", parameterToString(localVarOptionals.LogLevelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelIsw.IsSet() {
		localVarQueryParams.Add("log_level__isw", parameterToString(localVarOptionals.LogLevelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelN.IsSet() {
		localVarQueryParams.Add("log_level__n", parameterToString(localVarOptionals.LogLevelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelNic.IsSet() {
		localVarQueryParams.Add("log_level__nic", parameterToString(localVarOptionals.LogLevelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelNie.IsSet() {
		localVarQueryParams.Add("log_level__nie", parameterToString(localVarOptionals.LogLevelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelNiew.IsSet() {
		localVarQueryParams.Add("log_level__niew", parameterToString(localVarOptionals.LogLevelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelNire.IsSet() {
		localVarQueryParams.Add("log_level__nire", parameterToString(localVarOptionals.LogLevelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelNisw.IsSet() {
		localVarQueryParams.Add("log_level__nisw", parameterToString(localVarOptionals.LogLevelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelNre.IsSet() {
		localVarQueryParams.Add("log_level__nre", parameterToString(localVarOptionals.LogLevelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogLevelRe.IsSet() {
		localVarQueryParams.Add("log_level__re", parameterToString(localVarOptionals.LogLevelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObject.IsSet() {
		localVarQueryParams.Add("log_object", parameterToString(localVarOptionals.LogObject.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectIc.IsSet() {
		localVarQueryParams.Add("log_object__ic", parameterToString(localVarOptionals.LogObjectIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectIe.IsSet() {
		localVarQueryParams.Add("log_object__ie", parameterToString(localVarOptionals.LogObjectIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectIew.IsSet() {
		localVarQueryParams.Add("log_object__iew", parameterToString(localVarOptionals.LogObjectIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectIre.IsSet() {
		localVarQueryParams.Add("log_object__ire", parameterToString(localVarOptionals.LogObjectIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectIsw.IsSet() {
		localVarQueryParams.Add("log_object__isw", parameterToString(localVarOptionals.LogObjectIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectN.IsSet() {
		localVarQueryParams.Add("log_object__n", parameterToString(localVarOptionals.LogObjectN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectNic.IsSet() {
		localVarQueryParams.Add("log_object__nic", parameterToString(localVarOptionals.LogObjectNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectNie.IsSet() {
		localVarQueryParams.Add("log_object__nie", parameterToString(localVarOptionals.LogObjectNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectNiew.IsSet() {
		localVarQueryParams.Add("log_object__niew", parameterToString(localVarOptionals.LogObjectNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectNire.IsSet() {
		localVarQueryParams.Add("log_object__nire", parameterToString(localVarOptionals.LogObjectNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectNisw.IsSet() {
		localVarQueryParams.Add("log_object__nisw", parameterToString(localVarOptionals.LogObjectNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectNre.IsSet() {
		localVarQueryParams.Add("log_object__nre", parameterToString(localVarOptionals.LogObjectNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LogObjectRe.IsSet() {
		localVarQueryParams.Add("log_object__re", parameterToString(localVarOptionals.LogObjectRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Message.IsSet() {
		localVarQueryParams.Add("message", parameterToString(localVarOptionals.Message.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageIc.IsSet() {
		localVarQueryParams.Add("message__ic", parameterToString(localVarOptionals.MessageIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageIe.IsSet() {
		localVarQueryParams.Add("message__ie", parameterToString(localVarOptionals.MessageIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageIew.IsSet() {
		localVarQueryParams.Add("message__iew", parameterToString(localVarOptionals.MessageIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageIre.IsSet() {
		localVarQueryParams.Add("message__ire", parameterToString(localVarOptionals.MessageIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageIsw.IsSet() {
		localVarQueryParams.Add("message__isw", parameterToString(localVarOptionals.MessageIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageN.IsSet() {
		localVarQueryParams.Add("message__n", parameterToString(localVarOptionals.MessageN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageNic.IsSet() {
		localVarQueryParams.Add("message__nic", parameterToString(localVarOptionals.MessageNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageNie.IsSet() {
		localVarQueryParams.Add("message__nie", parameterToString(localVarOptionals.MessageNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageNiew.IsSet() {
		localVarQueryParams.Add("message__niew", parameterToString(localVarOptionals.MessageNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageNire.IsSet() {
		localVarQueryParams.Add("message__nire", parameterToString(localVarOptionals.MessageNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageNisw.IsSet() {
		localVarQueryParams.Add("message__nisw", parameterToString(localVarOptionals.MessageNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageNre.IsSet() {
		localVarQueryParams.Add("message__nre", parameterToString(localVarOptionals.MessageNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MessageRe.IsSet() {
		localVarQueryParams.Add("message__re", parameterToString(localVarOptionals.MessageRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedJobLogEntryList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job log entries.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job log entry.
 * @param optional nil or *ExtrasApiExtrasJobLogsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return JobLogEntry
*/

type ExtrasApiExtrasJobLogsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobLogsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobLogsRetrieveOpts) (JobLogEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLogEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-logs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobLogEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job results
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobResultsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobResultsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobResultsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasJobResultsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-results/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job results
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job result.
 * @param optional nil or *ExtrasApiExtrasJobResultsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobResultsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobResultsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobResultsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-results/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job results
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasJobResultsListOpts - Optional Parameters:
     * @param "DateCreated" (optional.Interface of []time.Time) - 
     * @param "DateCreatedGt" (optional.Interface of []time.Time) - 
     * @param "DateCreatedGte" (optional.Interface of []time.Time) - 
     * @param "DateCreatedLt" (optional.Interface of []time.Time) - 
     * @param "DateCreatedLte" (optional.Interface of []time.Time) - 
     * @param "DateCreatedN" (optional.Interface of []time.Time) - 
     * @param "DateDone" (optional.Interface of []time.Time) - 
     * @param "DateDoneGt" (optional.Interface of []time.Time) - 
     * @param "DateDoneGte" (optional.Interface of []time.Time) - 
     * @param "DateDoneIsnull" (optional.Bool) - 
     * @param "DateDoneLt" (optional.Interface of []time.Time) - 
     * @param "DateDoneLte" (optional.Interface of []time.Time) - 
     * @param "DateDoneN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "JobModel" (optional.Interface of []string) - 
     * @param "JobModelIsnull" (optional.Bool) - 
     * @param "JobModelN" (optional.Interface of []string) - 
     * @param "JobModelId" (optional.Interface of []string) -  Job (ID) - Deprecated (use job_model filter)
     * @param "JobModelIdIsnull" (optional.Bool) - 
     * @param "JobModelIdN" (optional.Interface of []string) -  Job (ID) - Deprecated (use job_model filter)
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusIc" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusIe" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusIew" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusIre" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusIsw" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusN" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusNic" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusNie" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusNiew" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusNire" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusNisw" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusNre" (optional.Interface of []string) -  Current state of the Job being run
     * @param "StatusRe" (optional.Interface of []string) -  Current state of the Job being run
     * @param "User" (optional.Interface of string) - 
     * @param "UserIsnull" (optional.Bool) - 
     * @param "UserN" (optional.Interface of string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedJobResultList
*/

type ExtrasApiExtrasJobResultsListOpts struct {
    DateCreated optional.Interface
    DateCreatedGt optional.Interface
    DateCreatedGte optional.Interface
    DateCreatedLt optional.Interface
    DateCreatedLte optional.Interface
    DateCreatedN optional.Interface
    DateDone optional.Interface
    DateDoneGt optional.Interface
    DateDoneGte optional.Interface
    DateDoneIsnull optional.Bool
    DateDoneLt optional.Interface
    DateDoneLte optional.Interface
    DateDoneN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    JobModel optional.Interface
    JobModelIsnull optional.Bool
    JobModelN optional.Interface
    JobModelId optional.Interface
    JobModelIdIsnull optional.Bool
    JobModelIdN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Status optional.Interface
    StatusIc optional.Interface
    StatusIe optional.Interface
    StatusIew optional.Interface
    StatusIre optional.Interface
    StatusIsw optional.Interface
    StatusN optional.Interface
    StatusNic optional.Interface
    StatusNie optional.Interface
    StatusNiew optional.Interface
    StatusNire optional.Interface
    StatusNisw optional.Interface
    StatusNre optional.Interface
    StatusRe optional.Interface
    User optional.Interface
    UserIsnull optional.Bool
    UserN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobResultsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasJobResultsListOpts) (PaginatedJobResultList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedJobResultList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-results/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DateCreated.IsSet() {
		localVarQueryParams.Add("date_created", parameterToString(localVarOptionals.DateCreated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreatedGt.IsSet() {
		localVarQueryParams.Add("date_created__gt", parameterToString(localVarOptionals.DateCreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreatedGte.IsSet() {
		localVarQueryParams.Add("date_created__gte", parameterToString(localVarOptionals.DateCreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreatedLt.IsSet() {
		localVarQueryParams.Add("date_created__lt", parameterToString(localVarOptionals.DateCreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreatedLte.IsSet() {
		localVarQueryParams.Add("date_created__lte", parameterToString(localVarOptionals.DateCreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreatedN.IsSet() {
		localVarQueryParams.Add("date_created__n", parameterToString(localVarOptionals.DateCreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateDone.IsSet() {
		localVarQueryParams.Add("date_done", parameterToString(localVarOptionals.DateDone.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateDoneGt.IsSet() {
		localVarQueryParams.Add("date_done__gt", parameterToString(localVarOptionals.DateDoneGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateDoneGte.IsSet() {
		localVarQueryParams.Add("date_done__gte", parameterToString(localVarOptionals.DateDoneGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateDoneIsnull.IsSet() {
		localVarQueryParams.Add("date_done__isnull", parameterToString(localVarOptionals.DateDoneIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateDoneLt.IsSet() {
		localVarQueryParams.Add("date_done__lt", parameterToString(localVarOptionals.DateDoneLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateDoneLte.IsSet() {
		localVarQueryParams.Add("date_done__lte", parameterToString(localVarOptionals.DateDoneLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateDoneN.IsSet() {
		localVarQueryParams.Add("date_done__n", parameterToString(localVarOptionals.DateDoneN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobModel.IsSet() {
		localVarQueryParams.Add("job_model", parameterToString(localVarOptionals.JobModel.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelIsnull.IsSet() {
		localVarQueryParams.Add("job_model__isnull", parameterToString(localVarOptionals.JobModelIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelN.IsSet() {
		localVarQueryParams.Add("job_model__n", parameterToString(localVarOptionals.JobModelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelId.IsSet() {
		localVarQueryParams.Add("job_model_id", parameterToString(localVarOptionals.JobModelId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelIdIsnull.IsSet() {
		localVarQueryParams.Add("job_model_id__isnull", parameterToString(localVarOptionals.JobModelIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelIdN.IsSet() {
		localVarQueryParams.Add("job_model_id__n", parameterToString(localVarOptionals.JobModelIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusIc.IsSet() {
		localVarQueryParams.Add("status__ic", parameterToString(localVarOptionals.StatusIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusIe.IsSet() {
		localVarQueryParams.Add("status__ie", parameterToString(localVarOptionals.StatusIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusIew.IsSet() {
		localVarQueryParams.Add("status__iew", parameterToString(localVarOptionals.StatusIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusIre.IsSet() {
		localVarQueryParams.Add("status__ire", parameterToString(localVarOptionals.StatusIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusIsw.IsSet() {
		localVarQueryParams.Add("status__isw", parameterToString(localVarOptionals.StatusIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusNic.IsSet() {
		localVarQueryParams.Add("status__nic", parameterToString(localVarOptionals.StatusNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusNie.IsSet() {
		localVarQueryParams.Add("status__nie", parameterToString(localVarOptionals.StatusNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusNiew.IsSet() {
		localVarQueryParams.Add("status__niew", parameterToString(localVarOptionals.StatusNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusNire.IsSet() {
		localVarQueryParams.Add("status__nire", parameterToString(localVarOptionals.StatusNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusNisw.IsSet() {
		localVarQueryParams.Add("status__nisw", parameterToString(localVarOptionals.StatusNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusNre.IsSet() {
		localVarQueryParams.Add("status__nre", parameterToString(localVarOptionals.StatusNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusRe.IsSet() {
		localVarQueryParams.Add("status__re", parameterToString(localVarOptionals.StatusRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.User.IsSet() {
		localVarQueryParams.Add("user", parameterToString(localVarOptionals.User.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserIsnull.IsSet() {
		localVarQueryParams.Add("user__isnull", parameterToString(localVarOptionals.UserIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserN.IsSet() {
		localVarQueryParams.Add("user__n", parameterToString(localVarOptionals.UserN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedJobResultList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job results
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job result.
 * @param optional nil or *ExtrasApiExtrasJobResultsLogsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return JobResult
*/

type ExtrasApiExtrasJobResultsLogsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobResultsLogsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobResultsLogsRetrieveOpts) (JobResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-results/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job results
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this job result.
 * @param optional nil or *ExtrasApiExtrasJobResultsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return JobResult
*/

type ExtrasApiExtrasJobResultsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobResultsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobResultsRetrieveOpts) (JobResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/job-results/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of job objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasJobsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of job objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Job
*/

type ExtrasApiExtrasJobsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableJobRequest, localVarOptionals *ExtrasApiExtrasJobsBulkPartialUpdateOpts) ([]Job, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Job
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of job objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasJobsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Job
*/

type ExtrasApiExtrasJobsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsBulkUpdate(ctx context.Context, body []BulkWritableJobRequest, localVarOptionals *ExtrasApiExtrasJobsBulkUpdateOpts) ([]Job, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Job
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a job object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Unique object identifier, either a UUID primary key or a composite key.
 * @param optional nil or *ExtrasApiExtrasJobsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of job objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
 * @param optional nil or *ExtrasApiExtrasJobsDestroyByNameOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasJobsDestroyByNameOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsDestroyByName(ctx context.Context, name string, localVarOptionals *ExtrasApiExtrasJobsDestroyByNameOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasJobsListOpts - Optional Parameters:
     * @param "ApprovalRequired" (optional.Bool) - 
     * @param "ApprovalRequiredOverride" (optional.Bool) - 
     * @param "DescriptionOverride" (optional.Bool) - 
     * @param "DryrunDefault" (optional.Bool) - 
     * @param "DryrunDefaultOverride" (optional.Bool) - 
     * @param "Enabled" (optional.Bool) - 
     * @param "Format" (optional.String) - 
     * @param "Grouping" (optional.Interface of []string) - 
     * @param "GroupingIc" (optional.Interface of []string) - 
     * @param "GroupingIe" (optional.Interface of []string) - 
     * @param "GroupingIew" (optional.Interface of []string) - 
     * @param "GroupingIre" (optional.Interface of []string) - 
     * @param "GroupingIsw" (optional.Interface of []string) - 
     * @param "GroupingN" (optional.Interface of []string) - 
     * @param "GroupingNic" (optional.Interface of []string) - 
     * @param "GroupingNie" (optional.Interface of []string) - 
     * @param "GroupingNiew" (optional.Interface of []string) - 
     * @param "GroupingNire" (optional.Interface of []string) - 
     * @param "GroupingNisw" (optional.Interface of []string) - 
     * @param "GroupingNre" (optional.Interface of []string) - 
     * @param "GroupingRe" (optional.Interface of []string) - 
     * @param "GroupingOverride" (optional.Bool) - 
     * @param "HasSensitiveVariables" (optional.Bool) - 
     * @param "HasSensitiveVariablesOverride" (optional.Bool) - 
     * @param "Hidden" (optional.Bool) - 
     * @param "HiddenOverride" (optional.Bool) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Installed" (optional.Bool) - 
     * @param "IsJobButtonReceiver" (optional.Bool) - 
     * @param "IsJobHookReceiver" (optional.Bool) - 
     * @param "JobClassName" (optional.Interface of []string) - 
     * @param "JobClassNameIc" (optional.Interface of []string) - 
     * @param "JobClassNameIe" (optional.Interface of []string) - 
     * @param "JobClassNameIew" (optional.Interface of []string) - 
     * @param "JobClassNameIre" (optional.Interface of []string) - 
     * @param "JobClassNameIsw" (optional.Interface of []string) - 
     * @param "JobClassNameN" (optional.Interface of []string) - 
     * @param "JobClassNameNic" (optional.Interface of []string) - 
     * @param "JobClassNameNie" (optional.Interface of []string) - 
     * @param "JobClassNameNiew" (optional.Interface of []string) - 
     * @param "JobClassNameNire" (optional.Interface of []string) - 
     * @param "JobClassNameNisw" (optional.Interface of []string) - 
     * @param "JobClassNameNre" (optional.Interface of []string) - 
     * @param "JobClassNameRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "ModuleName" (optional.Interface of []string) - 
     * @param "ModuleNameIc" (optional.Interface of []string) - 
     * @param "ModuleNameIe" (optional.Interface of []string) - 
     * @param "ModuleNameIew" (optional.Interface of []string) - 
     * @param "ModuleNameIre" (optional.Interface of []string) - 
     * @param "ModuleNameIsw" (optional.Interface of []string) - 
     * @param "ModuleNameN" (optional.Interface of []string) - 
     * @param "ModuleNameNic" (optional.Interface of []string) - 
     * @param "ModuleNameNie" (optional.Interface of []string) - 
     * @param "ModuleNameNiew" (optional.Interface of []string) - 
     * @param "ModuleNameNire" (optional.Interface of []string) - 
     * @param "ModuleNameNisw" (optional.Interface of []string) - 
     * @param "ModuleNameNre" (optional.Interface of []string) - 
     * @param "ModuleNameRe" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "NameOverride" (optional.Bool) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "ReadOnly" (optional.Bool) - 
     * @param "SoftTimeLimit" (optional.Interface of []float32) - 
     * @param "SoftTimeLimitGt" (optional.Interface of []float32) - 
     * @param "SoftTimeLimitGte" (optional.Interface of []float32) - 
     * @param "SoftTimeLimitLt" (optional.Interface of []float32) - 
     * @param "SoftTimeLimitLte" (optional.Interface of []float32) - 
     * @param "SoftTimeLimitN" (optional.Interface of []float32) - 
     * @param "SoftTimeLimitOverride" (optional.Bool) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "TimeLimit" (optional.Interface of []float32) - 
     * @param "TimeLimitGt" (optional.Interface of []float32) - 
     * @param "TimeLimitGte" (optional.Interface of []float32) - 
     * @param "TimeLimitLt" (optional.Interface of []float32) - 
     * @param "TimeLimitLte" (optional.Interface of []float32) - 
     * @param "TimeLimitN" (optional.Interface of []float32) - 
     * @param "TimeLimitOverride" (optional.Bool) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedJobList
*/

type ExtrasApiExtrasJobsListOpts struct {
    ApprovalRequired optional.Bool
    ApprovalRequiredOverride optional.Bool
    DescriptionOverride optional.Bool
    DryrunDefault optional.Bool
    DryrunDefaultOverride optional.Bool
    Enabled optional.Bool
    Format optional.String
    Grouping optional.Interface
    GroupingIc optional.Interface
    GroupingIe optional.Interface
    GroupingIew optional.Interface
    GroupingIre optional.Interface
    GroupingIsw optional.Interface
    GroupingN optional.Interface
    GroupingNic optional.Interface
    GroupingNie optional.Interface
    GroupingNiew optional.Interface
    GroupingNire optional.Interface
    GroupingNisw optional.Interface
    GroupingNre optional.Interface
    GroupingRe optional.Interface
    GroupingOverride optional.Bool
    HasSensitiveVariables optional.Bool
    HasSensitiveVariablesOverride optional.Bool
    Hidden optional.Bool
    HiddenOverride optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Installed optional.Bool
    IsJobButtonReceiver optional.Bool
    IsJobHookReceiver optional.Bool
    JobClassName optional.Interface
    JobClassNameIc optional.Interface
    JobClassNameIe optional.Interface
    JobClassNameIew optional.Interface
    JobClassNameIre optional.Interface
    JobClassNameIsw optional.Interface
    JobClassNameN optional.Interface
    JobClassNameNic optional.Interface
    JobClassNameNie optional.Interface
    JobClassNameNiew optional.Interface
    JobClassNameNire optional.Interface
    JobClassNameNisw optional.Interface
    JobClassNameNre optional.Interface
    JobClassNameRe optional.Interface
    Limit optional.Int32
    ModuleName optional.Interface
    ModuleNameIc optional.Interface
    ModuleNameIe optional.Interface
    ModuleNameIew optional.Interface
    ModuleNameIre optional.Interface
    ModuleNameIsw optional.Interface
    ModuleNameN optional.Interface
    ModuleNameNic optional.Interface
    ModuleNameNie optional.Interface
    ModuleNameNiew optional.Interface
    ModuleNameNire optional.Interface
    ModuleNameNisw optional.Interface
    ModuleNameNre optional.Interface
    ModuleNameRe optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    NameOverride optional.Bool
    Offset optional.Int32
    Q optional.String
    ReadOnly optional.Bool
    SoftTimeLimit optional.Interface
    SoftTimeLimitGt optional.Interface
    SoftTimeLimitGte optional.Interface
    SoftTimeLimitLt optional.Interface
    SoftTimeLimitLte optional.Interface
    SoftTimeLimitN optional.Interface
    SoftTimeLimitOverride optional.Bool
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    TimeLimit optional.Interface
    TimeLimitGt optional.Interface
    TimeLimitGte optional.Interface
    TimeLimitLt optional.Interface
    TimeLimitLte optional.Interface
    TimeLimitN optional.Interface
    TimeLimitOverride optional.Bool
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasJobsListOpts) (PaginatedJobList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedJobList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ApprovalRequired.IsSet() {
		localVarQueryParams.Add("approval_required", parameterToString(localVarOptionals.ApprovalRequired.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApprovalRequiredOverride.IsSet() {
		localVarQueryParams.Add("approval_required_override", parameterToString(localVarOptionals.ApprovalRequiredOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionOverride.IsSet() {
		localVarQueryParams.Add("description_override", parameterToString(localVarOptionals.DescriptionOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DryrunDefault.IsSet() {
		localVarQueryParams.Add("dryrun_default", parameterToString(localVarOptionals.DryrunDefault.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DryrunDefaultOverride.IsSet() {
		localVarQueryParams.Add("dryrun_default_override", parameterToString(localVarOptionals.DryrunDefaultOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIc.IsSet() {
		localVarQueryParams.Add("grouping__ic", parameterToString(localVarOptionals.GroupingIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIe.IsSet() {
		localVarQueryParams.Add("grouping__ie", parameterToString(localVarOptionals.GroupingIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIew.IsSet() {
		localVarQueryParams.Add("grouping__iew", parameterToString(localVarOptionals.GroupingIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIre.IsSet() {
		localVarQueryParams.Add("grouping__ire", parameterToString(localVarOptionals.GroupingIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingIsw.IsSet() {
		localVarQueryParams.Add("grouping__isw", parameterToString(localVarOptionals.GroupingIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingN.IsSet() {
		localVarQueryParams.Add("grouping__n", parameterToString(localVarOptionals.GroupingN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNic.IsSet() {
		localVarQueryParams.Add("grouping__nic", parameterToString(localVarOptionals.GroupingNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNie.IsSet() {
		localVarQueryParams.Add("grouping__nie", parameterToString(localVarOptionals.GroupingNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNiew.IsSet() {
		localVarQueryParams.Add("grouping__niew", parameterToString(localVarOptionals.GroupingNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNire.IsSet() {
		localVarQueryParams.Add("grouping__nire", parameterToString(localVarOptionals.GroupingNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNisw.IsSet() {
		localVarQueryParams.Add("grouping__nisw", parameterToString(localVarOptionals.GroupingNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingNre.IsSet() {
		localVarQueryParams.Add("grouping__nre", parameterToString(localVarOptionals.GroupingNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingRe.IsSet() {
		localVarQueryParams.Add("grouping__re", parameterToString(localVarOptionals.GroupingRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupingOverride.IsSet() {
		localVarQueryParams.Add("grouping_override", parameterToString(localVarOptionals.GroupingOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSensitiveVariables.IsSet() {
		localVarQueryParams.Add("has_sensitive_variables", parameterToString(localVarOptionals.HasSensitiveVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSensitiveVariablesOverride.IsSet() {
		localVarQueryParams.Add("has_sensitive_variables_override", parameterToString(localVarOptionals.HasSensitiveVariablesOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hidden.IsSet() {
		localVarQueryParams.Add("hidden", parameterToString(localVarOptionals.Hidden.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HiddenOverride.IsSet() {
		localVarQueryParams.Add("hidden_override", parameterToString(localVarOptionals.HiddenOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Installed.IsSet() {
		localVarQueryParams.Add("installed", parameterToString(localVarOptionals.Installed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsJobButtonReceiver.IsSet() {
		localVarQueryParams.Add("is_job_button_receiver", parameterToString(localVarOptionals.IsJobButtonReceiver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsJobHookReceiver.IsSet() {
		localVarQueryParams.Add("is_job_hook_receiver", parameterToString(localVarOptionals.IsJobHookReceiver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassName.IsSet() {
		localVarQueryParams.Add("job_class_name", parameterToString(localVarOptionals.JobClassName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameIc.IsSet() {
		localVarQueryParams.Add("job_class_name__ic", parameterToString(localVarOptionals.JobClassNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameIe.IsSet() {
		localVarQueryParams.Add("job_class_name__ie", parameterToString(localVarOptionals.JobClassNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameIew.IsSet() {
		localVarQueryParams.Add("job_class_name__iew", parameterToString(localVarOptionals.JobClassNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameIre.IsSet() {
		localVarQueryParams.Add("job_class_name__ire", parameterToString(localVarOptionals.JobClassNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameIsw.IsSet() {
		localVarQueryParams.Add("job_class_name__isw", parameterToString(localVarOptionals.JobClassNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameN.IsSet() {
		localVarQueryParams.Add("job_class_name__n", parameterToString(localVarOptionals.JobClassNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameNic.IsSet() {
		localVarQueryParams.Add("job_class_name__nic", parameterToString(localVarOptionals.JobClassNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameNie.IsSet() {
		localVarQueryParams.Add("job_class_name__nie", parameterToString(localVarOptionals.JobClassNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameNiew.IsSet() {
		localVarQueryParams.Add("job_class_name__niew", parameterToString(localVarOptionals.JobClassNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameNire.IsSet() {
		localVarQueryParams.Add("job_class_name__nire", parameterToString(localVarOptionals.JobClassNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameNisw.IsSet() {
		localVarQueryParams.Add("job_class_name__nisw", parameterToString(localVarOptionals.JobClassNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameNre.IsSet() {
		localVarQueryParams.Add("job_class_name__nre", parameterToString(localVarOptionals.JobClassNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobClassNameRe.IsSet() {
		localVarQueryParams.Add("job_class_name__re", parameterToString(localVarOptionals.JobClassNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleName.IsSet() {
		localVarQueryParams.Add("module_name", parameterToString(localVarOptionals.ModuleName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameIc.IsSet() {
		localVarQueryParams.Add("module_name__ic", parameterToString(localVarOptionals.ModuleNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameIe.IsSet() {
		localVarQueryParams.Add("module_name__ie", parameterToString(localVarOptionals.ModuleNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameIew.IsSet() {
		localVarQueryParams.Add("module_name__iew", parameterToString(localVarOptionals.ModuleNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameIre.IsSet() {
		localVarQueryParams.Add("module_name__ire", parameterToString(localVarOptionals.ModuleNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameIsw.IsSet() {
		localVarQueryParams.Add("module_name__isw", parameterToString(localVarOptionals.ModuleNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameN.IsSet() {
		localVarQueryParams.Add("module_name__n", parameterToString(localVarOptionals.ModuleNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameNic.IsSet() {
		localVarQueryParams.Add("module_name__nic", parameterToString(localVarOptionals.ModuleNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameNie.IsSet() {
		localVarQueryParams.Add("module_name__nie", parameterToString(localVarOptionals.ModuleNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameNiew.IsSet() {
		localVarQueryParams.Add("module_name__niew", parameterToString(localVarOptionals.ModuleNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameNire.IsSet() {
		localVarQueryParams.Add("module_name__nire", parameterToString(localVarOptionals.ModuleNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameNisw.IsSet() {
		localVarQueryParams.Add("module_name__nisw", parameterToString(localVarOptionals.ModuleNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameNre.IsSet() {
		localVarQueryParams.Add("module_name__nre", parameterToString(localVarOptionals.ModuleNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNameRe.IsSet() {
		localVarQueryParams.Add("module_name__re", parameterToString(localVarOptionals.ModuleNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameOverride.IsSet() {
		localVarQueryParams.Add("name_override", parameterToString(localVarOptionals.NameOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReadOnly.IsSet() {
		localVarQueryParams.Add("read_only", parameterToString(localVarOptionals.ReadOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SoftTimeLimit.IsSet() {
		localVarQueryParams.Add("soft_time_limit", parameterToString(localVarOptionals.SoftTimeLimit.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftTimeLimitGt.IsSet() {
		localVarQueryParams.Add("soft_time_limit__gt", parameterToString(localVarOptionals.SoftTimeLimitGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftTimeLimitGte.IsSet() {
		localVarQueryParams.Add("soft_time_limit__gte", parameterToString(localVarOptionals.SoftTimeLimitGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftTimeLimitLt.IsSet() {
		localVarQueryParams.Add("soft_time_limit__lt", parameterToString(localVarOptionals.SoftTimeLimitLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftTimeLimitLte.IsSet() {
		localVarQueryParams.Add("soft_time_limit__lte", parameterToString(localVarOptionals.SoftTimeLimitLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftTimeLimitN.IsSet() {
		localVarQueryParams.Add("soft_time_limit__n", parameterToString(localVarOptionals.SoftTimeLimitN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftTimeLimitOverride.IsSet() {
		localVarQueryParams.Add("soft_time_limit_override", parameterToString(localVarOptionals.SoftTimeLimitOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLimit.IsSet() {
		localVarQueryParams.Add("time_limit", parameterToString(localVarOptionals.TimeLimit.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLimitGt.IsSet() {
		localVarQueryParams.Add("time_limit__gt", parameterToString(localVarOptionals.TimeLimitGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLimitGte.IsSet() {
		localVarQueryParams.Add("time_limit__gte", parameterToString(localVarOptionals.TimeLimitGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLimitLt.IsSet() {
		localVarQueryParams.Add("time_limit__lt", parameterToString(localVarOptionals.TimeLimitLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLimitLte.IsSet() {
		localVarQueryParams.Add("time_limit__lte", parameterToString(localVarOptionals.TimeLimitLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLimitN.IsSet() {
		localVarQueryParams.Add("time_limit__n", parameterToString(localVarOptionals.TimeLimitN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLimitOverride.IsSet() {
		localVarQueryParams.Add("time_limit_override", parameterToString(localVarOptionals.TimeLimitOverride.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedJobList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id Unique object identifier, either a UUID primary key or a composite key.
 * @param optional nil or *ExtrasApiExtrasJobsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasJobsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasJobsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param name
 * @param optional nil or *ExtrasApiExtrasJobsNotesCreateByNameOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasJobsNotesCreateByNameOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsNotesCreateByName(ctx context.Context, body NoteInputRequest, name string, localVarOptionals *ExtrasApiExtrasJobsNotesCreateByNameOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{name}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Unique object identifier, either a UUID primary key or a composite key.
 * @param optional nil or *ExtrasApiExtrasJobsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasJobsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
 * @param optional nil or *ExtrasApiExtrasJobsNotesListByNameOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasJobsNotesListByNameOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobsNotesListByName(ctx context.Context, name string, localVarOptionals *ExtrasApiExtrasJobsNotesListByNameOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{name}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a job object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Unique object identifier, either a UUID primary key or a composite key.
 * @param optional nil or *ExtrasApiExtrasJobsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedJobRequest) - 
     * @param "Format" (optional.String) - 
@return Job
*/

type ExtrasApiExtrasJobsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobsPartialUpdateOpts) (Job, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Job
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of job objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
 * @param optional nil or *ExtrasApiExtrasJobsPartialUpdateByNameOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedJobRequest) - 
     * @param "Format" (optional.String) - 
@return Job
*/

type ExtrasApiExtrasJobsPartialUpdateByNameOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsPartialUpdateByName(ctx context.Context, name string, localVarOptionals *ExtrasApiExtrasJobsPartialUpdateByNameOpts) (Job, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Job
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a job object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Unique object identifier, either a UUID primary key or a composite key.
 * @param optional nil or *ExtrasApiExtrasJobsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Job
*/

type ExtrasApiExtrasJobsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobsRetrieveOpts) (Job, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Job
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of job objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
 * @param optional nil or *ExtrasApiExtrasJobsRetrieveByNameOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Job
*/

type ExtrasApiExtrasJobsRetrieveByNameOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobsRetrieveByName(ctx context.Context, name string, localVarOptionals *ExtrasApiExtrasJobsRetrieveByNameOpts) (Job, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Job
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Run the specified Job.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Unique object identifier, either a UUID primary key or a composite key.
 * @param optional nil or *ExtrasApiExtrasJobsRunCreateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobInputRequest) - 
     * @param "Format" (optional.String) - 
@return JobRunResponse
*/

type ExtrasApiExtrasJobsRunCreateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsRunCreate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobsRunCreateOpts) (JobRunResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobRunResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{id}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v JobRunResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Run the specified Job.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
 * @param optional nil or *ExtrasApiExtrasJobsRunCreateByNameOpts - Optional Parameters:
     * @param "Body" (optional.Interface of JobInputRequest) - 
     * @param "Format" (optional.String) - 
@return JobRunResponse
*/

type ExtrasApiExtrasJobsRunCreateByNameOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsRunCreateByName(ctx context.Context, name string, localVarOptionals *ExtrasApiExtrasJobsRunCreateByNameOpts) (JobRunResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobRunResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v JobRunResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a job object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id Unique object identifier, either a UUID primary key or a composite key.
 * @param optional nil or *ExtrasApiExtrasJobsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Job
*/

type ExtrasApiExtrasJobsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsUpdate(ctx context.Context, body JobRequest, id string, localVarOptionals *ExtrasApiExtrasJobsUpdateOpts) (Job, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Job
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of job objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param name
 * @param optional nil or *ExtrasApiExtrasJobsUpdateByNameOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Job
*/

type ExtrasApiExtrasJobsUpdateByNameOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasJobsUpdateByName(ctx context.Context, body JobRequest, name string, localVarOptionals *ExtrasApiExtrasJobsUpdateByNameOpts) (Job, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Job
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Get details of the input variables that may/must be specified to run a particular Job.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Unique object identifier, either a UUID primary key or a composite key.
 * @param optional nil or *ExtrasApiExtrasJobsVariablesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedJobVariableList
*/

type ExtrasApiExtrasJobsVariablesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobsVariablesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasJobsVariablesListOpts) (PaginatedJobVariableList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedJobVariableList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{id}/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedJobVariableList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Get details of the input variables that may/must be specified to run a particular Job.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
 * @param optional nil or *ExtrasApiExtrasJobsVariablesListByNameOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedJobVariableList
*/

type ExtrasApiExtrasJobsVariablesListByNameOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasJobsVariablesListByName(ctx context.Context, name string, localVarOptionals *ExtrasApiExtrasJobsVariablesListByNameOpts) (PaginatedJobVariableList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedJobVariableList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/jobs/{name}/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedJobVariableList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of note objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasNotesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasNotesBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasNotesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasNotesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of note objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasNotesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Note
*/

type ExtrasApiExtrasNotesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasNotesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableNoteRequest, localVarOptionals *ExtrasApiExtrasNotesBulkPartialUpdateOpts) ([]Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of note objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasNotesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Note
*/

type ExtrasApiExtrasNotesBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasNotesBulkUpdate(ctx context.Context, body []BulkWritableNoteRequest, localVarOptionals *ExtrasApiExtrasNotesBulkUpdateOpts) ([]Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more note objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasNotesCreate(ctx context.Context, body NoteRequest, localVarOptionals *ExtrasApiExtrasNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a note object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this note.
 * @param optional nil or *ExtrasApiExtrasNotesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasNotesDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasNotesDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasNotesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of note objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasNotesListOpts - Optional Parameters:
     * @param "AssignedObjectId" (optional.Interface of []string) - 
     * @param "AssignedObjectIdIc" (optional.Interface of []string) - 
     * @param "AssignedObjectIdIe" (optional.Interface of []string) - 
     * @param "AssignedObjectIdIew" (optional.Interface of []string) - 
     * @param "AssignedObjectIdIre" (optional.Interface of []string) - 
     * @param "AssignedObjectIdIsw" (optional.Interface of []string) - 
     * @param "AssignedObjectIdN" (optional.Interface of []string) - 
     * @param "AssignedObjectIdNic" (optional.Interface of []string) - 
     * @param "AssignedObjectIdNie" (optional.Interface of []string) - 
     * @param "AssignedObjectIdNiew" (optional.Interface of []string) - 
     * @param "AssignedObjectIdNire" (optional.Interface of []string) - 
     * @param "AssignedObjectIdNisw" (optional.Interface of []string) - 
     * @param "AssignedObjectIdNre" (optional.Interface of []string) - 
     * @param "AssignedObjectIdRe" (optional.Interface of []string) - 
     * @param "AssignedObjectType" (optional.String) - 
     * @param "AssignedObjectTypeN" (optional.String) - 
     * @param "AssignedObjectTypeId" (optional.Int32) - 
     * @param "AssignedObjectTypeIdN" (optional.Int32) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Note" (optional.Interface of []string) - 
     * @param "NoteIc" (optional.Interface of []string) - 
     * @param "NoteIe" (optional.Interface of []string) - 
     * @param "NoteIew" (optional.Interface of []string) - 
     * @param "NoteIre" (optional.Interface of []string) - 
     * @param "NoteIsw" (optional.Interface of []string) - 
     * @param "NoteN" (optional.Interface of []string) - 
     * @param "NoteNic" (optional.Interface of []string) - 
     * @param "NoteNie" (optional.Interface of []string) - 
     * @param "NoteNiew" (optional.Interface of []string) - 
     * @param "NoteNire" (optional.Interface of []string) - 
     * @param "NoteNisw" (optional.Interface of []string) - 
     * @param "NoteNre" (optional.Interface of []string) - 
     * @param "NoteRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "User" (optional.Interface of []string) - 
     * @param "UserIsnull" (optional.Bool) - 
     * @param "UserN" (optional.Interface of []string) - 
     * @param "UserName" (optional.Interface of []string) - 
     * @param "UserNameIc" (optional.Interface of []string) - 
     * @param "UserNameIe" (optional.Interface of []string) - 
     * @param "UserNameIew" (optional.Interface of []string) - 
     * @param "UserNameIre" (optional.Interface of []string) - 
     * @param "UserNameIsw" (optional.Interface of []string) - 
     * @param "UserNameN" (optional.Interface of []string) - 
     * @param "UserNameNic" (optional.Interface of []string) - 
     * @param "UserNameNie" (optional.Interface of []string) - 
     * @param "UserNameNiew" (optional.Interface of []string) - 
     * @param "UserNameNire" (optional.Interface of []string) - 
     * @param "UserNameNisw" (optional.Interface of []string) - 
     * @param "UserNameNre" (optional.Interface of []string) - 
     * @param "UserNameRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasNotesListOpts struct {
    AssignedObjectId optional.Interface
    AssignedObjectIdIc optional.Interface
    AssignedObjectIdIe optional.Interface
    AssignedObjectIdIew optional.Interface
    AssignedObjectIdIre optional.Interface
    AssignedObjectIdIsw optional.Interface
    AssignedObjectIdN optional.Interface
    AssignedObjectIdNic optional.Interface
    AssignedObjectIdNie optional.Interface
    AssignedObjectIdNiew optional.Interface
    AssignedObjectIdNire optional.Interface
    AssignedObjectIdNisw optional.Interface
    AssignedObjectIdNre optional.Interface
    AssignedObjectIdRe optional.Interface
    AssignedObjectType optional.String
    AssignedObjectTypeN optional.String
    AssignedObjectTypeId optional.Int32
    AssignedObjectTypeIdN optional.Int32
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Note optional.Interface
    NoteIc optional.Interface
    NoteIe optional.Interface
    NoteIew optional.Interface
    NoteIre optional.Interface
    NoteIsw optional.Interface
    NoteN optional.Interface
    NoteNic optional.Interface
    NoteNie optional.Interface
    NoteNiew optional.Interface
    NoteNire optional.Interface
    NoteNisw optional.Interface
    NoteNre optional.Interface
    NoteRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    User optional.Interface
    UserIsnull optional.Bool
    UserN optional.Interface
    UserName optional.Interface
    UserNameIc optional.Interface
    UserNameIe optional.Interface
    UserNameIew optional.Interface
    UserNameIre optional.Interface
    UserNameIsw optional.Interface
    UserNameN optional.Interface
    UserNameNic optional.Interface
    UserNameNie optional.Interface
    UserNameNiew optional.Interface
    UserNameNire optional.Interface
    UserNameNisw optional.Interface
    UserNameNre optional.Interface
    UserNameRe optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasNotesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AssignedObjectId.IsSet() {
		localVarQueryParams.Add("assigned_object_id", parameterToString(localVarOptionals.AssignedObjectId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdIc.IsSet() {
		localVarQueryParams.Add("assigned_object_id__ic", parameterToString(localVarOptionals.AssignedObjectIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdIe.IsSet() {
		localVarQueryParams.Add("assigned_object_id__ie", parameterToString(localVarOptionals.AssignedObjectIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdIew.IsSet() {
		localVarQueryParams.Add("assigned_object_id__iew", parameterToString(localVarOptionals.AssignedObjectIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdIre.IsSet() {
		localVarQueryParams.Add("assigned_object_id__ire", parameterToString(localVarOptionals.AssignedObjectIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdIsw.IsSet() {
		localVarQueryParams.Add("assigned_object_id__isw", parameterToString(localVarOptionals.AssignedObjectIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdN.IsSet() {
		localVarQueryParams.Add("assigned_object_id__n", parameterToString(localVarOptionals.AssignedObjectIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdNic.IsSet() {
		localVarQueryParams.Add("assigned_object_id__nic", parameterToString(localVarOptionals.AssignedObjectIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdNie.IsSet() {
		localVarQueryParams.Add("assigned_object_id__nie", parameterToString(localVarOptionals.AssignedObjectIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdNiew.IsSet() {
		localVarQueryParams.Add("assigned_object_id__niew", parameterToString(localVarOptionals.AssignedObjectIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdNire.IsSet() {
		localVarQueryParams.Add("assigned_object_id__nire", parameterToString(localVarOptionals.AssignedObjectIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdNisw.IsSet() {
		localVarQueryParams.Add("assigned_object_id__nisw", parameterToString(localVarOptionals.AssignedObjectIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdNre.IsSet() {
		localVarQueryParams.Add("assigned_object_id__nre", parameterToString(localVarOptionals.AssignedObjectIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectIdRe.IsSet() {
		localVarQueryParams.Add("assigned_object_id__re", parameterToString(localVarOptionals.AssignedObjectIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectType.IsSet() {
		localVarQueryParams.Add("assigned_object_type", parameterToString(localVarOptionals.AssignedObjectType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectTypeN.IsSet() {
		localVarQueryParams.Add("assigned_object_type__n", parameterToString(localVarOptionals.AssignedObjectTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectTypeId.IsSet() {
		localVarQueryParams.Add("assigned_object_type_id", parameterToString(localVarOptionals.AssignedObjectTypeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedObjectTypeIdN.IsSet() {
		localVarQueryParams.Add("assigned_object_type_id__n", parameterToString(localVarOptionals.AssignedObjectTypeIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Note.IsSet() {
		localVarQueryParams.Add("note", parameterToString(localVarOptionals.Note.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteIc.IsSet() {
		localVarQueryParams.Add("note__ic", parameterToString(localVarOptionals.NoteIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteIe.IsSet() {
		localVarQueryParams.Add("note__ie", parameterToString(localVarOptionals.NoteIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteIew.IsSet() {
		localVarQueryParams.Add("note__iew", parameterToString(localVarOptionals.NoteIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteIre.IsSet() {
		localVarQueryParams.Add("note__ire", parameterToString(localVarOptionals.NoteIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteIsw.IsSet() {
		localVarQueryParams.Add("note__isw", parameterToString(localVarOptionals.NoteIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteN.IsSet() {
		localVarQueryParams.Add("note__n", parameterToString(localVarOptionals.NoteN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteNic.IsSet() {
		localVarQueryParams.Add("note__nic", parameterToString(localVarOptionals.NoteNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteNie.IsSet() {
		localVarQueryParams.Add("note__nie", parameterToString(localVarOptionals.NoteNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteNiew.IsSet() {
		localVarQueryParams.Add("note__niew", parameterToString(localVarOptionals.NoteNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteNire.IsSet() {
		localVarQueryParams.Add("note__nire", parameterToString(localVarOptionals.NoteNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteNisw.IsSet() {
		localVarQueryParams.Add("note__nisw", parameterToString(localVarOptionals.NoteNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteNre.IsSet() {
		localVarQueryParams.Add("note__nre", parameterToString(localVarOptionals.NoteNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NoteRe.IsSet() {
		localVarQueryParams.Add("note__re", parameterToString(localVarOptionals.NoteRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.User.IsSet() {
		localVarQueryParams.Add("user", parameterToString(localVarOptionals.User.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserIsnull.IsSet() {
		localVarQueryParams.Add("user__isnull", parameterToString(localVarOptionals.UserIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserN.IsSet() {
		localVarQueryParams.Add("user__n", parameterToString(localVarOptionals.UserN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserName.IsSet() {
		localVarQueryParams.Add("user_name", parameterToString(localVarOptionals.UserName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIc.IsSet() {
		localVarQueryParams.Add("user_name__ic", parameterToString(localVarOptionals.UserNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIe.IsSet() {
		localVarQueryParams.Add("user_name__ie", parameterToString(localVarOptionals.UserNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIew.IsSet() {
		localVarQueryParams.Add("user_name__iew", parameterToString(localVarOptionals.UserNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIre.IsSet() {
		localVarQueryParams.Add("user_name__ire", parameterToString(localVarOptionals.UserNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIsw.IsSet() {
		localVarQueryParams.Add("user_name__isw", parameterToString(localVarOptionals.UserNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameN.IsSet() {
		localVarQueryParams.Add("user_name__n", parameterToString(localVarOptionals.UserNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNic.IsSet() {
		localVarQueryParams.Add("user_name__nic", parameterToString(localVarOptionals.UserNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNie.IsSet() {
		localVarQueryParams.Add("user_name__nie", parameterToString(localVarOptionals.UserNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNiew.IsSet() {
		localVarQueryParams.Add("user_name__niew", parameterToString(localVarOptionals.UserNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNire.IsSet() {
		localVarQueryParams.Add("user_name__nire", parameterToString(localVarOptionals.UserNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNisw.IsSet() {
		localVarQueryParams.Add("user_name__nisw", parameterToString(localVarOptionals.UserNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNre.IsSet() {
		localVarQueryParams.Add("user_name__nre", parameterToString(localVarOptionals.UserNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameRe.IsSet() {
		localVarQueryParams.Add("user_name__re", parameterToString(localVarOptionals.UserNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a note object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this note.
 * @param optional nil or *ExtrasApiExtrasNotesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedNoteRequest) - 
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasNotesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasNotesPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasNotesPartialUpdateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a note object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this note.
 * @param optional nil or *ExtrasApiExtrasNotesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Note
*/

type ExtrasApiExtrasNotesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasNotesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasNotesRetrieveOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a note object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this note.
 * @param optional nil or *ExtrasApiExtrasNotesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasNotesUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasNotesUpdate(ctx context.Context, body NoteRequest, id string, localVarOptionals *ExtrasApiExtrasNotesUpdateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of recent changes.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasObjectChangesListOpts - Optional Parameters:
     * @param "Action" (optional.Interface of []string) - 
     * @param "ActionIc" (optional.Interface of []string) - 
     * @param "ActionIe" (optional.Interface of []string) - 
     * @param "ActionIew" (optional.Interface of []string) - 
     * @param "ActionIre" (optional.Interface of []string) - 
     * @param "ActionIsw" (optional.Interface of []string) - 
     * @param "ActionN" (optional.Interface of []string) - 
     * @param "ActionNic" (optional.Interface of []string) - 
     * @param "ActionNie" (optional.Interface of []string) - 
     * @param "ActionNiew" (optional.Interface of []string) - 
     * @param "ActionNire" (optional.Interface of []string) - 
     * @param "ActionNisw" (optional.Interface of []string) - 
     * @param "ActionNre" (optional.Interface of []string) - 
     * @param "ActionRe" (optional.Interface of []string) - 
     * @param "ChangedObjectId" (optional.Interface of []string) - 
     * @param "ChangedObjectIdIc" (optional.Interface of []string) - 
     * @param "ChangedObjectIdIe" (optional.Interface of []string) - 
     * @param "ChangedObjectIdIew" (optional.Interface of []string) - 
     * @param "ChangedObjectIdIre" (optional.Interface of []string) - 
     * @param "ChangedObjectIdIsw" (optional.Interface of []string) - 
     * @param "ChangedObjectIdN" (optional.Interface of []string) - 
     * @param "ChangedObjectIdNic" (optional.Interface of []string) - 
     * @param "ChangedObjectIdNie" (optional.Interface of []string) - 
     * @param "ChangedObjectIdNiew" (optional.Interface of []string) - 
     * @param "ChangedObjectIdNire" (optional.Interface of []string) - 
     * @param "ChangedObjectIdNisw" (optional.Interface of []string) - 
     * @param "ChangedObjectIdNre" (optional.Interface of []string) - 
     * @param "ChangedObjectIdRe" (optional.Interface of []string) - 
     * @param "ChangedObjectType" (optional.String) - 
     * @param "ChangedObjectTypeIsnull" (optional.Bool) - 
     * @param "ChangedObjectTypeN" (optional.String) - 
     * @param "ChangedObjectTypeId" (optional.Int32) - 
     * @param "ChangedObjectTypeIdIsnull" (optional.Bool) - 
     * @param "ChangedObjectTypeIdN" (optional.Int32) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "ObjectRepr" (optional.Interface of []string) - 
     * @param "ObjectReprIc" (optional.Interface of []string) - 
     * @param "ObjectReprIe" (optional.Interface of []string) - 
     * @param "ObjectReprIew" (optional.Interface of []string) - 
     * @param "ObjectReprIre" (optional.Interface of []string) - 
     * @param "ObjectReprIsw" (optional.Interface of []string) - 
     * @param "ObjectReprN" (optional.Interface of []string) - 
     * @param "ObjectReprNic" (optional.Interface of []string) - 
     * @param "ObjectReprNie" (optional.Interface of []string) - 
     * @param "ObjectReprNiew" (optional.Interface of []string) - 
     * @param "ObjectReprNire" (optional.Interface of []string) - 
     * @param "ObjectReprNisw" (optional.Interface of []string) - 
     * @param "ObjectReprNre" (optional.Interface of []string) - 
     * @param "ObjectReprRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "RequestId" (optional.Interface of []string) - 
     * @param "RequestIdIc" (optional.Interface of []string) - 
     * @param "RequestIdIe" (optional.Interface of []string) - 
     * @param "RequestIdIew" (optional.Interface of []string) - 
     * @param "RequestIdIre" (optional.Interface of []string) - 
     * @param "RequestIdIsw" (optional.Interface of []string) - 
     * @param "RequestIdN" (optional.Interface of []string) - 
     * @param "RequestIdNic" (optional.Interface of []string) - 
     * @param "RequestIdNie" (optional.Interface of []string) - 
     * @param "RequestIdNiew" (optional.Interface of []string) - 
     * @param "RequestIdNire" (optional.Interface of []string) - 
     * @param "RequestIdNisw" (optional.Interface of []string) - 
     * @param "RequestIdNre" (optional.Interface of []string) - 
     * @param "RequestIdRe" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Time" (optional.Interface of []time.Time) - 
     * @param "TimeGt" (optional.Interface of []time.Time) - 
     * @param "TimeGte" (optional.Interface of []time.Time) - 
     * @param "TimeLt" (optional.Interface of []time.Time) - 
     * @param "TimeLte" (optional.Interface of []time.Time) - 
     * @param "TimeN" (optional.Interface of []time.Time) - 
     * @param "User" (optional.Interface of []string) - 
     * @param "UserIsnull" (optional.Bool) - 
     * @param "UserN" (optional.Interface of []string) - 
     * @param "UserId" (optional.Interface of []string) -  User (ID) - Deprecated (use user filter)
     * @param "UserIdIsnull" (optional.Bool) - 
     * @param "UserIdN" (optional.Interface of []string) -  User (ID) - Deprecated (use user filter)
     * @param "UserName" (optional.Interface of []string) - 
     * @param "UserNameIc" (optional.Interface of []string) - 
     * @param "UserNameIe" (optional.Interface of []string) - 
     * @param "UserNameIew" (optional.Interface of []string) - 
     * @param "UserNameIre" (optional.Interface of []string) - 
     * @param "UserNameIsw" (optional.Interface of []string) - 
     * @param "UserNameN" (optional.Interface of []string) - 
     * @param "UserNameNic" (optional.Interface of []string) - 
     * @param "UserNameNie" (optional.Interface of []string) - 
     * @param "UserNameNiew" (optional.Interface of []string) - 
     * @param "UserNameNire" (optional.Interface of []string) - 
     * @param "UserNameNisw" (optional.Interface of []string) - 
     * @param "UserNameNre" (optional.Interface of []string) - 
     * @param "UserNameRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedObjectChangeList
*/

type ExtrasApiExtrasObjectChangesListOpts struct {
    Action optional.Interface
    ActionIc optional.Interface
    ActionIe optional.Interface
    ActionIew optional.Interface
    ActionIre optional.Interface
    ActionIsw optional.Interface
    ActionN optional.Interface
    ActionNic optional.Interface
    ActionNie optional.Interface
    ActionNiew optional.Interface
    ActionNire optional.Interface
    ActionNisw optional.Interface
    ActionNre optional.Interface
    ActionRe optional.Interface
    ChangedObjectId optional.Interface
    ChangedObjectIdIc optional.Interface
    ChangedObjectIdIe optional.Interface
    ChangedObjectIdIew optional.Interface
    ChangedObjectIdIre optional.Interface
    ChangedObjectIdIsw optional.Interface
    ChangedObjectIdN optional.Interface
    ChangedObjectIdNic optional.Interface
    ChangedObjectIdNie optional.Interface
    ChangedObjectIdNiew optional.Interface
    ChangedObjectIdNire optional.Interface
    ChangedObjectIdNisw optional.Interface
    ChangedObjectIdNre optional.Interface
    ChangedObjectIdRe optional.Interface
    ChangedObjectType optional.String
    ChangedObjectTypeIsnull optional.Bool
    ChangedObjectTypeN optional.String
    ChangedObjectTypeId optional.Int32
    ChangedObjectTypeIdIsnull optional.Bool
    ChangedObjectTypeIdN optional.Int32
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    ObjectRepr optional.Interface
    ObjectReprIc optional.Interface
    ObjectReprIe optional.Interface
    ObjectReprIew optional.Interface
    ObjectReprIre optional.Interface
    ObjectReprIsw optional.Interface
    ObjectReprN optional.Interface
    ObjectReprNic optional.Interface
    ObjectReprNie optional.Interface
    ObjectReprNiew optional.Interface
    ObjectReprNire optional.Interface
    ObjectReprNisw optional.Interface
    ObjectReprNre optional.Interface
    ObjectReprRe optional.Interface
    Offset optional.Int32
    Q optional.String
    RequestId optional.Interface
    RequestIdIc optional.Interface
    RequestIdIe optional.Interface
    RequestIdIew optional.Interface
    RequestIdIre optional.Interface
    RequestIdIsw optional.Interface
    RequestIdN optional.Interface
    RequestIdNic optional.Interface
    RequestIdNie optional.Interface
    RequestIdNiew optional.Interface
    RequestIdNire optional.Interface
    RequestIdNisw optional.Interface
    RequestIdNre optional.Interface
    RequestIdRe optional.Interface
    Sort optional.String
    Time optional.Interface
    TimeGt optional.Interface
    TimeGte optional.Interface
    TimeLt optional.Interface
    TimeLte optional.Interface
    TimeN optional.Interface
    User optional.Interface
    UserIsnull optional.Bool
    UserN optional.Interface
    UserId optional.Interface
    UserIdIsnull optional.Bool
    UserIdN optional.Interface
    UserName optional.Interface
    UserNameIc optional.Interface
    UserNameIe optional.Interface
    UserNameIew optional.Interface
    UserNameIre optional.Interface
    UserNameIsw optional.Interface
    UserNameN optional.Interface
    UserNameNic optional.Interface
    UserNameNie optional.Interface
    UserNameNiew optional.Interface
    UserNameNire optional.Interface
    UserNameNisw optional.Interface
    UserNameNre optional.Interface
    UserNameRe optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasObjectChangesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasObjectChangesListOpts) (PaginatedObjectChangeList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedObjectChangeList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/object-changes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Action.IsSet() {
		localVarQueryParams.Add("action", parameterToString(localVarOptionals.Action.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionIc.IsSet() {
		localVarQueryParams.Add("action__ic", parameterToString(localVarOptionals.ActionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionIe.IsSet() {
		localVarQueryParams.Add("action__ie", parameterToString(localVarOptionals.ActionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionIew.IsSet() {
		localVarQueryParams.Add("action__iew", parameterToString(localVarOptionals.ActionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionIre.IsSet() {
		localVarQueryParams.Add("action__ire", parameterToString(localVarOptionals.ActionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionIsw.IsSet() {
		localVarQueryParams.Add("action__isw", parameterToString(localVarOptionals.ActionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionN.IsSet() {
		localVarQueryParams.Add("action__n", parameterToString(localVarOptionals.ActionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionNic.IsSet() {
		localVarQueryParams.Add("action__nic", parameterToString(localVarOptionals.ActionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionNie.IsSet() {
		localVarQueryParams.Add("action__nie", parameterToString(localVarOptionals.ActionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionNiew.IsSet() {
		localVarQueryParams.Add("action__niew", parameterToString(localVarOptionals.ActionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionNire.IsSet() {
		localVarQueryParams.Add("action__nire", parameterToString(localVarOptionals.ActionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionNisw.IsSet() {
		localVarQueryParams.Add("action__nisw", parameterToString(localVarOptionals.ActionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionNre.IsSet() {
		localVarQueryParams.Add("action__nre", parameterToString(localVarOptionals.ActionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ActionRe.IsSet() {
		localVarQueryParams.Add("action__re", parameterToString(localVarOptionals.ActionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectId.IsSet() {
		localVarQueryParams.Add("changed_object_id", parameterToString(localVarOptionals.ChangedObjectId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdIc.IsSet() {
		localVarQueryParams.Add("changed_object_id__ic", parameterToString(localVarOptionals.ChangedObjectIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdIe.IsSet() {
		localVarQueryParams.Add("changed_object_id__ie", parameterToString(localVarOptionals.ChangedObjectIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdIew.IsSet() {
		localVarQueryParams.Add("changed_object_id__iew", parameterToString(localVarOptionals.ChangedObjectIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdIre.IsSet() {
		localVarQueryParams.Add("changed_object_id__ire", parameterToString(localVarOptionals.ChangedObjectIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdIsw.IsSet() {
		localVarQueryParams.Add("changed_object_id__isw", parameterToString(localVarOptionals.ChangedObjectIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdN.IsSet() {
		localVarQueryParams.Add("changed_object_id__n", parameterToString(localVarOptionals.ChangedObjectIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdNic.IsSet() {
		localVarQueryParams.Add("changed_object_id__nic", parameterToString(localVarOptionals.ChangedObjectIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdNie.IsSet() {
		localVarQueryParams.Add("changed_object_id__nie", parameterToString(localVarOptionals.ChangedObjectIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdNiew.IsSet() {
		localVarQueryParams.Add("changed_object_id__niew", parameterToString(localVarOptionals.ChangedObjectIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdNire.IsSet() {
		localVarQueryParams.Add("changed_object_id__nire", parameterToString(localVarOptionals.ChangedObjectIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdNisw.IsSet() {
		localVarQueryParams.Add("changed_object_id__nisw", parameterToString(localVarOptionals.ChangedObjectIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdNre.IsSet() {
		localVarQueryParams.Add("changed_object_id__nre", parameterToString(localVarOptionals.ChangedObjectIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdRe.IsSet() {
		localVarQueryParams.Add("changed_object_id__re", parameterToString(localVarOptionals.ChangedObjectIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectType.IsSet() {
		localVarQueryParams.Add("changed_object_type", parameterToString(localVarOptionals.ChangedObjectType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectTypeIsnull.IsSet() {
		localVarQueryParams.Add("changed_object_type__isnull", parameterToString(localVarOptionals.ChangedObjectTypeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectTypeN.IsSet() {
		localVarQueryParams.Add("changed_object_type__n", parameterToString(localVarOptionals.ChangedObjectTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectTypeId.IsSet() {
		localVarQueryParams.Add("changed_object_type_id", parameterToString(localVarOptionals.ChangedObjectTypeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectTypeIdIsnull.IsSet() {
		localVarQueryParams.Add("changed_object_type_id__isnull", parameterToString(localVarOptionals.ChangedObjectTypeIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectTypeIdN.IsSet() {
		localVarQueryParams.Add("changed_object_type_id__n", parameterToString(localVarOptionals.ChangedObjectTypeIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectRepr.IsSet() {
		localVarQueryParams.Add("object_repr", parameterToString(localVarOptionals.ObjectRepr.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIc.IsSet() {
		localVarQueryParams.Add("object_repr__ic", parameterToString(localVarOptionals.ObjectReprIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIe.IsSet() {
		localVarQueryParams.Add("object_repr__ie", parameterToString(localVarOptionals.ObjectReprIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIew.IsSet() {
		localVarQueryParams.Add("object_repr__iew", parameterToString(localVarOptionals.ObjectReprIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIre.IsSet() {
		localVarQueryParams.Add("object_repr__ire", parameterToString(localVarOptionals.ObjectReprIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIsw.IsSet() {
		localVarQueryParams.Add("object_repr__isw", parameterToString(localVarOptionals.ObjectReprIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprN.IsSet() {
		localVarQueryParams.Add("object_repr__n", parameterToString(localVarOptionals.ObjectReprN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNic.IsSet() {
		localVarQueryParams.Add("object_repr__nic", parameterToString(localVarOptionals.ObjectReprNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNie.IsSet() {
		localVarQueryParams.Add("object_repr__nie", parameterToString(localVarOptionals.ObjectReprNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNiew.IsSet() {
		localVarQueryParams.Add("object_repr__niew", parameterToString(localVarOptionals.ObjectReprNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNire.IsSet() {
		localVarQueryParams.Add("object_repr__nire", parameterToString(localVarOptionals.ObjectReprNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNisw.IsSet() {
		localVarQueryParams.Add("object_repr__nisw", parameterToString(localVarOptionals.ObjectReprNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNre.IsSet() {
		localVarQueryParams.Add("object_repr__nre", parameterToString(localVarOptionals.ObjectReprNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprRe.IsSet() {
		localVarQueryParams.Add("object_repr__re", parameterToString(localVarOptionals.ObjectReprRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestId.IsSet() {
		localVarQueryParams.Add("request_id", parameterToString(localVarOptionals.RequestId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdIc.IsSet() {
		localVarQueryParams.Add("request_id__ic", parameterToString(localVarOptionals.RequestIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdIe.IsSet() {
		localVarQueryParams.Add("request_id__ie", parameterToString(localVarOptionals.RequestIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdIew.IsSet() {
		localVarQueryParams.Add("request_id__iew", parameterToString(localVarOptionals.RequestIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdIre.IsSet() {
		localVarQueryParams.Add("request_id__ire", parameterToString(localVarOptionals.RequestIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdIsw.IsSet() {
		localVarQueryParams.Add("request_id__isw", parameterToString(localVarOptionals.RequestIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdN.IsSet() {
		localVarQueryParams.Add("request_id__n", parameterToString(localVarOptionals.RequestIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdNic.IsSet() {
		localVarQueryParams.Add("request_id__nic", parameterToString(localVarOptionals.RequestIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdNie.IsSet() {
		localVarQueryParams.Add("request_id__nie", parameterToString(localVarOptionals.RequestIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdNiew.IsSet() {
		localVarQueryParams.Add("request_id__niew", parameterToString(localVarOptionals.RequestIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdNire.IsSet() {
		localVarQueryParams.Add("request_id__nire", parameterToString(localVarOptionals.RequestIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdNisw.IsSet() {
		localVarQueryParams.Add("request_id__nisw", parameterToString(localVarOptionals.RequestIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdNre.IsSet() {
		localVarQueryParams.Add("request_id__nre", parameterToString(localVarOptionals.RequestIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RequestIdRe.IsSet() {
		localVarQueryParams.Add("request_id__re", parameterToString(localVarOptionals.RequestIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Time.IsSet() {
		localVarQueryParams.Add("time", parameterToString(localVarOptionals.Time.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeGt.IsSet() {
		localVarQueryParams.Add("time__gt", parameterToString(localVarOptionals.TimeGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeGte.IsSet() {
		localVarQueryParams.Add("time__gte", parameterToString(localVarOptionals.TimeGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLt.IsSet() {
		localVarQueryParams.Add("time__lt", parameterToString(localVarOptionals.TimeLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeLte.IsSet() {
		localVarQueryParams.Add("time__lte", parameterToString(localVarOptionals.TimeLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeN.IsSet() {
		localVarQueryParams.Add("time__n", parameterToString(localVarOptionals.TimeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.User.IsSet() {
		localVarQueryParams.Add("user", parameterToString(localVarOptionals.User.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserIsnull.IsSet() {
		localVarQueryParams.Add("user__isnull", parameterToString(localVarOptionals.UserIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserN.IsSet() {
		localVarQueryParams.Add("user__n", parameterToString(localVarOptionals.UserN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("user_id", parameterToString(localVarOptionals.UserId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserIdIsnull.IsSet() {
		localVarQueryParams.Add("user_id__isnull", parameterToString(localVarOptionals.UserIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserIdN.IsSet() {
		localVarQueryParams.Add("user_id__n", parameterToString(localVarOptionals.UserIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserName.IsSet() {
		localVarQueryParams.Add("user_name", parameterToString(localVarOptionals.UserName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIc.IsSet() {
		localVarQueryParams.Add("user_name__ic", parameterToString(localVarOptionals.UserNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIe.IsSet() {
		localVarQueryParams.Add("user_name__ie", parameterToString(localVarOptionals.UserNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIew.IsSet() {
		localVarQueryParams.Add("user_name__iew", parameterToString(localVarOptionals.UserNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIre.IsSet() {
		localVarQueryParams.Add("user_name__ire", parameterToString(localVarOptionals.UserNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIsw.IsSet() {
		localVarQueryParams.Add("user_name__isw", parameterToString(localVarOptionals.UserNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameN.IsSet() {
		localVarQueryParams.Add("user_name__n", parameterToString(localVarOptionals.UserNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNic.IsSet() {
		localVarQueryParams.Add("user_name__nic", parameterToString(localVarOptionals.UserNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNie.IsSet() {
		localVarQueryParams.Add("user_name__nie", parameterToString(localVarOptionals.UserNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNiew.IsSet() {
		localVarQueryParams.Add("user_name__niew", parameterToString(localVarOptionals.UserNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNire.IsSet() {
		localVarQueryParams.Add("user_name__nire", parameterToString(localVarOptionals.UserNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNisw.IsSet() {
		localVarQueryParams.Add("user_name__nisw", parameterToString(localVarOptionals.UserNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNre.IsSet() {
		localVarQueryParams.Add("user_name__nre", parameterToString(localVarOptionals.UserNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameRe.IsSet() {
		localVarQueryParams.Add("user_name__re", parameterToString(localVarOptionals.UserNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedObjectChangeList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of recent changes.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this object change.
 * @param optional nil or *ExtrasApiExtrasObjectChangesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ObjectChange
*/

type ExtrasApiExtrasObjectChangesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasObjectChangesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasObjectChangesRetrieveOpts) (ObjectChange, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ObjectChange
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/object-changes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ObjectChange
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of relationship association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasRelationshipAssociationsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of relationship association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RelationshipAssociation
*/

type ExtrasApiExtrasRelationshipAssociationsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableRelationshipAssociationRequest, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsBulkPartialUpdateOpts) ([]RelationshipAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RelationshipAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RelationshipAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of relationship association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RelationshipAssociation
*/

type ExtrasApiExtrasRelationshipAssociationsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsBulkUpdate(ctx context.Context, body []BulkWritableRelationshipAssociationRequest, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsBulkUpdateOpts) ([]RelationshipAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RelationshipAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RelationshipAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more relationship association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RelationshipAssociation
*/

type ExtrasApiExtrasRelationshipAssociationsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsCreate(ctx context.Context, body RelationshipAssociationRequest, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsCreateOpts) (RelationshipAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RelationshipAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v RelationshipAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a relationship association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this relationship association.
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasRelationshipAssociationsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of relationship association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsListOpts - Optional Parameters:
     * @param "DestinationId" (optional.Interface of []string) - 
     * @param "DestinationIdIc" (optional.Interface of []string) - 
     * @param "DestinationIdIe" (optional.Interface of []string) - 
     * @param "DestinationIdIew" (optional.Interface of []string) - 
     * @param "DestinationIdIre" (optional.Interface of []string) - 
     * @param "DestinationIdIsw" (optional.Interface of []string) - 
     * @param "DestinationIdN" (optional.Interface of []string) - 
     * @param "DestinationIdNic" (optional.Interface of []string) - 
     * @param "DestinationIdNie" (optional.Interface of []string) - 
     * @param "DestinationIdNiew" (optional.Interface of []string) - 
     * @param "DestinationIdNire" (optional.Interface of []string) - 
     * @param "DestinationIdNisw" (optional.Interface of []string) - 
     * @param "DestinationIdNre" (optional.Interface of []string) - 
     * @param "DestinationIdRe" (optional.Interface of []string) - 
     * @param "DestinationType" (optional.Interface of []int32) - 
     * @param "DestinationTypeN" (optional.Interface of []int32) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PeerId" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Relationship" (optional.Interface of []string) -  Relationship (key)
     * @param "RelationshipN" (optional.Interface of []string) -  Relationship (key)
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "SourceId" (optional.Interface of []string) - 
     * @param "SourceIdIc" (optional.Interface of []string) - 
     * @param "SourceIdIe" (optional.Interface of []string) - 
     * @param "SourceIdIew" (optional.Interface of []string) - 
     * @param "SourceIdIre" (optional.Interface of []string) - 
     * @param "SourceIdIsw" (optional.Interface of []string) - 
     * @param "SourceIdN" (optional.Interface of []string) - 
     * @param "SourceIdNic" (optional.Interface of []string) - 
     * @param "SourceIdNie" (optional.Interface of []string) - 
     * @param "SourceIdNiew" (optional.Interface of []string) - 
     * @param "SourceIdNire" (optional.Interface of []string) - 
     * @param "SourceIdNisw" (optional.Interface of []string) - 
     * @param "SourceIdNre" (optional.Interface of []string) - 
     * @param "SourceIdRe" (optional.Interface of []string) - 
     * @param "SourceType" (optional.Interface of []int32) - 
     * @param "SourceTypeN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRelationshipAssociationList
*/

type ExtrasApiExtrasRelationshipAssociationsListOpts struct {
    DestinationId optional.Interface
    DestinationIdIc optional.Interface
    DestinationIdIe optional.Interface
    DestinationIdIew optional.Interface
    DestinationIdIre optional.Interface
    DestinationIdIsw optional.Interface
    DestinationIdN optional.Interface
    DestinationIdNic optional.Interface
    DestinationIdNie optional.Interface
    DestinationIdNiew optional.Interface
    DestinationIdNire optional.Interface
    DestinationIdNisw optional.Interface
    DestinationIdNre optional.Interface
    DestinationIdRe optional.Interface
    DestinationType optional.Interface
    DestinationTypeN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    PeerId optional.Interface
    Q optional.String
    Relationship optional.Interface
    RelationshipN optional.Interface
    Sort optional.String
    SourceId optional.Interface
    SourceIdIc optional.Interface
    SourceIdIe optional.Interface
    SourceIdIew optional.Interface
    SourceIdIre optional.Interface
    SourceIdIsw optional.Interface
    SourceIdN optional.Interface
    SourceIdNic optional.Interface
    SourceIdNie optional.Interface
    SourceIdNiew optional.Interface
    SourceIdNire optional.Interface
    SourceIdNisw optional.Interface
    SourceIdNre optional.Interface
    SourceIdRe optional.Interface
    SourceType optional.Interface
    SourceTypeN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsListOpts) (PaginatedRelationshipAssociationList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRelationshipAssociationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DestinationId.IsSet() {
		localVarQueryParams.Add("destination_id", parameterToString(localVarOptionals.DestinationId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdIc.IsSet() {
		localVarQueryParams.Add("destination_id__ic", parameterToString(localVarOptionals.DestinationIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdIe.IsSet() {
		localVarQueryParams.Add("destination_id__ie", parameterToString(localVarOptionals.DestinationIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdIew.IsSet() {
		localVarQueryParams.Add("destination_id__iew", parameterToString(localVarOptionals.DestinationIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdIre.IsSet() {
		localVarQueryParams.Add("destination_id__ire", parameterToString(localVarOptionals.DestinationIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdIsw.IsSet() {
		localVarQueryParams.Add("destination_id__isw", parameterToString(localVarOptionals.DestinationIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdN.IsSet() {
		localVarQueryParams.Add("destination_id__n", parameterToString(localVarOptionals.DestinationIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdNic.IsSet() {
		localVarQueryParams.Add("destination_id__nic", parameterToString(localVarOptionals.DestinationIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdNie.IsSet() {
		localVarQueryParams.Add("destination_id__nie", parameterToString(localVarOptionals.DestinationIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdNiew.IsSet() {
		localVarQueryParams.Add("destination_id__niew", parameterToString(localVarOptionals.DestinationIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdNire.IsSet() {
		localVarQueryParams.Add("destination_id__nire", parameterToString(localVarOptionals.DestinationIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdNisw.IsSet() {
		localVarQueryParams.Add("destination_id__nisw", parameterToString(localVarOptionals.DestinationIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdNre.IsSet() {
		localVarQueryParams.Add("destination_id__nre", parameterToString(localVarOptionals.DestinationIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIdRe.IsSet() {
		localVarQueryParams.Add("destination_id__re", parameterToString(localVarOptionals.DestinationIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationType.IsSet() {
		localVarQueryParams.Add("destination_type", parameterToString(localVarOptionals.DestinationType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationTypeN.IsSet() {
		localVarQueryParams.Add("destination_type__n", parameterToString(localVarOptionals.DestinationTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PeerId.IsSet() {
		localVarQueryParams.Add("peer_id", parameterToString(localVarOptionals.PeerId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Relationship.IsSet() {
		localVarQueryParams.Add("relationship", parameterToString(localVarOptionals.Relationship.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RelationshipN.IsSet() {
		localVarQueryParams.Add("relationship__n", parameterToString(localVarOptionals.RelationshipN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceId.IsSet() {
		localVarQueryParams.Add("source_id", parameterToString(localVarOptionals.SourceId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdIc.IsSet() {
		localVarQueryParams.Add("source_id__ic", parameterToString(localVarOptionals.SourceIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdIe.IsSet() {
		localVarQueryParams.Add("source_id__ie", parameterToString(localVarOptionals.SourceIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdIew.IsSet() {
		localVarQueryParams.Add("source_id__iew", parameterToString(localVarOptionals.SourceIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdIre.IsSet() {
		localVarQueryParams.Add("source_id__ire", parameterToString(localVarOptionals.SourceIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdIsw.IsSet() {
		localVarQueryParams.Add("source_id__isw", parameterToString(localVarOptionals.SourceIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdN.IsSet() {
		localVarQueryParams.Add("source_id__n", parameterToString(localVarOptionals.SourceIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdNic.IsSet() {
		localVarQueryParams.Add("source_id__nic", parameterToString(localVarOptionals.SourceIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdNie.IsSet() {
		localVarQueryParams.Add("source_id__nie", parameterToString(localVarOptionals.SourceIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdNiew.IsSet() {
		localVarQueryParams.Add("source_id__niew", parameterToString(localVarOptionals.SourceIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdNire.IsSet() {
		localVarQueryParams.Add("source_id__nire", parameterToString(localVarOptionals.SourceIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdNisw.IsSet() {
		localVarQueryParams.Add("source_id__nisw", parameterToString(localVarOptionals.SourceIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdNre.IsSet() {
		localVarQueryParams.Add("source_id__nre", parameterToString(localVarOptionals.SourceIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIdRe.IsSet() {
		localVarQueryParams.Add("source_id__re", parameterToString(localVarOptionals.SourceIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceType.IsSet() {
		localVarQueryParams.Add("source_type", parameterToString(localVarOptionals.SourceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceTypeN.IsSet() {
		localVarQueryParams.Add("source_type__n", parameterToString(localVarOptionals.SourceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRelationshipAssociationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a relationship association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this relationship association.
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedRelationshipAssociationRequest) - 
     * @param "Format" (optional.String) - 
@return RelationshipAssociation
*/

type ExtrasApiExtrasRelationshipAssociationsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsPartialUpdateOpts) (RelationshipAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RelationshipAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RelationshipAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a relationship association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this relationship association.
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return RelationshipAssociation
*/

type ExtrasApiExtrasRelationshipAssociationsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsRetrieveOpts) (RelationshipAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RelationshipAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RelationshipAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a relationship association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this relationship association.
 * @param optional nil or *ExtrasApiExtrasRelationshipAssociationsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RelationshipAssociation
*/

type ExtrasApiExtrasRelationshipAssociationsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipAssociationsUpdate(ctx context.Context, body RelationshipAssociationRequest, id string, localVarOptionals *ExtrasApiExtrasRelationshipAssociationsUpdateOpts) (RelationshipAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RelationshipAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationship-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RelationshipAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of relationship objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRelationshipsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasRelationshipsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasRelationshipsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of relationship objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRelationshipsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Relationship
*/

type ExtrasApiExtrasRelationshipsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableRelationshipRequest, localVarOptionals *ExtrasApiExtrasRelationshipsBulkPartialUpdateOpts) ([]Relationship, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Relationship
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Relationship
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of relationship objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRelationshipsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Relationship
*/

type ExtrasApiExtrasRelationshipsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipsBulkUpdate(ctx context.Context, body []BulkWritableRelationshipRequest, localVarOptionals *ExtrasApiExtrasRelationshipsBulkUpdateOpts) ([]Relationship, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Relationship
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Relationship
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more relationship objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRelationshipsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Relationship
*/

type ExtrasApiExtrasRelationshipsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipsCreate(ctx context.Context, body RelationshipRequest, localVarOptionals *ExtrasApiExtrasRelationshipsCreateOpts) (Relationship, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Relationship
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Relationship
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a relationship object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this relationship.
 * @param optional nil or *ExtrasApiExtrasRelationshipsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasRelationshipsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRelationshipsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of relationship objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasRelationshipsListOpts - Optional Parameters:
     * @param "DestinationType" (optional.Interface of []int32) - 
     * @param "DestinationTypeN" (optional.Interface of []int32) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Key" (optional.Interface of []string) - 
     * @param "KeyIc" (optional.Interface of []string) - 
     * @param "KeyIe" (optional.Interface of []string) - 
     * @param "KeyIew" (optional.Interface of []string) - 
     * @param "KeyIre" (optional.Interface of []string) - 
     * @param "KeyIsw" (optional.Interface of []string) - 
     * @param "KeyN" (optional.Interface of []string) - 
     * @param "KeyNic" (optional.Interface of []string) - 
     * @param "KeyNie" (optional.Interface of []string) - 
     * @param "KeyNiew" (optional.Interface of []string) - 
     * @param "KeyNire" (optional.Interface of []string) - 
     * @param "KeyNisw" (optional.Interface of []string) - 
     * @param "KeyNre" (optional.Interface of []string) - 
     * @param "KeyRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "SourceType" (optional.Interface of []int32) - 
     * @param "SourceTypeN" (optional.Interface of []int32) - 
     * @param "Type_" (optional.Interface of []string) -  Cardinality of this relationship
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) -  Cardinality of this relationship
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRelationshipList
*/

type ExtrasApiExtrasRelationshipsListOpts struct {
    DestinationType optional.Interface
    DestinationTypeN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Key optional.Interface
    KeyIc optional.Interface
    KeyIe optional.Interface
    KeyIew optional.Interface
    KeyIre optional.Interface
    KeyIsw optional.Interface
    KeyN optional.Interface
    KeyNic optional.Interface
    KeyNie optional.Interface
    KeyNiew optional.Interface
    KeyNire optional.Interface
    KeyNisw optional.Interface
    KeyNre optional.Interface
    KeyRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    SourceType optional.Interface
    SourceTypeN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasRelationshipsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasRelationshipsListOpts) (PaginatedRelationshipList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRelationshipList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DestinationType.IsSet() {
		localVarQueryParams.Add("destination_type", parameterToString(localVarOptionals.DestinationType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationTypeN.IsSet() {
		localVarQueryParams.Add("destination_type__n", parameterToString(localVarOptionals.DestinationTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Key.IsSet() {
		localVarQueryParams.Add("key", parameterToString(localVarOptionals.Key.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIc.IsSet() {
		localVarQueryParams.Add("key__ic", parameterToString(localVarOptionals.KeyIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIe.IsSet() {
		localVarQueryParams.Add("key__ie", parameterToString(localVarOptionals.KeyIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIew.IsSet() {
		localVarQueryParams.Add("key__iew", parameterToString(localVarOptionals.KeyIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIre.IsSet() {
		localVarQueryParams.Add("key__ire", parameterToString(localVarOptionals.KeyIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIsw.IsSet() {
		localVarQueryParams.Add("key__isw", parameterToString(localVarOptionals.KeyIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyN.IsSet() {
		localVarQueryParams.Add("key__n", parameterToString(localVarOptionals.KeyN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNic.IsSet() {
		localVarQueryParams.Add("key__nic", parameterToString(localVarOptionals.KeyNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNie.IsSet() {
		localVarQueryParams.Add("key__nie", parameterToString(localVarOptionals.KeyNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNiew.IsSet() {
		localVarQueryParams.Add("key__niew", parameterToString(localVarOptionals.KeyNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNire.IsSet() {
		localVarQueryParams.Add("key__nire", parameterToString(localVarOptionals.KeyNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNisw.IsSet() {
		localVarQueryParams.Add("key__nisw", parameterToString(localVarOptionals.KeyNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNre.IsSet() {
		localVarQueryParams.Add("key__nre", parameterToString(localVarOptionals.KeyNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyRe.IsSet() {
		localVarQueryParams.Add("key__re", parameterToString(localVarOptionals.KeyRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceType.IsSet() {
		localVarQueryParams.Add("source_type", parameterToString(localVarOptionals.SourceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SourceTypeN.IsSet() {
		localVarQueryParams.Add("source_type__n", parameterToString(localVarOptionals.SourceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRelationshipList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this relationship.
 * @param optional nil or *ExtrasApiExtrasRelationshipsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasRelationshipsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasRelationshipsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this relationship.
 * @param optional nil or *ExtrasApiExtrasRelationshipsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasRelationshipsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasRelationshipsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRelationshipsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a relationship object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this relationship.
 * @param optional nil or *ExtrasApiExtrasRelationshipsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedRelationshipRequest) - 
     * @param "Format" (optional.String) - 
@return Relationship
*/

type ExtrasApiExtrasRelationshipsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRelationshipsPartialUpdateOpts) (Relationship, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Relationship
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Relationship
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a relationship object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this relationship.
 * @param optional nil or *ExtrasApiExtrasRelationshipsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Relationship
*/

type ExtrasApiExtrasRelationshipsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasRelationshipsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRelationshipsRetrieveOpts) (Relationship, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Relationship
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Relationship
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a relationship object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this relationship.
 * @param optional nil or *ExtrasApiExtrasRelationshipsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Relationship
*/

type ExtrasApiExtrasRelationshipsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRelationshipsUpdate(ctx context.Context, body RelationshipRequest, id string, localVarOptionals *ExtrasApiExtrasRelationshipsUpdateOpts) (Relationship, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Relationship
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/relationships/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Relationship
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of role objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRolesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasRolesBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRolesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasRolesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of role objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRolesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Role
*/

type ExtrasApiExtrasRolesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRolesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableRoleRequest, localVarOptionals *ExtrasApiExtrasRolesBulkPartialUpdateOpts) ([]Role, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Role
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of role objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRolesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Role
*/

type ExtrasApiExtrasRolesBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRolesBulkUpdate(ctx context.Context, body []BulkWritableRoleRequest, localVarOptionals *ExtrasApiExtrasRolesBulkUpdateOpts) ([]Role, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Role
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more role objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasRolesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Role
*/

type ExtrasApiExtrasRolesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRolesCreate(ctx context.Context, body RoleRequest, localVarOptionals *ExtrasApiExtrasRolesCreateOpts) (Role, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Role
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a role object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this role.
 * @param optional nil or *ExtrasApiExtrasRolesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasRolesDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRolesDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRolesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of role objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasRolesListOpts - Optional Parameters:
     * @param "Color" (optional.Interface of []string) - 
     * @param "ColorIc" (optional.Interface of []string) - 
     * @param "ColorIe" (optional.Interface of []string) - 
     * @param "ColorIew" (optional.Interface of []string) - 
     * @param "ColorIre" (optional.Interface of []string) - 
     * @param "ColorIsw" (optional.Interface of []string) - 
     * @param "ColorN" (optional.Interface of []string) - 
     * @param "ColorNic" (optional.Interface of []string) - 
     * @param "ColorNie" (optional.Interface of []string) - 
     * @param "ColorNiew" (optional.Interface of []string) - 
     * @param "ColorNire" (optional.Interface of []string) - 
     * @param "ColorNisw" (optional.Interface of []string) - 
     * @param "ColorNre" (optional.Interface of []string) - 
     * @param "ColorRe" (optional.Interface of []string) - 
     * @param "ContentTypes" (optional.Interface of []int32) - 
     * @param "ContentTypesIc" (optional.Interface of []int32) - 
     * @param "ContentTypesIe" (optional.Interface of []int32) - 
     * @param "ContentTypesIew" (optional.Interface of []int32) - 
     * @param "ContentTypesIre" (optional.Interface of []int32) - 
     * @param "ContentTypesIsw" (optional.Interface of []int32) - 
     * @param "ContentTypesN" (optional.Interface of []int32) - 
     * @param "ContentTypesNic" (optional.Interface of []int32) - 
     * @param "ContentTypesNie" (optional.Interface of []int32) - 
     * @param "ContentTypesNiew" (optional.Interface of []int32) - 
     * @param "ContentTypesNire" (optional.Interface of []int32) - 
     * @param "ContentTypesNisw" (optional.Interface of []int32) - 
     * @param "ContentTypesNre" (optional.Interface of []int32) - 
     * @param "ContentTypesRe" (optional.Interface of []int32) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Weight" (optional.Interface of []int32) - 
     * @param "WeightGt" (optional.Interface of []int32) - 
     * @param "WeightGte" (optional.Interface of []int32) - 
     * @param "WeightIsnull" (optional.Bool) - 
     * @param "WeightLt" (optional.Interface of []int32) - 
     * @param "WeightLte" (optional.Interface of []int32) - 
     * @param "WeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRoleList
*/

type ExtrasApiExtrasRolesListOpts struct {
    Color optional.Interface
    ColorIc optional.Interface
    ColorIe optional.Interface
    ColorIew optional.Interface
    ColorIre optional.Interface
    ColorIsw optional.Interface
    ColorN optional.Interface
    ColorNic optional.Interface
    ColorNie optional.Interface
    ColorNiew optional.Interface
    ColorNire optional.Interface
    ColorNisw optional.Interface
    ColorNre optional.Interface
    ColorRe optional.Interface
    ContentTypes optional.Interface
    ContentTypesIc optional.Interface
    ContentTypesIe optional.Interface
    ContentTypesIew optional.Interface
    ContentTypesIre optional.Interface
    ContentTypesIsw optional.Interface
    ContentTypesN optional.Interface
    ContentTypesNic optional.Interface
    ContentTypesNie optional.Interface
    ContentTypesNiew optional.Interface
    ContentTypesNire optional.Interface
    ContentTypesNisw optional.Interface
    ContentTypesNre optional.Interface
    ContentTypesRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Weight optional.Interface
    WeightGt optional.Interface
    WeightGte optional.Interface
    WeightIsnull optional.Bool
    WeightLt optional.Interface
    WeightLte optional.Interface
    WeightN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasRolesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasRolesListOpts) (PaginatedRoleList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRoleList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Color.IsSet() {
		localVarQueryParams.Add("color", parameterToString(localVarOptionals.Color.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIc.IsSet() {
		localVarQueryParams.Add("color__ic", parameterToString(localVarOptionals.ColorIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIe.IsSet() {
		localVarQueryParams.Add("color__ie", parameterToString(localVarOptionals.ColorIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIew.IsSet() {
		localVarQueryParams.Add("color__iew", parameterToString(localVarOptionals.ColorIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIre.IsSet() {
		localVarQueryParams.Add("color__ire", parameterToString(localVarOptionals.ColorIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIsw.IsSet() {
		localVarQueryParams.Add("color__isw", parameterToString(localVarOptionals.ColorIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorN.IsSet() {
		localVarQueryParams.Add("color__n", parameterToString(localVarOptionals.ColorN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNic.IsSet() {
		localVarQueryParams.Add("color__nic", parameterToString(localVarOptionals.ColorNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNie.IsSet() {
		localVarQueryParams.Add("color__nie", parameterToString(localVarOptionals.ColorNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNiew.IsSet() {
		localVarQueryParams.Add("color__niew", parameterToString(localVarOptionals.ColorNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNire.IsSet() {
		localVarQueryParams.Add("color__nire", parameterToString(localVarOptionals.ColorNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNisw.IsSet() {
		localVarQueryParams.Add("color__nisw", parameterToString(localVarOptionals.ColorNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNre.IsSet() {
		localVarQueryParams.Add("color__nre", parameterToString(localVarOptionals.ColorNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorRe.IsSet() {
		localVarQueryParams.Add("color__re", parameterToString(localVarOptionals.ColorRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypes.IsSet() {
		localVarQueryParams.Add("content_types", parameterToString(localVarOptionals.ContentTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIc.IsSet() {
		localVarQueryParams.Add("content_types__ic", parameterToString(localVarOptionals.ContentTypesIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIe.IsSet() {
		localVarQueryParams.Add("content_types__ie", parameterToString(localVarOptionals.ContentTypesIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIew.IsSet() {
		localVarQueryParams.Add("content_types__iew", parameterToString(localVarOptionals.ContentTypesIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIre.IsSet() {
		localVarQueryParams.Add("content_types__ire", parameterToString(localVarOptionals.ContentTypesIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIsw.IsSet() {
		localVarQueryParams.Add("content_types__isw", parameterToString(localVarOptionals.ContentTypesIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesN.IsSet() {
		localVarQueryParams.Add("content_types__n", parameterToString(localVarOptionals.ContentTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNic.IsSet() {
		localVarQueryParams.Add("content_types__nic", parameterToString(localVarOptionals.ContentTypesNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNie.IsSet() {
		localVarQueryParams.Add("content_types__nie", parameterToString(localVarOptionals.ContentTypesNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNiew.IsSet() {
		localVarQueryParams.Add("content_types__niew", parameterToString(localVarOptionals.ContentTypesNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNire.IsSet() {
		localVarQueryParams.Add("content_types__nire", parameterToString(localVarOptionals.ContentTypesNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNisw.IsSet() {
		localVarQueryParams.Add("content_types__nisw", parameterToString(localVarOptionals.ContentTypesNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNre.IsSet() {
		localVarQueryParams.Add("content_types__nre", parameterToString(localVarOptionals.ContentTypesNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesRe.IsSet() {
		localVarQueryParams.Add("content_types__re", parameterToString(localVarOptionals.ContentTypesRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Weight.IsSet() {
		localVarQueryParams.Add("weight", parameterToString(localVarOptionals.Weight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGt.IsSet() {
		localVarQueryParams.Add("weight__gt", parameterToString(localVarOptionals.WeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGte.IsSet() {
		localVarQueryParams.Add("weight__gte", parameterToString(localVarOptionals.WeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightIsnull.IsSet() {
		localVarQueryParams.Add("weight__isnull", parameterToString(localVarOptionals.WeightIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLt.IsSet() {
		localVarQueryParams.Add("weight__lt", parameterToString(localVarOptionals.WeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLte.IsSet() {
		localVarQueryParams.Add("weight__lte", parameterToString(localVarOptionals.WeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightN.IsSet() {
		localVarQueryParams.Add("weight__n", parameterToString(localVarOptionals.WeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRoleList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this role.
 * @param optional nil or *ExtrasApiExtrasRolesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasRolesNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRolesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasRolesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this role.
 * @param optional nil or *ExtrasApiExtrasRolesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasRolesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasRolesNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRolesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a role object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this role.
 * @param optional nil or *ExtrasApiExtrasRolesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedRoleRequest) - 
     * @param "Format" (optional.String) - 
@return Role
*/

type ExtrasApiExtrasRolesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRolesPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRolesPartialUpdateOpts) (Role, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Role
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a role object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this role.
 * @param optional nil or *ExtrasApiExtrasRolesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Role
*/

type ExtrasApiExtrasRolesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasRolesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasRolesRetrieveOpts) (Role, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Role
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a role object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this role.
 * @param optional nil or *ExtrasApiExtrasRolesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Role
*/

type ExtrasApiExtrasRolesUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasRolesUpdate(ctx context.Context, body RoleRequest, id string, localVarOptionals *ExtrasApiExtrasRolesUpdateOpts) (Role, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Role
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of scheduled jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this scheduled job.
 * @param optional nil or *ExtrasApiExtrasScheduledJobsApproveCreateOpts - Optional Parameters:
     * @param "Force" (optional.Bool) -  force execution even if start time has passed
     * @param "Format" (optional.String) - 
@return ScheduledJob
*/

type ExtrasApiExtrasScheduledJobsApproveCreateOpts struct {
    Force optional.Bool
    Format optional.String
}

func (a *ExtrasApiService) ExtrasScheduledJobsApproveCreate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasScheduledJobsApproveCreateOpts) (ScheduledJob, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ScheduledJob
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/scheduled-jobs/{id}/approve/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Force.IsSet() {
		localVarQueryParams.Add("force", parameterToString(localVarOptionals.Force.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ScheduledJob
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of scheduled jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this scheduled job.
 * @param optional nil or *ExtrasApiExtrasScheduledJobsDenyCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ScheduledJob
*/

type ExtrasApiExtrasScheduledJobsDenyCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasScheduledJobsDenyCreate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasScheduledJobsDenyCreateOpts) (ScheduledJob, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ScheduledJob
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/scheduled-jobs/{id}/deny/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ScheduledJob
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of scheduled jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this scheduled job.
 * @param optional nil or *ExtrasApiExtrasScheduledJobsDryRunCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return JobResult
*/

type ExtrasApiExtrasScheduledJobsDryRunCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasScheduledJobsDryRunCreate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasScheduledJobsDryRunCreateOpts) (JobResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/scheduled-jobs/{id}/dry-run/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of scheduled jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasScheduledJobsListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "JobModel" (optional.Interface of []string) - 
     * @param "JobModelIsnull" (optional.Bool) - 
     * @param "JobModelN" (optional.Interface of []string) - 
     * @param "JobModelId" (optional.Interface of []string) -  Job (ID) - Deprecated (use job_model filter)
     * @param "JobModelIdIsnull" (optional.Bool) - 
     * @param "JobModelIdN" (optional.Interface of []string) -  Job (ID) - Deprecated (use job_model filter)
     * @param "LastRunAt" (optional.Interface of []time.Time) - 
     * @param "LastRunAtGt" (optional.Interface of []time.Time) - 
     * @param "LastRunAtGte" (optional.Interface of []time.Time) - 
     * @param "LastRunAtIsnull" (optional.Bool) - 
     * @param "LastRunAtLt" (optional.Interface of []time.Time) - 
     * @param "LastRunAtLte" (optional.Interface of []time.Time) - 
     * @param "LastRunAtN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "StartTime" (optional.Interface of []time.Time) - 
     * @param "StartTimeGt" (optional.Interface of []time.Time) - 
     * @param "StartTimeGte" (optional.Interface of []time.Time) - 
     * @param "StartTimeLt" (optional.Interface of []time.Time) - 
     * @param "StartTimeLte" (optional.Interface of []time.Time) - 
     * @param "StartTimeN" (optional.Interface of []time.Time) - 
     * @param "TotalRunCount" (optional.Interface of []int32) - 
     * @param "TotalRunCountGt" (optional.Interface of []int32) - 
     * @param "TotalRunCountGte" (optional.Interface of []int32) - 
     * @param "TotalRunCountLt" (optional.Interface of []int32) - 
     * @param "TotalRunCountLte" (optional.Interface of []int32) - 
     * @param "TotalRunCountN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedScheduledJobList
*/

type ExtrasApiExtrasScheduledJobsListOpts struct {
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    JobModel optional.Interface
    JobModelIsnull optional.Bool
    JobModelN optional.Interface
    JobModelId optional.Interface
    JobModelIdIsnull optional.Bool
    JobModelIdN optional.Interface
    LastRunAt optional.Interface
    LastRunAtGt optional.Interface
    LastRunAtGte optional.Interface
    LastRunAtIsnull optional.Bool
    LastRunAtLt optional.Interface
    LastRunAtLte optional.Interface
    LastRunAtN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    StartTime optional.Interface
    StartTimeGt optional.Interface
    StartTimeGte optional.Interface
    StartTimeLt optional.Interface
    StartTimeLte optional.Interface
    StartTimeN optional.Interface
    TotalRunCount optional.Interface
    TotalRunCountGt optional.Interface
    TotalRunCountGte optional.Interface
    TotalRunCountLt optional.Interface
    TotalRunCountLte optional.Interface
    TotalRunCountN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasScheduledJobsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasScheduledJobsListOpts) (PaginatedScheduledJobList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedScheduledJobList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/scheduled-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobModel.IsSet() {
		localVarQueryParams.Add("job_model", parameterToString(localVarOptionals.JobModel.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelIsnull.IsSet() {
		localVarQueryParams.Add("job_model__isnull", parameterToString(localVarOptionals.JobModelIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelN.IsSet() {
		localVarQueryParams.Add("job_model__n", parameterToString(localVarOptionals.JobModelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelId.IsSet() {
		localVarQueryParams.Add("job_model_id", parameterToString(localVarOptionals.JobModelId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelIdIsnull.IsSet() {
		localVarQueryParams.Add("job_model_id__isnull", parameterToString(localVarOptionals.JobModelIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobModelIdN.IsSet() {
		localVarQueryParams.Add("job_model_id__n", parameterToString(localVarOptionals.JobModelIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastRunAt.IsSet() {
		localVarQueryParams.Add("last_run_at", parameterToString(localVarOptionals.LastRunAt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastRunAtGt.IsSet() {
		localVarQueryParams.Add("last_run_at__gt", parameterToString(localVarOptionals.LastRunAtGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastRunAtGte.IsSet() {
		localVarQueryParams.Add("last_run_at__gte", parameterToString(localVarOptionals.LastRunAtGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastRunAtIsnull.IsSet() {
		localVarQueryParams.Add("last_run_at__isnull", parameterToString(localVarOptionals.LastRunAtIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastRunAtLt.IsSet() {
		localVarQueryParams.Add("last_run_at__lt", parameterToString(localVarOptionals.LastRunAtLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastRunAtLte.IsSet() {
		localVarQueryParams.Add("last_run_at__lte", parameterToString(localVarOptionals.LastRunAtLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastRunAtN.IsSet() {
		localVarQueryParams.Add("last_run_at__n", parameterToString(localVarOptionals.LastRunAtN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartTime.IsSet() {
		localVarQueryParams.Add("start_time", parameterToString(localVarOptionals.StartTime.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeGt.IsSet() {
		localVarQueryParams.Add("start_time__gt", parameterToString(localVarOptionals.StartTimeGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeGte.IsSet() {
		localVarQueryParams.Add("start_time__gte", parameterToString(localVarOptionals.StartTimeGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeLt.IsSet() {
		localVarQueryParams.Add("start_time__lt", parameterToString(localVarOptionals.StartTimeLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeLte.IsSet() {
		localVarQueryParams.Add("start_time__lte", parameterToString(localVarOptionals.StartTimeLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeN.IsSet() {
		localVarQueryParams.Add("start_time__n", parameterToString(localVarOptionals.StartTimeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TotalRunCount.IsSet() {
		localVarQueryParams.Add("total_run_count", parameterToString(localVarOptionals.TotalRunCount.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TotalRunCountGt.IsSet() {
		localVarQueryParams.Add("total_run_count__gt", parameterToString(localVarOptionals.TotalRunCountGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TotalRunCountGte.IsSet() {
		localVarQueryParams.Add("total_run_count__gte", parameterToString(localVarOptionals.TotalRunCountGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TotalRunCountLt.IsSet() {
		localVarQueryParams.Add("total_run_count__lt", parameterToString(localVarOptionals.TotalRunCountLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TotalRunCountLte.IsSet() {
		localVarQueryParams.Add("total_run_count__lte", parameterToString(localVarOptionals.TotalRunCountLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TotalRunCountN.IsSet() {
		localVarQueryParams.Add("total_run_count__n", parameterToString(localVarOptionals.TotalRunCountN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedScheduledJobList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of scheduled jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this scheduled job.
 * @param optional nil or *ExtrasApiExtrasScheduledJobsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ScheduledJob
*/

type ExtrasApiExtrasScheduledJobsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasScheduledJobsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasScheduledJobsRetrieveOpts) (ScheduledJob, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ScheduledJob
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/scheduled-jobs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ScheduledJob
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasSecretsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasSecretsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Secret
*/

type ExtrasApiExtrasSecretsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableSecretRequest, localVarOptionals *ExtrasApiExtrasSecretsBulkPartialUpdateOpts) ([]Secret, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Secret
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Secret
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Secret
*/

type ExtrasApiExtrasSecretsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsBulkUpdate(ctx context.Context, body []BulkWritableSecretRequest, localVarOptionals *ExtrasApiExtrasSecretsBulkUpdateOpts) ([]Secret, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Secret
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Secret
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Check that a secret&#x27;s value is accessible.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secret.
 * @param optional nil or *ExtrasApiExtrasSecretsCheckRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return InlineResponse200
*/

type ExtrasApiExtrasSecretsCheckRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsCheckRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsCheckRetrieveOpts) (InlineResponse200, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse200
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/{id}/check/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse200
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Secret
*/

type ExtrasApiExtrasSecretsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsCreate(ctx context.Context, body SecretRequest, localVarOptionals *ExtrasApiExtrasSecretsCreateOpts) (Secret, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Secret
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Secret
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secret.
 * @param optional nil or *ExtrasApiExtrasSecretsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasSecretsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasSecretsGroupsAssociationsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []SecretsGroupAssociation
*/

type ExtrasApiExtrasSecretsGroupsAssociationsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableSecretsGroupAssociationRequest, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsBulkPartialUpdateOpts) ([]SecretsGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []SecretsGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SecretsGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []SecretsGroupAssociation
*/

type ExtrasApiExtrasSecretsGroupsAssociationsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsBulkUpdate(ctx context.Context, body []BulkWritableSecretsGroupAssociationRequest, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsBulkUpdateOpts) ([]SecretsGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []SecretsGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SecretsGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return SecretsGroupAssociation
*/

type ExtrasApiExtrasSecretsGroupsAssociationsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsCreate(ctx context.Context, body SecretsGroupAssociationRequest, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsCreateOpts) (SecretsGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecretsGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v SecretsGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secrets group association.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasSecretsGroupsAssociationsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsListOpts - Optional Parameters:
     * @param "AccessType" (optional.Interface of []string) - 
     * @param "AccessTypeIc" (optional.Interface of []string) - 
     * @param "AccessTypeIe" (optional.Interface of []string) - 
     * @param "AccessTypeIew" (optional.Interface of []string) - 
     * @param "AccessTypeIre" (optional.Interface of []string) - 
     * @param "AccessTypeIsw" (optional.Interface of []string) - 
     * @param "AccessTypeN" (optional.Interface of []string) - 
     * @param "AccessTypeNic" (optional.Interface of []string) - 
     * @param "AccessTypeNie" (optional.Interface of []string) - 
     * @param "AccessTypeNiew" (optional.Interface of []string) - 
     * @param "AccessTypeNire" (optional.Interface of []string) - 
     * @param "AccessTypeNisw" (optional.Interface of []string) - 
     * @param "AccessTypeNre" (optional.Interface of []string) - 
     * @param "AccessTypeRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Secret" (optional.Interface of []string) - 
     * @param "SecretN" (optional.Interface of []string) - 
     * @param "SecretId" (optional.Interface of []string) -  Secret (ID) - Deprecated (use secret filter)
     * @param "SecretIdN" (optional.Interface of []string) -  Secret (ID) - Deprecated (use secret filter)
     * @param "SecretType" (optional.Interface of []string) - 
     * @param "SecretTypeIc" (optional.Interface of []string) - 
     * @param "SecretTypeIe" (optional.Interface of []string) - 
     * @param "SecretTypeIew" (optional.Interface of []string) - 
     * @param "SecretTypeIre" (optional.Interface of []string) - 
     * @param "SecretTypeIsw" (optional.Interface of []string) - 
     * @param "SecretTypeN" (optional.Interface of []string) - 
     * @param "SecretTypeNic" (optional.Interface of []string) - 
     * @param "SecretTypeNie" (optional.Interface of []string) - 
     * @param "SecretTypeNiew" (optional.Interface of []string) - 
     * @param "SecretTypeNire" (optional.Interface of []string) - 
     * @param "SecretTypeNisw" (optional.Interface of []string) - 
     * @param "SecretTypeNre" (optional.Interface of []string) - 
     * @param "SecretTypeRe" (optional.Interface of []string) - 
     * @param "SecretsGroup" (optional.Interface of []string) - 
     * @param "SecretsGroupN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedSecretsGroupAssociationList
*/

type ExtrasApiExtrasSecretsGroupsAssociationsListOpts struct {
    AccessType optional.Interface
    AccessTypeIc optional.Interface
    AccessTypeIe optional.Interface
    AccessTypeIew optional.Interface
    AccessTypeIre optional.Interface
    AccessTypeIsw optional.Interface
    AccessTypeN optional.Interface
    AccessTypeNic optional.Interface
    AccessTypeNie optional.Interface
    AccessTypeNiew optional.Interface
    AccessTypeNire optional.Interface
    AccessTypeNisw optional.Interface
    AccessTypeNre optional.Interface
    AccessTypeRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Secret optional.Interface
    SecretN optional.Interface
    SecretId optional.Interface
    SecretIdN optional.Interface
    SecretType optional.Interface
    SecretTypeIc optional.Interface
    SecretTypeIe optional.Interface
    SecretTypeIew optional.Interface
    SecretTypeIre optional.Interface
    SecretTypeIsw optional.Interface
    SecretTypeN optional.Interface
    SecretTypeNic optional.Interface
    SecretTypeNie optional.Interface
    SecretTypeNiew optional.Interface
    SecretTypeNire optional.Interface
    SecretTypeNisw optional.Interface
    SecretTypeNre optional.Interface
    SecretTypeRe optional.Interface
    SecretsGroup optional.Interface
    SecretsGroupN optional.Interface
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsListOpts) (PaginatedSecretsGroupAssociationList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedSecretsGroupAssociationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccessType.IsSet() {
		localVarQueryParams.Add("access_type", parameterToString(localVarOptionals.AccessType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeIc.IsSet() {
		localVarQueryParams.Add("access_type__ic", parameterToString(localVarOptionals.AccessTypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeIe.IsSet() {
		localVarQueryParams.Add("access_type__ie", parameterToString(localVarOptionals.AccessTypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeIew.IsSet() {
		localVarQueryParams.Add("access_type__iew", parameterToString(localVarOptionals.AccessTypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeIre.IsSet() {
		localVarQueryParams.Add("access_type__ire", parameterToString(localVarOptionals.AccessTypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeIsw.IsSet() {
		localVarQueryParams.Add("access_type__isw", parameterToString(localVarOptionals.AccessTypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeN.IsSet() {
		localVarQueryParams.Add("access_type__n", parameterToString(localVarOptionals.AccessTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeNic.IsSet() {
		localVarQueryParams.Add("access_type__nic", parameterToString(localVarOptionals.AccessTypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeNie.IsSet() {
		localVarQueryParams.Add("access_type__nie", parameterToString(localVarOptionals.AccessTypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeNiew.IsSet() {
		localVarQueryParams.Add("access_type__niew", parameterToString(localVarOptionals.AccessTypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeNire.IsSet() {
		localVarQueryParams.Add("access_type__nire", parameterToString(localVarOptionals.AccessTypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeNisw.IsSet() {
		localVarQueryParams.Add("access_type__nisw", parameterToString(localVarOptionals.AccessTypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeNre.IsSet() {
		localVarQueryParams.Add("access_type__nre", parameterToString(localVarOptionals.AccessTypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTypeRe.IsSet() {
		localVarQueryParams.Add("access_type__re", parameterToString(localVarOptionals.AccessTypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Secret.IsSet() {
		localVarQueryParams.Add("secret", parameterToString(localVarOptionals.Secret.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretN.IsSet() {
		localVarQueryParams.Add("secret__n", parameterToString(localVarOptionals.SecretN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretId.IsSet() {
		localVarQueryParams.Add("secret_id", parameterToString(localVarOptionals.SecretId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretIdN.IsSet() {
		localVarQueryParams.Add("secret_id__n", parameterToString(localVarOptionals.SecretIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretType.IsSet() {
		localVarQueryParams.Add("secret_type", parameterToString(localVarOptionals.SecretType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeIc.IsSet() {
		localVarQueryParams.Add("secret_type__ic", parameterToString(localVarOptionals.SecretTypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeIe.IsSet() {
		localVarQueryParams.Add("secret_type__ie", parameterToString(localVarOptionals.SecretTypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeIew.IsSet() {
		localVarQueryParams.Add("secret_type__iew", parameterToString(localVarOptionals.SecretTypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeIre.IsSet() {
		localVarQueryParams.Add("secret_type__ire", parameterToString(localVarOptionals.SecretTypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeIsw.IsSet() {
		localVarQueryParams.Add("secret_type__isw", parameterToString(localVarOptionals.SecretTypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeN.IsSet() {
		localVarQueryParams.Add("secret_type__n", parameterToString(localVarOptionals.SecretTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeNic.IsSet() {
		localVarQueryParams.Add("secret_type__nic", parameterToString(localVarOptionals.SecretTypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeNie.IsSet() {
		localVarQueryParams.Add("secret_type__nie", parameterToString(localVarOptionals.SecretTypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeNiew.IsSet() {
		localVarQueryParams.Add("secret_type__niew", parameterToString(localVarOptionals.SecretTypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeNire.IsSet() {
		localVarQueryParams.Add("secret_type__nire", parameterToString(localVarOptionals.SecretTypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeNisw.IsSet() {
		localVarQueryParams.Add("secret_type__nisw", parameterToString(localVarOptionals.SecretTypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeNre.IsSet() {
		localVarQueryParams.Add("secret_type__nre", parameterToString(localVarOptionals.SecretTypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretTypeRe.IsSet() {
		localVarQueryParams.Add("secret_type__re", parameterToString(localVarOptionals.SecretTypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroup.IsSet() {
		localVarQueryParams.Add("secrets_group", parameterToString(localVarOptionals.SecretsGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupN.IsSet() {
		localVarQueryParams.Add("secrets_group__n", parameterToString(localVarOptionals.SecretsGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedSecretsGroupAssociationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secrets group association.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedSecretsGroupAssociationRequest) - 
     * @param "Format" (optional.String) - 
@return SecretsGroupAssociation
*/

type ExtrasApiExtrasSecretsGroupsAssociationsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsPartialUpdateOpts) (SecretsGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecretsGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SecretsGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secrets group association.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return SecretsGroupAssociation
*/

type ExtrasApiExtrasSecretsGroupsAssociationsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsRetrieveOpts) (SecretsGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecretsGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SecretsGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this secrets group association.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsAssociationsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return SecretsGroupAssociation
*/

type ExtrasApiExtrasSecretsGroupsAssociationsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsAssociationsUpdate(ctx context.Context, body SecretsGroupAssociationRequest, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsAssociationsUpdateOpts) (SecretsGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecretsGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SecretsGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasSecretsGroupsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasSecretsGroupsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []SecretsGroup
*/

type ExtrasApiExtrasSecretsGroupsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableSecretsGroupRequest, localVarOptionals *ExtrasApiExtrasSecretsGroupsBulkPartialUpdateOpts) ([]SecretsGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []SecretsGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SecretsGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []SecretsGroup
*/

type ExtrasApiExtrasSecretsGroupsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsBulkUpdate(ctx context.Context, body []BulkWritableSecretsGroupRequest, localVarOptionals *ExtrasApiExtrasSecretsGroupsBulkUpdateOpts) ([]SecretsGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []SecretsGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SecretsGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return SecretsGroup
*/

type ExtrasApiExtrasSecretsGroupsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsCreate(ctx context.Context, body SecretsGroupRequest, localVarOptionals *ExtrasApiExtrasSecretsGroupsCreateOpts) (SecretsGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecretsGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v SecretsGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secrets group.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasSecretsGroupsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedSecretsGroupList
*/

type ExtrasApiExtrasSecretsGroupsListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsGroupsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasSecretsGroupsListOpts) (PaginatedSecretsGroupList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedSecretsGroupList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedSecretsGroupList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this secrets group.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasSecretsGroupsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secrets group.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasSecretsGroupsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsGroupsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secrets group.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedSecretsGroupRequest) - 
     * @param "Format" (optional.String) - 
@return SecretsGroup
*/

type ExtrasApiExtrasSecretsGroupsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsPartialUpdateOpts) (SecretsGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecretsGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SecretsGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secrets group.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return SecretsGroup
*/

type ExtrasApiExtrasSecretsGroupsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsGroupsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsRetrieveOpts) (SecretsGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecretsGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SecretsGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this secrets group.
 * @param optional nil or *ExtrasApiExtrasSecretsGroupsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return SecretsGroup
*/

type ExtrasApiExtrasSecretsGroupsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsGroupsUpdate(ctx context.Context, body SecretsGroupRequest, id string, localVarOptionals *ExtrasApiExtrasSecretsGroupsUpdateOpts) (SecretsGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecretsGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SecretsGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasSecretsListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Provider" (optional.Interface of []string) - 
     * @param "ProviderIc" (optional.Interface of []string) - 
     * @param "ProviderIe" (optional.Interface of []string) - 
     * @param "ProviderIew" (optional.Interface of []string) - 
     * @param "ProviderIre" (optional.Interface of []string) - 
     * @param "ProviderIsw" (optional.Interface of []string) - 
     * @param "ProviderN" (optional.Interface of []string) - 
     * @param "ProviderNic" (optional.Interface of []string) - 
     * @param "ProviderNie" (optional.Interface of []string) - 
     * @param "ProviderNiew" (optional.Interface of []string) - 
     * @param "ProviderNire" (optional.Interface of []string) - 
     * @param "ProviderNisw" (optional.Interface of []string) - 
     * @param "ProviderNre" (optional.Interface of []string) - 
     * @param "ProviderRe" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedSecretList
*/

type ExtrasApiExtrasSecretsListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Provider optional.Interface
    ProviderIc optional.Interface
    ProviderIe optional.Interface
    ProviderIew optional.Interface
    ProviderIre optional.Interface
    ProviderIsw optional.Interface
    ProviderN optional.Interface
    ProviderNic optional.Interface
    ProviderNie optional.Interface
    ProviderNiew optional.Interface
    ProviderNire optional.Interface
    ProviderNisw optional.Interface
    ProviderNre optional.Interface
    ProviderRe optional.Interface
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasSecretsListOpts) (PaginatedSecretList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedSecretList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Provider.IsSet() {
		localVarQueryParams.Add("provider", parameterToString(localVarOptionals.Provider.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderIc.IsSet() {
		localVarQueryParams.Add("provider__ic", parameterToString(localVarOptionals.ProviderIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderIe.IsSet() {
		localVarQueryParams.Add("provider__ie", parameterToString(localVarOptionals.ProviderIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderIew.IsSet() {
		localVarQueryParams.Add("provider__iew", parameterToString(localVarOptionals.ProviderIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderIre.IsSet() {
		localVarQueryParams.Add("provider__ire", parameterToString(localVarOptionals.ProviderIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderIsw.IsSet() {
		localVarQueryParams.Add("provider__isw", parameterToString(localVarOptionals.ProviderIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderN.IsSet() {
		localVarQueryParams.Add("provider__n", parameterToString(localVarOptionals.ProviderN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNic.IsSet() {
		localVarQueryParams.Add("provider__nic", parameterToString(localVarOptionals.ProviderNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNie.IsSet() {
		localVarQueryParams.Add("provider__nie", parameterToString(localVarOptionals.ProviderNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNiew.IsSet() {
		localVarQueryParams.Add("provider__niew", parameterToString(localVarOptionals.ProviderNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNire.IsSet() {
		localVarQueryParams.Add("provider__nire", parameterToString(localVarOptionals.ProviderNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNisw.IsSet() {
		localVarQueryParams.Add("provider__nisw", parameterToString(localVarOptionals.ProviderNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNre.IsSet() {
		localVarQueryParams.Add("provider__nre", parameterToString(localVarOptionals.ProviderNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderRe.IsSet() {
		localVarQueryParams.Add("provider__re", parameterToString(localVarOptionals.ProviderRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedSecretList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this secret.
 * @param optional nil or *ExtrasApiExtrasSecretsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasSecretsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasSecretsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secret.
 * @param optional nil or *ExtrasApiExtrasSecretsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasSecretsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secret.
 * @param optional nil or *ExtrasApiExtrasSecretsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedSecretRequest) - 
     * @param "Format" (optional.String) - 
@return Secret
*/

type ExtrasApiExtrasSecretsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsPartialUpdateOpts) (Secret, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Secret
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Secret
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this secret.
 * @param optional nil or *ExtrasApiExtrasSecretsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Secret
*/

type ExtrasApiExtrasSecretsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasSecretsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasSecretsRetrieveOpts) (Secret, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Secret
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Secret
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this secret.
 * @param optional nil or *ExtrasApiExtrasSecretsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Secret
*/

type ExtrasApiExtrasSecretsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasSecretsUpdate(ctx context.Context, body SecretRequest, id string, localVarOptionals *ExtrasApiExtrasSecretsUpdateOpts) (Secret, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Secret
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/secrets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Secret
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasStatusesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasStatusesBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasStatusesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasStatusesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasStatusesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Status
*/

type ExtrasApiExtrasStatusesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasStatusesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableStatusRequest, localVarOptionals *ExtrasApiExtrasStatusesBulkPartialUpdateOpts) ([]Status, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Status
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Status
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasStatusesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Status
*/

type ExtrasApiExtrasStatusesBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasStatusesBulkUpdate(ctx context.Context, body []BulkWritableStatusRequest, localVarOptionals *ExtrasApiExtrasStatusesBulkUpdateOpts) ([]Status, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Status
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Status
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasStatusesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Status
*/

type ExtrasApiExtrasStatusesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasStatusesCreate(ctx context.Context, body StatusRequest, localVarOptionals *ExtrasApiExtrasStatusesCreateOpts) (Status, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Status
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this status.
 * @param optional nil or *ExtrasApiExtrasStatusesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasStatusesDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasStatusesDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasStatusesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasStatusesListOpts - Optional Parameters:
     * @param "Color" (optional.Interface of []string) - 
     * @param "ColorIc" (optional.Interface of []string) - 
     * @param "ColorIe" (optional.Interface of []string) - 
     * @param "ColorIew" (optional.Interface of []string) - 
     * @param "ColorIre" (optional.Interface of []string) - 
     * @param "ColorIsw" (optional.Interface of []string) - 
     * @param "ColorN" (optional.Interface of []string) - 
     * @param "ColorNic" (optional.Interface of []string) - 
     * @param "ColorNie" (optional.Interface of []string) - 
     * @param "ColorNiew" (optional.Interface of []string) - 
     * @param "ColorNire" (optional.Interface of []string) - 
     * @param "ColorNisw" (optional.Interface of []string) - 
     * @param "ColorNre" (optional.Interface of []string) - 
     * @param "ColorRe" (optional.Interface of []string) - 
     * @param "ContentTypes" (optional.Interface of []int32) - 
     * @param "ContentTypesIc" (optional.Interface of []int32) - 
     * @param "ContentTypesIe" (optional.Interface of []int32) - 
     * @param "ContentTypesIew" (optional.Interface of []int32) - 
     * @param "ContentTypesIre" (optional.Interface of []int32) - 
     * @param "ContentTypesIsw" (optional.Interface of []int32) - 
     * @param "ContentTypesN" (optional.Interface of []int32) - 
     * @param "ContentTypesNic" (optional.Interface of []int32) - 
     * @param "ContentTypesNie" (optional.Interface of []int32) - 
     * @param "ContentTypesNiew" (optional.Interface of []int32) - 
     * @param "ContentTypesNire" (optional.Interface of []int32) - 
     * @param "ContentTypesNisw" (optional.Interface of []int32) - 
     * @param "ContentTypesNre" (optional.Interface of []int32) - 
     * @param "ContentTypesRe" (optional.Interface of []int32) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedStatusList
*/

type ExtrasApiExtrasStatusesListOpts struct {
    Color optional.Interface
    ColorIc optional.Interface
    ColorIe optional.Interface
    ColorIew optional.Interface
    ColorIre optional.Interface
    ColorIsw optional.Interface
    ColorN optional.Interface
    ColorNic optional.Interface
    ColorNie optional.Interface
    ColorNiew optional.Interface
    ColorNire optional.Interface
    ColorNisw optional.Interface
    ColorNre optional.Interface
    ColorRe optional.Interface
    ContentTypes optional.Interface
    ContentTypesIc optional.Interface
    ContentTypesIe optional.Interface
    ContentTypesIew optional.Interface
    ContentTypesIre optional.Interface
    ContentTypesIsw optional.Interface
    ContentTypesN optional.Interface
    ContentTypesNic optional.Interface
    ContentTypesNie optional.Interface
    ContentTypesNiew optional.Interface
    ContentTypesNire optional.Interface
    ContentTypesNisw optional.Interface
    ContentTypesNre optional.Interface
    ContentTypesRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasStatusesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasStatusesListOpts) (PaginatedStatusList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedStatusList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Color.IsSet() {
		localVarQueryParams.Add("color", parameterToString(localVarOptionals.Color.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIc.IsSet() {
		localVarQueryParams.Add("color__ic", parameterToString(localVarOptionals.ColorIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIe.IsSet() {
		localVarQueryParams.Add("color__ie", parameterToString(localVarOptionals.ColorIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIew.IsSet() {
		localVarQueryParams.Add("color__iew", parameterToString(localVarOptionals.ColorIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIre.IsSet() {
		localVarQueryParams.Add("color__ire", parameterToString(localVarOptionals.ColorIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIsw.IsSet() {
		localVarQueryParams.Add("color__isw", parameterToString(localVarOptionals.ColorIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorN.IsSet() {
		localVarQueryParams.Add("color__n", parameterToString(localVarOptionals.ColorN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNic.IsSet() {
		localVarQueryParams.Add("color__nic", parameterToString(localVarOptionals.ColorNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNie.IsSet() {
		localVarQueryParams.Add("color__nie", parameterToString(localVarOptionals.ColorNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNiew.IsSet() {
		localVarQueryParams.Add("color__niew", parameterToString(localVarOptionals.ColorNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNire.IsSet() {
		localVarQueryParams.Add("color__nire", parameterToString(localVarOptionals.ColorNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNisw.IsSet() {
		localVarQueryParams.Add("color__nisw", parameterToString(localVarOptionals.ColorNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNre.IsSet() {
		localVarQueryParams.Add("color__nre", parameterToString(localVarOptionals.ColorNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorRe.IsSet() {
		localVarQueryParams.Add("color__re", parameterToString(localVarOptionals.ColorRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypes.IsSet() {
		localVarQueryParams.Add("content_types", parameterToString(localVarOptionals.ContentTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIc.IsSet() {
		localVarQueryParams.Add("content_types__ic", parameterToString(localVarOptionals.ContentTypesIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIe.IsSet() {
		localVarQueryParams.Add("content_types__ie", parameterToString(localVarOptionals.ContentTypesIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIew.IsSet() {
		localVarQueryParams.Add("content_types__iew", parameterToString(localVarOptionals.ContentTypesIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIre.IsSet() {
		localVarQueryParams.Add("content_types__ire", parameterToString(localVarOptionals.ContentTypesIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIsw.IsSet() {
		localVarQueryParams.Add("content_types__isw", parameterToString(localVarOptionals.ContentTypesIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesN.IsSet() {
		localVarQueryParams.Add("content_types__n", parameterToString(localVarOptionals.ContentTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNic.IsSet() {
		localVarQueryParams.Add("content_types__nic", parameterToString(localVarOptionals.ContentTypesNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNie.IsSet() {
		localVarQueryParams.Add("content_types__nie", parameterToString(localVarOptionals.ContentTypesNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNiew.IsSet() {
		localVarQueryParams.Add("content_types__niew", parameterToString(localVarOptionals.ContentTypesNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNire.IsSet() {
		localVarQueryParams.Add("content_types__nire", parameterToString(localVarOptionals.ContentTypesNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNisw.IsSet() {
		localVarQueryParams.Add("content_types__nisw", parameterToString(localVarOptionals.ContentTypesNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNre.IsSet() {
		localVarQueryParams.Add("content_types__nre", parameterToString(localVarOptionals.ContentTypesNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesRe.IsSet() {
		localVarQueryParams.Add("content_types__re", parameterToString(localVarOptionals.ContentTypesRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedStatusList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this status.
 * @param optional nil or *ExtrasApiExtrasStatusesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasStatusesNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasStatusesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasStatusesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this status.
 * @param optional nil or *ExtrasApiExtrasStatusesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasStatusesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasStatusesNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasStatusesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this status.
 * @param optional nil or *ExtrasApiExtrasStatusesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedStatusRequest) - 
     * @param "Format" (optional.String) - 
@return Status
*/

type ExtrasApiExtrasStatusesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasStatusesPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasStatusesPartialUpdateOpts) (Status, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Status
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this status.
 * @param optional nil or *ExtrasApiExtrasStatusesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Status
*/

type ExtrasApiExtrasStatusesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasStatusesRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasStatusesRetrieveOpts) (Status, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Status
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
View and manage custom status choices for objects with a &#x60;status&#x60; field.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this status.
 * @param optional nil or *ExtrasApiExtrasStatusesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Status
*/

type ExtrasApiExtrasStatusesUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasStatusesUpdate(ctx context.Context, body StatusRequest, id string, localVarOptionals *ExtrasApiExtrasStatusesUpdateOpts) (Status, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Status
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/statuses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of tag objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasTagsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasTagsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTagsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasTagsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of tag objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasTagsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Tag
*/

type ExtrasApiExtrasTagsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTagsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableTagRequest, localVarOptionals *ExtrasApiExtrasTagsBulkPartialUpdateOpts) ([]Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of tag objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasTagsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Tag
*/

type ExtrasApiExtrasTagsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTagsBulkUpdate(ctx context.Context, body []BulkWritableTagRequest, localVarOptionals *ExtrasApiExtrasTagsBulkUpdateOpts) ([]Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more tag objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasTagsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Tag
*/

type ExtrasApiExtrasTagsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTagsCreate(ctx context.Context, body TagRequest, localVarOptionals *ExtrasApiExtrasTagsCreateOpts) (Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a tag object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tag.
 * @param optional nil or *ExtrasApiExtrasTagsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasTagsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTagsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasTagsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of tag objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasTagsListOpts - Optional Parameters:
     * @param "Color" (optional.Interface of []string) - 
     * @param "ColorIc" (optional.Interface of []string) - 
     * @param "ColorIe" (optional.Interface of []string) - 
     * @param "ColorIew" (optional.Interface of []string) - 
     * @param "ColorIre" (optional.Interface of []string) - 
     * @param "ColorIsw" (optional.Interface of []string) - 
     * @param "ColorN" (optional.Interface of []string) - 
     * @param "ColorNic" (optional.Interface of []string) - 
     * @param "ColorNie" (optional.Interface of []string) - 
     * @param "ColorNiew" (optional.Interface of []string) - 
     * @param "ColorNire" (optional.Interface of []string) - 
     * @param "ColorNisw" (optional.Interface of []string) - 
     * @param "ColorNre" (optional.Interface of []string) - 
     * @param "ColorRe" (optional.Interface of []string) - 
     * @param "ContentTypes" (optional.Interface of []int32) - 
     * @param "ContentTypesIc" (optional.Interface of []int32) - 
     * @param "ContentTypesIe" (optional.Interface of []int32) - 
     * @param "ContentTypesIew" (optional.Interface of []int32) - 
     * @param "ContentTypesIre" (optional.Interface of []int32) - 
     * @param "ContentTypesIsw" (optional.Interface of []int32) - 
     * @param "ContentTypesN" (optional.Interface of []int32) - 
     * @param "ContentTypesNic" (optional.Interface of []int32) - 
     * @param "ContentTypesNie" (optional.Interface of []int32) - 
     * @param "ContentTypesNiew" (optional.Interface of []int32) - 
     * @param "ContentTypesNire" (optional.Interface of []int32) - 
     * @param "ContentTypesNisw" (optional.Interface of []int32) - 
     * @param "ContentTypesNre" (optional.Interface of []int32) - 
     * @param "ContentTypesRe" (optional.Interface of []int32) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedTagList
*/

type ExtrasApiExtrasTagsListOpts struct {
    Color optional.Interface
    ColorIc optional.Interface
    ColorIe optional.Interface
    ColorIew optional.Interface
    ColorIre optional.Interface
    ColorIsw optional.Interface
    ColorN optional.Interface
    ColorNic optional.Interface
    ColorNie optional.Interface
    ColorNiew optional.Interface
    ColorNire optional.Interface
    ColorNisw optional.Interface
    ColorNre optional.Interface
    ColorRe optional.Interface
    ContentTypes optional.Interface
    ContentTypesIc optional.Interface
    ContentTypesIe optional.Interface
    ContentTypesIew optional.Interface
    ContentTypesIre optional.Interface
    ContentTypesIsw optional.Interface
    ContentTypesN optional.Interface
    ContentTypesNic optional.Interface
    ContentTypesNie optional.Interface
    ContentTypesNiew optional.Interface
    ContentTypesNire optional.Interface
    ContentTypesNisw optional.Interface
    ContentTypesNre optional.Interface
    ContentTypesRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasTagsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasTagsListOpts) (PaginatedTagList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedTagList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Color.IsSet() {
		localVarQueryParams.Add("color", parameterToString(localVarOptionals.Color.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIc.IsSet() {
		localVarQueryParams.Add("color__ic", parameterToString(localVarOptionals.ColorIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIe.IsSet() {
		localVarQueryParams.Add("color__ie", parameterToString(localVarOptionals.ColorIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIew.IsSet() {
		localVarQueryParams.Add("color__iew", parameterToString(localVarOptionals.ColorIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIre.IsSet() {
		localVarQueryParams.Add("color__ire", parameterToString(localVarOptionals.ColorIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIsw.IsSet() {
		localVarQueryParams.Add("color__isw", parameterToString(localVarOptionals.ColorIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorN.IsSet() {
		localVarQueryParams.Add("color__n", parameterToString(localVarOptionals.ColorN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNic.IsSet() {
		localVarQueryParams.Add("color__nic", parameterToString(localVarOptionals.ColorNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNie.IsSet() {
		localVarQueryParams.Add("color__nie", parameterToString(localVarOptionals.ColorNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNiew.IsSet() {
		localVarQueryParams.Add("color__niew", parameterToString(localVarOptionals.ColorNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNire.IsSet() {
		localVarQueryParams.Add("color__nire", parameterToString(localVarOptionals.ColorNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNisw.IsSet() {
		localVarQueryParams.Add("color__nisw", parameterToString(localVarOptionals.ColorNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNre.IsSet() {
		localVarQueryParams.Add("color__nre", parameterToString(localVarOptionals.ColorNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorRe.IsSet() {
		localVarQueryParams.Add("color__re", parameterToString(localVarOptionals.ColorRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypes.IsSet() {
		localVarQueryParams.Add("content_types", parameterToString(localVarOptionals.ContentTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIc.IsSet() {
		localVarQueryParams.Add("content_types__ic", parameterToString(localVarOptionals.ContentTypesIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIe.IsSet() {
		localVarQueryParams.Add("content_types__ie", parameterToString(localVarOptionals.ContentTypesIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIew.IsSet() {
		localVarQueryParams.Add("content_types__iew", parameterToString(localVarOptionals.ContentTypesIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIre.IsSet() {
		localVarQueryParams.Add("content_types__ire", parameterToString(localVarOptionals.ContentTypesIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIsw.IsSet() {
		localVarQueryParams.Add("content_types__isw", parameterToString(localVarOptionals.ContentTypesIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesN.IsSet() {
		localVarQueryParams.Add("content_types__n", parameterToString(localVarOptionals.ContentTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNic.IsSet() {
		localVarQueryParams.Add("content_types__nic", parameterToString(localVarOptionals.ContentTypesNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNie.IsSet() {
		localVarQueryParams.Add("content_types__nie", parameterToString(localVarOptionals.ContentTypesNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNiew.IsSet() {
		localVarQueryParams.Add("content_types__niew", parameterToString(localVarOptionals.ContentTypesNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNire.IsSet() {
		localVarQueryParams.Add("content_types__nire", parameterToString(localVarOptionals.ContentTypesNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNisw.IsSet() {
		localVarQueryParams.Add("content_types__nisw", parameterToString(localVarOptionals.ContentTypesNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNre.IsSet() {
		localVarQueryParams.Add("content_types__nre", parameterToString(localVarOptionals.ContentTypesNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesRe.IsSet() {
		localVarQueryParams.Add("content_types__re", parameterToString(localVarOptionals.ContentTypesRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedTagList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this tag.
 * @param optional nil or *ExtrasApiExtrasTagsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasTagsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTagsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasTagsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tag.
 * @param optional nil or *ExtrasApiExtrasTagsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasTagsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasTagsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasTagsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a tag object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tag.
 * @param optional nil or *ExtrasApiExtrasTagsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedTagRequest) - 
     * @param "Format" (optional.String) - 
@return Tag
*/

type ExtrasApiExtrasTagsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTagsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasTagsPartialUpdateOpts) (Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a tag object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tag.
 * @param optional nil or *ExtrasApiExtrasTagsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Tag
*/

type ExtrasApiExtrasTagsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasTagsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasTagsRetrieveOpts) (Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a tag object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this tag.
 * @param optional nil or *ExtrasApiExtrasTagsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Tag
*/

type ExtrasApiExtrasTagsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTagsUpdate(ctx context.Context, body TagRequest, id string, localVarOptionals *ExtrasApiExtrasTagsUpdateOpts) (Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a list of team objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasTeamsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasTeamsBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTeamsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasTeamsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a list of team objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasTeamsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Team
*/

type ExtrasApiExtrasTeamsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTeamsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableTeamRequest, localVarOptionals *ExtrasApiExtrasTeamsBulkPartialUpdateOpts) ([]Team, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Team
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Team
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a list of team objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasTeamsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Team
*/

type ExtrasApiExtrasTeamsBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTeamsBulkUpdate(ctx context.Context, body []BulkWritableTeamRequest, localVarOptionals *ExtrasApiExtrasTeamsBulkUpdateOpts) ([]Team, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Team
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Team
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Create one or more team objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasTeamsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Team
*/

type ExtrasApiExtrasTeamsCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTeamsCreate(ctx context.Context, body TeamRequest, localVarOptionals *ExtrasApiExtrasTeamsCreateOpts) (Team, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Team
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Team
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Destroy a team object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this team.
 * @param optional nil or *ExtrasApiExtrasTeamsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasTeamsDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTeamsDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasTeamsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a list of team objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasTeamsListOpts - Optional Parameters:
     * @param "Address" (optional.Interface of []string) - 
     * @param "AddressIc" (optional.Interface of []string) - 
     * @param "AddressIe" (optional.Interface of []string) - 
     * @param "AddressIew" (optional.Interface of []string) - 
     * @param "AddressIre" (optional.Interface of []string) - 
     * @param "AddressIsw" (optional.Interface of []string) - 
     * @param "AddressN" (optional.Interface of []string) - 
     * @param "AddressNic" (optional.Interface of []string) - 
     * @param "AddressNie" (optional.Interface of []string) - 
     * @param "AddressNiew" (optional.Interface of []string) - 
     * @param "AddressNire" (optional.Interface of []string) - 
     * @param "AddressNisw" (optional.Interface of []string) - 
     * @param "AddressNre" (optional.Interface of []string) - 
     * @param "AddressRe" (optional.Interface of []string) - 
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "Contacts" (optional.Interface of []string) - 
     * @param "ContactsN" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Email" (optional.Interface of []string) - 
     * @param "EmailIc" (optional.Interface of []string) - 
     * @param "EmailIe" (optional.Interface of []string) - 
     * @param "EmailIew" (optional.Interface of []string) - 
     * @param "EmailIre" (optional.Interface of []string) - 
     * @param "EmailIsw" (optional.Interface of []string) - 
     * @param "EmailN" (optional.Interface of []string) - 
     * @param "EmailNic" (optional.Interface of []string) - 
     * @param "EmailNie" (optional.Interface of []string) - 
     * @param "EmailNiew" (optional.Interface of []string) - 
     * @param "EmailNire" (optional.Interface of []string) - 
     * @param "EmailNisw" (optional.Interface of []string) - 
     * @param "EmailNre" (optional.Interface of []string) - 
     * @param "EmailRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Phone" (optional.Interface of []string) - 
     * @param "PhoneIc" (optional.Interface of []string) - 
     * @param "PhoneIe" (optional.Interface of []string) - 
     * @param "PhoneIew" (optional.Interface of []string) - 
     * @param "PhoneIre" (optional.Interface of []string) - 
     * @param "PhoneIsw" (optional.Interface of []string) - 
     * @param "PhoneN" (optional.Interface of []string) - 
     * @param "PhoneNic" (optional.Interface of []string) - 
     * @param "PhoneNie" (optional.Interface of []string) - 
     * @param "PhoneNiew" (optional.Interface of []string) - 
     * @param "PhoneNire" (optional.Interface of []string) - 
     * @param "PhoneNisw" (optional.Interface of []string) - 
     * @param "PhoneNre" (optional.Interface of []string) - 
     * @param "PhoneRe" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "SimilarToLocationData" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedTeamList
*/

type ExtrasApiExtrasTeamsListOpts struct {
    Address optional.Interface
    AddressIc optional.Interface
    AddressIe optional.Interface
    AddressIew optional.Interface
    AddressIre optional.Interface
    AddressIsw optional.Interface
    AddressN optional.Interface
    AddressNic optional.Interface
    AddressNie optional.Interface
    AddressNiew optional.Interface
    AddressNire optional.Interface
    AddressNisw optional.Interface
    AddressNre optional.Interface
    AddressRe optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    Contacts optional.Interface
    ContactsN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Email optional.Interface
    EmailIc optional.Interface
    EmailIe optional.Interface
    EmailIew optional.Interface
    EmailIre optional.Interface
    EmailIsw optional.Interface
    EmailN optional.Interface
    EmailNic optional.Interface
    EmailNie optional.Interface
    EmailNiew optional.Interface
    EmailNire optional.Interface
    EmailNisw optional.Interface
    EmailNre optional.Interface
    EmailRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Phone optional.Interface
    PhoneIc optional.Interface
    PhoneIe optional.Interface
    PhoneIew optional.Interface
    PhoneIre optional.Interface
    PhoneIsw optional.Interface
    PhoneN optional.Interface
    PhoneNic optional.Interface
    PhoneNie optional.Interface
    PhoneNiew optional.Interface
    PhoneNire optional.Interface
    PhoneNisw optional.Interface
    PhoneNre optional.Interface
    PhoneRe optional.Interface
    Q optional.String
    SimilarToLocationData optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasTeamsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasTeamsListOpts) (PaginatedTeamList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedTeamList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Address.IsSet() {
		localVarQueryParams.Add("address", parameterToString(localVarOptionals.Address.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIc.IsSet() {
		localVarQueryParams.Add("address__ic", parameterToString(localVarOptionals.AddressIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIe.IsSet() {
		localVarQueryParams.Add("address__ie", parameterToString(localVarOptionals.AddressIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIew.IsSet() {
		localVarQueryParams.Add("address__iew", parameterToString(localVarOptionals.AddressIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIre.IsSet() {
		localVarQueryParams.Add("address__ire", parameterToString(localVarOptionals.AddressIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressIsw.IsSet() {
		localVarQueryParams.Add("address__isw", parameterToString(localVarOptionals.AddressIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressN.IsSet() {
		localVarQueryParams.Add("address__n", parameterToString(localVarOptionals.AddressN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNic.IsSet() {
		localVarQueryParams.Add("address__nic", parameterToString(localVarOptionals.AddressNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNie.IsSet() {
		localVarQueryParams.Add("address__nie", parameterToString(localVarOptionals.AddressNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNiew.IsSet() {
		localVarQueryParams.Add("address__niew", parameterToString(localVarOptionals.AddressNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNire.IsSet() {
		localVarQueryParams.Add("address__nire", parameterToString(localVarOptionals.AddressNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNisw.IsSet() {
		localVarQueryParams.Add("address__nisw", parameterToString(localVarOptionals.AddressNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressNre.IsSet() {
		localVarQueryParams.Add("address__nre", parameterToString(localVarOptionals.AddressNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AddressRe.IsSet() {
		localVarQueryParams.Add("address__re", parameterToString(localVarOptionals.AddressRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Contacts.IsSet() {
		localVarQueryParams.Add("contacts", parameterToString(localVarOptionals.Contacts.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactsN.IsSet() {
		localVarQueryParams.Add("contacts__n", parameterToString(localVarOptionals.ContactsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarQueryParams.Add("email", parameterToString(localVarOptionals.Email.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIc.IsSet() {
		localVarQueryParams.Add("email__ic", parameterToString(localVarOptionals.EmailIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIe.IsSet() {
		localVarQueryParams.Add("email__ie", parameterToString(localVarOptionals.EmailIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIew.IsSet() {
		localVarQueryParams.Add("email__iew", parameterToString(localVarOptionals.EmailIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIre.IsSet() {
		localVarQueryParams.Add("email__ire", parameterToString(localVarOptionals.EmailIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIsw.IsSet() {
		localVarQueryParams.Add("email__isw", parameterToString(localVarOptionals.EmailIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailN.IsSet() {
		localVarQueryParams.Add("email__n", parameterToString(localVarOptionals.EmailN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNic.IsSet() {
		localVarQueryParams.Add("email__nic", parameterToString(localVarOptionals.EmailNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNie.IsSet() {
		localVarQueryParams.Add("email__nie", parameterToString(localVarOptionals.EmailNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNiew.IsSet() {
		localVarQueryParams.Add("email__niew", parameterToString(localVarOptionals.EmailNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNire.IsSet() {
		localVarQueryParams.Add("email__nire", parameterToString(localVarOptionals.EmailNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNisw.IsSet() {
		localVarQueryParams.Add("email__nisw", parameterToString(localVarOptionals.EmailNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNre.IsSet() {
		localVarQueryParams.Add("email__nre", parameterToString(localVarOptionals.EmailNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailRe.IsSet() {
		localVarQueryParams.Add("email__re", parameterToString(localVarOptionals.EmailRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Phone.IsSet() {
		localVarQueryParams.Add("phone", parameterToString(localVarOptionals.Phone.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIc.IsSet() {
		localVarQueryParams.Add("phone__ic", parameterToString(localVarOptionals.PhoneIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIe.IsSet() {
		localVarQueryParams.Add("phone__ie", parameterToString(localVarOptionals.PhoneIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIew.IsSet() {
		localVarQueryParams.Add("phone__iew", parameterToString(localVarOptionals.PhoneIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIre.IsSet() {
		localVarQueryParams.Add("phone__ire", parameterToString(localVarOptionals.PhoneIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneIsw.IsSet() {
		localVarQueryParams.Add("phone__isw", parameterToString(localVarOptionals.PhoneIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneN.IsSet() {
		localVarQueryParams.Add("phone__n", parameterToString(localVarOptionals.PhoneN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNic.IsSet() {
		localVarQueryParams.Add("phone__nic", parameterToString(localVarOptionals.PhoneNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNie.IsSet() {
		localVarQueryParams.Add("phone__nie", parameterToString(localVarOptionals.PhoneNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNiew.IsSet() {
		localVarQueryParams.Add("phone__niew", parameterToString(localVarOptionals.PhoneNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNire.IsSet() {
		localVarQueryParams.Add("phone__nire", parameterToString(localVarOptionals.PhoneNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNisw.IsSet() {
		localVarQueryParams.Add("phone__nisw", parameterToString(localVarOptionals.PhoneNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNre.IsSet() {
		localVarQueryParams.Add("phone__nre", parameterToString(localVarOptionals.PhoneNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneRe.IsSet() {
		localVarQueryParams.Add("phone__re", parameterToString(localVarOptionals.PhoneRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SimilarToLocationData.IsSet() {
		localVarQueryParams.Add("similar_to_location_data", parameterToString(localVarOptionals.SimilarToLocationData.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedTeamList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this team.
 * @param optional nil or *ExtrasApiExtrasTeamsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasTeamsNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTeamsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasTeamsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this team.
 * @param optional nil or *ExtrasApiExtrasTeamsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasTeamsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasTeamsNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasTeamsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Partial update a team object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this team.
 * @param optional nil or *ExtrasApiExtrasTeamsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedTeamRequest) - 
     * @param "Format" (optional.String) - 
@return Team
*/

type ExtrasApiExtrasTeamsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTeamsPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasTeamsPartialUpdateOpts) (Team, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Team
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Team
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Retrieve a team object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this team.
 * @param optional nil or *ExtrasApiExtrasTeamsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Team
*/

type ExtrasApiExtrasTeamsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasTeamsRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasTeamsRetrieveOpts) (Team, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Team
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Team
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Update a team object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this team.
 * @param optional nil or *ExtrasApiExtrasTeamsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Team
*/

type ExtrasApiExtrasTeamsUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasTeamsUpdate(ctx context.Context, body TeamRequest, id string, localVarOptionals *ExtrasApiExtrasTeamsUpdateOpts) (Team, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Team
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/teams/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Team
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasWebhooksBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasWebhooksBulkDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasWebhooksBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *ExtrasApiExtrasWebhooksBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasWebhooksBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Webhook
*/

type ExtrasApiExtrasWebhooksBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasWebhooksBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableWebhookRequest, localVarOptionals *ExtrasApiExtrasWebhooksBulkPartialUpdateOpts) ([]Webhook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Webhook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Webhook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasWebhooksBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Webhook
*/

type ExtrasApiExtrasWebhooksBulkUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasWebhooksBulkUpdate(ctx context.Context, body []BulkWritableWebhookRequest, localVarOptionals *ExtrasApiExtrasWebhooksBulkUpdateOpts) ([]Webhook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Webhook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Webhook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *ExtrasApiExtrasWebhooksCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Webhook
*/

type ExtrasApiExtrasWebhooksCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasWebhooksCreate(ctx context.Context, body WebhookRequest, localVarOptionals *ExtrasApiExtrasWebhooksCreateOpts) (Webhook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Webhook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Webhook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this webhook.
 * @param optional nil or *ExtrasApiExtrasWebhooksDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type ExtrasApiExtrasWebhooksDestroyOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasWebhooksDestroy(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasWebhooksDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasWebhooksListOpts - Optional Parameters:
     * @param "ContentTypes" (optional.Interface of []int32) - 
     * @param "ContentTypesIc" (optional.Interface of []int32) - 
     * @param "ContentTypesIe" (optional.Interface of []int32) - 
     * @param "ContentTypesIew" (optional.Interface of []int32) - 
     * @param "ContentTypesIre" (optional.Interface of []int32) - 
     * @param "ContentTypesIsw" (optional.Interface of []int32) - 
     * @param "ContentTypesN" (optional.Interface of []int32) - 
     * @param "ContentTypesNic" (optional.Interface of []int32) - 
     * @param "ContentTypesNie" (optional.Interface of []int32) - 
     * @param "ContentTypesNiew" (optional.Interface of []int32) - 
     * @param "ContentTypesNire" (optional.Interface of []int32) - 
     * @param "ContentTypesNisw" (optional.Interface of []int32) - 
     * @param "ContentTypesNre" (optional.Interface of []int32) - 
     * @param "ContentTypesRe" (optional.Interface of []int32) - 
     * @param "Enabled" (optional.Bool) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PayloadUrl" (optional.Interface of []string) - 
     * @param "PayloadUrlIc" (optional.Interface of []string) - 
     * @param "PayloadUrlIe" (optional.Interface of []string) - 
     * @param "PayloadUrlIew" (optional.Interface of []string) - 
     * @param "PayloadUrlIre" (optional.Interface of []string) - 
     * @param "PayloadUrlIsw" (optional.Interface of []string) - 
     * @param "PayloadUrlN" (optional.Interface of []string) - 
     * @param "PayloadUrlNic" (optional.Interface of []string) - 
     * @param "PayloadUrlNie" (optional.Interface of []string) - 
     * @param "PayloadUrlNiew" (optional.Interface of []string) - 
     * @param "PayloadUrlNire" (optional.Interface of []string) - 
     * @param "PayloadUrlNisw" (optional.Interface of []string) - 
     * @param "PayloadUrlNre" (optional.Interface of []string) - 
     * @param "PayloadUrlRe" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "TypeCreate" (optional.Bool) - 
     * @param "TypeDelete" (optional.Bool) - 
     * @param "TypeUpdate" (optional.Bool) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedWebhookList
*/

type ExtrasApiExtrasWebhooksListOpts struct {
    ContentTypes optional.Interface
    ContentTypesIc optional.Interface
    ContentTypesIe optional.Interface
    ContentTypesIew optional.Interface
    ContentTypesIre optional.Interface
    ContentTypesIsw optional.Interface
    ContentTypesN optional.Interface
    ContentTypesNic optional.Interface
    ContentTypesNie optional.Interface
    ContentTypesNiew optional.Interface
    ContentTypesNire optional.Interface
    ContentTypesNisw optional.Interface
    ContentTypesNre optional.Interface
    ContentTypesRe optional.Interface
    Enabled optional.Bool
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    PayloadUrl optional.Interface
    PayloadUrlIc optional.Interface
    PayloadUrlIe optional.Interface
    PayloadUrlIew optional.Interface
    PayloadUrlIre optional.Interface
    PayloadUrlIsw optional.Interface
    PayloadUrlN optional.Interface
    PayloadUrlNic optional.Interface
    PayloadUrlNie optional.Interface
    PayloadUrlNiew optional.Interface
    PayloadUrlNire optional.Interface
    PayloadUrlNisw optional.Interface
    PayloadUrlNre optional.Interface
    PayloadUrlRe optional.Interface
    Q optional.String
    Sort optional.String
    TypeCreate optional.Bool
    TypeDelete optional.Bool
    TypeUpdate optional.Bool
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasWebhooksList(ctx context.Context, localVarOptionals *ExtrasApiExtrasWebhooksListOpts) (PaginatedWebhookList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedWebhookList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentTypes.IsSet() {
		localVarQueryParams.Add("content_types", parameterToString(localVarOptionals.ContentTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIc.IsSet() {
		localVarQueryParams.Add("content_types__ic", parameterToString(localVarOptionals.ContentTypesIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIe.IsSet() {
		localVarQueryParams.Add("content_types__ie", parameterToString(localVarOptionals.ContentTypesIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIew.IsSet() {
		localVarQueryParams.Add("content_types__iew", parameterToString(localVarOptionals.ContentTypesIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIre.IsSet() {
		localVarQueryParams.Add("content_types__ire", parameterToString(localVarOptionals.ContentTypesIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIsw.IsSet() {
		localVarQueryParams.Add("content_types__isw", parameterToString(localVarOptionals.ContentTypesIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesN.IsSet() {
		localVarQueryParams.Add("content_types__n", parameterToString(localVarOptionals.ContentTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNic.IsSet() {
		localVarQueryParams.Add("content_types__nic", parameterToString(localVarOptionals.ContentTypesNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNie.IsSet() {
		localVarQueryParams.Add("content_types__nie", parameterToString(localVarOptionals.ContentTypesNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNiew.IsSet() {
		localVarQueryParams.Add("content_types__niew", parameterToString(localVarOptionals.ContentTypesNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNire.IsSet() {
		localVarQueryParams.Add("content_types__nire", parameterToString(localVarOptionals.ContentTypesNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNisw.IsSet() {
		localVarQueryParams.Add("content_types__nisw", parameterToString(localVarOptionals.ContentTypesNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNre.IsSet() {
		localVarQueryParams.Add("content_types__nre", parameterToString(localVarOptionals.ContentTypesNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesRe.IsSet() {
		localVarQueryParams.Add("content_types__re", parameterToString(localVarOptionals.ContentTypesRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrl.IsSet() {
		localVarQueryParams.Add("payload_url", parameterToString(localVarOptionals.PayloadUrl.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlIc.IsSet() {
		localVarQueryParams.Add("payload_url__ic", parameterToString(localVarOptionals.PayloadUrlIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlIe.IsSet() {
		localVarQueryParams.Add("payload_url__ie", parameterToString(localVarOptionals.PayloadUrlIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlIew.IsSet() {
		localVarQueryParams.Add("payload_url__iew", parameterToString(localVarOptionals.PayloadUrlIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlIre.IsSet() {
		localVarQueryParams.Add("payload_url__ire", parameterToString(localVarOptionals.PayloadUrlIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlIsw.IsSet() {
		localVarQueryParams.Add("payload_url__isw", parameterToString(localVarOptionals.PayloadUrlIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlN.IsSet() {
		localVarQueryParams.Add("payload_url__n", parameterToString(localVarOptionals.PayloadUrlN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlNic.IsSet() {
		localVarQueryParams.Add("payload_url__nic", parameterToString(localVarOptionals.PayloadUrlNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlNie.IsSet() {
		localVarQueryParams.Add("payload_url__nie", parameterToString(localVarOptionals.PayloadUrlNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlNiew.IsSet() {
		localVarQueryParams.Add("payload_url__niew", parameterToString(localVarOptionals.PayloadUrlNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlNire.IsSet() {
		localVarQueryParams.Add("payload_url__nire", parameterToString(localVarOptionals.PayloadUrlNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlNisw.IsSet() {
		localVarQueryParams.Add("payload_url__nisw", parameterToString(localVarOptionals.PayloadUrlNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlNre.IsSet() {
		localVarQueryParams.Add("payload_url__nre", parameterToString(localVarOptionals.PayloadUrlNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PayloadUrlRe.IsSet() {
		localVarQueryParams.Add("payload_url__re", parameterToString(localVarOptionals.PayloadUrlRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TypeCreate.IsSet() {
		localVarQueryParams.Add("type_create", parameterToString(localVarOptionals.TypeCreate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TypeDelete.IsSet() {
		localVarQueryParams.Add("type_delete", parameterToString(localVarOptionals.TypeDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TypeUpdate.IsSet() {
		localVarQueryParams.Add("type_update", parameterToString(localVarOptionals.TypeUpdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedWebhookList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this webhook.
 * @param optional nil or *ExtrasApiExtrasWebhooksNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type ExtrasApiExtrasWebhooksNotesCreateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasWebhooksNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *ExtrasApiExtrasWebhooksNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this webhook.
 * @param optional nil or *ExtrasApiExtrasWebhooksNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type ExtrasApiExtrasWebhooksNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasWebhooksNotesList(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasWebhooksNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this webhook.
 * @param optional nil or *ExtrasApiExtrasWebhooksPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWebhookRequest) - 
     * @param "Format" (optional.String) - 
@return Webhook
*/

type ExtrasApiExtrasWebhooksPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *ExtrasApiService) ExtrasWebhooksPartialUpdate(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasWebhooksPartialUpdateOpts) (Webhook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Webhook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Webhook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this webhook.
 * @param optional nil or *ExtrasApiExtrasWebhooksRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Webhook
*/

type ExtrasApiExtrasWebhooksRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *ExtrasApiService) ExtrasWebhooksRetrieve(ctx context.Context, id string, localVarOptionals *ExtrasApiExtrasWebhooksRetrieveOpts) (Webhook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Webhook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Webhook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExtrasApiService
Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this webhook.
 * @param optional nil or *ExtrasApiExtrasWebhooksUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Webhook
*/

type ExtrasApiExtrasWebhooksUpdateOpts struct {
    Format optional.String
}

func (a *ExtrasApiService) ExtrasWebhooksUpdate(ctx context.Context, body WebhookRequest, id string, localVarOptionals *ExtrasApiExtrasWebhooksUpdateOpts) (Webhook, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Webhook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/webhooks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Webhook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
