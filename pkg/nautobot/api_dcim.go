/*
API Documentation

Source of truth and network automation platform

API version: 2.2.5 (2.2)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package nautobot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DcimAPIService DcimAPI service
type DcimAPIService service

type ApiDcimCablesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimCablesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimCablesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimCablesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimCablesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimCablesBulkDestroyExecute(r)
}

/*
DcimCablesBulkDestroy Method for DcimCablesBulkDestroy

Destroy a list of cable objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimCablesBulkDestroy(ctx context.Context) ApiDcimCablesBulkDestroyRequest {
	return ApiDcimCablesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimCablesBulkDestroyExecute(r ApiDcimCablesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimCablesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableCableRequest *[]PatchedBulkWritableCableRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimCablesBulkPartialUpdateRequest) PatchedBulkWritableCableRequest(patchedBulkWritableCableRequest []PatchedBulkWritableCableRequest) ApiDcimCablesBulkPartialUpdateRequest {
	r.patchedBulkWritableCableRequest = &patchedBulkWritableCableRequest
	return r
}

func (r ApiDcimCablesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimCablesBulkPartialUpdateRequest) Execute() ([]Cable, *http.Response, error) {
	return r.ApiService.DcimCablesBulkPartialUpdateExecute(r)
}

/*
DcimCablesBulkPartialUpdate Method for DcimCablesBulkPartialUpdate

Partial update a list of cable objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimCablesBulkPartialUpdate(ctx context.Context) ApiDcimCablesBulkPartialUpdateRequest {
	return ApiDcimCablesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Cable
func (a *DcimAPIService) DcimCablesBulkPartialUpdateExecute(r ApiDcimCablesBulkPartialUpdateRequest) ([]Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableCableRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableCableRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableCableRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableCableRequest *[]BulkWritableCableRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimCablesBulkUpdateRequest) BulkWritableCableRequest(bulkWritableCableRequest []BulkWritableCableRequest) ApiDcimCablesBulkUpdateRequest {
	r.bulkWritableCableRequest = &bulkWritableCableRequest
	return r
}

func (r ApiDcimCablesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimCablesBulkUpdateRequest) Execute() ([]Cable, *http.Response, error) {
	return r.ApiService.DcimCablesBulkUpdateExecute(r)
}

/*
DcimCablesBulkUpdate Method for DcimCablesBulkUpdate

Update a list of cable objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimCablesBulkUpdate(ctx context.Context) ApiDcimCablesBulkUpdateRequest {
	return ApiDcimCablesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Cable
func (a *DcimAPIService) DcimCablesBulkUpdateExecute(r ApiDcimCablesBulkUpdateRequest) ([]Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableCableRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableCableRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableCableRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableCableRequest *WritableCableRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimCablesCreateRequest) WritableCableRequest(writableCableRequest WritableCableRequest) ApiDcimCablesCreateRequest {
	r.writableCableRequest = &writableCableRequest
	return r
}

func (r ApiDcimCablesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimCablesCreateRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesCreateExecute(r)
}

/*
DcimCablesCreate Method for DcimCablesCreate

Create one or more cable objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesCreateRequest
*/
func (a *DcimAPIService) DcimCablesCreate(ctx context.Context) ApiDcimCablesCreateRequest {
	return ApiDcimCablesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimAPIService) DcimCablesCreateExecute(r ApiDcimCablesCreateRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableCableRequest == nil {
		return localVarReturnValue, nil, reportError("writableCableRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableCableRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimCablesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimCablesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimCablesDestroyExecute(r)
}

/*
DcimCablesDestroy Method for DcimCablesDestroy

Destroy a cable object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this cable.
 @return ApiDcimCablesDestroyRequest
*/
func (a *DcimAPIService) DcimCablesDestroy(ctx context.Context, id string) ApiDcimCablesDestroyRequest {
	return ApiDcimCablesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimCablesDestroyExecute(r ApiDcimCablesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimCablesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	color *[]string
	colorIc *[]string
	colorIe *[]string
	colorIew *[]string
	colorIre *[]string
	colorIsw *[]string
	colorN *[]string
	colorNic *[]string
	colorNie *[]string
	colorNiew *[]string
	colorNire *[]string
	colorNisw *[]string
	colorNre *[]string
	colorRe *[]string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	device *[]string
	deviceId *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	length *[]int32
	lengthGt *[]int32
	lengthGte *[]int32
	lengthIsnull *bool
	lengthLt *[]int32
	lengthLte *[]int32
	lengthN *[]int32
	lengthUnit *[]string
	lengthUnitIc *[]string
	lengthUnitIe *[]string
	lengthUnitIew *[]string
	lengthUnitIre *[]string
	lengthUnitIsw *[]string
	lengthUnitN *[]string
	lengthUnitNic *[]string
	lengthUnitNie *[]string
	lengthUnitNiew *[]string
	lengthUnitNire *[]string
	lengthUnitNisw *[]string
	lengthUnitNre *[]string
	lengthUnitRe *[]string
	limit *int32
	location *[]string
	locationId *[]string
	offset *int32
	q *string
	rack *[]string
	rackId *[]string
	sort *string
	status *[]string
	statusN *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	tenant *[]string
	tenantId *[]string
	terminationAId *[]string
	terminationAIdIc *[]string
	terminationAIdIe *[]string
	terminationAIdIew *[]string
	terminationAIdIre *[]string
	terminationAIdIsw *[]string
	terminationAIdN *[]string
	terminationAIdNic *[]string
	terminationAIdNie *[]string
	terminationAIdNiew *[]string
	terminationAIdNire *[]string
	terminationAIdNisw *[]string
	terminationAIdNre *[]string
	terminationAIdRe *[]string
	terminationAType *[]int32
	terminationATypeN *[]int32
	terminationBId *[]string
	terminationBIdIc *[]string
	terminationBIdIe *[]string
	terminationBIdIew *[]string
	terminationBIdIre *[]string
	terminationBIdIsw *[]string
	terminationBIdN *[]string
	terminationBIdNic *[]string
	terminationBIdNie *[]string
	terminationBIdNiew *[]string
	terminationBIdNire *[]string
	terminationBIdNisw *[]string
	terminationBIdNre *[]string
	terminationBIdRe *[]string
	terminationBType *[]int32
	terminationBTypeN *[]int32
	terminationType *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

func (r ApiDcimCablesListRequest) Color(color []string) ApiDcimCablesListRequest {
	r.color = &color
	return r
}

func (r ApiDcimCablesListRequest) ColorIc(colorIc []string) ApiDcimCablesListRequest {
	r.colorIc = &colorIc
	return r
}

func (r ApiDcimCablesListRequest) ColorIe(colorIe []string) ApiDcimCablesListRequest {
	r.colorIe = &colorIe
	return r
}

func (r ApiDcimCablesListRequest) ColorIew(colorIew []string) ApiDcimCablesListRequest {
	r.colorIew = &colorIew
	return r
}

func (r ApiDcimCablesListRequest) ColorIre(colorIre []string) ApiDcimCablesListRequest {
	r.colorIre = &colorIre
	return r
}

func (r ApiDcimCablesListRequest) ColorIsw(colorIsw []string) ApiDcimCablesListRequest {
	r.colorIsw = &colorIsw
	return r
}

func (r ApiDcimCablesListRequest) ColorN(colorN []string) ApiDcimCablesListRequest {
	r.colorN = &colorN
	return r
}

func (r ApiDcimCablesListRequest) ColorNic(colorNic []string) ApiDcimCablesListRequest {
	r.colorNic = &colorNic
	return r
}

func (r ApiDcimCablesListRequest) ColorNie(colorNie []string) ApiDcimCablesListRequest {
	r.colorNie = &colorNie
	return r
}

func (r ApiDcimCablesListRequest) ColorNiew(colorNiew []string) ApiDcimCablesListRequest {
	r.colorNiew = &colorNiew
	return r
}

func (r ApiDcimCablesListRequest) ColorNire(colorNire []string) ApiDcimCablesListRequest {
	r.colorNire = &colorNire
	return r
}

func (r ApiDcimCablesListRequest) ColorNisw(colorNisw []string) ApiDcimCablesListRequest {
	r.colorNisw = &colorNisw
	return r
}

func (r ApiDcimCablesListRequest) ColorNre(colorNre []string) ApiDcimCablesListRequest {
	r.colorNre = &colorNre
	return r
}

func (r ApiDcimCablesListRequest) ColorRe(colorRe []string) ApiDcimCablesListRequest {
	r.colorRe = &colorRe
	return r
}

func (r ApiDcimCablesListRequest) Created(created []time.Time) ApiDcimCablesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimCablesListRequest) CreatedGt(createdGt []time.Time) ApiDcimCablesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimCablesListRequest) CreatedGte(createdGte []time.Time) ApiDcimCablesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimCablesListRequest) CreatedIsnull(createdIsnull bool) ApiDcimCablesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimCablesListRequest) CreatedLt(createdLt []time.Time) ApiDcimCablesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimCablesListRequest) CreatedLte(createdLte []time.Time) ApiDcimCablesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimCablesListRequest) CreatedN(createdN []time.Time) ApiDcimCablesListRequest {
	r.createdN = &createdN
	return r
}

// Device (name)
func (r ApiDcimCablesListRequest) Device(device []string) ApiDcimCablesListRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiDcimCablesListRequest) DeviceId(deviceId []string) ApiDcimCablesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimCablesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimCablesListRequest) Id(id []string) ApiDcimCablesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimCablesListRequest) IdIc(idIc []string) ApiDcimCablesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimCablesListRequest) IdIe(idIe []string) ApiDcimCablesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimCablesListRequest) IdIew(idIew []string) ApiDcimCablesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimCablesListRequest) IdIre(idIre []string) ApiDcimCablesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimCablesListRequest) IdIsw(idIsw []string) ApiDcimCablesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimCablesListRequest) IdN(idN []string) ApiDcimCablesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimCablesListRequest) IdNic(idNic []string) ApiDcimCablesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimCablesListRequest) IdNie(idNie []string) ApiDcimCablesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimCablesListRequest) IdNiew(idNiew []string) ApiDcimCablesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimCablesListRequest) IdNire(idNire []string) ApiDcimCablesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimCablesListRequest) IdNisw(idNisw []string) ApiDcimCablesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimCablesListRequest) IdNre(idNre []string) ApiDcimCablesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimCablesListRequest) IdRe(idRe []string) ApiDcimCablesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimCablesListRequest) Label(label []string) ApiDcimCablesListRequest {
	r.label = &label
	return r
}

func (r ApiDcimCablesListRequest) LabelIc(labelIc []string) ApiDcimCablesListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimCablesListRequest) LabelIe(labelIe []string) ApiDcimCablesListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimCablesListRequest) LabelIew(labelIew []string) ApiDcimCablesListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimCablesListRequest) LabelIre(labelIre []string) ApiDcimCablesListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimCablesListRequest) LabelIsw(labelIsw []string) ApiDcimCablesListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimCablesListRequest) LabelN(labelN []string) ApiDcimCablesListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimCablesListRequest) LabelNic(labelNic []string) ApiDcimCablesListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimCablesListRequest) LabelNie(labelNie []string) ApiDcimCablesListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimCablesListRequest) LabelNiew(labelNiew []string) ApiDcimCablesListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimCablesListRequest) LabelNire(labelNire []string) ApiDcimCablesListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimCablesListRequest) LabelNisw(labelNisw []string) ApiDcimCablesListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimCablesListRequest) LabelNre(labelNre []string) ApiDcimCablesListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimCablesListRequest) LabelRe(labelRe []string) ApiDcimCablesListRequest {
	r.labelRe = &labelRe
	return r
}

func (r ApiDcimCablesListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimCablesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimCablesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimCablesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimCablesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimCablesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimCablesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimCablesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimCablesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimCablesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimCablesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimCablesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimCablesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimCablesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

func (r ApiDcimCablesListRequest) Length(length []int32) ApiDcimCablesListRequest {
	r.length = &length
	return r
}

func (r ApiDcimCablesListRequest) LengthGt(lengthGt []int32) ApiDcimCablesListRequest {
	r.lengthGt = &lengthGt
	return r
}

func (r ApiDcimCablesListRequest) LengthGte(lengthGte []int32) ApiDcimCablesListRequest {
	r.lengthGte = &lengthGte
	return r
}

func (r ApiDcimCablesListRequest) LengthIsnull(lengthIsnull bool) ApiDcimCablesListRequest {
	r.lengthIsnull = &lengthIsnull
	return r
}

func (r ApiDcimCablesListRequest) LengthLt(lengthLt []int32) ApiDcimCablesListRequest {
	r.lengthLt = &lengthLt
	return r
}

func (r ApiDcimCablesListRequest) LengthLte(lengthLte []int32) ApiDcimCablesListRequest {
	r.lengthLte = &lengthLte
	return r
}

func (r ApiDcimCablesListRequest) LengthN(lengthN []int32) ApiDcimCablesListRequest {
	r.lengthN = &lengthN
	return r
}

func (r ApiDcimCablesListRequest) LengthUnit(lengthUnit []string) ApiDcimCablesListRequest {
	r.lengthUnit = &lengthUnit
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitIc(lengthUnitIc []string) ApiDcimCablesListRequest {
	r.lengthUnitIc = &lengthUnitIc
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitIe(lengthUnitIe []string) ApiDcimCablesListRequest {
	r.lengthUnitIe = &lengthUnitIe
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitIew(lengthUnitIew []string) ApiDcimCablesListRequest {
	r.lengthUnitIew = &lengthUnitIew
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitIre(lengthUnitIre []string) ApiDcimCablesListRequest {
	r.lengthUnitIre = &lengthUnitIre
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitIsw(lengthUnitIsw []string) ApiDcimCablesListRequest {
	r.lengthUnitIsw = &lengthUnitIsw
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitN(lengthUnitN []string) ApiDcimCablesListRequest {
	r.lengthUnitN = &lengthUnitN
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitNic(lengthUnitNic []string) ApiDcimCablesListRequest {
	r.lengthUnitNic = &lengthUnitNic
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitNie(lengthUnitNie []string) ApiDcimCablesListRequest {
	r.lengthUnitNie = &lengthUnitNie
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitNiew(lengthUnitNiew []string) ApiDcimCablesListRequest {
	r.lengthUnitNiew = &lengthUnitNiew
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitNire(lengthUnitNire []string) ApiDcimCablesListRequest {
	r.lengthUnitNire = &lengthUnitNire
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitNisw(lengthUnitNisw []string) ApiDcimCablesListRequest {
	r.lengthUnitNisw = &lengthUnitNisw
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitNre(lengthUnitNre []string) ApiDcimCablesListRequest {
	r.lengthUnitNre = &lengthUnitNre
	return r
}

func (r ApiDcimCablesListRequest) LengthUnitRe(lengthUnitRe []string) ApiDcimCablesListRequest {
	r.lengthUnitRe = &lengthUnitRe
	return r
}

// Number of results to return per page.
func (r ApiDcimCablesListRequest) Limit(limit int32) ApiDcimCablesListRequest {
	r.limit = &limit
	return r
}

// Location (name)
func (r ApiDcimCablesListRequest) Location(location []string) ApiDcimCablesListRequest {
	r.location = &location
	return r
}

// Location (ID)
func (r ApiDcimCablesListRequest) LocationId(locationId []string) ApiDcimCablesListRequest {
	r.locationId = &locationId
	return r
}

// The initial index from which to return the results.
func (r ApiDcimCablesListRequest) Offset(offset int32) ApiDcimCablesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimCablesListRequest) Q(q string) ApiDcimCablesListRequest {
	r.q = &q
	return r
}

// Rack (name)
func (r ApiDcimCablesListRequest) Rack(rack []string) ApiDcimCablesListRequest {
	r.rack = &rack
	return r
}

// Rack (ID)
func (r ApiDcimCablesListRequest) RackId(rackId []string) ApiDcimCablesListRequest {
	r.rackId = &rackId
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimCablesListRequest) Sort(sort string) ApiDcimCablesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimCablesListRequest) Status(status []string) ApiDcimCablesListRequest {
	r.status = &status
	return r
}

func (r ApiDcimCablesListRequest) StatusN(statusN []string) ApiDcimCablesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimCablesListRequest) Tags(tags []string) ApiDcimCablesListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimCablesListRequest) TagsIsnull(tagsIsnull bool) ApiDcimCablesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimCablesListRequest) TagsN(tagsN []string) ApiDcimCablesListRequest {
	r.tagsN = &tagsN
	return r
}

// Tenant (name)
func (r ApiDcimCablesListRequest) Tenant(tenant []string) ApiDcimCablesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (ID)
func (r ApiDcimCablesListRequest) TenantId(tenantId []string) ApiDcimCablesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimCablesListRequest) TerminationAId(terminationAId []string) ApiDcimCablesListRequest {
	r.terminationAId = &terminationAId
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdIc(terminationAIdIc []string) ApiDcimCablesListRequest {
	r.terminationAIdIc = &terminationAIdIc
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdIe(terminationAIdIe []string) ApiDcimCablesListRequest {
	r.terminationAIdIe = &terminationAIdIe
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdIew(terminationAIdIew []string) ApiDcimCablesListRequest {
	r.terminationAIdIew = &terminationAIdIew
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdIre(terminationAIdIre []string) ApiDcimCablesListRequest {
	r.terminationAIdIre = &terminationAIdIre
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdIsw(terminationAIdIsw []string) ApiDcimCablesListRequest {
	r.terminationAIdIsw = &terminationAIdIsw
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdN(terminationAIdN []string) ApiDcimCablesListRequest {
	r.terminationAIdN = &terminationAIdN
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdNic(terminationAIdNic []string) ApiDcimCablesListRequest {
	r.terminationAIdNic = &terminationAIdNic
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdNie(terminationAIdNie []string) ApiDcimCablesListRequest {
	r.terminationAIdNie = &terminationAIdNie
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdNiew(terminationAIdNiew []string) ApiDcimCablesListRequest {
	r.terminationAIdNiew = &terminationAIdNiew
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdNire(terminationAIdNire []string) ApiDcimCablesListRequest {
	r.terminationAIdNire = &terminationAIdNire
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdNisw(terminationAIdNisw []string) ApiDcimCablesListRequest {
	r.terminationAIdNisw = &terminationAIdNisw
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdNre(terminationAIdNre []string) ApiDcimCablesListRequest {
	r.terminationAIdNre = &terminationAIdNre
	return r
}

func (r ApiDcimCablesListRequest) TerminationAIdRe(terminationAIdRe []string) ApiDcimCablesListRequest {
	r.terminationAIdRe = &terminationAIdRe
	return r
}

func (r ApiDcimCablesListRequest) TerminationAType(terminationAType []int32) ApiDcimCablesListRequest {
	r.terminationAType = &terminationAType
	return r
}

func (r ApiDcimCablesListRequest) TerminationATypeN(terminationATypeN []int32) ApiDcimCablesListRequest {
	r.terminationATypeN = &terminationATypeN
	return r
}

func (r ApiDcimCablesListRequest) TerminationBId(terminationBId []string) ApiDcimCablesListRequest {
	r.terminationBId = &terminationBId
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdIc(terminationBIdIc []string) ApiDcimCablesListRequest {
	r.terminationBIdIc = &terminationBIdIc
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdIe(terminationBIdIe []string) ApiDcimCablesListRequest {
	r.terminationBIdIe = &terminationBIdIe
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdIew(terminationBIdIew []string) ApiDcimCablesListRequest {
	r.terminationBIdIew = &terminationBIdIew
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdIre(terminationBIdIre []string) ApiDcimCablesListRequest {
	r.terminationBIdIre = &terminationBIdIre
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdIsw(terminationBIdIsw []string) ApiDcimCablesListRequest {
	r.terminationBIdIsw = &terminationBIdIsw
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdN(terminationBIdN []string) ApiDcimCablesListRequest {
	r.terminationBIdN = &terminationBIdN
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdNic(terminationBIdNic []string) ApiDcimCablesListRequest {
	r.terminationBIdNic = &terminationBIdNic
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdNie(terminationBIdNie []string) ApiDcimCablesListRequest {
	r.terminationBIdNie = &terminationBIdNie
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdNiew(terminationBIdNiew []string) ApiDcimCablesListRequest {
	r.terminationBIdNiew = &terminationBIdNiew
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdNire(terminationBIdNire []string) ApiDcimCablesListRequest {
	r.terminationBIdNire = &terminationBIdNire
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdNisw(terminationBIdNisw []string) ApiDcimCablesListRequest {
	r.terminationBIdNisw = &terminationBIdNisw
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdNre(terminationBIdNre []string) ApiDcimCablesListRequest {
	r.terminationBIdNre = &terminationBIdNre
	return r
}

func (r ApiDcimCablesListRequest) TerminationBIdRe(terminationBIdRe []string) ApiDcimCablesListRequest {
	r.terminationBIdRe = &terminationBIdRe
	return r
}

func (r ApiDcimCablesListRequest) TerminationBType(terminationBType []int32) ApiDcimCablesListRequest {
	r.terminationBType = &terminationBType
	return r
}

func (r ApiDcimCablesListRequest) TerminationBTypeN(terminationBTypeN []int32) ApiDcimCablesListRequest {
	r.terminationBTypeN = &terminationBTypeN
	return r
}

func (r ApiDcimCablesListRequest) TerminationType(terminationType []string) ApiDcimCablesListRequest {
	r.terminationType = &terminationType
	return r
}

func (r ApiDcimCablesListRequest) Type_(type_ []string) ApiDcimCablesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimCablesListRequest) TypeIc(typeIc []string) ApiDcimCablesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimCablesListRequest) TypeIe(typeIe []string) ApiDcimCablesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimCablesListRequest) TypeIew(typeIew []string) ApiDcimCablesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimCablesListRequest) TypeIre(typeIre []string) ApiDcimCablesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimCablesListRequest) TypeIsw(typeIsw []string) ApiDcimCablesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimCablesListRequest) TypeN(typeN []string) ApiDcimCablesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimCablesListRequest) TypeNic(typeNic []string) ApiDcimCablesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimCablesListRequest) TypeNie(typeNie []string) ApiDcimCablesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimCablesListRequest) TypeNiew(typeNiew []string) ApiDcimCablesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimCablesListRequest) TypeNire(typeNire []string) ApiDcimCablesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimCablesListRequest) TypeNisw(typeNisw []string) ApiDcimCablesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimCablesListRequest) TypeNre(typeNre []string) ApiDcimCablesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimCablesListRequest) TypeRe(typeRe []string) ApiDcimCablesListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimCablesListRequest) Depth(depth int32) ApiDcimCablesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimCablesListRequest) Execute() (*PaginatedCableList, *http.Response, error) {
	return r.ApiService.DcimCablesListExecute(r)
}

/*
DcimCablesList Method for DcimCablesList

Retrieve a list of cable objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimCablesListRequest
*/
func (a *DcimAPIService) DcimCablesList(ctx context.Context) ApiDcimCablesListRequest {
	return ApiDcimCablesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedCableList
func (a *DcimAPIService) DcimCablesListExecute(r ApiDcimCablesListRequest) (*PaginatedCableList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedCableList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.color != nil {
		t := *r.color
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color", t, "multi")
		}
	}
	if r.colorIc != nil {
		t := *r.colorIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__ic", t, "multi")
		}
	}
	if r.colorIe != nil {
		t := *r.colorIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__ie", t, "multi")
		}
	}
	if r.colorIew != nil {
		t := *r.colorIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__iew", t, "multi")
		}
	}
	if r.colorIre != nil {
		t := *r.colorIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__ire", t, "multi")
		}
	}
	if r.colorIsw != nil {
		t := *r.colorIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__isw", t, "multi")
		}
	}
	if r.colorN != nil {
		t := *r.colorN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__n", t, "multi")
		}
	}
	if r.colorNic != nil {
		t := *r.colorNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__nic", t, "multi")
		}
	}
	if r.colorNie != nil {
		t := *r.colorNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__nie", t, "multi")
		}
	}
	if r.colorNiew != nil {
		t := *r.colorNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__niew", t, "multi")
		}
	}
	if r.colorNire != nil {
		t := *r.colorNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__nire", t, "multi")
		}
	}
	if r.colorNisw != nil {
		t := *r.colorNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__nisw", t, "multi")
		}
	}
	if r.colorNre != nil {
		t := *r.colorNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__nre", t, "multi")
		}
	}
	if r.colorRe != nil {
		t := *r.colorRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "color__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "color__re", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.length != nil {
		t := *r.length
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length", t, "multi")
		}
	}
	if r.lengthGt != nil {
		t := *r.lengthGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length__gt", t, "multi")
		}
	}
	if r.lengthGte != nil {
		t := *r.lengthGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length__gte", t, "multi")
		}
	}
	if r.lengthIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "length__isnull", r.lengthIsnull, "")
	}
	if r.lengthLt != nil {
		t := *r.lengthLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length__lt", t, "multi")
		}
	}
	if r.lengthLte != nil {
		t := *r.lengthLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length__lte", t, "multi")
		}
	}
	if r.lengthN != nil {
		t := *r.lengthN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length__n", t, "multi")
		}
	}
	if r.lengthUnit != nil {
		t := *r.lengthUnit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit", t, "multi")
		}
	}
	if r.lengthUnitIc != nil {
		t := *r.lengthUnitIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__ic", t, "multi")
		}
	}
	if r.lengthUnitIe != nil {
		t := *r.lengthUnitIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__ie", t, "multi")
		}
	}
	if r.lengthUnitIew != nil {
		t := *r.lengthUnitIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__iew", t, "multi")
		}
	}
	if r.lengthUnitIre != nil {
		t := *r.lengthUnitIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__ire", t, "multi")
		}
	}
	if r.lengthUnitIsw != nil {
		t := *r.lengthUnitIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__isw", t, "multi")
		}
	}
	if r.lengthUnitN != nil {
		t := *r.lengthUnitN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__n", t, "multi")
		}
	}
	if r.lengthUnitNic != nil {
		t := *r.lengthUnitNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nic", t, "multi")
		}
	}
	if r.lengthUnitNie != nil {
		t := *r.lengthUnitNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nie", t, "multi")
		}
	}
	if r.lengthUnitNiew != nil {
		t := *r.lengthUnitNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__niew", t, "multi")
		}
	}
	if r.lengthUnitNire != nil {
		t := *r.lengthUnitNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nire", t, "multi")
		}
	}
	if r.lengthUnitNisw != nil {
		t := *r.lengthUnitNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nisw", t, "multi")
		}
	}
	if r.lengthUnitNre != nil {
		t := *r.lengthUnitNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__nre", t, "multi")
		}
	}
	if r.lengthUnitRe != nil {
		t := *r.lengthUnitRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "length_unit__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationId != nil {
		t := *r.locationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location_id", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rack != nil {
		t := *r.rack
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack", t, "multi")
		}
	}
	if r.rackId != nil {
		t := *r.rackId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_id", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.terminationAId != nil {
		t := *r.terminationAId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id", t, "multi")
		}
	}
	if r.terminationAIdIc != nil {
		t := *r.terminationAIdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__ic", t, "multi")
		}
	}
	if r.terminationAIdIe != nil {
		t := *r.terminationAIdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__ie", t, "multi")
		}
	}
	if r.terminationAIdIew != nil {
		t := *r.terminationAIdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__iew", t, "multi")
		}
	}
	if r.terminationAIdIre != nil {
		t := *r.terminationAIdIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__ire", t, "multi")
		}
	}
	if r.terminationAIdIsw != nil {
		t := *r.terminationAIdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__isw", t, "multi")
		}
	}
	if r.terminationAIdN != nil {
		t := *r.terminationAIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__n", t, "multi")
		}
	}
	if r.terminationAIdNic != nil {
		t := *r.terminationAIdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nic", t, "multi")
		}
	}
	if r.terminationAIdNie != nil {
		t := *r.terminationAIdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nie", t, "multi")
		}
	}
	if r.terminationAIdNiew != nil {
		t := *r.terminationAIdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__niew", t, "multi")
		}
	}
	if r.terminationAIdNire != nil {
		t := *r.terminationAIdNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nire", t, "multi")
		}
	}
	if r.terminationAIdNisw != nil {
		t := *r.terminationAIdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nisw", t, "multi")
		}
	}
	if r.terminationAIdNre != nil {
		t := *r.terminationAIdNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__nre", t, "multi")
		}
	}
	if r.terminationAIdRe != nil {
		t := *r.terminationAIdRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_id__re", t, "multi")
		}
	}
	if r.terminationAType != nil {
		t := *r.terminationAType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_type", t, "multi")
		}
	}
	if r.terminationATypeN != nil {
		t := *r.terminationATypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_a_type__n", t, "multi")
		}
	}
	if r.terminationBId != nil {
		t := *r.terminationBId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id", t, "multi")
		}
	}
	if r.terminationBIdIc != nil {
		t := *r.terminationBIdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__ic", t, "multi")
		}
	}
	if r.terminationBIdIe != nil {
		t := *r.terminationBIdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__ie", t, "multi")
		}
	}
	if r.terminationBIdIew != nil {
		t := *r.terminationBIdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__iew", t, "multi")
		}
	}
	if r.terminationBIdIre != nil {
		t := *r.terminationBIdIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__ire", t, "multi")
		}
	}
	if r.terminationBIdIsw != nil {
		t := *r.terminationBIdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__isw", t, "multi")
		}
	}
	if r.terminationBIdN != nil {
		t := *r.terminationBIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__n", t, "multi")
		}
	}
	if r.terminationBIdNic != nil {
		t := *r.terminationBIdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nic", t, "multi")
		}
	}
	if r.terminationBIdNie != nil {
		t := *r.terminationBIdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nie", t, "multi")
		}
	}
	if r.terminationBIdNiew != nil {
		t := *r.terminationBIdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__niew", t, "multi")
		}
	}
	if r.terminationBIdNire != nil {
		t := *r.terminationBIdNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nire", t, "multi")
		}
	}
	if r.terminationBIdNisw != nil {
		t := *r.terminationBIdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nisw", t, "multi")
		}
	}
	if r.terminationBIdNre != nil {
		t := *r.terminationBIdNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__nre", t, "multi")
		}
	}
	if r.terminationBIdRe != nil {
		t := *r.terminationBIdRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_id__re", t, "multi")
		}
	}
	if r.terminationBType != nil {
		t := *r.terminationBType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_type", t, "multi")
		}
	}
	if r.terminationBTypeN != nil {
		t := *r.terminationBTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_b_type__n", t, "multi")
		}
	}
	if r.terminationType != nil {
		t := *r.terminationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_type", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimCablesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimCablesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimCablesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimCablesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimCablesNotesCreateExecute(r)
}

/*
DcimCablesNotesCreate Method for DcimCablesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this cable.
 @return ApiDcimCablesNotesCreateRequest
*/
func (a *DcimAPIService) DcimCablesNotesCreate(ctx context.Context, id string) ApiDcimCablesNotesCreateRequest {
	return ApiDcimCablesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimCablesNotesCreateExecute(r ApiDcimCablesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimCablesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimCablesNotesListRequest) Limit(limit int32) ApiDcimCablesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimCablesNotesListRequest) Offset(offset int32) ApiDcimCablesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimCablesNotesListRequest) Depth(depth int32) ApiDcimCablesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimCablesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimCablesNotesListExecute(r)
}

/*
DcimCablesNotesList Method for DcimCablesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this cable.
 @return ApiDcimCablesNotesListRequest
*/
func (a *DcimAPIService) DcimCablesNotesList(ctx context.Context, id string) ApiDcimCablesNotesListRequest {
	return ApiDcimCablesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimCablesNotesListExecute(r ApiDcimCablesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableCableRequest *PatchedWritableCableRequest
}

func (r ApiDcimCablesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimCablesPartialUpdateRequest) PatchedWritableCableRequest(patchedWritableCableRequest PatchedWritableCableRequest) ApiDcimCablesPartialUpdateRequest {
	r.patchedWritableCableRequest = &patchedWritableCableRequest
	return r
}

func (r ApiDcimCablesPartialUpdateRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesPartialUpdateExecute(r)
}

/*
DcimCablesPartialUpdate Method for DcimCablesPartialUpdate

Partial update a cable object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this cable.
 @return ApiDcimCablesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimCablesPartialUpdate(ctx context.Context, id string) ApiDcimCablesPartialUpdateRequest {
	return ApiDcimCablesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimAPIService) DcimCablesPartialUpdateExecute(r ApiDcimCablesPartialUpdateRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableCableRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimCablesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimCablesRetrieveRequest) Depth(depth int32) ApiDcimCablesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimCablesRetrieveRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesRetrieveExecute(r)
}

/*
DcimCablesRetrieve Method for DcimCablesRetrieve

Retrieve a cable object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this cable.
 @return ApiDcimCablesRetrieveRequest
*/
func (a *DcimAPIService) DcimCablesRetrieve(ctx context.Context, id string) ApiDcimCablesRetrieveRequest {
	return ApiDcimCablesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimAPIService) DcimCablesRetrieveExecute(r ApiDcimCablesRetrieveRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimCablesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableCableRequest *WritableCableRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimCablesUpdateRequest) WritableCableRequest(writableCableRequest WritableCableRequest) ApiDcimCablesUpdateRequest {
	r.writableCableRequest = &writableCableRequest
	return r
}

func (r ApiDcimCablesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimCablesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimCablesUpdateRequest) Execute() (*Cable, *http.Response, error) {
	return r.ApiService.DcimCablesUpdateExecute(r)
}

/*
DcimCablesUpdate Method for DcimCablesUpdate

Update a cable object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this cable.
 @return ApiDcimCablesUpdateRequest
*/
func (a *DcimAPIService) DcimCablesUpdate(ctx context.Context, id string) ApiDcimCablesUpdateRequest {
	return ApiDcimCablesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Cable
func (a *DcimAPIService) DcimCablesUpdateExecute(r ApiDcimCablesUpdateRequest) (*Cable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Cable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimCablesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableCableRequest == nil {
		return localVarReturnValue, nil, reportError("writableCableRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableCableRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConnectedDeviceListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	peerDevice *string
	peerInterface *string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

// The name of the peer device
func (r ApiDcimConnectedDeviceListRequest) PeerDevice(peerDevice string) ApiDcimConnectedDeviceListRequest {
	r.peerDevice = &peerDevice
	return r
}

// The name of the peer interface
func (r ApiDcimConnectedDeviceListRequest) PeerInterface(peerInterface string) ApiDcimConnectedDeviceListRequest {
	r.peerInterface = &peerInterface
	return r
}

func (r ApiDcimConnectedDeviceListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConnectedDeviceListRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimConnectedDeviceListRequest) Depth(depth int32) ApiDcimConnectedDeviceListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConnectedDeviceListRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.DcimConnectedDeviceListExecute(r)
}

/*
DcimConnectedDeviceList Method for DcimConnectedDeviceList

This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer
interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors
via a protocol such as LLDP. Two query parameters must be included in the request:

* `peer_device`: The name of the peer device
* `peer_interface`: The name of the peer interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConnectedDeviceListRequest
*/
func (a *DcimAPIService) DcimConnectedDeviceList(ctx context.Context) ApiDcimConnectedDeviceListRequest {
	return ApiDcimConnectedDeviceListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *DcimAPIService) DcimConnectedDeviceListExecute(r ApiDcimConnectedDeviceListRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConnectedDeviceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/connected-device/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.peerDevice == nil {
		return localVarReturnValue, nil, reportError("peerDevice is required and must be specified")
	}
	if r.peerInterface == nil {
		return localVarReturnValue, nil, reportError("peerInterface is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "peer_device", r.peerDevice, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "peer_interface", r.peerInterface, "")
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleConnectionsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	device *[]string
	deviceId *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	limit *int32
	location *string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	sort *string
	depth *int32
}

// Device (name)
func (r ApiDcimConsoleConnectionsListRequest) Device(device []string) ApiDcimConsoleConnectionsListRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiDcimConsoleConnectionsListRequest) DeviceId(deviceId []string) ApiDcimConsoleConnectionsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleConnectionsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimConsoleConnectionsListRequest) Id(id []string) ApiDcimConsoleConnectionsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdIc(idIc []string) ApiDcimConsoleConnectionsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdIe(idIe []string) ApiDcimConsoleConnectionsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdIew(idIew []string) ApiDcimConsoleConnectionsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdIre(idIre []string) ApiDcimConsoleConnectionsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdIsw(idIsw []string) ApiDcimConsoleConnectionsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdN(idN []string) ApiDcimConsoleConnectionsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdNic(idNic []string) ApiDcimConsoleConnectionsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdNie(idNie []string) ApiDcimConsoleConnectionsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdNiew(idNiew []string) ApiDcimConsoleConnectionsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdNire(idNire []string) ApiDcimConsoleConnectionsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdNisw(idNisw []string) ApiDcimConsoleConnectionsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdNre(idNre []string) ApiDcimConsoleConnectionsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) IdRe(idRe []string) ApiDcimConsoleConnectionsListRequest {
	r.idRe = &idRe
	return r
}

// Number of results to return per page.
func (r ApiDcimConsoleConnectionsListRequest) Limit(limit int32) ApiDcimConsoleConnectionsListRequest {
	r.limit = &limit
	return r
}

// Location (name)
func (r ApiDcimConsoleConnectionsListRequest) Location(location string) ApiDcimConsoleConnectionsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) Name(name []string) ApiDcimConsoleConnectionsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIc(nameIc []string) ApiDcimConsoleConnectionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIe(nameIe []string) ApiDcimConsoleConnectionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIew(nameIew []string) ApiDcimConsoleConnectionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIre(nameIre []string) ApiDcimConsoleConnectionsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameIsw(nameIsw []string) ApiDcimConsoleConnectionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameN(nameN []string) ApiDcimConsoleConnectionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNic(nameNic []string) ApiDcimConsoleConnectionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNie(nameNie []string) ApiDcimConsoleConnectionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNiew(nameNiew []string) ApiDcimConsoleConnectionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNire(nameNire []string) ApiDcimConsoleConnectionsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNisw(nameNisw []string) ApiDcimConsoleConnectionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameNre(nameNre []string) ApiDcimConsoleConnectionsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) NameRe(nameRe []string) ApiDcimConsoleConnectionsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsoleConnectionsListRequest) Offset(offset int32) ApiDcimConsoleConnectionsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimConsoleConnectionsListRequest) Sort(sort string) ApiDcimConsoleConnectionsListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimConsoleConnectionsListRequest) Depth(depth int32) ApiDcimConsoleConnectionsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsoleConnectionsListRequest) Execute() (*PaginatedConsolePortList, *http.Response, error) {
	return r.ApiService.DcimConsoleConnectionsListExecute(r)
}

/*
DcimConsoleConnectionsList Method for DcimConsoleConnectionsList

Retrieve a list of console port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleConnectionsListRequest
*/
func (a *DcimAPIService) DcimConsoleConnectionsList(ctx context.Context) ApiDcimConsoleConnectionsListRequest {
	return ApiDcimConsoleConnectionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedConsolePortList
func (a *DcimAPIService) DcimConsoleConnectionsListExecute(r ApiDcimConsoleConnectionsListRequest) (*PaginatedConsolePortList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedConsolePortList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleConnectionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortTemplatesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimConsolePortTemplatesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimConsolePortTemplatesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesBulkDestroyExecute(r)
}

/*
DcimConsolePortTemplatesBulkDestroy Method for DcimConsolePortTemplatesBulkDestroy

Destroy a list of console port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesBulkDestroy(ctx context.Context) ApiDcimConsolePortTemplatesBulkDestroyRequest {
	return ApiDcimConsolePortTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimConsolePortTemplatesBulkDestroyExecute(r ApiDcimConsolePortTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableConsolePortTemplateRequest *[]PatchedBulkWritableConsolePortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortTemplatesBulkPartialUpdateRequest) PatchedBulkWritableConsolePortTemplateRequest(patchedBulkWritableConsolePortTemplateRequest []PatchedBulkWritableConsolePortTemplateRequest) ApiDcimConsolePortTemplatesBulkPartialUpdateRequest {
	r.patchedBulkWritableConsolePortTemplateRequest = &patchedBulkWritableConsolePortTemplateRequest
	return r
}

func (r ApiDcimConsolePortTemplatesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortTemplatesBulkPartialUpdateRequest) Execute() ([]ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimConsolePortTemplatesBulkPartialUpdate Method for DcimConsolePortTemplatesBulkPartialUpdate

Partial update a list of console port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimConsolePortTemplatesBulkPartialUpdateRequest {
	return ApiDcimConsolePortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConsolePortTemplate
func (a *DcimAPIService) DcimConsolePortTemplatesBulkPartialUpdateExecute(r ApiDcimConsolePortTemplatesBulkPartialUpdateRequest) ([]ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableConsolePortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableConsolePortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableConsolePortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableConsolePortTemplateRequest *[]BulkWritableConsolePortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortTemplatesBulkUpdateRequest) BulkWritableConsolePortTemplateRequest(bulkWritableConsolePortTemplateRequest []BulkWritableConsolePortTemplateRequest) ApiDcimConsolePortTemplatesBulkUpdateRequest {
	r.bulkWritableConsolePortTemplateRequest = &bulkWritableConsolePortTemplateRequest
	return r
}

func (r ApiDcimConsolePortTemplatesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortTemplatesBulkUpdateRequest) Execute() ([]ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesBulkUpdateExecute(r)
}

/*
DcimConsolePortTemplatesBulkUpdate Method for DcimConsolePortTemplatesBulkUpdate

Update a list of console port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesBulkUpdate(ctx context.Context) ApiDcimConsolePortTemplatesBulkUpdateRequest {
	return ApiDcimConsolePortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConsolePortTemplate
func (a *DcimAPIService) DcimConsolePortTemplatesBulkUpdateExecute(r ApiDcimConsolePortTemplatesBulkUpdateRequest) ([]ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableConsolePortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableConsolePortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableConsolePortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableConsolePortTemplateRequest *WritableConsolePortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortTemplatesCreateRequest) WritableConsolePortTemplateRequest(writableConsolePortTemplateRequest WritableConsolePortTemplateRequest) ApiDcimConsolePortTemplatesCreateRequest {
	r.writableConsolePortTemplateRequest = &writableConsolePortTemplateRequest
	return r
}

func (r ApiDcimConsolePortTemplatesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortTemplatesCreateRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesCreateExecute(r)
}

/*
DcimConsolePortTemplatesCreate Method for DcimConsolePortTemplatesCreate

Create one or more console port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesCreateRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesCreate(ctx context.Context) ApiDcimConsolePortTemplatesCreateRequest {
	return ApiDcimConsolePortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimAPIService) DcimConsolePortTemplatesCreateExecute(r ApiDcimConsolePortTemplatesCreateRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableConsolePortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableConsolePortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableConsolePortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortTemplatesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesDestroyExecute(r)
}

/*
DcimConsolePortTemplatesDestroy Method for DcimConsolePortTemplatesDestroy

Destroy a console port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port template.
 @return ApiDcimConsolePortTemplatesDestroyRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesDestroy(ctx context.Context, id string) ApiDcimConsolePortTemplatesDestroyRequest {
	return ApiDcimConsolePortTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimConsolePortTemplatesDestroyExecute(r ApiDcimConsolePortTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceType *[]string
	deviceTypeN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) Description(description []string) ApiDcimConsolePortTemplatesListRequest {
	r.description = &description
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionIre(descriptionIre []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionN(descriptionN []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionNire(descriptionNire []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionNre(descriptionNre []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

// Description
func (r ApiDcimConsolePortTemplatesListRequest) DescriptionRe(descriptionRe []string) ApiDcimConsolePortTemplatesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) DeviceType(deviceType []string) ApiDcimConsolePortTemplatesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimConsolePortTemplatesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesListRequest {
	r.format = &format
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) Id(id []string) ApiDcimConsolePortTemplatesListRequest {
	r.id = &id
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdIc(idIc []string) ApiDcimConsolePortTemplatesListRequest {
	r.idIc = &idIc
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdIe(idIe []string) ApiDcimConsolePortTemplatesListRequest {
	r.idIe = &idIe
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdIew(idIew []string) ApiDcimConsolePortTemplatesListRequest {
	r.idIew = &idIew
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdIre(idIre []string) ApiDcimConsolePortTemplatesListRequest {
	r.idIre = &idIre
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdIsw(idIsw []string) ApiDcimConsolePortTemplatesListRequest {
	r.idIsw = &idIsw
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdN(idN []string) ApiDcimConsolePortTemplatesListRequest {
	r.idN = &idN
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdNic(idNic []string) ApiDcimConsolePortTemplatesListRequest {
	r.idNic = &idNic
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdNie(idNie []string) ApiDcimConsolePortTemplatesListRequest {
	r.idNie = &idNie
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdNiew(idNiew []string) ApiDcimConsolePortTemplatesListRequest {
	r.idNiew = &idNiew
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdNire(idNire []string) ApiDcimConsolePortTemplatesListRequest {
	r.idNire = &idNire
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdNisw(idNisw []string) ApiDcimConsolePortTemplatesListRequest {
	r.idNisw = &idNisw
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdNre(idNre []string) ApiDcimConsolePortTemplatesListRequest {
	r.idNre = &idNre
	return r
}

// ID
func (r ApiDcimConsolePortTemplatesListRequest) IdRe(idRe []string) ApiDcimConsolePortTemplatesListRequest {
	r.idRe = &idRe
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) Label(label []string) ApiDcimConsolePortTemplatesListRequest {
	r.label = &label
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelIc(labelIc []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelIc = &labelIc
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelIe(labelIe []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelIe = &labelIe
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelIew(labelIew []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelIew = &labelIew
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelIre(labelIre []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelIre = &labelIre
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelIsw(labelIsw []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelIsw = &labelIsw
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelN(labelN []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelN = &labelN
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelNic(labelNic []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelNic = &labelNic
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelNie(labelNie []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelNie = &labelNie
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelNiew(labelNiew []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelNiew = &labelNiew
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelNire(labelNire []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelNire = &labelNire
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelNisw(labelNisw []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelNisw = &labelNisw
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelNre(labelNre []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelNre = &labelNre
	return r
}

// Label
func (r ApiDcimConsolePortTemplatesListRequest) LabelRe(labelRe []string) ApiDcimConsolePortTemplatesListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimConsolePortTemplatesListRequest) Limit(limit int32) ApiDcimConsolePortTemplatesListRequest {
	r.limit = &limit
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) Name(name []string) ApiDcimConsolePortTemplatesListRequest {
	r.name = &name
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameIc(nameIc []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameIe(nameIe []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameIew(nameIew []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameIre(nameIre []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIre = &nameIre
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameIsw(nameIsw []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameN(nameN []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameNic(nameNic []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameNie(nameNie []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameNiew(nameNiew []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameNire(nameNire []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNire = &nameNire
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameNisw(nameNisw []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameNre(nameNre []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameNre = &nameNre
	return r
}

// Name
func (r ApiDcimConsolePortTemplatesListRequest) NameRe(nameRe []string) ApiDcimConsolePortTemplatesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsolePortTemplatesListRequest) Offset(offset int32) ApiDcimConsolePortTemplatesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimConsolePortTemplatesListRequest) Q(q string) ApiDcimConsolePortTemplatesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimConsolePortTemplatesListRequest) Sort(sort string) ApiDcimConsolePortTemplatesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) Type_(type_ []string) ApiDcimConsolePortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeIc(typeIc []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeIe(typeIe []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeIew(typeIew []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeIre(typeIre []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeIsw(typeIsw []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeN(typeN []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeNic(typeNic []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeNie(typeNie []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeNiew(typeNiew []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeNire(typeNire []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeNisw(typeNisw []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeNre(typeNre []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) TypeRe(typeRe []string) ApiDcimConsolePortTemplatesListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimConsolePortTemplatesListRequest) Depth(depth int32) ApiDcimConsolePortTemplatesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsolePortTemplatesListRequest) Execute() (*PaginatedConsolePortTemplateList, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesListExecute(r)
}

/*
DcimConsolePortTemplatesList Method for DcimConsolePortTemplatesList

Retrieve a list of console port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortTemplatesListRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesList(ctx context.Context) ApiDcimConsolePortTemplatesListRequest {
	return ApiDcimConsolePortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedConsolePortTemplateList
func (a *DcimAPIService) DcimConsolePortTemplatesListExecute(r ApiDcimConsolePortTemplatesListRequest) (*PaginatedConsolePortTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedConsolePortTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortTemplatesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimConsolePortTemplatesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimConsolePortTemplatesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortTemplatesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesNotesCreateExecute(r)
}

/*
DcimConsolePortTemplatesNotesCreate Method for DcimConsolePortTemplatesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port template.
 @return ApiDcimConsolePortTemplatesNotesCreateRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesNotesCreate(ctx context.Context, id string) ApiDcimConsolePortTemplatesNotesCreateRequest {
	return ApiDcimConsolePortTemplatesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimConsolePortTemplatesNotesCreateExecute(r ApiDcimConsolePortTemplatesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimConsolePortTemplatesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimConsolePortTemplatesNotesListRequest) Limit(limit int32) ApiDcimConsolePortTemplatesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsolePortTemplatesNotesListRequest) Offset(offset int32) ApiDcimConsolePortTemplatesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimConsolePortTemplatesNotesListRequest) Depth(depth int32) ApiDcimConsolePortTemplatesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsolePortTemplatesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesNotesListExecute(r)
}

/*
DcimConsolePortTemplatesNotesList Method for DcimConsolePortTemplatesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port template.
 @return ApiDcimConsolePortTemplatesNotesListRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesNotesList(ctx context.Context, id string) ApiDcimConsolePortTemplatesNotesListRequest {
	return ApiDcimConsolePortTemplatesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimConsolePortTemplatesNotesListExecute(r ApiDcimConsolePortTemplatesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableConsolePortTemplateRequest *PatchedWritableConsolePortTemplateRequest
}

func (r ApiDcimConsolePortTemplatesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortTemplatesPartialUpdateRequest) PatchedWritableConsolePortTemplateRequest(patchedWritableConsolePortTemplateRequest PatchedWritableConsolePortTemplateRequest) ApiDcimConsolePortTemplatesPartialUpdateRequest {
	r.patchedWritableConsolePortTemplateRequest = &patchedWritableConsolePortTemplateRequest
	return r
}

func (r ApiDcimConsolePortTemplatesPartialUpdateRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesPartialUpdateExecute(r)
}

/*
DcimConsolePortTemplatesPartialUpdate Method for DcimConsolePortTemplatesPartialUpdate

Partial update a console port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port template.
 @return ApiDcimConsolePortTemplatesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesPartialUpdate(ctx context.Context, id string) ApiDcimConsolePortTemplatesPartialUpdateRequest {
	return ApiDcimConsolePortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimAPIService) DcimConsolePortTemplatesPartialUpdateExecute(r ApiDcimConsolePortTemplatesPartialUpdateRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableConsolePortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimConsolePortTemplatesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimConsolePortTemplatesRetrieveRequest) Depth(depth int32) ApiDcimConsolePortTemplatesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsolePortTemplatesRetrieveRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesRetrieveExecute(r)
}

/*
DcimConsolePortTemplatesRetrieve Method for DcimConsolePortTemplatesRetrieve

Retrieve a console port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port template.
 @return ApiDcimConsolePortTemplatesRetrieveRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesRetrieve(ctx context.Context, id string) ApiDcimConsolePortTemplatesRetrieveRequest {
	return ApiDcimConsolePortTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimAPIService) DcimConsolePortTemplatesRetrieveExecute(r ApiDcimConsolePortTemplatesRetrieveRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableConsolePortTemplateRequest *WritableConsolePortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortTemplatesUpdateRequest) WritableConsolePortTemplateRequest(writableConsolePortTemplateRequest WritableConsolePortTemplateRequest) ApiDcimConsolePortTemplatesUpdateRequest {
	r.writableConsolePortTemplateRequest = &writableConsolePortTemplateRequest
	return r
}

func (r ApiDcimConsolePortTemplatesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortTemplatesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortTemplatesUpdateRequest) Execute() (*ConsolePortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsolePortTemplatesUpdateExecute(r)
}

/*
DcimConsolePortTemplatesUpdate Method for DcimConsolePortTemplatesUpdate

Update a console port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port template.
 @return ApiDcimConsolePortTemplatesUpdateRequest
*/
func (a *DcimAPIService) DcimConsolePortTemplatesUpdate(ctx context.Context, id string) ApiDcimConsolePortTemplatesUpdateRequest {
	return ApiDcimConsolePortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePortTemplate
func (a *DcimAPIService) DcimConsolePortTemplatesUpdateExecute(r ApiDcimConsolePortTemplatesUpdateRequest) (*ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableConsolePortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableConsolePortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableConsolePortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimConsolePortsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimConsolePortsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsolePortsBulkDestroyExecute(r)
}

/*
DcimConsolePortsBulkDestroy Method for DcimConsolePortsBulkDestroy

Destroy a list of console port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimConsolePortsBulkDestroy(ctx context.Context) ApiDcimConsolePortsBulkDestroyRequest {
	return ApiDcimConsolePortsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimConsolePortsBulkDestroyExecute(r ApiDcimConsolePortsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsolePortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableConsolePortRequest *[]PatchedBulkWritableConsolePortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortsBulkPartialUpdateRequest) PatchedBulkWritableConsolePortRequest(patchedBulkWritableConsolePortRequest []PatchedBulkWritableConsolePortRequest) ApiDcimConsolePortsBulkPartialUpdateRequest {
	r.patchedBulkWritableConsolePortRequest = &patchedBulkWritableConsolePortRequest
	return r
}

func (r ApiDcimConsolePortsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortsBulkPartialUpdateRequest) Execute() ([]ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsBulkPartialUpdateExecute(r)
}

/*
DcimConsolePortsBulkPartialUpdate Method for DcimConsolePortsBulkPartialUpdate

Partial update a list of console port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimConsolePortsBulkPartialUpdate(ctx context.Context) ApiDcimConsolePortsBulkPartialUpdateRequest {
	return ApiDcimConsolePortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConsolePort
func (a *DcimAPIService) DcimConsolePortsBulkPartialUpdateExecute(r ApiDcimConsolePortsBulkPartialUpdateRequest) ([]ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableConsolePortRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableConsolePortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableConsolePortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableConsolePortRequest *[]BulkWritableConsolePortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortsBulkUpdateRequest) BulkWritableConsolePortRequest(bulkWritableConsolePortRequest []BulkWritableConsolePortRequest) ApiDcimConsolePortsBulkUpdateRequest {
	r.bulkWritableConsolePortRequest = &bulkWritableConsolePortRequest
	return r
}

func (r ApiDcimConsolePortsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortsBulkUpdateRequest) Execute() ([]ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsBulkUpdateExecute(r)
}

/*
DcimConsolePortsBulkUpdate Method for DcimConsolePortsBulkUpdate

Update a list of console port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimConsolePortsBulkUpdate(ctx context.Context) ApiDcimConsolePortsBulkUpdateRequest {
	return ApiDcimConsolePortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConsolePort
func (a *DcimAPIService) DcimConsolePortsBulkUpdateExecute(r ApiDcimConsolePortsBulkUpdateRequest) ([]ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableConsolePortRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableConsolePortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableConsolePortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableConsolePortRequest *WritableConsolePortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortsCreateRequest) WritableConsolePortRequest(writableConsolePortRequest WritableConsolePortRequest) ApiDcimConsolePortsCreateRequest {
	r.writableConsolePortRequest = &writableConsolePortRequest
	return r
}

func (r ApiDcimConsolePortsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortsCreateRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsCreateExecute(r)
}

/*
DcimConsolePortsCreate Method for DcimConsolePortsCreate

Create one or more console port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsCreateRequest
*/
func (a *DcimAPIService) DcimConsolePortsCreate(ctx context.Context) ApiDcimConsolePortsCreateRequest {
	return ApiDcimConsolePortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimAPIService) DcimConsolePortsCreateExecute(r ApiDcimConsolePortsCreateRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableConsolePortRequest == nil {
		return localVarReturnValue, nil, reportError("writableConsolePortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableConsolePortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsolePortsDestroyExecute(r)
}

/*
DcimConsolePortsDestroy Method for DcimConsolePortsDestroy

Destroy a console port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port.
 @return ApiDcimConsolePortsDestroyRequest
*/
func (a *DcimAPIService) DcimConsolePortsDestroy(ctx context.Context, id string) ApiDcimConsolePortsDestroyRequest {
	return ApiDcimConsolePortsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimConsolePortsDestroyExecute(r ApiDcimConsolePortsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsolePortsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	cable *[]string
	cableIsnull *bool
	cableN *[]string
	connected *bool
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasCable *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Cable
func (r ApiDcimConsolePortsListRequest) Cable(cable []string) ApiDcimConsolePortsListRequest {
	r.cable = &cable
	return r
}

func (r ApiDcimConsolePortsListRequest) CableIsnull(cableIsnull bool) ApiDcimConsolePortsListRequest {
	r.cableIsnull = &cableIsnull
	return r
}

// Cable
func (r ApiDcimConsolePortsListRequest) CableN(cableN []string) ApiDcimConsolePortsListRequest {
	r.cableN = &cableN
	return r
}

// Connected status (bool)
func (r ApiDcimConsolePortsListRequest) Connected(connected bool) ApiDcimConsolePortsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimConsolePortsListRequest) Description(description []string) ApiDcimConsolePortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIc(descriptionIc []string) ApiDcimConsolePortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIe(descriptionIe []string) ApiDcimConsolePortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIew(descriptionIew []string) ApiDcimConsolePortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIre(descriptionIre []string) ApiDcimConsolePortsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimConsolePortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionN(descriptionN []string) ApiDcimConsolePortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNic(descriptionNic []string) ApiDcimConsolePortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNie(descriptionNie []string) ApiDcimConsolePortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimConsolePortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNire(descriptionNire []string) ApiDcimConsolePortsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimConsolePortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionNre(descriptionNre []string) ApiDcimConsolePortsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimConsolePortsListRequest) DescriptionRe(descriptionRe []string) ApiDcimConsolePortsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimConsolePortsListRequest) Device(device []string) ApiDcimConsolePortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimConsolePortsListRequest) DeviceN(deviceN []string) ApiDcimConsolePortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimConsolePortsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsListRequest {
	r.format = &format
	return r
}

// Has cable
func (r ApiDcimConsolePortsListRequest) HasCable(hasCable bool) ApiDcimConsolePortsListRequest {
	r.hasCable = &hasCable
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimConsolePortsListRequest) Id(id []string) ApiDcimConsolePortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimConsolePortsListRequest) IdIc(idIc []string) ApiDcimConsolePortsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimConsolePortsListRequest) IdIe(idIe []string) ApiDcimConsolePortsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimConsolePortsListRequest) IdIew(idIew []string) ApiDcimConsolePortsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimConsolePortsListRequest) IdIre(idIre []string) ApiDcimConsolePortsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimConsolePortsListRequest) IdIsw(idIsw []string) ApiDcimConsolePortsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimConsolePortsListRequest) IdN(idN []string) ApiDcimConsolePortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimConsolePortsListRequest) IdNic(idNic []string) ApiDcimConsolePortsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimConsolePortsListRequest) IdNie(idNie []string) ApiDcimConsolePortsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimConsolePortsListRequest) IdNiew(idNiew []string) ApiDcimConsolePortsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimConsolePortsListRequest) IdNire(idNire []string) ApiDcimConsolePortsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimConsolePortsListRequest) IdNisw(idNisw []string) ApiDcimConsolePortsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimConsolePortsListRequest) IdNre(idNre []string) ApiDcimConsolePortsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimConsolePortsListRequest) IdRe(idRe []string) ApiDcimConsolePortsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimConsolePortsListRequest) Label(label []string) ApiDcimConsolePortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIc(labelIc []string) ApiDcimConsolePortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIe(labelIe []string) ApiDcimConsolePortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIew(labelIew []string) ApiDcimConsolePortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIre(labelIre []string) ApiDcimConsolePortsListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelIsw(labelIsw []string) ApiDcimConsolePortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelN(labelN []string) ApiDcimConsolePortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNic(labelNic []string) ApiDcimConsolePortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNie(labelNie []string) ApiDcimConsolePortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNiew(labelNiew []string) ApiDcimConsolePortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNire(labelNire []string) ApiDcimConsolePortsListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNisw(labelNisw []string) ApiDcimConsolePortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelNre(labelNre []string) ApiDcimConsolePortsListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimConsolePortsListRequest) LabelRe(labelRe []string) ApiDcimConsolePortsListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimConsolePortsListRequest) Limit(limit int32) ApiDcimConsolePortsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimConsolePortsListRequest) Location(location []string) ApiDcimConsolePortsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimConsolePortsListRequest) LocationN(locationN []string) ApiDcimConsolePortsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimConsolePortsListRequest) Name(name []string) ApiDcimConsolePortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIc(nameIc []string) ApiDcimConsolePortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIe(nameIe []string) ApiDcimConsolePortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIew(nameIew []string) ApiDcimConsolePortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIre(nameIre []string) ApiDcimConsolePortsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimConsolePortsListRequest) NameIsw(nameIsw []string) ApiDcimConsolePortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimConsolePortsListRequest) NameN(nameN []string) ApiDcimConsolePortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNic(nameNic []string) ApiDcimConsolePortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNie(nameNie []string) ApiDcimConsolePortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNiew(nameNiew []string) ApiDcimConsolePortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNire(nameNire []string) ApiDcimConsolePortsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNisw(nameNisw []string) ApiDcimConsolePortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimConsolePortsListRequest) NameNre(nameNre []string) ApiDcimConsolePortsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimConsolePortsListRequest) NameRe(nameRe []string) ApiDcimConsolePortsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsolePortsListRequest) Offset(offset int32) ApiDcimConsolePortsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimConsolePortsListRequest) Q(q string) ApiDcimConsolePortsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimConsolePortsListRequest) Sort(sort string) ApiDcimConsolePortsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimConsolePortsListRequest) Tags(tags []string) ApiDcimConsolePortsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimConsolePortsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimConsolePortsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimConsolePortsListRequest) TagsN(tagsN []string) ApiDcimConsolePortsListRequest {
	r.tagsN = &tagsN
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) Type_(type_ []string) ApiDcimConsolePortsListRequest {
	r.type_ = &type_
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeIc(typeIc []string) ApiDcimConsolePortsListRequest {
	r.typeIc = &typeIc
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeIe(typeIe []string) ApiDcimConsolePortsListRequest {
	r.typeIe = &typeIe
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeIew(typeIew []string) ApiDcimConsolePortsListRequest {
	r.typeIew = &typeIew
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeIre(typeIre []string) ApiDcimConsolePortsListRequest {
	r.typeIre = &typeIre
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeIsw(typeIsw []string) ApiDcimConsolePortsListRequest {
	r.typeIsw = &typeIsw
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeN(typeN []string) ApiDcimConsolePortsListRequest {
	r.typeN = &typeN
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeNic(typeNic []string) ApiDcimConsolePortsListRequest {
	r.typeNic = &typeNic
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeNie(typeNie []string) ApiDcimConsolePortsListRequest {
	r.typeNie = &typeNie
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeNiew(typeNiew []string) ApiDcimConsolePortsListRequest {
	r.typeNiew = &typeNiew
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeNire(typeNire []string) ApiDcimConsolePortsListRequest {
	r.typeNire = &typeNire
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeNisw(typeNisw []string) ApiDcimConsolePortsListRequest {
	r.typeNisw = &typeNisw
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeNre(typeNre []string) ApiDcimConsolePortsListRequest {
	r.typeNre = &typeNre
	return r
}

// Physical port type
func (r ApiDcimConsolePortsListRequest) TypeRe(typeRe []string) ApiDcimConsolePortsListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimConsolePortsListRequest) Depth(depth int32) ApiDcimConsolePortsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsolePortsListRequest) Execute() (*PaginatedConsolePortList, *http.Response, error) {
	return r.ApiService.DcimConsolePortsListExecute(r)
}

/*
DcimConsolePortsList Method for DcimConsolePortsList

Retrieve a list of console port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsolePortsListRequest
*/
func (a *DcimAPIService) DcimConsolePortsList(ctx context.Context) ApiDcimConsolePortsListRequest {
	return ApiDcimConsolePortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedConsolePortList
func (a *DcimAPIService) DcimConsolePortsListExecute(r ApiDcimConsolePortsListRequest) (*PaginatedConsolePortList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedConsolePortList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cable != nil {
		t := *r.cable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable", t, "multi")
		}
	}
	if r.cableIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cable__isnull", r.cableIsnull, "")
	}
	if r.cableN != nil {
		t := *r.cableN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", t, "multi")
		}
	}
	if r.connected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connected", r.connected, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasCable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_cable", r.hasCable, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimConsolePortsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimConsolePortsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimConsolePortsNotesCreateExecute(r)
}

/*
DcimConsolePortsNotesCreate Method for DcimConsolePortsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port.
 @return ApiDcimConsolePortsNotesCreateRequest
*/
func (a *DcimAPIService) DcimConsolePortsNotesCreate(ctx context.Context, id string) ApiDcimConsolePortsNotesCreateRequest {
	return ApiDcimConsolePortsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimConsolePortsNotesCreateExecute(r ApiDcimConsolePortsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimConsolePortsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimConsolePortsNotesListRequest) Limit(limit int32) ApiDcimConsolePortsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsolePortsNotesListRequest) Offset(offset int32) ApiDcimConsolePortsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimConsolePortsNotesListRequest) Depth(depth int32) ApiDcimConsolePortsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsolePortsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimConsolePortsNotesListExecute(r)
}

/*
DcimConsolePortsNotesList Method for DcimConsolePortsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port.
 @return ApiDcimConsolePortsNotesListRequest
*/
func (a *DcimAPIService) DcimConsolePortsNotesList(ctx context.Context, id string) ApiDcimConsolePortsNotesListRequest {
	return ApiDcimConsolePortsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimConsolePortsNotesListExecute(r ApiDcimConsolePortsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableConsolePortRequest *PatchedWritableConsolePortRequest
}

func (r ApiDcimConsolePortsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortsPartialUpdateRequest) PatchedWritableConsolePortRequest(patchedWritableConsolePortRequest PatchedWritableConsolePortRequest) ApiDcimConsolePortsPartialUpdateRequest {
	r.patchedWritableConsolePortRequest = &patchedWritableConsolePortRequest
	return r
}

func (r ApiDcimConsolePortsPartialUpdateRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsPartialUpdateExecute(r)
}

/*
DcimConsolePortsPartialUpdate Method for DcimConsolePortsPartialUpdate

Partial update a console port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port.
 @return ApiDcimConsolePortsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimConsolePortsPartialUpdate(ctx context.Context, id string) ApiDcimConsolePortsPartialUpdateRequest {
	return ApiDcimConsolePortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimAPIService) DcimConsolePortsPartialUpdateExecute(r ApiDcimConsolePortsPartialUpdateRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableConsolePortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimConsolePortsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimConsolePortsRetrieveRequest) Depth(depth int32) ApiDcimConsolePortsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsolePortsRetrieveRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsRetrieveExecute(r)
}

/*
DcimConsolePortsRetrieve Method for DcimConsolePortsRetrieve

Retrieve a console port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port.
 @return ApiDcimConsolePortsRetrieveRequest
*/
func (a *DcimAPIService) DcimConsolePortsRetrieve(ctx context.Context, id string) ApiDcimConsolePortsRetrieveRequest {
	return ApiDcimConsolePortsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimAPIService) DcimConsolePortsRetrieveExecute(r ApiDcimConsolePortsRetrieveRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsTraceRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimConsolePortsTraceRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsTraceRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimConsolePortsTraceRetrieveRequest) Depth(depth int32) ApiDcimConsolePortsTraceRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsolePortsTraceRetrieveRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsTraceRetrieveExecute(r)
}

/*
DcimConsolePortsTraceRetrieve Method for DcimConsolePortsTraceRetrieve

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port.
 @return ApiDcimConsolePortsTraceRetrieveRequest
*/
func (a *DcimAPIService) DcimConsolePortsTraceRetrieve(ctx context.Context, id string) ApiDcimConsolePortsTraceRetrieveRequest {
	return ApiDcimConsolePortsTraceRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimAPIService) DcimConsolePortsTraceRetrieveExecute(r ApiDcimConsolePortsTraceRetrieveRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsTraceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsolePortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableConsolePortRequest *WritableConsolePortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsolePortsUpdateRequest) WritableConsolePortRequest(writableConsolePortRequest WritableConsolePortRequest) ApiDcimConsolePortsUpdateRequest {
	r.writableConsolePortRequest = &writableConsolePortRequest
	return r
}

func (r ApiDcimConsolePortsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsolePortsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsolePortsUpdateRequest) Execute() (*ConsolePort, *http.Response, error) {
	return r.ApiService.DcimConsolePortsUpdateExecute(r)
}

/*
DcimConsolePortsUpdate Method for DcimConsolePortsUpdate

Update a console port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console port.
 @return ApiDcimConsolePortsUpdateRequest
*/
func (a *DcimAPIService) DcimConsolePortsUpdate(ctx context.Context, id string) ApiDcimConsolePortsUpdateRequest {
	return ApiDcimConsolePortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsolePort
func (a *DcimAPIService) DcimConsolePortsUpdateExecute(r ApiDcimConsolePortsUpdateRequest) (*ConsolePort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsolePort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsolePortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableConsolePortRequest == nil {
		return localVarReturnValue, nil, reportError("writableConsolePortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableConsolePortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortTemplatesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimConsoleServerPortTemplatesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimConsoleServerPortTemplatesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesBulkDestroyExecute(r)
}

/*
DcimConsoleServerPortTemplatesBulkDestroy Method for DcimConsoleServerPortTemplatesBulkDestroy

Destroy a list of console server port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesBulkDestroy(ctx context.Context) ApiDcimConsoleServerPortTemplatesBulkDestroyRequest {
	return ApiDcimConsoleServerPortTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimConsoleServerPortTemplatesBulkDestroyExecute(r ApiDcimConsoleServerPortTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableConsoleServerPortTemplateRequest *[]PatchedBulkWritableConsoleServerPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest) PatchedBulkWritableConsoleServerPortTemplateRequest(patchedBulkWritableConsoleServerPortTemplateRequest []PatchedBulkWritableConsoleServerPortTemplateRequest) ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest {
	r.patchedBulkWritableConsoleServerPortTemplateRequest = &patchedBulkWritableConsoleServerPortTemplateRequest
	return r
}

func (r ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest) Execute() ([]ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimConsoleServerPortTemplatesBulkPartialUpdate Method for DcimConsoleServerPortTemplatesBulkPartialUpdate

Partial update a list of console server port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest {
	return ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConsoleServerPortTemplate
func (a *DcimAPIService) DcimConsoleServerPortTemplatesBulkPartialUpdateExecute(r ApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest) ([]ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableConsoleServerPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableConsoleServerPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableConsoleServerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableConsoleServerPortTemplateRequest *[]BulkWritableConsoleServerPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortTemplatesBulkUpdateRequest) BulkWritableConsoleServerPortTemplateRequest(bulkWritableConsoleServerPortTemplateRequest []BulkWritableConsoleServerPortTemplateRequest) ApiDcimConsoleServerPortTemplatesBulkUpdateRequest {
	r.bulkWritableConsoleServerPortTemplateRequest = &bulkWritableConsoleServerPortTemplateRequest
	return r
}

func (r ApiDcimConsoleServerPortTemplatesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortTemplatesBulkUpdateRequest) Execute() ([]ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesBulkUpdateExecute(r)
}

/*
DcimConsoleServerPortTemplatesBulkUpdate Method for DcimConsoleServerPortTemplatesBulkUpdate

Update a list of console server port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesBulkUpdate(ctx context.Context) ApiDcimConsoleServerPortTemplatesBulkUpdateRequest {
	return ApiDcimConsoleServerPortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConsoleServerPortTemplate
func (a *DcimAPIService) DcimConsoleServerPortTemplatesBulkUpdateExecute(r ApiDcimConsoleServerPortTemplatesBulkUpdateRequest) ([]ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableConsoleServerPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableConsoleServerPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableConsoleServerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableConsoleServerPortTemplateRequest *WritableConsoleServerPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortTemplatesCreateRequest) WritableConsoleServerPortTemplateRequest(writableConsoleServerPortTemplateRequest WritableConsoleServerPortTemplateRequest) ApiDcimConsoleServerPortTemplatesCreateRequest {
	r.writableConsoleServerPortTemplateRequest = &writableConsoleServerPortTemplateRequest
	return r
}

func (r ApiDcimConsoleServerPortTemplatesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortTemplatesCreateRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesCreateExecute(r)
}

/*
DcimConsoleServerPortTemplatesCreate Method for DcimConsoleServerPortTemplatesCreate

Create one or more console server port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesCreateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesCreate(ctx context.Context) ApiDcimConsoleServerPortTemplatesCreateRequest {
	return ApiDcimConsoleServerPortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimAPIService) DcimConsoleServerPortTemplatesCreateExecute(r ApiDcimConsoleServerPortTemplatesCreateRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableConsoleServerPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableConsoleServerPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableConsoleServerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortTemplatesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesDestroyExecute(r)
}

/*
DcimConsoleServerPortTemplatesDestroy Method for DcimConsoleServerPortTemplatesDestroy

Destroy a console server port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesDestroyRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesDestroy(ctx context.Context, id string) ApiDcimConsoleServerPortTemplatesDestroyRequest {
	return ApiDcimConsoleServerPortTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimConsoleServerPortTemplatesDestroyExecute(r ApiDcimConsoleServerPortTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceType *[]string
	deviceTypeN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) Description(description []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.description = &description
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionIre(descriptionIre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionN(descriptionN []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionNire(descriptionNire []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionNre(descriptionNre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

// Description
func (r ApiDcimConsoleServerPortTemplatesListRequest) DescriptionRe(descriptionRe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) DeviceType(deviceType []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesListRequest {
	r.format = &format
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) Id(id []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.id = &id
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdIc(idIc []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idIc = &idIc
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdIe(idIe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idIe = &idIe
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdIew(idIew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idIew = &idIew
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdIre(idIre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idIre = &idIre
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdIsw(idIsw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idIsw = &idIsw
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdN(idN []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idN = &idN
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdNic(idNic []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idNic = &idNic
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdNie(idNie []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idNie = &idNie
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdNiew(idNiew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idNiew = &idNiew
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdNire(idNire []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idNire = &idNire
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdNisw(idNisw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idNisw = &idNisw
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdNre(idNre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idNre = &idNre
	return r
}

// ID
func (r ApiDcimConsoleServerPortTemplatesListRequest) IdRe(idRe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.idRe = &idRe
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) Label(label []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.label = &label
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelIc(labelIc []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelIc = &labelIc
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelIe(labelIe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelIe = &labelIe
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelIew(labelIew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelIew = &labelIew
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelIre(labelIre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelIre = &labelIre
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelIsw(labelIsw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelIsw = &labelIsw
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelN(labelN []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelN = &labelN
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelNic(labelNic []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelNic = &labelNic
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelNie(labelNie []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelNie = &labelNie
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelNiew(labelNiew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelNiew = &labelNiew
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelNire(labelNire []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelNire = &labelNire
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelNisw(labelNisw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelNisw = &labelNisw
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelNre(labelNre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelNre = &labelNre
	return r
}

// Label
func (r ApiDcimConsoleServerPortTemplatesListRequest) LabelRe(labelRe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimConsoleServerPortTemplatesListRequest) Limit(limit int32) ApiDcimConsoleServerPortTemplatesListRequest {
	r.limit = &limit
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) Name(name []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.name = &name
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIc(nameIc []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIe(nameIe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIew(nameIew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIre(nameIre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIre = &nameIre
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameIsw(nameIsw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameN(nameN []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNic(nameNic []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNie(nameNie []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNiew(nameNiew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNire(nameNire []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNire = &nameNire
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNisw(nameNisw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameNre(nameNre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameNre = &nameNre
	return r
}

// Name
func (r ApiDcimConsoleServerPortTemplatesListRequest) NameRe(nameRe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsoleServerPortTemplatesListRequest) Offset(offset int32) ApiDcimConsoleServerPortTemplatesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimConsoleServerPortTemplatesListRequest) Q(q string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimConsoleServerPortTemplatesListRequest) Sort(sort string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) Type_(type_ []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeIc(typeIc []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeIe(typeIe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeIew(typeIew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeIre(typeIre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeIsw(typeIsw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeN(typeN []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeNic(typeNic []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeNie(typeNie []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeNiew(typeNiew []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeNire(typeNire []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeNisw(typeNisw []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeNre(typeNre []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) TypeRe(typeRe []string) ApiDcimConsoleServerPortTemplatesListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimConsoleServerPortTemplatesListRequest) Depth(depth int32) ApiDcimConsoleServerPortTemplatesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsoleServerPortTemplatesListRequest) Execute() (*PaginatedConsoleServerPortTemplateList, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesListExecute(r)
}

/*
DcimConsoleServerPortTemplatesList Method for DcimConsoleServerPortTemplatesList

Retrieve a list of console server port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortTemplatesListRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesList(ctx context.Context) ApiDcimConsoleServerPortTemplatesListRequest {
	return ApiDcimConsoleServerPortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedConsoleServerPortTemplateList
func (a *DcimAPIService) DcimConsoleServerPortTemplatesListExecute(r ApiDcimConsoleServerPortTemplatesListRequest) (*PaginatedConsoleServerPortTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedConsoleServerPortTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortTemplatesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimConsoleServerPortTemplatesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimConsoleServerPortTemplatesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortTemplatesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesNotesCreateExecute(r)
}

/*
DcimConsoleServerPortTemplatesNotesCreate Method for DcimConsoleServerPortTemplatesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesNotesCreateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesNotesCreate(ctx context.Context, id string) ApiDcimConsoleServerPortTemplatesNotesCreateRequest {
	return ApiDcimConsoleServerPortTemplatesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimConsoleServerPortTemplatesNotesCreateExecute(r ApiDcimConsoleServerPortTemplatesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimConsoleServerPortTemplatesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimConsoleServerPortTemplatesNotesListRequest) Limit(limit int32) ApiDcimConsoleServerPortTemplatesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsoleServerPortTemplatesNotesListRequest) Offset(offset int32) ApiDcimConsoleServerPortTemplatesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimConsoleServerPortTemplatesNotesListRequest) Depth(depth int32) ApiDcimConsoleServerPortTemplatesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsoleServerPortTemplatesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesNotesListExecute(r)
}

/*
DcimConsoleServerPortTemplatesNotesList Method for DcimConsoleServerPortTemplatesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesNotesListRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesNotesList(ctx context.Context, id string) ApiDcimConsoleServerPortTemplatesNotesListRequest {
	return ApiDcimConsoleServerPortTemplatesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimConsoleServerPortTemplatesNotesListExecute(r ApiDcimConsoleServerPortTemplatesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableConsoleServerPortTemplateRequest *PatchedWritableConsoleServerPortTemplateRequest
}

func (r ApiDcimConsoleServerPortTemplatesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortTemplatesPartialUpdateRequest) PatchedWritableConsoleServerPortTemplateRequest(patchedWritableConsoleServerPortTemplateRequest PatchedWritableConsoleServerPortTemplateRequest) ApiDcimConsoleServerPortTemplatesPartialUpdateRequest {
	r.patchedWritableConsoleServerPortTemplateRequest = &patchedWritableConsoleServerPortTemplateRequest
	return r
}

func (r ApiDcimConsoleServerPortTemplatesPartialUpdateRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesPartialUpdateExecute(r)
}

/*
DcimConsoleServerPortTemplatesPartialUpdate Method for DcimConsoleServerPortTemplatesPartialUpdate

Partial update a console server port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesPartialUpdate(ctx context.Context, id string) ApiDcimConsoleServerPortTemplatesPartialUpdateRequest {
	return ApiDcimConsoleServerPortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimAPIService) DcimConsoleServerPortTemplatesPartialUpdateExecute(r ApiDcimConsoleServerPortTemplatesPartialUpdateRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableConsoleServerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimConsoleServerPortTemplatesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimConsoleServerPortTemplatesRetrieveRequest) Depth(depth int32) ApiDcimConsoleServerPortTemplatesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsoleServerPortTemplatesRetrieveRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesRetrieveExecute(r)
}

/*
DcimConsoleServerPortTemplatesRetrieve Method for DcimConsoleServerPortTemplatesRetrieve

Retrieve a console server port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesRetrieveRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesRetrieve(ctx context.Context, id string) ApiDcimConsoleServerPortTemplatesRetrieveRequest {
	return ApiDcimConsoleServerPortTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimAPIService) DcimConsoleServerPortTemplatesRetrieveExecute(r ApiDcimConsoleServerPortTemplatesRetrieveRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableConsoleServerPortTemplateRequest *WritableConsoleServerPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortTemplatesUpdateRequest) WritableConsoleServerPortTemplateRequest(writableConsoleServerPortTemplateRequest WritableConsoleServerPortTemplateRequest) ApiDcimConsoleServerPortTemplatesUpdateRequest {
	r.writableConsoleServerPortTemplateRequest = &writableConsoleServerPortTemplateRequest
	return r
}

func (r ApiDcimConsoleServerPortTemplatesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortTemplatesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortTemplatesUpdateRequest) Execute() (*ConsoleServerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortTemplatesUpdateExecute(r)
}

/*
DcimConsoleServerPortTemplatesUpdate Method for DcimConsoleServerPortTemplatesUpdate

Update a console server port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port template.
 @return ApiDcimConsoleServerPortTemplatesUpdateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortTemplatesUpdate(ctx context.Context, id string) ApiDcimConsoleServerPortTemplatesUpdateRequest {
	return ApiDcimConsoleServerPortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPortTemplate
func (a *DcimAPIService) DcimConsoleServerPortTemplatesUpdateExecute(r ApiDcimConsoleServerPortTemplatesUpdateRequest) (*ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableConsoleServerPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableConsoleServerPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableConsoleServerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimConsoleServerPortsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimConsoleServerPortsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsBulkDestroyExecute(r)
}

/*
DcimConsoleServerPortsBulkDestroy Method for DcimConsoleServerPortsBulkDestroy

Destroy a list of console server port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsBulkDestroy(ctx context.Context) ApiDcimConsoleServerPortsBulkDestroyRequest {
	return ApiDcimConsoleServerPortsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimConsoleServerPortsBulkDestroyExecute(r ApiDcimConsoleServerPortsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableConsoleServerPortRequest *[]PatchedBulkWritableConsoleServerPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortsBulkPartialUpdateRequest) PatchedBulkWritableConsoleServerPortRequest(patchedBulkWritableConsoleServerPortRequest []PatchedBulkWritableConsoleServerPortRequest) ApiDcimConsoleServerPortsBulkPartialUpdateRequest {
	r.patchedBulkWritableConsoleServerPortRequest = &patchedBulkWritableConsoleServerPortRequest
	return r
}

func (r ApiDcimConsoleServerPortsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortsBulkPartialUpdateRequest) Execute() ([]ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsBulkPartialUpdateExecute(r)
}

/*
DcimConsoleServerPortsBulkPartialUpdate Method for DcimConsoleServerPortsBulkPartialUpdate

Partial update a list of console server port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsBulkPartialUpdate(ctx context.Context) ApiDcimConsoleServerPortsBulkPartialUpdateRequest {
	return ApiDcimConsoleServerPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConsoleServerPort
func (a *DcimAPIService) DcimConsoleServerPortsBulkPartialUpdateExecute(r ApiDcimConsoleServerPortsBulkPartialUpdateRequest) ([]ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableConsoleServerPortRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableConsoleServerPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableConsoleServerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableConsoleServerPortRequest *[]BulkWritableConsoleServerPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortsBulkUpdateRequest) BulkWritableConsoleServerPortRequest(bulkWritableConsoleServerPortRequest []BulkWritableConsoleServerPortRequest) ApiDcimConsoleServerPortsBulkUpdateRequest {
	r.bulkWritableConsoleServerPortRequest = &bulkWritableConsoleServerPortRequest
	return r
}

func (r ApiDcimConsoleServerPortsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortsBulkUpdateRequest) Execute() ([]ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsBulkUpdateExecute(r)
}

/*
DcimConsoleServerPortsBulkUpdate Method for DcimConsoleServerPortsBulkUpdate

Update a list of console server port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsBulkUpdate(ctx context.Context) ApiDcimConsoleServerPortsBulkUpdateRequest {
	return ApiDcimConsoleServerPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConsoleServerPort
func (a *DcimAPIService) DcimConsoleServerPortsBulkUpdateExecute(r ApiDcimConsoleServerPortsBulkUpdateRequest) ([]ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableConsoleServerPortRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableConsoleServerPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableConsoleServerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableConsoleServerPortRequest *WritableConsoleServerPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortsCreateRequest) WritableConsoleServerPortRequest(writableConsoleServerPortRequest WritableConsoleServerPortRequest) ApiDcimConsoleServerPortsCreateRequest {
	r.writableConsoleServerPortRequest = &writableConsoleServerPortRequest
	return r
}

func (r ApiDcimConsoleServerPortsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortsCreateRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsCreateExecute(r)
}

/*
DcimConsoleServerPortsCreate Method for DcimConsoleServerPortsCreate

Create one or more console server port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsCreateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsCreate(ctx context.Context) ApiDcimConsoleServerPortsCreateRequest {
	return ApiDcimConsoleServerPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimAPIService) DcimConsoleServerPortsCreateExecute(r ApiDcimConsoleServerPortsCreateRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableConsoleServerPortRequest == nil {
		return localVarReturnValue, nil, reportError("writableConsoleServerPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableConsoleServerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsDestroyExecute(r)
}

/*
DcimConsoleServerPortsDestroy Method for DcimConsoleServerPortsDestroy

Destroy a console server port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port.
 @return ApiDcimConsoleServerPortsDestroyRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsDestroy(ctx context.Context, id string) ApiDcimConsoleServerPortsDestroyRequest {
	return ApiDcimConsoleServerPortsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimConsoleServerPortsDestroyExecute(r ApiDcimConsoleServerPortsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	cable *[]string
	cableIsnull *bool
	cableN *[]string
	connected *bool
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasCable *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Cable
func (r ApiDcimConsoleServerPortsListRequest) Cable(cable []string) ApiDcimConsoleServerPortsListRequest {
	r.cable = &cable
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) CableIsnull(cableIsnull bool) ApiDcimConsoleServerPortsListRequest {
	r.cableIsnull = &cableIsnull
	return r
}

// Cable
func (r ApiDcimConsoleServerPortsListRequest) CableN(cableN []string) ApiDcimConsoleServerPortsListRequest {
	r.cableN = &cableN
	return r
}

// Connected status (bool)
func (r ApiDcimConsoleServerPortsListRequest) Connected(connected bool) ApiDcimConsoleServerPortsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Description(description []string) ApiDcimConsoleServerPortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIc(descriptionIc []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIe(descriptionIe []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIew(descriptionIew []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIre(descriptionIre []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionN(descriptionN []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNic(descriptionNic []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNie(descriptionNie []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNire(descriptionNire []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionNre(descriptionNre []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DescriptionRe(descriptionRe []string) ApiDcimConsoleServerPortsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Device(device []string) ApiDcimConsoleServerPortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) DeviceN(deviceN []string) ApiDcimConsoleServerPortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsListRequest {
	r.format = &format
	return r
}

// Has cable
func (r ApiDcimConsoleServerPortsListRequest) HasCable(hasCable bool) ApiDcimConsoleServerPortsListRequest {
	r.hasCable = &hasCable
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimConsoleServerPortsListRequest) Id(id []string) ApiDcimConsoleServerPortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdIc(idIc []string) ApiDcimConsoleServerPortsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdIe(idIe []string) ApiDcimConsoleServerPortsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdIew(idIew []string) ApiDcimConsoleServerPortsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdIre(idIre []string) ApiDcimConsoleServerPortsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdIsw(idIsw []string) ApiDcimConsoleServerPortsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdN(idN []string) ApiDcimConsoleServerPortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdNic(idNic []string) ApiDcimConsoleServerPortsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdNie(idNie []string) ApiDcimConsoleServerPortsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdNiew(idNiew []string) ApiDcimConsoleServerPortsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdNire(idNire []string) ApiDcimConsoleServerPortsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdNisw(idNisw []string) ApiDcimConsoleServerPortsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdNre(idNre []string) ApiDcimConsoleServerPortsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) IdRe(idRe []string) ApiDcimConsoleServerPortsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Label(label []string) ApiDcimConsoleServerPortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIc(labelIc []string) ApiDcimConsoleServerPortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIe(labelIe []string) ApiDcimConsoleServerPortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIew(labelIew []string) ApiDcimConsoleServerPortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIre(labelIre []string) ApiDcimConsoleServerPortsListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelIsw(labelIsw []string) ApiDcimConsoleServerPortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelN(labelN []string) ApiDcimConsoleServerPortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNic(labelNic []string) ApiDcimConsoleServerPortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNie(labelNie []string) ApiDcimConsoleServerPortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNiew(labelNiew []string) ApiDcimConsoleServerPortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNire(labelNire []string) ApiDcimConsoleServerPortsListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNisw(labelNisw []string) ApiDcimConsoleServerPortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelNre(labelNre []string) ApiDcimConsoleServerPortsListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LabelRe(labelRe []string) ApiDcimConsoleServerPortsListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimConsoleServerPortsListRequest) Limit(limit int32) ApiDcimConsoleServerPortsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Location(location []string) ApiDcimConsoleServerPortsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) LocationN(locationN []string) ApiDcimConsoleServerPortsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Name(name []string) ApiDcimConsoleServerPortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIc(nameIc []string) ApiDcimConsoleServerPortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIe(nameIe []string) ApiDcimConsoleServerPortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIew(nameIew []string) ApiDcimConsoleServerPortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIre(nameIre []string) ApiDcimConsoleServerPortsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameIsw(nameIsw []string) ApiDcimConsoleServerPortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameN(nameN []string) ApiDcimConsoleServerPortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNic(nameNic []string) ApiDcimConsoleServerPortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNie(nameNie []string) ApiDcimConsoleServerPortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNiew(nameNiew []string) ApiDcimConsoleServerPortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNire(nameNire []string) ApiDcimConsoleServerPortsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNisw(nameNisw []string) ApiDcimConsoleServerPortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameNre(nameNre []string) ApiDcimConsoleServerPortsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) NameRe(nameRe []string) ApiDcimConsoleServerPortsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsoleServerPortsListRequest) Offset(offset int32) ApiDcimConsoleServerPortsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimConsoleServerPortsListRequest) Q(q string) ApiDcimConsoleServerPortsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimConsoleServerPortsListRequest) Sort(sort string) ApiDcimConsoleServerPortsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Tags(tags []string) ApiDcimConsoleServerPortsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimConsoleServerPortsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) TagsN(tagsN []string) ApiDcimConsoleServerPortsListRequest {
	r.tagsN = &tagsN
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) Type_(type_ []string) ApiDcimConsoleServerPortsListRequest {
	r.type_ = &type_
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeIc(typeIc []string) ApiDcimConsoleServerPortsListRequest {
	r.typeIc = &typeIc
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeIe(typeIe []string) ApiDcimConsoleServerPortsListRequest {
	r.typeIe = &typeIe
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeIew(typeIew []string) ApiDcimConsoleServerPortsListRequest {
	r.typeIew = &typeIew
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeIre(typeIre []string) ApiDcimConsoleServerPortsListRequest {
	r.typeIre = &typeIre
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeIsw(typeIsw []string) ApiDcimConsoleServerPortsListRequest {
	r.typeIsw = &typeIsw
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeN(typeN []string) ApiDcimConsoleServerPortsListRequest {
	r.typeN = &typeN
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeNic(typeNic []string) ApiDcimConsoleServerPortsListRequest {
	r.typeNic = &typeNic
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeNie(typeNie []string) ApiDcimConsoleServerPortsListRequest {
	r.typeNie = &typeNie
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeNiew(typeNiew []string) ApiDcimConsoleServerPortsListRequest {
	r.typeNiew = &typeNiew
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeNire(typeNire []string) ApiDcimConsoleServerPortsListRequest {
	r.typeNire = &typeNire
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeNisw(typeNisw []string) ApiDcimConsoleServerPortsListRequest {
	r.typeNisw = &typeNisw
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeNre(typeNre []string) ApiDcimConsoleServerPortsListRequest {
	r.typeNre = &typeNre
	return r
}

// Physical port type
func (r ApiDcimConsoleServerPortsListRequest) TypeRe(typeRe []string) ApiDcimConsoleServerPortsListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimConsoleServerPortsListRequest) Depth(depth int32) ApiDcimConsoleServerPortsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsoleServerPortsListRequest) Execute() (*PaginatedConsoleServerPortList, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsListExecute(r)
}

/*
DcimConsoleServerPortsList Method for DcimConsoleServerPortsList

Retrieve a list of console server port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimConsoleServerPortsListRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsList(ctx context.Context) ApiDcimConsoleServerPortsListRequest {
	return ApiDcimConsoleServerPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedConsoleServerPortList
func (a *DcimAPIService) DcimConsoleServerPortsListExecute(r ApiDcimConsoleServerPortsListRequest) (*PaginatedConsoleServerPortList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedConsoleServerPortList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cable != nil {
		t := *r.cable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable", t, "multi")
		}
	}
	if r.cableIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cable__isnull", r.cableIsnull, "")
	}
	if r.cableN != nil {
		t := *r.cableN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", t, "multi")
		}
	}
	if r.connected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connected", r.connected, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasCable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_cable", r.hasCable, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimConsoleServerPortsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimConsoleServerPortsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsNotesCreateExecute(r)
}

/*
DcimConsoleServerPortsNotesCreate Method for DcimConsoleServerPortsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port.
 @return ApiDcimConsoleServerPortsNotesCreateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsNotesCreate(ctx context.Context, id string) ApiDcimConsoleServerPortsNotesCreateRequest {
	return ApiDcimConsoleServerPortsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimConsoleServerPortsNotesCreateExecute(r ApiDcimConsoleServerPortsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimConsoleServerPortsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimConsoleServerPortsNotesListRequest) Limit(limit int32) ApiDcimConsoleServerPortsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimConsoleServerPortsNotesListRequest) Offset(offset int32) ApiDcimConsoleServerPortsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimConsoleServerPortsNotesListRequest) Depth(depth int32) ApiDcimConsoleServerPortsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsoleServerPortsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsNotesListExecute(r)
}

/*
DcimConsoleServerPortsNotesList Method for DcimConsoleServerPortsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port.
 @return ApiDcimConsoleServerPortsNotesListRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsNotesList(ctx context.Context, id string) ApiDcimConsoleServerPortsNotesListRequest {
	return ApiDcimConsoleServerPortsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimConsoleServerPortsNotesListExecute(r ApiDcimConsoleServerPortsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableConsoleServerPortRequest *PatchedWritableConsoleServerPortRequest
}

func (r ApiDcimConsoleServerPortsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortsPartialUpdateRequest) PatchedWritableConsoleServerPortRequest(patchedWritableConsoleServerPortRequest PatchedWritableConsoleServerPortRequest) ApiDcimConsoleServerPortsPartialUpdateRequest {
	r.patchedWritableConsoleServerPortRequest = &patchedWritableConsoleServerPortRequest
	return r
}

func (r ApiDcimConsoleServerPortsPartialUpdateRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsPartialUpdateExecute(r)
}

/*
DcimConsoleServerPortsPartialUpdate Method for DcimConsoleServerPortsPartialUpdate

Partial update a console server port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port.
 @return ApiDcimConsoleServerPortsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsPartialUpdate(ctx context.Context, id string) ApiDcimConsoleServerPortsPartialUpdateRequest {
	return ApiDcimConsoleServerPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimAPIService) DcimConsoleServerPortsPartialUpdateExecute(r ApiDcimConsoleServerPortsPartialUpdateRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableConsoleServerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimConsoleServerPortsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimConsoleServerPortsRetrieveRequest) Depth(depth int32) ApiDcimConsoleServerPortsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsoleServerPortsRetrieveRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsRetrieveExecute(r)
}

/*
DcimConsoleServerPortsRetrieve Method for DcimConsoleServerPortsRetrieve

Retrieve a console server port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port.
 @return ApiDcimConsoleServerPortsRetrieveRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsRetrieve(ctx context.Context, id string) ApiDcimConsoleServerPortsRetrieveRequest {
	return ApiDcimConsoleServerPortsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimAPIService) DcimConsoleServerPortsRetrieveExecute(r ApiDcimConsoleServerPortsRetrieveRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsTraceRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimConsoleServerPortsTraceRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsTraceRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimConsoleServerPortsTraceRetrieveRequest) Depth(depth int32) ApiDcimConsoleServerPortsTraceRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimConsoleServerPortsTraceRetrieveRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsTraceRetrieveExecute(r)
}

/*
DcimConsoleServerPortsTraceRetrieve Method for DcimConsoleServerPortsTraceRetrieve

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port.
 @return ApiDcimConsoleServerPortsTraceRetrieveRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsTraceRetrieve(ctx context.Context, id string) ApiDcimConsoleServerPortsTraceRetrieveRequest {
	return ApiDcimConsoleServerPortsTraceRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimAPIService) DcimConsoleServerPortsTraceRetrieveExecute(r ApiDcimConsoleServerPortsTraceRetrieveRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsTraceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimConsoleServerPortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableConsoleServerPortRequest *WritableConsoleServerPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimConsoleServerPortsUpdateRequest) WritableConsoleServerPortRequest(writableConsoleServerPortRequest WritableConsoleServerPortRequest) ApiDcimConsoleServerPortsUpdateRequest {
	r.writableConsoleServerPortRequest = &writableConsoleServerPortRequest
	return r
}

func (r ApiDcimConsoleServerPortsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimConsoleServerPortsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimConsoleServerPortsUpdateRequest) Execute() (*ConsoleServerPort, *http.Response, error) {
	return r.ApiService.DcimConsoleServerPortsUpdateExecute(r)
}

/*
DcimConsoleServerPortsUpdate Method for DcimConsoleServerPortsUpdate

Update a console server port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this console server port.
 @return ApiDcimConsoleServerPortsUpdateRequest
*/
func (a *DcimAPIService) DcimConsoleServerPortsUpdate(ctx context.Context, id string) ApiDcimConsoleServerPortsUpdateRequest {
	return ApiDcimConsoleServerPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleServerPort
func (a *DcimAPIService) DcimConsoleServerPortsUpdateExecute(r ApiDcimConsoleServerPortsUpdateRequest) (*ConsoleServerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleServerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimConsoleServerPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableConsoleServerPortRequest == nil {
		return localVarReturnValue, nil, reportError("writableConsoleServerPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableConsoleServerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsBulkDestroyExecute(r)
}

/*
DcimControllerManagedDeviceGroupsBulkDestroy Method for DcimControllerManagedDeviceGroupsBulkDestroy

Destroy a list of controller managed device group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsBulkDestroy(ctx context.Context) ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest {
	return ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsBulkDestroyExecute(r ApiDcimControllerManagedDeviceGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableControllerManagedDeviceGroupRequest *[]PatchedBulkWritableControllerManagedDeviceGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest) PatchedBulkWritableControllerManagedDeviceGroupRequest(patchedBulkWritableControllerManagedDeviceGroupRequest []PatchedBulkWritableControllerManagedDeviceGroupRequest) ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest {
	r.patchedBulkWritableControllerManagedDeviceGroupRequest = &patchedBulkWritableControllerManagedDeviceGroupRequest
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest) Execute() ([]ControllerManagedDeviceGroup, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsBulkPartialUpdateExecute(r)
}

/*
DcimControllerManagedDeviceGroupsBulkPartialUpdate Method for DcimControllerManagedDeviceGroupsBulkPartialUpdate

Partial update a list of controller managed device group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsBulkPartialUpdate(ctx context.Context) ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest {
	return ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ControllerManagedDeviceGroup
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsBulkPartialUpdateExecute(r ApiDcimControllerManagedDeviceGroupsBulkPartialUpdateRequest) ([]ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ControllerManagedDeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableControllerManagedDeviceGroupRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableControllerManagedDeviceGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableControllerManagedDeviceGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableControllerManagedDeviceGroupRequest *[]BulkWritableControllerManagedDeviceGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest) BulkWritableControllerManagedDeviceGroupRequest(bulkWritableControllerManagedDeviceGroupRequest []BulkWritableControllerManagedDeviceGroupRequest) ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest {
	r.bulkWritableControllerManagedDeviceGroupRequest = &bulkWritableControllerManagedDeviceGroupRequest
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest) Execute() ([]ControllerManagedDeviceGroup, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsBulkUpdateExecute(r)
}

/*
DcimControllerManagedDeviceGroupsBulkUpdate Method for DcimControllerManagedDeviceGroupsBulkUpdate

Update a list of controller managed device group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsBulkUpdate(ctx context.Context) ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest {
	return ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ControllerManagedDeviceGroup
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsBulkUpdateExecute(r ApiDcimControllerManagedDeviceGroupsBulkUpdateRequest) ([]ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ControllerManagedDeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableControllerManagedDeviceGroupRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableControllerManagedDeviceGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableControllerManagedDeviceGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	controllerManagedDeviceGroupRequest *ControllerManagedDeviceGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllerManagedDeviceGroupsCreateRequest) ControllerManagedDeviceGroupRequest(controllerManagedDeviceGroupRequest ControllerManagedDeviceGroupRequest) ApiDcimControllerManagedDeviceGroupsCreateRequest {
	r.controllerManagedDeviceGroupRequest = &controllerManagedDeviceGroupRequest
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsCreateRequest) Execute() (*ControllerManagedDeviceGroup, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsCreateExecute(r)
}

/*
DcimControllerManagedDeviceGroupsCreate Method for DcimControllerManagedDeviceGroupsCreate

Create one or more controller managed device group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllerManagedDeviceGroupsCreateRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsCreate(ctx context.Context) ApiDcimControllerManagedDeviceGroupsCreateRequest {
	return ApiDcimControllerManagedDeviceGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ControllerManagedDeviceGroup
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsCreateExecute(r ApiDcimControllerManagedDeviceGroupsCreateRequest) (*ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerManagedDeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.controllerManagedDeviceGroupRequest == nil {
		return localVarReturnValue, nil, reportError("controllerManagedDeviceGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.controllerManagedDeviceGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllerManagedDeviceGroupsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsDestroyExecute(r)
}

/*
DcimControllerManagedDeviceGroupsDestroy Method for DcimControllerManagedDeviceGroupsDestroy

Destroy a controller managed device group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller managed device group.
 @return ApiDcimControllerManagedDeviceGroupsDestroyRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsDestroy(ctx context.Context, id string) ApiDcimControllerManagedDeviceGroupsDestroyRequest {
	return ApiDcimControllerManagedDeviceGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsDestroyExecute(r ApiDcimControllerManagedDeviceGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	controller *[]string
	controllerN *[]string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	parent *[]string
	parentIsnull *bool
	parentN *[]string
	q *string
	sort *string
	subtree *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	weight *[]int32
	weightGt *[]int32
	weightGte *[]int32
	weightLt *[]int32
	weightLte *[]int32
	weightN *[]int32
	depth *int32
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Controller(controller []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.controller = &controller
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) ControllerN(controllerN []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.controllerN = &controllerN
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Created(created []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) CreatedGt(createdGt []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) CreatedGte(createdGte []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) CreatedLt(createdLt []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) CreatedLte(createdLte []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) CreatedN(createdN []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimControllerManagedDeviceGroupsListRequest) Id(id []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdIc(idIc []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdIe(idIe []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdIew(idIew []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdIre(idIre []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdIsw(idIsw []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdN(idN []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdNic(idNic []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdNie(idNie []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdNiew(idNiew []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdNire(idNire []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdNisw(idNisw []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdNre(idNre []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) IdRe(idRe []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimControllerManagedDeviceGroupsListRequest) Limit(limit int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Name(name []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameIc(nameIc []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameIe(nameIe []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameIew(nameIew []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameIre(nameIre []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameIsw(nameIsw []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameN(nameN []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameNic(nameNic []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameNie(nameNie []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameNiew(nameNiew []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameNire(nameNire []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameNisw(nameNisw []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameNre(nameNre []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) NameRe(nameRe []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimControllerManagedDeviceGroupsListRequest) Offset(offset int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Parent(parent []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.parent = &parent
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) ParentIsnull(parentIsnull bool) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.parentIsnull = &parentIsnull
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) ParentN(parentN []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.parentN = &parentN
	return r
}

// Search
func (r ApiDcimControllerManagedDeviceGroupsListRequest) Q(q string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimControllerManagedDeviceGroupsListRequest) Sort(sort string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Subtree(subtree []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.subtree = &subtree
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Tags(tags []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) TagsN(tagsN []string) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Weight(weight []int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.weight = &weight
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) WeightGt(weightGt []int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.weightGt = &weightGt
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) WeightGte(weightGte []int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.weightGte = &weightGte
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) WeightLt(weightLt []int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.weightLt = &weightLt
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) WeightLte(weightLte []int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.weightLte = &weightLte
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) WeightN(weightN []int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.weightN = &weightN
	return r
}

// Serializer Depth
func (r ApiDcimControllerManagedDeviceGroupsListRequest) Depth(depth int32) ApiDcimControllerManagedDeviceGroupsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsListRequest) Execute() (*PaginatedControllerManagedDeviceGroupList, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsListExecute(r)
}

/*
DcimControllerManagedDeviceGroupsList Method for DcimControllerManagedDeviceGroupsList

Retrieve a list of controller managed device group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllerManagedDeviceGroupsListRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsList(ctx context.Context) ApiDcimControllerManagedDeviceGroupsListRequest {
	return ApiDcimControllerManagedDeviceGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedControllerManagedDeviceGroupList
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsListExecute(r ApiDcimControllerManagedDeviceGroupsListRequest) (*PaginatedControllerManagedDeviceGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedControllerManagedDeviceGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.controller != nil {
		t := *r.controller
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "controller", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "controller", t, "multi")
		}
	}
	if r.controllerN != nil {
		t := *r.controllerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "controller__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "controller__n", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "multi")
		}
	}
	if r.parentIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent__isnull", r.parentIsnull, "")
	}
	if r.parentN != nil {
		t := *r.parentN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.subtree != nil {
		t := *r.subtree
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subtree", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subtree", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.weight != nil {
		t := *r.weight
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight", t, "multi")
		}
	}
	if r.weightGt != nil {
		t := *r.weightGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gt", t, "multi")
		}
	}
	if r.weightGte != nil {
		t := *r.weightGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gte", t, "multi")
		}
	}
	if r.weightLt != nil {
		t := *r.weightLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lt", t, "multi")
		}
	}
	if r.weightLte != nil {
		t := *r.weightLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lte", t, "multi")
		}
	}
	if r.weightN != nil {
		t := *r.weightN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllerManagedDeviceGroupsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimControllerManagedDeviceGroupsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsNotesCreateExecute(r)
}

/*
DcimControllerManagedDeviceGroupsNotesCreate Method for DcimControllerManagedDeviceGroupsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller managed device group.
 @return ApiDcimControllerManagedDeviceGroupsNotesCreateRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsNotesCreate(ctx context.Context, id string) ApiDcimControllerManagedDeviceGroupsNotesCreateRequest {
	return ApiDcimControllerManagedDeviceGroupsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsNotesCreateExecute(r ApiDcimControllerManagedDeviceGroupsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimControllerManagedDeviceGroupsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimControllerManagedDeviceGroupsNotesListRequest) Limit(limit int32) ApiDcimControllerManagedDeviceGroupsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimControllerManagedDeviceGroupsNotesListRequest) Offset(offset int32) ApiDcimControllerManagedDeviceGroupsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimControllerManagedDeviceGroupsNotesListRequest) Depth(depth int32) ApiDcimControllerManagedDeviceGroupsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsNotesListExecute(r)
}

/*
DcimControllerManagedDeviceGroupsNotesList Method for DcimControllerManagedDeviceGroupsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller managed device group.
 @return ApiDcimControllerManagedDeviceGroupsNotesListRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsNotesList(ctx context.Context, id string) ApiDcimControllerManagedDeviceGroupsNotesListRequest {
	return ApiDcimControllerManagedDeviceGroupsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsNotesListExecute(r ApiDcimControllerManagedDeviceGroupsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedControllerManagedDeviceGroupRequest *PatchedControllerManagedDeviceGroupRequest
}

func (r ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest) PatchedControllerManagedDeviceGroupRequest(patchedControllerManagedDeviceGroupRequest PatchedControllerManagedDeviceGroupRequest) ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest {
	r.patchedControllerManagedDeviceGroupRequest = &patchedControllerManagedDeviceGroupRequest
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest) Execute() (*ControllerManagedDeviceGroup, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsPartialUpdateExecute(r)
}

/*
DcimControllerManagedDeviceGroupsPartialUpdate Method for DcimControllerManagedDeviceGroupsPartialUpdate

Partial update a controller managed device group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller managed device group.
 @return ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsPartialUpdate(ctx context.Context, id string) ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest {
	return ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ControllerManagedDeviceGroup
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsPartialUpdateExecute(r ApiDcimControllerManagedDeviceGroupsPartialUpdateRequest) (*ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerManagedDeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedControllerManagedDeviceGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimControllerManagedDeviceGroupsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimControllerManagedDeviceGroupsRetrieveRequest) Depth(depth int32) ApiDcimControllerManagedDeviceGroupsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsRetrieveRequest) Execute() (*ControllerManagedDeviceGroup, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsRetrieveExecute(r)
}

/*
DcimControllerManagedDeviceGroupsRetrieve Method for DcimControllerManagedDeviceGroupsRetrieve

Retrieve a controller managed device group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller managed device group.
 @return ApiDcimControllerManagedDeviceGroupsRetrieveRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsRetrieve(ctx context.Context, id string) ApiDcimControllerManagedDeviceGroupsRetrieveRequest {
	return ApiDcimControllerManagedDeviceGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ControllerManagedDeviceGroup
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsRetrieveExecute(r ApiDcimControllerManagedDeviceGroupsRetrieveRequest) (*ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerManagedDeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllerManagedDeviceGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	controllerManagedDeviceGroupRequest *ControllerManagedDeviceGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllerManagedDeviceGroupsUpdateRequest) ControllerManagedDeviceGroupRequest(controllerManagedDeviceGroupRequest ControllerManagedDeviceGroupRequest) ApiDcimControllerManagedDeviceGroupsUpdateRequest {
	r.controllerManagedDeviceGroupRequest = &controllerManagedDeviceGroupRequest
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllerManagedDeviceGroupsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllerManagedDeviceGroupsUpdateRequest) Execute() (*ControllerManagedDeviceGroup, *http.Response, error) {
	return r.ApiService.DcimControllerManagedDeviceGroupsUpdateExecute(r)
}

/*
DcimControllerManagedDeviceGroupsUpdate Method for DcimControllerManagedDeviceGroupsUpdate

Update a controller managed device group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller managed device group.
 @return ApiDcimControllerManagedDeviceGroupsUpdateRequest
*/
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsUpdate(ctx context.Context, id string) ApiDcimControllerManagedDeviceGroupsUpdateRequest {
	return ApiDcimControllerManagedDeviceGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ControllerManagedDeviceGroup
func (a *DcimAPIService) DcimControllerManagedDeviceGroupsUpdateExecute(r ApiDcimControllerManagedDeviceGroupsUpdateRequest) (*ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerManagedDeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllerManagedDeviceGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controller-managed-device-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.controllerManagedDeviceGroupRequest == nil {
		return localVarReturnValue, nil, reportError("controllerManagedDeviceGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.controllerManagedDeviceGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllersBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimControllersBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimControllersBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllersBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimControllersBulkDestroyExecute(r)
}

/*
DcimControllersBulkDestroy Method for DcimControllersBulkDestroy

Destroy a list of controller objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllersBulkDestroyRequest
*/
func (a *DcimAPIService) DcimControllersBulkDestroy(ctx context.Context) ApiDcimControllersBulkDestroyRequest {
	return ApiDcimControllersBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimControllersBulkDestroyExecute(r ApiDcimControllersBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimControllersBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableControllerRequest *[]PatchedBulkWritableControllerRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllersBulkPartialUpdateRequest) PatchedBulkWritableControllerRequest(patchedBulkWritableControllerRequest []PatchedBulkWritableControllerRequest) ApiDcimControllersBulkPartialUpdateRequest {
	r.patchedBulkWritableControllerRequest = &patchedBulkWritableControllerRequest
	return r
}

func (r ApiDcimControllersBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllersBulkPartialUpdateRequest) Execute() ([]Controller, *http.Response, error) {
	return r.ApiService.DcimControllersBulkPartialUpdateExecute(r)
}

/*
DcimControllersBulkPartialUpdate Method for DcimControllersBulkPartialUpdate

Partial update a list of controller objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllersBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimControllersBulkPartialUpdate(ctx context.Context) ApiDcimControllersBulkPartialUpdateRequest {
	return ApiDcimControllersBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Controller
func (a *DcimAPIService) DcimControllersBulkPartialUpdateExecute(r ApiDcimControllersBulkPartialUpdateRequest) ([]Controller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Controller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableControllerRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableControllerRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableControllerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableControllerRequest *[]BulkWritableControllerRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllersBulkUpdateRequest) BulkWritableControllerRequest(bulkWritableControllerRequest []BulkWritableControllerRequest) ApiDcimControllersBulkUpdateRequest {
	r.bulkWritableControllerRequest = &bulkWritableControllerRequest
	return r
}

func (r ApiDcimControllersBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllersBulkUpdateRequest) Execute() ([]Controller, *http.Response, error) {
	return r.ApiService.DcimControllersBulkUpdateExecute(r)
}

/*
DcimControllersBulkUpdate Method for DcimControllersBulkUpdate

Update a list of controller objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllersBulkUpdateRequest
*/
func (a *DcimAPIService) DcimControllersBulkUpdate(ctx context.Context) ApiDcimControllersBulkUpdateRequest {
	return ApiDcimControllersBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Controller
func (a *DcimAPIService) DcimControllersBulkUpdateExecute(r ApiDcimControllersBulkUpdateRequest) ([]Controller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Controller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableControllerRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableControllerRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableControllerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	controllerRequest *ControllerRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllersCreateRequest) ControllerRequest(controllerRequest ControllerRequest) ApiDcimControllersCreateRequest {
	r.controllerRequest = &controllerRequest
	return r
}

func (r ApiDcimControllersCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllersCreateRequest) Execute() (*Controller, *http.Response, error) {
	return r.ApiService.DcimControllersCreateExecute(r)
}

/*
DcimControllersCreate Method for DcimControllersCreate

Create one or more controller objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllersCreateRequest
*/
func (a *DcimAPIService) DcimControllersCreate(ctx context.Context) ApiDcimControllersCreateRequest {
	return ApiDcimControllersCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Controller
func (a *DcimAPIService) DcimControllersCreateExecute(r ApiDcimControllersCreateRequest) (*Controller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Controller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.controllerRequest == nil {
		return localVarReturnValue, nil, reportError("controllerRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.controllerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllersDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllersDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimControllersDestroyExecute(r)
}

/*
DcimControllersDestroy Method for DcimControllersDestroy

Destroy a controller object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller.
 @return ApiDcimControllersDestroyRequest
*/
func (a *DcimAPIService) DcimControllersDestroy(ctx context.Context, id string) ApiDcimControllersDestroyRequest {
	return ApiDcimControllersDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimControllersDestroyExecute(r ApiDcimControllersDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimControllersListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	controllerDevice *[]string
	controllerDeviceIsnull *bool
	controllerDeviceN *[]string
	controllerDeviceRedundancyGroup *[]string
	controllerDeviceRedundancyGroupIsnull *bool
	controllerDeviceRedundancyGroupN *[]string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	externalIntegration *[]string
	externalIntegrationIsnull *bool
	externalIntegrationN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	platform *[]string
	platformIsnull *bool
	platformN *[]string
	q *string
	role *[]string
	roleIsnull *bool
	roleN *[]string
	sort *string
	status *[]string
	statusN *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	depth *int32
}

func (r ApiDcimControllersListRequest) ControllerDevice(controllerDevice []string) ApiDcimControllersListRequest {
	r.controllerDevice = &controllerDevice
	return r
}

func (r ApiDcimControllersListRequest) ControllerDeviceIsnull(controllerDeviceIsnull bool) ApiDcimControllersListRequest {
	r.controllerDeviceIsnull = &controllerDeviceIsnull
	return r
}

func (r ApiDcimControllersListRequest) ControllerDeviceN(controllerDeviceN []string) ApiDcimControllersListRequest {
	r.controllerDeviceN = &controllerDeviceN
	return r
}

func (r ApiDcimControllersListRequest) ControllerDeviceRedundancyGroup(controllerDeviceRedundancyGroup []string) ApiDcimControllersListRequest {
	r.controllerDeviceRedundancyGroup = &controllerDeviceRedundancyGroup
	return r
}

func (r ApiDcimControllersListRequest) ControllerDeviceRedundancyGroupIsnull(controllerDeviceRedundancyGroupIsnull bool) ApiDcimControllersListRequest {
	r.controllerDeviceRedundancyGroupIsnull = &controllerDeviceRedundancyGroupIsnull
	return r
}

func (r ApiDcimControllersListRequest) ControllerDeviceRedundancyGroupN(controllerDeviceRedundancyGroupN []string) ApiDcimControllersListRequest {
	r.controllerDeviceRedundancyGroupN = &controllerDeviceRedundancyGroupN
	return r
}

func (r ApiDcimControllersListRequest) Created(created []time.Time) ApiDcimControllersListRequest {
	r.created = &created
	return r
}

func (r ApiDcimControllersListRequest) CreatedGt(createdGt []time.Time) ApiDcimControllersListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimControllersListRequest) CreatedGte(createdGte []time.Time) ApiDcimControllersListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimControllersListRequest) CreatedIsnull(createdIsnull bool) ApiDcimControllersListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimControllersListRequest) CreatedLt(createdLt []time.Time) ApiDcimControllersListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimControllersListRequest) CreatedLte(createdLte []time.Time) ApiDcimControllersListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimControllersListRequest) CreatedN(createdN []time.Time) ApiDcimControllersListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimControllersListRequest) Description(description []string) ApiDcimControllersListRequest {
	r.description = &description
	return r
}

func (r ApiDcimControllersListRequest) DescriptionIc(descriptionIc []string) ApiDcimControllersListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimControllersListRequest) DescriptionIe(descriptionIe []string) ApiDcimControllersListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimControllersListRequest) DescriptionIew(descriptionIew []string) ApiDcimControllersListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimControllersListRequest) DescriptionIre(descriptionIre []string) ApiDcimControllersListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimControllersListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimControllersListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimControllersListRequest) DescriptionN(descriptionN []string) ApiDcimControllersListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimControllersListRequest) DescriptionNic(descriptionNic []string) ApiDcimControllersListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimControllersListRequest) DescriptionNie(descriptionNie []string) ApiDcimControllersListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimControllersListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimControllersListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimControllersListRequest) DescriptionNire(descriptionNire []string) ApiDcimControllersListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimControllersListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimControllersListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimControllersListRequest) DescriptionNre(descriptionNre []string) ApiDcimControllersListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimControllersListRequest) DescriptionRe(descriptionRe []string) ApiDcimControllersListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimControllersListRequest) ExternalIntegration(externalIntegration []string) ApiDcimControllersListRequest {
	r.externalIntegration = &externalIntegration
	return r
}

func (r ApiDcimControllersListRequest) ExternalIntegrationIsnull(externalIntegrationIsnull bool) ApiDcimControllersListRequest {
	r.externalIntegrationIsnull = &externalIntegrationIsnull
	return r
}

func (r ApiDcimControllersListRequest) ExternalIntegrationN(externalIntegrationN []string) ApiDcimControllersListRequest {
	r.externalIntegrationN = &externalIntegrationN
	return r
}

func (r ApiDcimControllersListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimControllersListRequest) Id(id []string) ApiDcimControllersListRequest {
	r.id = &id
	return r
}

func (r ApiDcimControllersListRequest) IdIc(idIc []string) ApiDcimControllersListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimControllersListRequest) IdIe(idIe []string) ApiDcimControllersListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimControllersListRequest) IdIew(idIew []string) ApiDcimControllersListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimControllersListRequest) IdIre(idIre []string) ApiDcimControllersListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimControllersListRequest) IdIsw(idIsw []string) ApiDcimControllersListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimControllersListRequest) IdN(idN []string) ApiDcimControllersListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimControllersListRequest) IdNic(idNic []string) ApiDcimControllersListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimControllersListRequest) IdNie(idNie []string) ApiDcimControllersListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimControllersListRequest) IdNiew(idNiew []string) ApiDcimControllersListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimControllersListRequest) IdNire(idNire []string) ApiDcimControllersListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimControllersListRequest) IdNisw(idNisw []string) ApiDcimControllersListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimControllersListRequest) IdNre(idNre []string) ApiDcimControllersListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimControllersListRequest) IdRe(idRe []string) ApiDcimControllersListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimControllersListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimControllersListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimControllersListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimControllersListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimControllersListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimControllersListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimControllersListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimControllersListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimControllersListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimControllersListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimControllersListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimControllersListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimControllersListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimControllersListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimControllersListRequest) Limit(limit int32) ApiDcimControllersListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimControllersListRequest) Location(location []string) ApiDcimControllersListRequest {
	r.location = &location
	return r
}

func (r ApiDcimControllersListRequest) LocationN(locationN []string) ApiDcimControllersListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimControllersListRequest) Name(name []string) ApiDcimControllersListRequest {
	r.name = &name
	return r
}

func (r ApiDcimControllersListRequest) NameIc(nameIc []string) ApiDcimControllersListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimControllersListRequest) NameIe(nameIe []string) ApiDcimControllersListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimControllersListRequest) NameIew(nameIew []string) ApiDcimControllersListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimControllersListRequest) NameIre(nameIre []string) ApiDcimControllersListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimControllersListRequest) NameIsw(nameIsw []string) ApiDcimControllersListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimControllersListRequest) NameN(nameN []string) ApiDcimControllersListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimControllersListRequest) NameNic(nameNic []string) ApiDcimControllersListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimControllersListRequest) NameNie(nameNie []string) ApiDcimControllersListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimControllersListRequest) NameNiew(nameNiew []string) ApiDcimControllersListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimControllersListRequest) NameNire(nameNire []string) ApiDcimControllersListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimControllersListRequest) NameNisw(nameNisw []string) ApiDcimControllersListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimControllersListRequest) NameNre(nameNre []string) ApiDcimControllersListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimControllersListRequest) NameRe(nameRe []string) ApiDcimControllersListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimControllersListRequest) Offset(offset int32) ApiDcimControllersListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimControllersListRequest) Platform(platform []string) ApiDcimControllersListRequest {
	r.platform = &platform
	return r
}

func (r ApiDcimControllersListRequest) PlatformIsnull(platformIsnull bool) ApiDcimControllersListRequest {
	r.platformIsnull = &platformIsnull
	return r
}

func (r ApiDcimControllersListRequest) PlatformN(platformN []string) ApiDcimControllersListRequest {
	r.platformN = &platformN
	return r
}

// Search
func (r ApiDcimControllersListRequest) Q(q string) ApiDcimControllersListRequest {
	r.q = &q
	return r
}

func (r ApiDcimControllersListRequest) Role(role []string) ApiDcimControllersListRequest {
	r.role = &role
	return r
}

func (r ApiDcimControllersListRequest) RoleIsnull(roleIsnull bool) ApiDcimControllersListRequest {
	r.roleIsnull = &roleIsnull
	return r
}

func (r ApiDcimControllersListRequest) RoleN(roleN []string) ApiDcimControllersListRequest {
	r.roleN = &roleN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimControllersListRequest) Sort(sort string) ApiDcimControllersListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimControllersListRequest) Status(status []string) ApiDcimControllersListRequest {
	r.status = &status
	return r
}

func (r ApiDcimControllersListRequest) StatusN(statusN []string) ApiDcimControllersListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimControllersListRequest) Tags(tags []string) ApiDcimControllersListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimControllersListRequest) TagsIsnull(tagsIsnull bool) ApiDcimControllersListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimControllersListRequest) TagsN(tagsN []string) ApiDcimControllersListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimControllersListRequest) Tenant(tenant []string) ApiDcimControllersListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimControllersListRequest) TenantIsnull(tenantIsnull bool) ApiDcimControllersListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiDcimControllersListRequest) TenantN(tenantN []string) ApiDcimControllersListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimControllersListRequest) TenantGroup(tenantGroup []string) ApiDcimControllersListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimControllersListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiDcimControllersListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiDcimControllersListRequest) TenantGroupN(tenantGroupN []string) ApiDcimControllersListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimControllersListRequest) TenantId(tenantId []*string) ApiDcimControllersListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimControllersListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiDcimControllersListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimControllersListRequest) TenantIdN(tenantIdN []*string) ApiDcimControllersListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// Serializer Depth
func (r ApiDcimControllersListRequest) Depth(depth int32) ApiDcimControllersListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimControllersListRequest) Execute() (*PaginatedControllerList, *http.Response, error) {
	return r.ApiService.DcimControllersListExecute(r)
}

/*
DcimControllersList Method for DcimControllersList

Retrieve a list of controller objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimControllersListRequest
*/
func (a *DcimAPIService) DcimControllersList(ctx context.Context) ApiDcimControllersListRequest {
	return ApiDcimControllersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedControllerList
func (a *DcimAPIService) DcimControllersListExecute(r ApiDcimControllersListRequest) (*PaginatedControllerList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedControllerList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.controllerDevice != nil {
		t := *r.controllerDevice
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device", t, "multi")
		}
	}
	if r.controllerDeviceIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device__isnull", r.controllerDeviceIsnull, "")
	}
	if r.controllerDeviceN != nil {
		t := *r.controllerDeviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device__n", t, "multi")
		}
	}
	if r.controllerDeviceRedundancyGroup != nil {
		t := *r.controllerDeviceRedundancyGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device_redundancy_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device_redundancy_group", t, "multi")
		}
	}
	if r.controllerDeviceRedundancyGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device_redundancy_group__isnull", r.controllerDeviceRedundancyGroupIsnull, "")
	}
	if r.controllerDeviceRedundancyGroupN != nil {
		t := *r.controllerDeviceRedundancyGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device_redundancy_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "controller_device_redundancy_group__n", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.externalIntegration != nil {
		t := *r.externalIntegration
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "external_integration", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "external_integration", t, "multi")
		}
	}
	if r.externalIntegrationIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "external_integration__isnull", r.externalIntegrationIsnull, "")
	}
	if r.externalIntegrationN != nil {
		t := *r.externalIntegrationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "external_integration__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "external_integration__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.platform != nil {
		t := *r.platform
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "platform", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "platform", t, "multi")
		}
	}
	if r.platformIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platform__isnull", r.platformIsnull, "")
	}
	if r.platformN != nil {
		t := *r.platformN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "platform__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "platform__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "multi")
		}
	}
	if r.roleIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__isnull", r.roleIsnull, "")
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllersNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimControllersNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimControllersNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllersNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimControllersNotesCreateExecute(r)
}

/*
DcimControllersNotesCreate Method for DcimControllersNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller.
 @return ApiDcimControllersNotesCreateRequest
*/
func (a *DcimAPIService) DcimControllersNotesCreate(ctx context.Context, id string) ApiDcimControllersNotesCreateRequest {
	return ApiDcimControllersNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimControllersNotesCreateExecute(r ApiDcimControllersNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimControllersNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimControllersNotesListRequest) Limit(limit int32) ApiDcimControllersNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimControllersNotesListRequest) Offset(offset int32) ApiDcimControllersNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimControllersNotesListRequest) Depth(depth int32) ApiDcimControllersNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimControllersNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimControllersNotesListExecute(r)
}

/*
DcimControllersNotesList Method for DcimControllersNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller.
 @return ApiDcimControllersNotesListRequest
*/
func (a *DcimAPIService) DcimControllersNotesList(ctx context.Context, id string) ApiDcimControllersNotesListRequest {
	return ApiDcimControllersNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimControllersNotesListExecute(r ApiDcimControllersNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedControllerRequest *PatchedControllerRequest
}

func (r ApiDcimControllersPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllersPartialUpdateRequest) PatchedControllerRequest(patchedControllerRequest PatchedControllerRequest) ApiDcimControllersPartialUpdateRequest {
	r.patchedControllerRequest = &patchedControllerRequest
	return r
}

func (r ApiDcimControllersPartialUpdateRequest) Execute() (*Controller, *http.Response, error) {
	return r.ApiService.DcimControllersPartialUpdateExecute(r)
}

/*
DcimControllersPartialUpdate Method for DcimControllersPartialUpdate

Partial update a controller object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller.
 @return ApiDcimControllersPartialUpdateRequest
*/
func (a *DcimAPIService) DcimControllersPartialUpdate(ctx context.Context, id string) ApiDcimControllersPartialUpdateRequest {
	return ApiDcimControllersPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Controller
func (a *DcimAPIService) DcimControllersPartialUpdateExecute(r ApiDcimControllersPartialUpdateRequest) (*Controller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Controller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedControllerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimControllersRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimControllersRetrieveRequest) Depth(depth int32) ApiDcimControllersRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimControllersRetrieveRequest) Execute() (*Controller, *http.Response, error) {
	return r.ApiService.DcimControllersRetrieveExecute(r)
}

/*
DcimControllersRetrieve Method for DcimControllersRetrieve

Retrieve a controller object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller.
 @return ApiDcimControllersRetrieveRequest
*/
func (a *DcimAPIService) DcimControllersRetrieve(ctx context.Context, id string) ApiDcimControllersRetrieveRequest {
	return ApiDcimControllersRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Controller
func (a *DcimAPIService) DcimControllersRetrieveExecute(r ApiDcimControllersRetrieveRequest) (*Controller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Controller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimControllersUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	controllerRequest *ControllerRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimControllersUpdateRequest) ControllerRequest(controllerRequest ControllerRequest) ApiDcimControllersUpdateRequest {
	r.controllerRequest = &controllerRequest
	return r
}

func (r ApiDcimControllersUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimControllersUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimControllersUpdateRequest) Execute() (*Controller, *http.Response, error) {
	return r.ApiService.DcimControllersUpdateExecute(r)
}

/*
DcimControllersUpdate Method for DcimControllersUpdate

Update a controller object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this controller.
 @return ApiDcimControllersUpdateRequest
*/
func (a *DcimAPIService) DcimControllersUpdate(ctx context.Context, id string) ApiDcimControllersUpdateRequest {
	return ApiDcimControllersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Controller
func (a *DcimAPIService) DcimControllersUpdateExecute(r ApiDcimControllersUpdateRequest) (*Controller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Controller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimControllersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/controllers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.controllerRequest == nil {
		return localVarReturnValue, nil, reportError("controllerRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.controllerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBayTemplatesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimDeviceBayTemplatesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimDeviceBayTemplatesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBayTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesBulkDestroyExecute(r)
}

/*
DcimDeviceBayTemplatesBulkDestroy Method for DcimDeviceBayTemplatesBulkDestroy

Destroy a list of device bay template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesBulkDestroy(ctx context.Context) ApiDcimDeviceBayTemplatesBulkDestroyRequest {
	return ApiDcimDeviceBayTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceBayTemplatesBulkDestroyExecute(r ApiDcimDeviceBayTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableDeviceBayTemplateRequest *[]PatchedBulkWritableDeviceBayTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest) PatchedBulkWritableDeviceBayTemplateRequest(patchedBulkWritableDeviceBayTemplateRequest []PatchedBulkWritableDeviceBayTemplateRequest) ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest {
	r.patchedBulkWritableDeviceBayTemplateRequest = &patchedBulkWritableDeviceBayTemplateRequest
	return r
}

func (r ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest) Execute() ([]DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimDeviceBayTemplatesBulkPartialUpdate Method for DcimDeviceBayTemplatesBulkPartialUpdate

Partial update a list of device bay template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest {
	return ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceBayTemplate
func (a *DcimAPIService) DcimDeviceBayTemplatesBulkPartialUpdateExecute(r ApiDcimDeviceBayTemplatesBulkPartialUpdateRequest) ([]DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableDeviceBayTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableDeviceBayTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableDeviceBayTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableDeviceBayTemplateRequest *[]BulkWritableDeviceBayTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBayTemplatesBulkUpdateRequest) BulkWritableDeviceBayTemplateRequest(bulkWritableDeviceBayTemplateRequest []BulkWritableDeviceBayTemplateRequest) ApiDcimDeviceBayTemplatesBulkUpdateRequest {
	r.bulkWritableDeviceBayTemplateRequest = &bulkWritableDeviceBayTemplateRequest
	return r
}

func (r ApiDcimDeviceBayTemplatesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBayTemplatesBulkUpdateRequest) Execute() ([]DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesBulkUpdateExecute(r)
}

/*
DcimDeviceBayTemplatesBulkUpdate Method for DcimDeviceBayTemplatesBulkUpdate

Update a list of device bay template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesBulkUpdate(ctx context.Context) ApiDcimDeviceBayTemplatesBulkUpdateRequest {
	return ApiDcimDeviceBayTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceBayTemplate
func (a *DcimAPIService) DcimDeviceBayTemplatesBulkUpdateExecute(r ApiDcimDeviceBayTemplatesBulkUpdateRequest) ([]DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableDeviceBayTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableDeviceBayTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableDeviceBayTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	deviceBayTemplateRequest *DeviceBayTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBayTemplatesCreateRequest) DeviceBayTemplateRequest(deviceBayTemplateRequest DeviceBayTemplateRequest) ApiDcimDeviceBayTemplatesCreateRequest {
	r.deviceBayTemplateRequest = &deviceBayTemplateRequest
	return r
}

func (r ApiDcimDeviceBayTemplatesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBayTemplatesCreateRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesCreateExecute(r)
}

/*
DcimDeviceBayTemplatesCreate Method for DcimDeviceBayTemplatesCreate

Create one or more device bay template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesCreate(ctx context.Context) ApiDcimDeviceBayTemplatesCreateRequest {
	return ApiDcimDeviceBayTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimAPIService) DcimDeviceBayTemplatesCreateExecute(r ApiDcimDeviceBayTemplatesCreateRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceBayTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("deviceBayTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceBayTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBayTemplatesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBayTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesDestroyExecute(r)
}

/*
DcimDeviceBayTemplatesDestroy Method for DcimDeviceBayTemplatesDestroy

Destroy a device bay template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesDestroy(ctx context.Context, id string) ApiDcimDeviceBayTemplatesDestroyRequest {
	return ApiDcimDeviceBayTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceBayTemplatesDestroyExecute(r ApiDcimDeviceBayTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceType *[]string
	deviceTypeN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	depth *int32
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) Description(description []string) ApiDcimDeviceBayTemplatesListRequest {
	r.description = &description
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionIre(descriptionIre []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionN(descriptionN []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionNire(descriptionNire []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionNre(descriptionNre []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

// Description
func (r ApiDcimDeviceBayTemplatesListRequest) DescriptionRe(descriptionRe []string) ApiDcimDeviceBayTemplatesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) DeviceType(deviceType []string) ApiDcimDeviceBayTemplatesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimDeviceBayTemplatesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesListRequest {
	r.format = &format
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) Id(id []string) ApiDcimDeviceBayTemplatesListRequest {
	r.id = &id
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdIc(idIc []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idIc = &idIc
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdIe(idIe []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idIe = &idIe
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdIew(idIew []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idIew = &idIew
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdIre(idIre []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idIre = &idIre
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdIsw(idIsw []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idIsw = &idIsw
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdN(idN []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idN = &idN
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdNic(idNic []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idNic = &idNic
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdNie(idNie []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idNie = &idNie
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdNiew(idNiew []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idNiew = &idNiew
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdNire(idNire []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idNire = &idNire
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdNisw(idNisw []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idNisw = &idNisw
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdNre(idNre []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idNre = &idNre
	return r
}

// ID
func (r ApiDcimDeviceBayTemplatesListRequest) IdRe(idRe []string) ApiDcimDeviceBayTemplatesListRequest {
	r.idRe = &idRe
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) Label(label []string) ApiDcimDeviceBayTemplatesListRequest {
	r.label = &label
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelIc(labelIc []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelIc = &labelIc
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelIe(labelIe []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelIe = &labelIe
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelIew(labelIew []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelIew = &labelIew
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelIre(labelIre []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelIre = &labelIre
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelIsw(labelIsw []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelIsw = &labelIsw
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelN(labelN []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelN = &labelN
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelNic(labelNic []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelNic = &labelNic
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelNie(labelNie []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelNie = &labelNie
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelNiew(labelNiew []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelNiew = &labelNiew
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelNire(labelNire []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelNire = &labelNire
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelNisw(labelNisw []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelNisw = &labelNisw
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelNre(labelNre []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelNre = &labelNre
	return r
}

// Label
func (r ApiDcimDeviceBayTemplatesListRequest) LabelRe(labelRe []string) ApiDcimDeviceBayTemplatesListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceBayTemplatesListRequest) Limit(limit int32) ApiDcimDeviceBayTemplatesListRequest {
	r.limit = &limit
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) Name(name []string) ApiDcimDeviceBayTemplatesListRequest {
	r.name = &name
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameIc(nameIc []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameIe(nameIe []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameIew(nameIew []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameIre(nameIre []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIre = &nameIre
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameIsw(nameIsw []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameN(nameN []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameN = &nameN
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameNic(nameNic []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameNie(nameNie []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameNiew(nameNiew []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameNire(nameNire []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNire = &nameNire
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameNisw(nameNisw []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameNre(nameNre []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameNre = &nameNre
	return r
}

// Name
func (r ApiDcimDeviceBayTemplatesListRequest) NameRe(nameRe []string) ApiDcimDeviceBayTemplatesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceBayTemplatesListRequest) Offset(offset int32) ApiDcimDeviceBayTemplatesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimDeviceBayTemplatesListRequest) Q(q string) ApiDcimDeviceBayTemplatesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimDeviceBayTemplatesListRequest) Sort(sort string) ApiDcimDeviceBayTemplatesListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimDeviceBayTemplatesListRequest) Depth(depth int32) ApiDcimDeviceBayTemplatesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceBayTemplatesListRequest) Execute() (*PaginatedDeviceBayTemplateList, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesListExecute(r)
}

/*
DcimDeviceBayTemplatesList Method for DcimDeviceBayTemplatesList

Retrieve a list of device bay template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBayTemplatesListRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesList(ctx context.Context) ApiDcimDeviceBayTemplatesListRequest {
	return ApiDcimDeviceBayTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceBayTemplateList
func (a *DcimAPIService) DcimDeviceBayTemplatesListExecute(r ApiDcimDeviceBayTemplatesListRequest) (*PaginatedDeviceBayTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceBayTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBayTemplatesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimDeviceBayTemplatesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimDeviceBayTemplatesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBayTemplatesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesNotesCreateExecute(r)
}

/*
DcimDeviceBayTemplatesNotesCreate Method for DcimDeviceBayTemplatesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesNotesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesNotesCreate(ctx context.Context, id string) ApiDcimDeviceBayTemplatesNotesCreateRequest {
	return ApiDcimDeviceBayTemplatesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimDeviceBayTemplatesNotesCreateExecute(r ApiDcimDeviceBayTemplatesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimDeviceBayTemplatesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceBayTemplatesNotesListRequest) Limit(limit int32) ApiDcimDeviceBayTemplatesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceBayTemplatesNotesListRequest) Offset(offset int32) ApiDcimDeviceBayTemplatesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimDeviceBayTemplatesNotesListRequest) Depth(depth int32) ApiDcimDeviceBayTemplatesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceBayTemplatesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesNotesListExecute(r)
}

/*
DcimDeviceBayTemplatesNotesList Method for DcimDeviceBayTemplatesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesNotesListRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesNotesList(ctx context.Context, id string) ApiDcimDeviceBayTemplatesNotesListRequest {
	return ApiDcimDeviceBayTemplatesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimDeviceBayTemplatesNotesListExecute(r ApiDcimDeviceBayTemplatesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedDeviceBayTemplateRequest *PatchedDeviceBayTemplateRequest
}

func (r ApiDcimDeviceBayTemplatesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBayTemplatesPartialUpdateRequest) PatchedDeviceBayTemplateRequest(patchedDeviceBayTemplateRequest PatchedDeviceBayTemplateRequest) ApiDcimDeviceBayTemplatesPartialUpdateRequest {
	r.patchedDeviceBayTemplateRequest = &patchedDeviceBayTemplateRequest
	return r
}

func (r ApiDcimDeviceBayTemplatesPartialUpdateRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesPartialUpdateExecute(r)
}

/*
DcimDeviceBayTemplatesPartialUpdate Method for DcimDeviceBayTemplatesPartialUpdate

Partial update a device bay template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesPartialUpdate(ctx context.Context, id string) ApiDcimDeviceBayTemplatesPartialUpdateRequest {
	return ApiDcimDeviceBayTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimAPIService) DcimDeviceBayTemplatesPartialUpdateExecute(r ApiDcimDeviceBayTemplatesPartialUpdateRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDeviceBayTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimDeviceBayTemplatesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimDeviceBayTemplatesRetrieveRequest) Depth(depth int32) ApiDcimDeviceBayTemplatesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceBayTemplatesRetrieveRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesRetrieveExecute(r)
}

/*
DcimDeviceBayTemplatesRetrieve Method for DcimDeviceBayTemplatesRetrieve

Retrieve a device bay template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesRetrieveRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesRetrieve(ctx context.Context, id string) ApiDcimDeviceBayTemplatesRetrieveRequest {
	return ApiDcimDeviceBayTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimAPIService) DcimDeviceBayTemplatesRetrieveExecute(r ApiDcimDeviceBayTemplatesRetrieveRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBayTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	deviceBayTemplateRequest *DeviceBayTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBayTemplatesUpdateRequest) DeviceBayTemplateRequest(deviceBayTemplateRequest DeviceBayTemplateRequest) ApiDcimDeviceBayTemplatesUpdateRequest {
	r.deviceBayTemplateRequest = &deviceBayTemplateRequest
	return r
}

func (r ApiDcimDeviceBayTemplatesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBayTemplatesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBayTemplatesUpdateRequest) Execute() (*DeviceBayTemplate, *http.Response, error) {
	return r.ApiService.DcimDeviceBayTemplatesUpdateExecute(r)
}

/*
DcimDeviceBayTemplatesUpdate Method for DcimDeviceBayTemplatesUpdate

Update a device bay template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay template.
 @return ApiDcimDeviceBayTemplatesUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceBayTemplatesUpdate(ctx context.Context, id string) ApiDcimDeviceBayTemplatesUpdateRequest {
	return ApiDcimDeviceBayTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBayTemplate
func (a *DcimAPIService) DcimDeviceBayTemplatesUpdateExecute(r ApiDcimDeviceBayTemplatesUpdateRequest) (*DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBayTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBayTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceBayTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("deviceBayTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceBayTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBaysBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimDeviceBaysBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimDeviceBaysBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBaysBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceBaysBulkDestroyExecute(r)
}

/*
DcimDeviceBaysBulkDestroy Method for DcimDeviceBaysBulkDestroy

Destroy a list of device bay objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysBulkDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceBaysBulkDestroy(ctx context.Context) ApiDcimDeviceBaysBulkDestroyRequest {
	return ApiDcimDeviceBaysBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceBaysBulkDestroyExecute(r ApiDcimDeviceBaysBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableDeviceBayRequest *[]PatchedBulkWritableDeviceBayRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBaysBulkPartialUpdateRequest) PatchedBulkWritableDeviceBayRequest(patchedBulkWritableDeviceBayRequest []PatchedBulkWritableDeviceBayRequest) ApiDcimDeviceBaysBulkPartialUpdateRequest {
	r.patchedBulkWritableDeviceBayRequest = &patchedBulkWritableDeviceBayRequest
	return r
}

func (r ApiDcimDeviceBaysBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBaysBulkPartialUpdateRequest) Execute() ([]DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysBulkPartialUpdateExecute(r)
}

/*
DcimDeviceBaysBulkPartialUpdate Method for DcimDeviceBaysBulkPartialUpdate

Partial update a list of device bay objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceBaysBulkPartialUpdate(ctx context.Context) ApiDcimDeviceBaysBulkPartialUpdateRequest {
	return ApiDcimDeviceBaysBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceBay
func (a *DcimAPIService) DcimDeviceBaysBulkPartialUpdateExecute(r ApiDcimDeviceBaysBulkPartialUpdateRequest) ([]DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableDeviceBayRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableDeviceBayRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableDeviceBayRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableDeviceBayRequest *[]BulkWritableDeviceBayRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBaysBulkUpdateRequest) BulkWritableDeviceBayRequest(bulkWritableDeviceBayRequest []BulkWritableDeviceBayRequest) ApiDcimDeviceBaysBulkUpdateRequest {
	r.bulkWritableDeviceBayRequest = &bulkWritableDeviceBayRequest
	return r
}

func (r ApiDcimDeviceBaysBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBaysBulkUpdateRequest) Execute() ([]DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysBulkUpdateExecute(r)
}

/*
DcimDeviceBaysBulkUpdate Method for DcimDeviceBaysBulkUpdate

Update a list of device bay objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysBulkUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceBaysBulkUpdate(ctx context.Context) ApiDcimDeviceBaysBulkUpdateRequest {
	return ApiDcimDeviceBaysBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceBay
func (a *DcimAPIService) DcimDeviceBaysBulkUpdateExecute(r ApiDcimDeviceBaysBulkUpdateRequest) ([]DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableDeviceBayRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableDeviceBayRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableDeviceBayRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	deviceBayRequest *DeviceBayRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBaysCreateRequest) DeviceBayRequest(deviceBayRequest DeviceBayRequest) ApiDcimDeviceBaysCreateRequest {
	r.deviceBayRequest = &deviceBayRequest
	return r
}

func (r ApiDcimDeviceBaysCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBaysCreateRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysCreateExecute(r)
}

/*
DcimDeviceBaysCreate Method for DcimDeviceBaysCreate

Create one or more device bay objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysCreateRequest
*/
func (a *DcimAPIService) DcimDeviceBaysCreate(ctx context.Context) ApiDcimDeviceBaysCreateRequest {
	return ApiDcimDeviceBaysCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimAPIService) DcimDeviceBaysCreateExecute(r ApiDcimDeviceBaysCreateRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceBayRequest == nil {
		return localVarReturnValue, nil, reportError("deviceBayRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceBayRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBaysDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBaysDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceBaysDestroyExecute(r)
}

/*
DcimDeviceBaysDestroy Method for DcimDeviceBaysDestroy

Destroy a device bay object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay.
 @return ApiDcimDeviceBaysDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceBaysDestroy(ctx context.Context, id string) ApiDcimDeviceBaysDestroyRequest {
	return ApiDcimDeviceBaysDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceBaysDestroyExecute(r ApiDcimDeviceBaysDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	installedDevice *[]string
	installedDeviceIsnull *bool
	installedDeviceN *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	depth *int32
}

func (r ApiDcimDeviceBaysListRequest) Description(description []string) ApiDcimDeviceBaysListRequest {
	r.description = &description
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIc(descriptionIc []string) ApiDcimDeviceBaysListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIe(descriptionIe []string) ApiDcimDeviceBaysListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIew(descriptionIew []string) ApiDcimDeviceBaysListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIre(descriptionIre []string) ApiDcimDeviceBaysListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimDeviceBaysListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionN(descriptionN []string) ApiDcimDeviceBaysListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNic(descriptionNic []string) ApiDcimDeviceBaysListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNie(descriptionNie []string) ApiDcimDeviceBaysListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimDeviceBaysListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNire(descriptionNire []string) ApiDcimDeviceBaysListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimDeviceBaysListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionNre(descriptionNre []string) ApiDcimDeviceBaysListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimDeviceBaysListRequest) DescriptionRe(descriptionRe []string) ApiDcimDeviceBaysListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimDeviceBaysListRequest) Device(device []string) ApiDcimDeviceBaysListRequest {
	r.device = &device
	return r
}

func (r ApiDcimDeviceBaysListRequest) DeviceN(deviceN []string) ApiDcimDeviceBaysListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimDeviceBaysListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimDeviceBaysListRequest) Id(id []string) ApiDcimDeviceBaysListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdIc(idIc []string) ApiDcimDeviceBaysListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdIe(idIe []string) ApiDcimDeviceBaysListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdIew(idIew []string) ApiDcimDeviceBaysListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdIre(idIre []string) ApiDcimDeviceBaysListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdIsw(idIsw []string) ApiDcimDeviceBaysListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdN(idN []string) ApiDcimDeviceBaysListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdNic(idNic []string) ApiDcimDeviceBaysListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdNie(idNie []string) ApiDcimDeviceBaysListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdNiew(idNiew []string) ApiDcimDeviceBaysListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdNire(idNire []string) ApiDcimDeviceBaysListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdNisw(idNisw []string) ApiDcimDeviceBaysListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdNre(idNre []string) ApiDcimDeviceBaysListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimDeviceBaysListRequest) IdRe(idRe []string) ApiDcimDeviceBaysListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimDeviceBaysListRequest) InstalledDevice(installedDevice []string) ApiDcimDeviceBaysListRequest {
	r.installedDevice = &installedDevice
	return r
}

func (r ApiDcimDeviceBaysListRequest) InstalledDeviceIsnull(installedDeviceIsnull bool) ApiDcimDeviceBaysListRequest {
	r.installedDeviceIsnull = &installedDeviceIsnull
	return r
}

func (r ApiDcimDeviceBaysListRequest) InstalledDeviceN(installedDeviceN []string) ApiDcimDeviceBaysListRequest {
	r.installedDeviceN = &installedDeviceN
	return r
}

func (r ApiDcimDeviceBaysListRequest) Label(label []string) ApiDcimDeviceBaysListRequest {
	r.label = &label
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIc(labelIc []string) ApiDcimDeviceBaysListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIe(labelIe []string) ApiDcimDeviceBaysListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIew(labelIew []string) ApiDcimDeviceBaysListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIre(labelIre []string) ApiDcimDeviceBaysListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelIsw(labelIsw []string) ApiDcimDeviceBaysListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelN(labelN []string) ApiDcimDeviceBaysListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNic(labelNic []string) ApiDcimDeviceBaysListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNie(labelNie []string) ApiDcimDeviceBaysListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNiew(labelNiew []string) ApiDcimDeviceBaysListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNire(labelNire []string) ApiDcimDeviceBaysListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNisw(labelNisw []string) ApiDcimDeviceBaysListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelNre(labelNre []string) ApiDcimDeviceBaysListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimDeviceBaysListRequest) LabelRe(labelRe []string) ApiDcimDeviceBaysListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceBaysListRequest) Limit(limit int32) ApiDcimDeviceBaysListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimDeviceBaysListRequest) Location(location []string) ApiDcimDeviceBaysListRequest {
	r.location = &location
	return r
}

func (r ApiDcimDeviceBaysListRequest) LocationN(locationN []string) ApiDcimDeviceBaysListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimDeviceBaysListRequest) Name(name []string) ApiDcimDeviceBaysListRequest {
	r.name = &name
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIc(nameIc []string) ApiDcimDeviceBaysListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIe(nameIe []string) ApiDcimDeviceBaysListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIew(nameIew []string) ApiDcimDeviceBaysListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIre(nameIre []string) ApiDcimDeviceBaysListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameIsw(nameIsw []string) ApiDcimDeviceBaysListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameN(nameN []string) ApiDcimDeviceBaysListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNic(nameNic []string) ApiDcimDeviceBaysListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNie(nameNie []string) ApiDcimDeviceBaysListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNiew(nameNiew []string) ApiDcimDeviceBaysListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNire(nameNire []string) ApiDcimDeviceBaysListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNisw(nameNisw []string) ApiDcimDeviceBaysListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameNre(nameNre []string) ApiDcimDeviceBaysListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimDeviceBaysListRequest) NameRe(nameRe []string) ApiDcimDeviceBaysListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceBaysListRequest) Offset(offset int32) ApiDcimDeviceBaysListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimDeviceBaysListRequest) Q(q string) ApiDcimDeviceBaysListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimDeviceBaysListRequest) Sort(sort string) ApiDcimDeviceBaysListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimDeviceBaysListRequest) Tags(tags []string) ApiDcimDeviceBaysListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimDeviceBaysListRequest) TagsIsnull(tagsIsnull bool) ApiDcimDeviceBaysListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimDeviceBaysListRequest) TagsN(tagsN []string) ApiDcimDeviceBaysListRequest {
	r.tagsN = &tagsN
	return r
}

// Serializer Depth
func (r ApiDcimDeviceBaysListRequest) Depth(depth int32) ApiDcimDeviceBaysListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceBaysListRequest) Execute() (*PaginatedDeviceBayList, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysListExecute(r)
}

/*
DcimDeviceBaysList Method for DcimDeviceBaysList

Retrieve a list of device bay objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceBaysListRequest
*/
func (a *DcimAPIService) DcimDeviceBaysList(ctx context.Context) ApiDcimDeviceBaysListRequest {
	return ApiDcimDeviceBaysListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceBayList
func (a *DcimAPIService) DcimDeviceBaysListExecute(r ApiDcimDeviceBaysListRequest) (*PaginatedDeviceBayList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceBayList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.installedDevice != nil {
		t := *r.installedDevice
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "installed_device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "installed_device", t, "multi")
		}
	}
	if r.installedDeviceIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "installed_device__isnull", r.installedDeviceIsnull, "")
	}
	if r.installedDeviceN != nil {
		t := *r.installedDeviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "installed_device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "installed_device__n", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBaysNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimDeviceBaysNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimDeviceBaysNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBaysNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysNotesCreateExecute(r)
}

/*
DcimDeviceBaysNotesCreate Method for DcimDeviceBaysNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay.
 @return ApiDcimDeviceBaysNotesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceBaysNotesCreate(ctx context.Context, id string) ApiDcimDeviceBaysNotesCreateRequest {
	return ApiDcimDeviceBaysNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimDeviceBaysNotesCreateExecute(r ApiDcimDeviceBaysNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimDeviceBaysNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceBaysNotesListRequest) Limit(limit int32) ApiDcimDeviceBaysNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceBaysNotesListRequest) Offset(offset int32) ApiDcimDeviceBaysNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimDeviceBaysNotesListRequest) Depth(depth int32) ApiDcimDeviceBaysNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceBaysNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysNotesListExecute(r)
}

/*
DcimDeviceBaysNotesList Method for DcimDeviceBaysNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay.
 @return ApiDcimDeviceBaysNotesListRequest
*/
func (a *DcimAPIService) DcimDeviceBaysNotesList(ctx context.Context, id string) ApiDcimDeviceBaysNotesListRequest {
	return ApiDcimDeviceBaysNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimDeviceBaysNotesListExecute(r ApiDcimDeviceBaysNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedDeviceBayRequest *PatchedDeviceBayRequest
}

func (r ApiDcimDeviceBaysPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBaysPartialUpdateRequest) PatchedDeviceBayRequest(patchedDeviceBayRequest PatchedDeviceBayRequest) ApiDcimDeviceBaysPartialUpdateRequest {
	r.patchedDeviceBayRequest = &patchedDeviceBayRequest
	return r
}

func (r ApiDcimDeviceBaysPartialUpdateRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysPartialUpdateExecute(r)
}

/*
DcimDeviceBaysPartialUpdate Method for DcimDeviceBaysPartialUpdate

Partial update a device bay object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay.
 @return ApiDcimDeviceBaysPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceBaysPartialUpdate(ctx context.Context, id string) ApiDcimDeviceBaysPartialUpdateRequest {
	return ApiDcimDeviceBaysPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimAPIService) DcimDeviceBaysPartialUpdateExecute(r ApiDcimDeviceBaysPartialUpdateRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDeviceBayRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimDeviceBaysRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimDeviceBaysRetrieveRequest) Depth(depth int32) ApiDcimDeviceBaysRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceBaysRetrieveRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysRetrieveExecute(r)
}

/*
DcimDeviceBaysRetrieve Method for DcimDeviceBaysRetrieve

Retrieve a device bay object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay.
 @return ApiDcimDeviceBaysRetrieveRequest
*/
func (a *DcimAPIService) DcimDeviceBaysRetrieve(ctx context.Context, id string) ApiDcimDeviceBaysRetrieveRequest {
	return ApiDcimDeviceBaysRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimAPIService) DcimDeviceBaysRetrieveExecute(r ApiDcimDeviceBaysRetrieveRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceBaysUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	deviceBayRequest *DeviceBayRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceBaysUpdateRequest) DeviceBayRequest(deviceBayRequest DeviceBayRequest) ApiDcimDeviceBaysUpdateRequest {
	r.deviceBayRequest = &deviceBayRequest
	return r
}

func (r ApiDcimDeviceBaysUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceBaysUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceBaysUpdateRequest) Execute() (*DeviceBay, *http.Response, error) {
	return r.ApiService.DcimDeviceBaysUpdateExecute(r)
}

/*
DcimDeviceBaysUpdate Method for DcimDeviceBaysUpdate

Update a device bay object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device bay.
 @return ApiDcimDeviceBaysUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceBaysUpdate(ctx context.Context, id string) ApiDcimDeviceBaysUpdateRequest {
	return ApiDcimDeviceBaysUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceBay
func (a *DcimAPIService) DcimDeviceBaysUpdateExecute(r ApiDcimDeviceBaysUpdateRequest) (*DeviceBay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceBay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceBaysUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceBayRequest == nil {
		return localVarReturnValue, nil, reportError("deviceBayRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceBayRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceFamiliesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimDeviceFamiliesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimDeviceFamiliesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceFamiliesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesBulkDestroyExecute(r)
}

/*
DcimDeviceFamiliesBulkDestroy Method for DcimDeviceFamiliesBulkDestroy

Destroy a list of device family objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceFamiliesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesBulkDestroy(ctx context.Context) ApiDcimDeviceFamiliesBulkDestroyRequest {
	return ApiDcimDeviceFamiliesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceFamiliesBulkDestroyExecute(r ApiDcimDeviceFamiliesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableDeviceFamilyRequest *[]PatchedBulkWritableDeviceFamilyRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceFamiliesBulkPartialUpdateRequest) PatchedBulkWritableDeviceFamilyRequest(patchedBulkWritableDeviceFamilyRequest []PatchedBulkWritableDeviceFamilyRequest) ApiDcimDeviceFamiliesBulkPartialUpdateRequest {
	r.patchedBulkWritableDeviceFamilyRequest = &patchedBulkWritableDeviceFamilyRequest
	return r
}

func (r ApiDcimDeviceFamiliesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceFamiliesBulkPartialUpdateRequest) Execute() ([]DeviceFamily, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesBulkPartialUpdateExecute(r)
}

/*
DcimDeviceFamiliesBulkPartialUpdate Method for DcimDeviceFamiliesBulkPartialUpdate

Partial update a list of device family objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceFamiliesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesBulkPartialUpdate(ctx context.Context) ApiDcimDeviceFamiliesBulkPartialUpdateRequest {
	return ApiDcimDeviceFamiliesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceFamily
func (a *DcimAPIService) DcimDeviceFamiliesBulkPartialUpdateExecute(r ApiDcimDeviceFamiliesBulkPartialUpdateRequest) ([]DeviceFamily, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceFamily
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableDeviceFamilyRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableDeviceFamilyRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableDeviceFamilyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableDeviceFamilyRequest *[]BulkWritableDeviceFamilyRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceFamiliesBulkUpdateRequest) BulkWritableDeviceFamilyRequest(bulkWritableDeviceFamilyRequest []BulkWritableDeviceFamilyRequest) ApiDcimDeviceFamiliesBulkUpdateRequest {
	r.bulkWritableDeviceFamilyRequest = &bulkWritableDeviceFamilyRequest
	return r
}

func (r ApiDcimDeviceFamiliesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceFamiliesBulkUpdateRequest) Execute() ([]DeviceFamily, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesBulkUpdateExecute(r)
}

/*
DcimDeviceFamiliesBulkUpdate Method for DcimDeviceFamiliesBulkUpdate

Update a list of device family objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceFamiliesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesBulkUpdate(ctx context.Context) ApiDcimDeviceFamiliesBulkUpdateRequest {
	return ApiDcimDeviceFamiliesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceFamily
func (a *DcimAPIService) DcimDeviceFamiliesBulkUpdateExecute(r ApiDcimDeviceFamiliesBulkUpdateRequest) ([]DeviceFamily, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceFamily
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableDeviceFamilyRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableDeviceFamilyRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableDeviceFamilyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	deviceFamilyRequest *DeviceFamilyRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceFamiliesCreateRequest) DeviceFamilyRequest(deviceFamilyRequest DeviceFamilyRequest) ApiDcimDeviceFamiliesCreateRequest {
	r.deviceFamilyRequest = &deviceFamilyRequest
	return r
}

func (r ApiDcimDeviceFamiliesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceFamiliesCreateRequest) Execute() (*DeviceFamily, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesCreateExecute(r)
}

/*
DcimDeviceFamiliesCreate Method for DcimDeviceFamiliesCreate

Create one or more device family objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceFamiliesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesCreate(ctx context.Context) ApiDcimDeviceFamiliesCreateRequest {
	return ApiDcimDeviceFamiliesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceFamily
func (a *DcimAPIService) DcimDeviceFamiliesCreateExecute(r ApiDcimDeviceFamiliesCreateRequest) (*DeviceFamily, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceFamily
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceFamilyRequest == nil {
		return localVarReturnValue, nil, reportError("deviceFamilyRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceFamilyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceFamiliesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceFamiliesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesDestroyExecute(r)
}

/*
DcimDeviceFamiliesDestroy Method for DcimDeviceFamiliesDestroy

Destroy a device family object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device family.
 @return ApiDcimDeviceFamiliesDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesDestroy(ctx context.Context, id string) ApiDcimDeviceFamiliesDestroyRequest {
	return ApiDcimDeviceFamiliesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceFamiliesDestroyExecute(r ApiDcimDeviceFamiliesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceTypes *[]string
	deviceTypesIsnull *bool
	deviceTypesN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasDeviceTypes *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	depth *int32
}

func (r ApiDcimDeviceFamiliesListRequest) Created(created []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) CreatedGt(createdGt []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) CreatedGte(createdGte []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) CreatedIsnull(createdIsnull bool) ApiDcimDeviceFamiliesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) CreatedLt(createdLt []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) CreatedLte(createdLte []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) CreatedN(createdN []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) Description(description []string) ApiDcimDeviceFamiliesListRequest {
	r.description = &description
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionIc(descriptionIc []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionIe(descriptionIe []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionIew(descriptionIew []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionIre(descriptionIre []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionN(descriptionN []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionNic(descriptionNic []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionNie(descriptionNie []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionNire(descriptionNire []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionNre(descriptionNre []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DescriptionRe(descriptionRe []string) ApiDcimDeviceFamiliesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DeviceTypes(deviceTypes []string) ApiDcimDeviceFamiliesListRequest {
	r.deviceTypes = &deviceTypes
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DeviceTypesIsnull(deviceTypesIsnull bool) ApiDcimDeviceFamiliesListRequest {
	r.deviceTypesIsnull = &deviceTypesIsnull
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) DeviceTypesN(deviceTypesN []string) ApiDcimDeviceFamiliesListRequest {
	r.deviceTypesN = &deviceTypesN
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesListRequest {
	r.format = &format
	return r
}

// Has device types
func (r ApiDcimDeviceFamiliesListRequest) HasDeviceTypes(hasDeviceTypes bool) ApiDcimDeviceFamiliesListRequest {
	r.hasDeviceTypes = &hasDeviceTypes
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimDeviceFamiliesListRequest) Id(id []string) ApiDcimDeviceFamiliesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdIc(idIc []string) ApiDcimDeviceFamiliesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdIe(idIe []string) ApiDcimDeviceFamiliesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdIew(idIew []string) ApiDcimDeviceFamiliesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdIre(idIre []string) ApiDcimDeviceFamiliesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdIsw(idIsw []string) ApiDcimDeviceFamiliesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdN(idN []string) ApiDcimDeviceFamiliesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdNic(idNic []string) ApiDcimDeviceFamiliesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdNie(idNie []string) ApiDcimDeviceFamiliesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdNiew(idNiew []string) ApiDcimDeviceFamiliesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdNire(idNire []string) ApiDcimDeviceFamiliesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdNisw(idNisw []string) ApiDcimDeviceFamiliesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdNre(idNre []string) ApiDcimDeviceFamiliesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) IdRe(idRe []string) ApiDcimDeviceFamiliesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimDeviceFamiliesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimDeviceFamiliesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceFamiliesListRequest) Limit(limit int32) ApiDcimDeviceFamiliesListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) Name(name []string) ApiDcimDeviceFamiliesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameIc(nameIc []string) ApiDcimDeviceFamiliesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameIe(nameIe []string) ApiDcimDeviceFamiliesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameIew(nameIew []string) ApiDcimDeviceFamiliesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameIre(nameIre []string) ApiDcimDeviceFamiliesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameIsw(nameIsw []string) ApiDcimDeviceFamiliesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameN(nameN []string) ApiDcimDeviceFamiliesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameNic(nameNic []string) ApiDcimDeviceFamiliesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameNie(nameNie []string) ApiDcimDeviceFamiliesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameNiew(nameNiew []string) ApiDcimDeviceFamiliesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameNire(nameNire []string) ApiDcimDeviceFamiliesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameNisw(nameNisw []string) ApiDcimDeviceFamiliesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameNre(nameNre []string) ApiDcimDeviceFamiliesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) NameRe(nameRe []string) ApiDcimDeviceFamiliesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceFamiliesListRequest) Offset(offset int32) ApiDcimDeviceFamiliesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimDeviceFamiliesListRequest) Q(q string) ApiDcimDeviceFamiliesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimDeviceFamiliesListRequest) Sort(sort string) ApiDcimDeviceFamiliesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) Tags(tags []string) ApiDcimDeviceFamiliesListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) TagsIsnull(tagsIsnull bool) ApiDcimDeviceFamiliesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) TagsN(tagsN []string) ApiDcimDeviceFamiliesListRequest {
	r.tagsN = &tagsN
	return r
}

// Serializer Depth
func (r ApiDcimDeviceFamiliesListRequest) Depth(depth int32) ApiDcimDeviceFamiliesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceFamiliesListRequest) Execute() (*PaginatedDeviceFamilyList, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesListExecute(r)
}

/*
DcimDeviceFamiliesList Method for DcimDeviceFamiliesList

Retrieve a list of device family objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceFamiliesListRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesList(ctx context.Context) ApiDcimDeviceFamiliesListRequest {
	return ApiDcimDeviceFamiliesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceFamilyList
func (a *DcimAPIService) DcimDeviceFamiliesListExecute(r ApiDcimDeviceFamiliesListRequest) (*PaginatedDeviceFamilyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceFamilyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_types", t, "multi")
		}
	}
	if r.deviceTypesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__isnull", r.deviceTypesIsnull, "")
	}
	if r.deviceTypesN != nil {
		t := *r.deviceTypesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasDeviceTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_device_types", r.hasDeviceTypes, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceFamiliesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimDeviceFamiliesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimDeviceFamiliesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceFamiliesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesNotesCreateExecute(r)
}

/*
DcimDeviceFamiliesNotesCreate Method for DcimDeviceFamiliesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device family.
 @return ApiDcimDeviceFamiliesNotesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesNotesCreate(ctx context.Context, id string) ApiDcimDeviceFamiliesNotesCreateRequest {
	return ApiDcimDeviceFamiliesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimDeviceFamiliesNotesCreateExecute(r ApiDcimDeviceFamiliesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimDeviceFamiliesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceFamiliesNotesListRequest) Limit(limit int32) ApiDcimDeviceFamiliesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceFamiliesNotesListRequest) Offset(offset int32) ApiDcimDeviceFamiliesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimDeviceFamiliesNotesListRequest) Depth(depth int32) ApiDcimDeviceFamiliesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceFamiliesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesNotesListExecute(r)
}

/*
DcimDeviceFamiliesNotesList Method for DcimDeviceFamiliesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device family.
 @return ApiDcimDeviceFamiliesNotesListRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesNotesList(ctx context.Context, id string) ApiDcimDeviceFamiliesNotesListRequest {
	return ApiDcimDeviceFamiliesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimDeviceFamiliesNotesListExecute(r ApiDcimDeviceFamiliesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedDeviceFamilyRequest *PatchedDeviceFamilyRequest
}

func (r ApiDcimDeviceFamiliesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceFamiliesPartialUpdateRequest) PatchedDeviceFamilyRequest(patchedDeviceFamilyRequest PatchedDeviceFamilyRequest) ApiDcimDeviceFamiliesPartialUpdateRequest {
	r.patchedDeviceFamilyRequest = &patchedDeviceFamilyRequest
	return r
}

func (r ApiDcimDeviceFamiliesPartialUpdateRequest) Execute() (*DeviceFamily, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesPartialUpdateExecute(r)
}

/*
DcimDeviceFamiliesPartialUpdate Method for DcimDeviceFamiliesPartialUpdate

Partial update a device family object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device family.
 @return ApiDcimDeviceFamiliesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesPartialUpdate(ctx context.Context, id string) ApiDcimDeviceFamiliesPartialUpdateRequest {
	return ApiDcimDeviceFamiliesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceFamily
func (a *DcimAPIService) DcimDeviceFamiliesPartialUpdateExecute(r ApiDcimDeviceFamiliesPartialUpdateRequest) (*DeviceFamily, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceFamily
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDeviceFamilyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimDeviceFamiliesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimDeviceFamiliesRetrieveRequest) Depth(depth int32) ApiDcimDeviceFamiliesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceFamiliesRetrieveRequest) Execute() (*DeviceFamily, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesRetrieveExecute(r)
}

/*
DcimDeviceFamiliesRetrieve Method for DcimDeviceFamiliesRetrieve

Retrieve a device family object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device family.
 @return ApiDcimDeviceFamiliesRetrieveRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesRetrieve(ctx context.Context, id string) ApiDcimDeviceFamiliesRetrieveRequest {
	return ApiDcimDeviceFamiliesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceFamily
func (a *DcimAPIService) DcimDeviceFamiliesRetrieveExecute(r ApiDcimDeviceFamiliesRetrieveRequest) (*DeviceFamily, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceFamily
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceFamiliesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	deviceFamilyRequest *DeviceFamilyRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceFamiliesUpdateRequest) DeviceFamilyRequest(deviceFamilyRequest DeviceFamilyRequest) ApiDcimDeviceFamiliesUpdateRequest {
	r.deviceFamilyRequest = &deviceFamilyRequest
	return r
}

func (r ApiDcimDeviceFamiliesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceFamiliesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceFamiliesUpdateRequest) Execute() (*DeviceFamily, *http.Response, error) {
	return r.ApiService.DcimDeviceFamiliesUpdateExecute(r)
}

/*
DcimDeviceFamiliesUpdate Method for DcimDeviceFamiliesUpdate

Update a device family object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device family.
 @return ApiDcimDeviceFamiliesUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceFamiliesUpdate(ctx context.Context, id string) ApiDcimDeviceFamiliesUpdateRequest {
	return ApiDcimDeviceFamiliesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceFamily
func (a *DcimAPIService) DcimDeviceFamiliesUpdateExecute(r ApiDcimDeviceFamiliesUpdateRequest) (*DeviceFamily, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceFamily
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceFamiliesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-families/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceFamilyRequest == nil {
		return localVarReturnValue, nil, reportError("deviceFamilyRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceFamilyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceRedundancyGroupsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimDeviceRedundancyGroupsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimDeviceRedundancyGroupsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceRedundancyGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsBulkDestroyExecute(r)
}

/*
DcimDeviceRedundancyGroupsBulkDestroy Method for DcimDeviceRedundancyGroupsBulkDestroy

Destroy a list of device redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRedundancyGroupsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsBulkDestroy(ctx context.Context) ApiDcimDeviceRedundancyGroupsBulkDestroyRequest {
	return ApiDcimDeviceRedundancyGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceRedundancyGroupsBulkDestroyExecute(r ApiDcimDeviceRedundancyGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableDeviceRedundancyGroupRequest *[]PatchedBulkWritableDeviceRedundancyGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest) PatchedBulkWritableDeviceRedundancyGroupRequest(patchedBulkWritableDeviceRedundancyGroupRequest []PatchedBulkWritableDeviceRedundancyGroupRequest) ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest {
	r.patchedBulkWritableDeviceRedundancyGroupRequest = &patchedBulkWritableDeviceRedundancyGroupRequest
	return r
}

func (r ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest) Execute() ([]DeviceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsBulkPartialUpdateExecute(r)
}

/*
DcimDeviceRedundancyGroupsBulkPartialUpdate Method for DcimDeviceRedundancyGroupsBulkPartialUpdate

Partial update a list of device redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsBulkPartialUpdate(ctx context.Context) ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest {
	return ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceRedundancyGroup
func (a *DcimAPIService) DcimDeviceRedundancyGroupsBulkPartialUpdateExecute(r ApiDcimDeviceRedundancyGroupsBulkPartialUpdateRequest) ([]DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableDeviceRedundancyGroupRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableDeviceRedundancyGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableDeviceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableDeviceRedundancyGroupRequest *[]BulkWritableDeviceRedundancyGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceRedundancyGroupsBulkUpdateRequest) BulkWritableDeviceRedundancyGroupRequest(bulkWritableDeviceRedundancyGroupRequest []BulkWritableDeviceRedundancyGroupRequest) ApiDcimDeviceRedundancyGroupsBulkUpdateRequest {
	r.bulkWritableDeviceRedundancyGroupRequest = &bulkWritableDeviceRedundancyGroupRequest
	return r
}

func (r ApiDcimDeviceRedundancyGroupsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceRedundancyGroupsBulkUpdateRequest) Execute() ([]DeviceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsBulkUpdateExecute(r)
}

/*
DcimDeviceRedundancyGroupsBulkUpdate Method for DcimDeviceRedundancyGroupsBulkUpdate

Update a list of device redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRedundancyGroupsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsBulkUpdate(ctx context.Context) ApiDcimDeviceRedundancyGroupsBulkUpdateRequest {
	return ApiDcimDeviceRedundancyGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceRedundancyGroup
func (a *DcimAPIService) DcimDeviceRedundancyGroupsBulkUpdateExecute(r ApiDcimDeviceRedundancyGroupsBulkUpdateRequest) ([]DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableDeviceRedundancyGroupRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableDeviceRedundancyGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableDeviceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableDeviceRedundancyGroupRequest *WritableDeviceRedundancyGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceRedundancyGroupsCreateRequest) WritableDeviceRedundancyGroupRequest(writableDeviceRedundancyGroupRequest WritableDeviceRedundancyGroupRequest) ApiDcimDeviceRedundancyGroupsCreateRequest {
	r.writableDeviceRedundancyGroupRequest = &writableDeviceRedundancyGroupRequest
	return r
}

func (r ApiDcimDeviceRedundancyGroupsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceRedundancyGroupsCreateRequest) Execute() (*DeviceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsCreateExecute(r)
}

/*
DcimDeviceRedundancyGroupsCreate Method for DcimDeviceRedundancyGroupsCreate

Create one or more device redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRedundancyGroupsCreateRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsCreate(ctx context.Context) ApiDcimDeviceRedundancyGroupsCreateRequest {
	return ApiDcimDeviceRedundancyGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceRedundancyGroup
func (a *DcimAPIService) DcimDeviceRedundancyGroupsCreateExecute(r ApiDcimDeviceRedundancyGroupsCreateRequest) (*DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableDeviceRedundancyGroupRequest == nil {
		return localVarReturnValue, nil, reportError("writableDeviceRedundancyGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableDeviceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceRedundancyGroupsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceRedundancyGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsDestroyExecute(r)
}

/*
DcimDeviceRedundancyGroupsDestroy Method for DcimDeviceRedundancyGroupsDestroy

Destroy a device redundancy group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device redundancy group.
 @return ApiDcimDeviceRedundancyGroupsDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsDestroy(ctx context.Context, id string) ApiDcimDeviceRedundancyGroupsDestroyRequest {
	return ApiDcimDeviceRedundancyGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceRedundancyGroupsDestroyExecute(r ApiDcimDeviceRedundancyGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	failoverStrategy *[]string
	failoverStrategyIc *[]string
	failoverStrategyIe *[]string
	failoverStrategyIew *[]string
	failoverStrategyIre *[]string
	failoverStrategyIsw *[]string
	failoverStrategyN *[]string
	failoverStrategyNic *[]string
	failoverStrategyNie *[]string
	failoverStrategyNiew *[]string
	failoverStrategyNire *[]string
	failoverStrategyNisw *[]string
	failoverStrategyNre *[]string
	failoverStrategyRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	secretsGroup *[]string
	secretsGroupIsnull *bool
	secretsGroupN *[]string
	sort *string
	status *[]string
	statusN *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	depth *int32
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) Created(created []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) CreatedGt(createdGt []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) CreatedGte(createdGte []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimDeviceRedundancyGroupsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) CreatedLt(createdLt []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) CreatedLte(createdLte []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) CreatedN(createdN []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategy(failoverStrategy []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategy = &failoverStrategy
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyIc(failoverStrategyIc []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyIc = &failoverStrategyIc
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyIe(failoverStrategyIe []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyIe = &failoverStrategyIe
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyIew(failoverStrategyIew []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyIew = &failoverStrategyIew
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyIre(failoverStrategyIre []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyIre = &failoverStrategyIre
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyIsw(failoverStrategyIsw []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyIsw = &failoverStrategyIsw
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyN(failoverStrategyN []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyN = &failoverStrategyN
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyNic(failoverStrategyNic []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyNic = &failoverStrategyNic
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyNie(failoverStrategyNie []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyNie = &failoverStrategyNie
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyNiew(failoverStrategyNiew []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyNiew = &failoverStrategyNiew
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyNire(failoverStrategyNire []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyNire = &failoverStrategyNire
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyNisw(failoverStrategyNisw []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyNisw = &failoverStrategyNisw
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyNre(failoverStrategyNre []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyNre = &failoverStrategyNre
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) FailoverStrategyRe(failoverStrategyRe []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.failoverStrategyRe = &failoverStrategyRe
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimDeviceRedundancyGroupsListRequest) Id(id []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdIc(idIc []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdIe(idIe []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdIew(idIew []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdIre(idIre []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdIsw(idIsw []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdN(idN []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdNic(idNic []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdNie(idNie []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdNiew(idNiew []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdNire(idNire []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdNisw(idNisw []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdNre(idNre []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) IdRe(idRe []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimDeviceRedundancyGroupsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimDeviceRedundancyGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceRedundancyGroupsListRequest) Limit(limit int32) ApiDcimDeviceRedundancyGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) Name(name []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameIc(nameIc []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameIe(nameIe []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameIew(nameIew []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameIre(nameIre []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameIsw(nameIsw []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameN(nameN []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameNic(nameNic []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameNie(nameNie []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameNiew(nameNiew []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameNire(nameNire []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameNisw(nameNisw []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameNre(nameNre []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) NameRe(nameRe []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceRedundancyGroupsListRequest) Offset(offset int32) ApiDcimDeviceRedundancyGroupsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimDeviceRedundancyGroupsListRequest) Q(q string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) SecretsGroup(secretsGroup []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.secretsGroup = &secretsGroup
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) SecretsGroupIsnull(secretsGroupIsnull bool) ApiDcimDeviceRedundancyGroupsListRequest {
	r.secretsGroupIsnull = &secretsGroupIsnull
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) SecretsGroupN(secretsGroupN []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.secretsGroupN = &secretsGroupN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimDeviceRedundancyGroupsListRequest) Sort(sort string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) Status(status []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.status = &status
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) StatusN(statusN []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) Tags(tags []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimDeviceRedundancyGroupsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) TagsN(tagsN []string) ApiDcimDeviceRedundancyGroupsListRequest {
	r.tagsN = &tagsN
	return r
}

// Serializer Depth
func (r ApiDcimDeviceRedundancyGroupsListRequest) Depth(depth int32) ApiDcimDeviceRedundancyGroupsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceRedundancyGroupsListRequest) Execute() (*PaginatedDeviceRedundancyGroupList, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsListExecute(r)
}

/*
DcimDeviceRedundancyGroupsList Method for DcimDeviceRedundancyGroupsList

Retrieve a list of device redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceRedundancyGroupsListRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsList(ctx context.Context) ApiDcimDeviceRedundancyGroupsListRequest {
	return ApiDcimDeviceRedundancyGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceRedundancyGroupList
func (a *DcimAPIService) DcimDeviceRedundancyGroupsListExecute(r ApiDcimDeviceRedundancyGroupsListRequest) (*PaginatedDeviceRedundancyGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceRedundancyGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.failoverStrategy != nil {
		t := *r.failoverStrategy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy", t, "multi")
		}
	}
	if r.failoverStrategyIc != nil {
		t := *r.failoverStrategyIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__ic", t, "multi")
		}
	}
	if r.failoverStrategyIe != nil {
		t := *r.failoverStrategyIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__ie", t, "multi")
		}
	}
	if r.failoverStrategyIew != nil {
		t := *r.failoverStrategyIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__iew", t, "multi")
		}
	}
	if r.failoverStrategyIre != nil {
		t := *r.failoverStrategyIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__ire", t, "multi")
		}
	}
	if r.failoverStrategyIsw != nil {
		t := *r.failoverStrategyIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__isw", t, "multi")
		}
	}
	if r.failoverStrategyN != nil {
		t := *r.failoverStrategyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__n", t, "multi")
		}
	}
	if r.failoverStrategyNic != nil {
		t := *r.failoverStrategyNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nic", t, "multi")
		}
	}
	if r.failoverStrategyNie != nil {
		t := *r.failoverStrategyNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nie", t, "multi")
		}
	}
	if r.failoverStrategyNiew != nil {
		t := *r.failoverStrategyNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__niew", t, "multi")
		}
	}
	if r.failoverStrategyNire != nil {
		t := *r.failoverStrategyNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nire", t, "multi")
		}
	}
	if r.failoverStrategyNisw != nil {
		t := *r.failoverStrategyNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nisw", t, "multi")
		}
	}
	if r.failoverStrategyNre != nil {
		t := *r.failoverStrategyNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__nre", t, "multi")
		}
	}
	if r.failoverStrategyRe != nil {
		t := *r.failoverStrategyRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "failover_strategy__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.secretsGroup != nil {
		t := *r.secretsGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group", t, "multi")
		}
	}
	if r.secretsGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__isnull", r.secretsGroupIsnull, "")
	}
	if r.secretsGroupN != nil {
		t := *r.secretsGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceRedundancyGroupsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimDeviceRedundancyGroupsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimDeviceRedundancyGroupsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceRedundancyGroupsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsNotesCreateExecute(r)
}

/*
DcimDeviceRedundancyGroupsNotesCreate Method for DcimDeviceRedundancyGroupsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device redundancy group.
 @return ApiDcimDeviceRedundancyGroupsNotesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsNotesCreate(ctx context.Context, id string) ApiDcimDeviceRedundancyGroupsNotesCreateRequest {
	return ApiDcimDeviceRedundancyGroupsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimDeviceRedundancyGroupsNotesCreateExecute(r ApiDcimDeviceRedundancyGroupsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimDeviceRedundancyGroupsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceRedundancyGroupsNotesListRequest) Limit(limit int32) ApiDcimDeviceRedundancyGroupsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceRedundancyGroupsNotesListRequest) Offset(offset int32) ApiDcimDeviceRedundancyGroupsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimDeviceRedundancyGroupsNotesListRequest) Depth(depth int32) ApiDcimDeviceRedundancyGroupsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceRedundancyGroupsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsNotesListExecute(r)
}

/*
DcimDeviceRedundancyGroupsNotesList Method for DcimDeviceRedundancyGroupsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device redundancy group.
 @return ApiDcimDeviceRedundancyGroupsNotesListRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsNotesList(ctx context.Context, id string) ApiDcimDeviceRedundancyGroupsNotesListRequest {
	return ApiDcimDeviceRedundancyGroupsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimDeviceRedundancyGroupsNotesListExecute(r ApiDcimDeviceRedundancyGroupsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableDeviceRedundancyGroupRequest *PatchedWritableDeviceRedundancyGroupRequest
}

func (r ApiDcimDeviceRedundancyGroupsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceRedundancyGroupsPartialUpdateRequest) PatchedWritableDeviceRedundancyGroupRequest(patchedWritableDeviceRedundancyGroupRequest PatchedWritableDeviceRedundancyGroupRequest) ApiDcimDeviceRedundancyGroupsPartialUpdateRequest {
	r.patchedWritableDeviceRedundancyGroupRequest = &patchedWritableDeviceRedundancyGroupRequest
	return r
}

func (r ApiDcimDeviceRedundancyGroupsPartialUpdateRequest) Execute() (*DeviceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsPartialUpdateExecute(r)
}

/*
DcimDeviceRedundancyGroupsPartialUpdate Method for DcimDeviceRedundancyGroupsPartialUpdate

Partial update a device redundancy group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device redundancy group.
 @return ApiDcimDeviceRedundancyGroupsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsPartialUpdate(ctx context.Context, id string) ApiDcimDeviceRedundancyGroupsPartialUpdateRequest {
	return ApiDcimDeviceRedundancyGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceRedundancyGroup
func (a *DcimAPIService) DcimDeviceRedundancyGroupsPartialUpdateExecute(r ApiDcimDeviceRedundancyGroupsPartialUpdateRequest) (*DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableDeviceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimDeviceRedundancyGroupsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimDeviceRedundancyGroupsRetrieveRequest) Depth(depth int32) ApiDcimDeviceRedundancyGroupsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceRedundancyGroupsRetrieveRequest) Execute() (*DeviceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsRetrieveExecute(r)
}

/*
DcimDeviceRedundancyGroupsRetrieve Method for DcimDeviceRedundancyGroupsRetrieve

Retrieve a device redundancy group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device redundancy group.
 @return ApiDcimDeviceRedundancyGroupsRetrieveRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsRetrieve(ctx context.Context, id string) ApiDcimDeviceRedundancyGroupsRetrieveRequest {
	return ApiDcimDeviceRedundancyGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceRedundancyGroup
func (a *DcimAPIService) DcimDeviceRedundancyGroupsRetrieveExecute(r ApiDcimDeviceRedundancyGroupsRetrieveRequest) (*DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceRedundancyGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableDeviceRedundancyGroupRequest *WritableDeviceRedundancyGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceRedundancyGroupsUpdateRequest) WritableDeviceRedundancyGroupRequest(writableDeviceRedundancyGroupRequest WritableDeviceRedundancyGroupRequest) ApiDcimDeviceRedundancyGroupsUpdateRequest {
	r.writableDeviceRedundancyGroupRequest = &writableDeviceRedundancyGroupRequest
	return r
}

func (r ApiDcimDeviceRedundancyGroupsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceRedundancyGroupsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceRedundancyGroupsUpdateRequest) Execute() (*DeviceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimDeviceRedundancyGroupsUpdateExecute(r)
}

/*
DcimDeviceRedundancyGroupsUpdate Method for DcimDeviceRedundancyGroupsUpdate

Update a device redundancy group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device redundancy group.
 @return ApiDcimDeviceRedundancyGroupsUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceRedundancyGroupsUpdate(ctx context.Context, id string) ApiDcimDeviceRedundancyGroupsUpdateRequest {
	return ApiDcimDeviceRedundancyGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceRedundancyGroup
func (a *DcimAPIService) DcimDeviceRedundancyGroupsUpdateExecute(r ApiDcimDeviceRedundancyGroupsUpdateRequest) (*DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceRedundancyGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableDeviceRedundancyGroupRequest == nil {
		return localVarReturnValue, nil, reportError("writableDeviceRedundancyGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableDeviceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimDeviceTypesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimDeviceTypesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceTypesBulkDestroyExecute(r)
}

/*
DcimDeviceTypesBulkDestroy Method for DcimDeviceTypesBulkDestroy

Destroy a list of device type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceTypesBulkDestroy(ctx context.Context) ApiDcimDeviceTypesBulkDestroyRequest {
	return ApiDcimDeviceTypesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceTypesBulkDestroyExecute(r ApiDcimDeviceTypesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableDeviceTypeRequest *[]PatchedBulkWritableDeviceTypeRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesBulkPartialUpdateRequest) PatchedBulkWritableDeviceTypeRequest(patchedBulkWritableDeviceTypeRequest []PatchedBulkWritableDeviceTypeRequest) ApiDcimDeviceTypesBulkPartialUpdateRequest {
	r.patchedBulkWritableDeviceTypeRequest = &patchedBulkWritableDeviceTypeRequest
	return r
}

func (r ApiDcimDeviceTypesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesBulkPartialUpdateRequest) Execute() ([]DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesBulkPartialUpdateExecute(r)
}

/*
DcimDeviceTypesBulkPartialUpdate Method for DcimDeviceTypesBulkPartialUpdate

Partial update a list of device type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesBulkPartialUpdate(ctx context.Context) ApiDcimDeviceTypesBulkPartialUpdateRequest {
	return ApiDcimDeviceTypesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceType
func (a *DcimAPIService) DcimDeviceTypesBulkPartialUpdateExecute(r ApiDcimDeviceTypesBulkPartialUpdateRequest) ([]DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableDeviceTypeRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableDeviceTypeRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableDeviceTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableDeviceTypeRequest *[]BulkWritableDeviceTypeRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesBulkUpdateRequest) BulkWritableDeviceTypeRequest(bulkWritableDeviceTypeRequest []BulkWritableDeviceTypeRequest) ApiDcimDeviceTypesBulkUpdateRequest {
	r.bulkWritableDeviceTypeRequest = &bulkWritableDeviceTypeRequest
	return r
}

func (r ApiDcimDeviceTypesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesBulkUpdateRequest) Execute() ([]DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesBulkUpdateExecute(r)
}

/*
DcimDeviceTypesBulkUpdate Method for DcimDeviceTypesBulkUpdate

Update a list of device type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesBulkUpdate(ctx context.Context) ApiDcimDeviceTypesBulkUpdateRequest {
	return ApiDcimDeviceTypesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceType
func (a *DcimAPIService) DcimDeviceTypesBulkUpdateExecute(r ApiDcimDeviceTypesBulkUpdateRequest) ([]DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableDeviceTypeRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableDeviceTypeRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableDeviceTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableDeviceTypeRequest *WritableDeviceTypeRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesCreateRequest) WritableDeviceTypeRequest(writableDeviceTypeRequest WritableDeviceTypeRequest) ApiDcimDeviceTypesCreateRequest {
	r.writableDeviceTypeRequest = &writableDeviceTypeRequest
	return r
}

func (r ApiDcimDeviceTypesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesCreateRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesCreateExecute(r)
}

/*
DcimDeviceTypesCreate Method for DcimDeviceTypesCreate

Create one or more device type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesCreate(ctx context.Context) ApiDcimDeviceTypesCreateRequest {
	return ApiDcimDeviceTypesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimAPIService) DcimDeviceTypesCreateExecute(r ApiDcimDeviceTypesCreateRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableDeviceTypeRequest == nil {
		return localVarReturnValue, nil, reportError("writableDeviceTypeRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableDeviceTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceTypesDestroyExecute(r)
}

/*
DcimDeviceTypesDestroy Method for DcimDeviceTypesDestroy

Destroy a device type object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type.
 @return ApiDcimDeviceTypesDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceTypesDestroy(ctx context.Context, id string) ApiDcimDeviceTypesDestroyRequest {
	return ApiDcimDeviceTypesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceTypesDestroyExecute(r ApiDcimDeviceTypesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	comments *[]string
	commentsIc *[]string
	commentsIe *[]string
	commentsIew *[]string
	commentsIre *[]string
	commentsIsw *[]string
	commentsN *[]string
	commentsNic *[]string
	commentsNie *[]string
	commentsNiew *[]string
	commentsNire *[]string
	commentsNisw *[]string
	commentsNre *[]string
	commentsRe *[]string
	consolePortTemplates *[]string
	consolePortTemplatesIsnull *bool
	consolePortTemplatesN *[]string
	consolePorts *bool
	consoleServerPortTemplates *[]string
	consoleServerPortTemplatesIsnull *bool
	consoleServerPortTemplatesN *[]string
	consoleServerPorts *bool
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	deviceBayTemplates *[]string
	deviceBayTemplatesIsnull *bool
	deviceBayTemplatesN *[]string
	deviceBays *bool
	deviceFamily *[]string
	deviceFamilyIsnull *bool
	deviceFamilyN *[]string
	devices *[]string
	devicesIsnull *bool
	devicesN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	frontPortTemplates *[]string
	frontPortTemplatesIsnull *bool
	frontPortTemplatesN *[]string
	hasConsolePortTemplates *bool
	hasConsoleServerPortTemplates *bool
	hasDeviceBayTemplates *bool
	hasDevices *bool
	hasFrontPortTemplates *bool
	hasInterfaceTemplates *bool
	hasPowerOutletTemplates *bool
	hasPowerPortTemplates *bool
	hasRearPortTemplates *bool
	hasSoftwareImageFiles *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interfaceTemplates *[]string
	interfaceTemplatesIsnull *bool
	interfaceTemplatesN *[]string
	interfaces *bool
	isFullDepth *bool
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	manufacturer *[]string
	manufacturerN *[]string
	model *[]string
	modelIc *[]string
	modelIe *[]string
	modelIew *[]string
	modelIre *[]string
	modelIsw *[]string
	modelN *[]string
	modelNic *[]string
	modelNie *[]string
	modelNiew *[]string
	modelNire *[]string
	modelNisw *[]string
	modelNre *[]string
	modelRe *[]string
	offset *int32
	partNumber *[]string
	partNumberIc *[]string
	partNumberIe *[]string
	partNumberIew *[]string
	partNumberIre *[]string
	partNumberIsw *[]string
	partNumberN *[]string
	partNumberNic *[]string
	partNumberNie *[]string
	partNumberNiew *[]string
	partNumberNire *[]string
	partNumberNisw *[]string
	partNumberNre *[]string
	partNumberRe *[]string
	passThroughPorts *bool
	powerOutletTemplates *[]string
	powerOutletTemplatesIsnull *bool
	powerOutletTemplatesN *[]string
	powerOutlets *bool
	powerPortTemplates *[]string
	powerPortTemplatesIsnull *bool
	powerPortTemplatesN *[]string
	powerPorts *bool
	q *string
	rearPortTemplates *[]string
	rearPortTemplatesIsnull *bool
	rearPortTemplatesN *[]string
	softwareImageFiles *[]string
	softwareImageFilesN *[]string
	sort *string
	subdeviceRole *[]string
	subdeviceRoleIc *[]string
	subdeviceRoleIe *[]string
	subdeviceRoleIew *[]string
	subdeviceRoleIre *[]string
	subdeviceRoleIsw *[]string
	subdeviceRoleN *[]string
	subdeviceRoleNic *[]string
	subdeviceRoleNie *[]string
	subdeviceRoleNiew *[]string
	subdeviceRoleNire *[]string
	subdeviceRoleNisw *[]string
	subdeviceRoleNre *[]string
	subdeviceRoleRe *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	uHeight *[]int32
	uHeightGt *[]int32
	uHeightGte *[]int32
	uHeightLt *[]int32
	uHeightLte *[]int32
	uHeightN *[]int32
	depth *int32
}

func (r ApiDcimDeviceTypesListRequest) Comments(comments []string) ApiDcimDeviceTypesListRequest {
	r.comments = &comments
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsIc(commentsIc []string) ApiDcimDeviceTypesListRequest {
	r.commentsIc = &commentsIc
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsIe(commentsIe []string) ApiDcimDeviceTypesListRequest {
	r.commentsIe = &commentsIe
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsIew(commentsIew []string) ApiDcimDeviceTypesListRequest {
	r.commentsIew = &commentsIew
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsIre(commentsIre []string) ApiDcimDeviceTypesListRequest {
	r.commentsIre = &commentsIre
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsIsw(commentsIsw []string) ApiDcimDeviceTypesListRequest {
	r.commentsIsw = &commentsIsw
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsN(commentsN []string) ApiDcimDeviceTypesListRequest {
	r.commentsN = &commentsN
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsNic(commentsNic []string) ApiDcimDeviceTypesListRequest {
	r.commentsNic = &commentsNic
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsNie(commentsNie []string) ApiDcimDeviceTypesListRequest {
	r.commentsNie = &commentsNie
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsNiew(commentsNiew []string) ApiDcimDeviceTypesListRequest {
	r.commentsNiew = &commentsNiew
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsNire(commentsNire []string) ApiDcimDeviceTypesListRequest {
	r.commentsNire = &commentsNire
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsNisw(commentsNisw []string) ApiDcimDeviceTypesListRequest {
	r.commentsNisw = &commentsNisw
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsNre(commentsNre []string) ApiDcimDeviceTypesListRequest {
	r.commentsNre = &commentsNre
	return r
}

func (r ApiDcimDeviceTypesListRequest) CommentsRe(commentsRe []string) ApiDcimDeviceTypesListRequest {
	r.commentsRe = &commentsRe
	return r
}

func (r ApiDcimDeviceTypesListRequest) ConsolePortTemplates(consolePortTemplates []string) ApiDcimDeviceTypesListRequest {
	r.consolePortTemplates = &consolePortTemplates
	return r
}

func (r ApiDcimDeviceTypesListRequest) ConsolePortTemplatesIsnull(consolePortTemplatesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.consolePortTemplatesIsnull = &consolePortTemplatesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) ConsolePortTemplatesN(consolePortTemplatesN []string) ApiDcimDeviceTypesListRequest {
	r.consolePortTemplatesN = &consolePortTemplatesN
	return r
}

// Has console ports
func (r ApiDcimDeviceTypesListRequest) ConsolePorts(consolePorts bool) ApiDcimDeviceTypesListRequest {
	r.consolePorts = &consolePorts
	return r
}

func (r ApiDcimDeviceTypesListRequest) ConsoleServerPortTemplates(consoleServerPortTemplates []string) ApiDcimDeviceTypesListRequest {
	r.consoleServerPortTemplates = &consoleServerPortTemplates
	return r
}

func (r ApiDcimDeviceTypesListRequest) ConsoleServerPortTemplatesIsnull(consoleServerPortTemplatesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.consoleServerPortTemplatesIsnull = &consoleServerPortTemplatesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) ConsoleServerPortTemplatesN(consoleServerPortTemplatesN []string) ApiDcimDeviceTypesListRequest {
	r.consoleServerPortTemplatesN = &consoleServerPortTemplatesN
	return r
}

// Has console server ports
func (r ApiDcimDeviceTypesListRequest) ConsoleServerPorts(consoleServerPorts bool) ApiDcimDeviceTypesListRequest {
	r.consoleServerPorts = &consoleServerPorts
	return r
}

func (r ApiDcimDeviceTypesListRequest) Created(created []time.Time) ApiDcimDeviceTypesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDeviceTypesListRequest) CreatedGt(createdGt []time.Time) ApiDcimDeviceTypesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimDeviceTypesListRequest) CreatedGte(createdGte []time.Time) ApiDcimDeviceTypesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDeviceTypesListRequest) CreatedIsnull(createdIsnull bool) ApiDcimDeviceTypesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) CreatedLt(createdLt []time.Time) ApiDcimDeviceTypesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimDeviceTypesListRequest) CreatedLte(createdLte []time.Time) ApiDcimDeviceTypesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDeviceTypesListRequest) CreatedN(createdN []time.Time) ApiDcimDeviceTypesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimDeviceTypesListRequest) DeviceBayTemplates(deviceBayTemplates []string) ApiDcimDeviceTypesListRequest {
	r.deviceBayTemplates = &deviceBayTemplates
	return r
}

func (r ApiDcimDeviceTypesListRequest) DeviceBayTemplatesIsnull(deviceBayTemplatesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.deviceBayTemplatesIsnull = &deviceBayTemplatesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) DeviceBayTemplatesN(deviceBayTemplatesN []string) ApiDcimDeviceTypesListRequest {
	r.deviceBayTemplatesN = &deviceBayTemplatesN
	return r
}

// Has device bays
func (r ApiDcimDeviceTypesListRequest) DeviceBays(deviceBays bool) ApiDcimDeviceTypesListRequest {
	r.deviceBays = &deviceBays
	return r
}

func (r ApiDcimDeviceTypesListRequest) DeviceFamily(deviceFamily []string) ApiDcimDeviceTypesListRequest {
	r.deviceFamily = &deviceFamily
	return r
}

func (r ApiDcimDeviceTypesListRequest) DeviceFamilyIsnull(deviceFamilyIsnull bool) ApiDcimDeviceTypesListRequest {
	r.deviceFamilyIsnull = &deviceFamilyIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) DeviceFamilyN(deviceFamilyN []string) ApiDcimDeviceTypesListRequest {
	r.deviceFamilyN = &deviceFamilyN
	return r
}

func (r ApiDcimDeviceTypesListRequest) Devices(devices []string) ApiDcimDeviceTypesListRequest {
	r.devices = &devices
	return r
}

func (r ApiDcimDeviceTypesListRequest) DevicesIsnull(devicesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.devicesIsnull = &devicesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) DevicesN(devicesN []string) ApiDcimDeviceTypesListRequest {
	r.devicesN = &devicesN
	return r
}

func (r ApiDcimDeviceTypesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesListRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesListRequest) FrontPortTemplates(frontPortTemplates []string) ApiDcimDeviceTypesListRequest {
	r.frontPortTemplates = &frontPortTemplates
	return r
}

func (r ApiDcimDeviceTypesListRequest) FrontPortTemplatesIsnull(frontPortTemplatesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.frontPortTemplatesIsnull = &frontPortTemplatesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) FrontPortTemplatesN(frontPortTemplatesN []string) ApiDcimDeviceTypesListRequest {
	r.frontPortTemplatesN = &frontPortTemplatesN
	return r
}

// Has console port templates
func (r ApiDcimDeviceTypesListRequest) HasConsolePortTemplates(hasConsolePortTemplates bool) ApiDcimDeviceTypesListRequest {
	r.hasConsolePortTemplates = &hasConsolePortTemplates
	return r
}

// Has console server port templates
func (r ApiDcimDeviceTypesListRequest) HasConsoleServerPortTemplates(hasConsoleServerPortTemplates bool) ApiDcimDeviceTypesListRequest {
	r.hasConsoleServerPortTemplates = &hasConsoleServerPortTemplates
	return r
}

// Has device bay templates
func (r ApiDcimDeviceTypesListRequest) HasDeviceBayTemplates(hasDeviceBayTemplates bool) ApiDcimDeviceTypesListRequest {
	r.hasDeviceBayTemplates = &hasDeviceBayTemplates
	return r
}

// Has device instances
func (r ApiDcimDeviceTypesListRequest) HasDevices(hasDevices bool) ApiDcimDeviceTypesListRequest {
	r.hasDevices = &hasDevices
	return r
}

// Has front port templates
func (r ApiDcimDeviceTypesListRequest) HasFrontPortTemplates(hasFrontPortTemplates bool) ApiDcimDeviceTypesListRequest {
	r.hasFrontPortTemplates = &hasFrontPortTemplates
	return r
}

// Has interface templates
func (r ApiDcimDeviceTypesListRequest) HasInterfaceTemplates(hasInterfaceTemplates bool) ApiDcimDeviceTypesListRequest {
	r.hasInterfaceTemplates = &hasInterfaceTemplates
	return r
}

// Has power outlet templates
func (r ApiDcimDeviceTypesListRequest) HasPowerOutletTemplates(hasPowerOutletTemplates bool) ApiDcimDeviceTypesListRequest {
	r.hasPowerOutletTemplates = &hasPowerOutletTemplates
	return r
}

// Has power port templates
func (r ApiDcimDeviceTypesListRequest) HasPowerPortTemplates(hasPowerPortTemplates bool) ApiDcimDeviceTypesListRequest {
	r.hasPowerPortTemplates = &hasPowerPortTemplates
	return r
}

// Has rear port templates
func (r ApiDcimDeviceTypesListRequest) HasRearPortTemplates(hasRearPortTemplates bool) ApiDcimDeviceTypesListRequest {
	r.hasRearPortTemplates = &hasRearPortTemplates
	return r
}

// Has software image files
func (r ApiDcimDeviceTypesListRequest) HasSoftwareImageFiles(hasSoftwareImageFiles bool) ApiDcimDeviceTypesListRequest {
	r.hasSoftwareImageFiles = &hasSoftwareImageFiles
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimDeviceTypesListRequest) Id(id []string) ApiDcimDeviceTypesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdIc(idIc []string) ApiDcimDeviceTypesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdIe(idIe []string) ApiDcimDeviceTypesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdIew(idIew []string) ApiDcimDeviceTypesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdIre(idIre []string) ApiDcimDeviceTypesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdIsw(idIsw []string) ApiDcimDeviceTypesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdN(idN []string) ApiDcimDeviceTypesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdNic(idNic []string) ApiDcimDeviceTypesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdNie(idNie []string) ApiDcimDeviceTypesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdNiew(idNiew []string) ApiDcimDeviceTypesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdNire(idNire []string) ApiDcimDeviceTypesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdNisw(idNisw []string) ApiDcimDeviceTypesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdNre(idNre []string) ApiDcimDeviceTypesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimDeviceTypesListRequest) IdRe(idRe []string) ApiDcimDeviceTypesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimDeviceTypesListRequest) InterfaceTemplates(interfaceTemplates []string) ApiDcimDeviceTypesListRequest {
	r.interfaceTemplates = &interfaceTemplates
	return r
}

func (r ApiDcimDeviceTypesListRequest) InterfaceTemplatesIsnull(interfaceTemplatesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.interfaceTemplatesIsnull = &interfaceTemplatesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) InterfaceTemplatesN(interfaceTemplatesN []string) ApiDcimDeviceTypesListRequest {
	r.interfaceTemplatesN = &interfaceTemplatesN
	return r
}

// Has interfaces
func (r ApiDcimDeviceTypesListRequest) Interfaces(interfaces bool) ApiDcimDeviceTypesListRequest {
	r.interfaces = &interfaces
	return r
}

func (r ApiDcimDeviceTypesListRequest) IsFullDepth(isFullDepth bool) ApiDcimDeviceTypesListRequest {
	r.isFullDepth = &isFullDepth
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimDeviceTypesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimDeviceTypesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimDeviceTypesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimDeviceTypesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimDeviceTypesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimDeviceTypesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDeviceTypesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimDeviceTypesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceTypesListRequest) Limit(limit int32) ApiDcimDeviceTypesListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimDeviceTypesListRequest) Manufacturer(manufacturer []string) ApiDcimDeviceTypesListRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiDcimDeviceTypesListRequest) ManufacturerN(manufacturerN []string) ApiDcimDeviceTypesListRequest {
	r.manufacturerN = &manufacturerN
	return r
}

func (r ApiDcimDeviceTypesListRequest) Model(model []string) ApiDcimDeviceTypesListRequest {
	r.model = &model
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIc(modelIc []string) ApiDcimDeviceTypesListRequest {
	r.modelIc = &modelIc
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIe(modelIe []string) ApiDcimDeviceTypesListRequest {
	r.modelIe = &modelIe
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIew(modelIew []string) ApiDcimDeviceTypesListRequest {
	r.modelIew = &modelIew
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIre(modelIre []string) ApiDcimDeviceTypesListRequest {
	r.modelIre = &modelIre
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelIsw(modelIsw []string) ApiDcimDeviceTypesListRequest {
	r.modelIsw = &modelIsw
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelN(modelN []string) ApiDcimDeviceTypesListRequest {
	r.modelN = &modelN
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNic(modelNic []string) ApiDcimDeviceTypesListRequest {
	r.modelNic = &modelNic
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNie(modelNie []string) ApiDcimDeviceTypesListRequest {
	r.modelNie = &modelNie
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNiew(modelNiew []string) ApiDcimDeviceTypesListRequest {
	r.modelNiew = &modelNiew
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNire(modelNire []string) ApiDcimDeviceTypesListRequest {
	r.modelNire = &modelNire
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNisw(modelNisw []string) ApiDcimDeviceTypesListRequest {
	r.modelNisw = &modelNisw
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelNre(modelNre []string) ApiDcimDeviceTypesListRequest {
	r.modelNre = &modelNre
	return r
}

func (r ApiDcimDeviceTypesListRequest) ModelRe(modelRe []string) ApiDcimDeviceTypesListRequest {
	r.modelRe = &modelRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceTypesListRequest) Offset(offset int32) ApiDcimDeviceTypesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumber(partNumber []string) ApiDcimDeviceTypesListRequest {
	r.partNumber = &partNumber
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIc(partNumberIc []string) ApiDcimDeviceTypesListRequest {
	r.partNumberIc = &partNumberIc
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIe(partNumberIe []string) ApiDcimDeviceTypesListRequest {
	r.partNumberIe = &partNumberIe
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIew(partNumberIew []string) ApiDcimDeviceTypesListRequest {
	r.partNumberIew = &partNumberIew
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIre(partNumberIre []string) ApiDcimDeviceTypesListRequest {
	r.partNumberIre = &partNumberIre
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberIsw(partNumberIsw []string) ApiDcimDeviceTypesListRequest {
	r.partNumberIsw = &partNumberIsw
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberN(partNumberN []string) ApiDcimDeviceTypesListRequest {
	r.partNumberN = &partNumberN
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNic(partNumberNic []string) ApiDcimDeviceTypesListRequest {
	r.partNumberNic = &partNumberNic
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNie(partNumberNie []string) ApiDcimDeviceTypesListRequest {
	r.partNumberNie = &partNumberNie
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNiew(partNumberNiew []string) ApiDcimDeviceTypesListRequest {
	r.partNumberNiew = &partNumberNiew
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNire(partNumberNire []string) ApiDcimDeviceTypesListRequest {
	r.partNumberNire = &partNumberNire
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNisw(partNumberNisw []string) ApiDcimDeviceTypesListRequest {
	r.partNumberNisw = &partNumberNisw
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberNre(partNumberNre []string) ApiDcimDeviceTypesListRequest {
	r.partNumberNre = &partNumberNre
	return r
}

func (r ApiDcimDeviceTypesListRequest) PartNumberRe(partNumberRe []string) ApiDcimDeviceTypesListRequest {
	r.partNumberRe = &partNumberRe
	return r
}

// Has pass-through ports
func (r ApiDcimDeviceTypesListRequest) PassThroughPorts(passThroughPorts bool) ApiDcimDeviceTypesListRequest {
	r.passThroughPorts = &passThroughPorts
	return r
}

func (r ApiDcimDeviceTypesListRequest) PowerOutletTemplates(powerOutletTemplates []string) ApiDcimDeviceTypesListRequest {
	r.powerOutletTemplates = &powerOutletTemplates
	return r
}

func (r ApiDcimDeviceTypesListRequest) PowerOutletTemplatesIsnull(powerOutletTemplatesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.powerOutletTemplatesIsnull = &powerOutletTemplatesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) PowerOutletTemplatesN(powerOutletTemplatesN []string) ApiDcimDeviceTypesListRequest {
	r.powerOutletTemplatesN = &powerOutletTemplatesN
	return r
}

// Has power outlets
func (r ApiDcimDeviceTypesListRequest) PowerOutlets(powerOutlets bool) ApiDcimDeviceTypesListRequest {
	r.powerOutlets = &powerOutlets
	return r
}

func (r ApiDcimDeviceTypesListRequest) PowerPortTemplates(powerPortTemplates []string) ApiDcimDeviceTypesListRequest {
	r.powerPortTemplates = &powerPortTemplates
	return r
}

func (r ApiDcimDeviceTypesListRequest) PowerPortTemplatesIsnull(powerPortTemplatesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.powerPortTemplatesIsnull = &powerPortTemplatesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) PowerPortTemplatesN(powerPortTemplatesN []string) ApiDcimDeviceTypesListRequest {
	r.powerPortTemplatesN = &powerPortTemplatesN
	return r
}

// Has power ports
func (r ApiDcimDeviceTypesListRequest) PowerPorts(powerPorts bool) ApiDcimDeviceTypesListRequest {
	r.powerPorts = &powerPorts
	return r
}

// Search
func (r ApiDcimDeviceTypesListRequest) Q(q string) ApiDcimDeviceTypesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimDeviceTypesListRequest) RearPortTemplates(rearPortTemplates []string) ApiDcimDeviceTypesListRequest {
	r.rearPortTemplates = &rearPortTemplates
	return r
}

func (r ApiDcimDeviceTypesListRequest) RearPortTemplatesIsnull(rearPortTemplatesIsnull bool) ApiDcimDeviceTypesListRequest {
	r.rearPortTemplatesIsnull = &rearPortTemplatesIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) RearPortTemplatesN(rearPortTemplatesN []string) ApiDcimDeviceTypesListRequest {
	r.rearPortTemplatesN = &rearPortTemplatesN
	return r
}

func (r ApiDcimDeviceTypesListRequest) SoftwareImageFiles(softwareImageFiles []string) ApiDcimDeviceTypesListRequest {
	r.softwareImageFiles = &softwareImageFiles
	return r
}

func (r ApiDcimDeviceTypesListRequest) SoftwareImageFilesN(softwareImageFilesN []string) ApiDcimDeviceTypesListRequest {
	r.softwareImageFilesN = &softwareImageFilesN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimDeviceTypesListRequest) Sort(sort string) ApiDcimDeviceTypesListRequest {
	r.sort = &sort
	return r
}

// Parent devices house child devices in device bays. Leave blank if this device type is neither a parent nor a child.
func (r ApiDcimDeviceTypesListRequest) SubdeviceRole(subdeviceRole []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRole = &subdeviceRole
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleIc(subdeviceRoleIc []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleIc = &subdeviceRoleIc
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleIe(subdeviceRoleIe []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleIe = &subdeviceRoleIe
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleIew(subdeviceRoleIew []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleIew = &subdeviceRoleIew
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleIre(subdeviceRoleIre []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleIre = &subdeviceRoleIre
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleIsw(subdeviceRoleIsw []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleIsw = &subdeviceRoleIsw
	return r
}

// Parent devices house child devices in device bays. Leave blank if this device type is neither a parent nor a child.
func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleN(subdeviceRoleN []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleN = &subdeviceRoleN
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleNic(subdeviceRoleNic []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleNic = &subdeviceRoleNic
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleNie(subdeviceRoleNie []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleNie = &subdeviceRoleNie
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleNiew(subdeviceRoleNiew []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleNiew = &subdeviceRoleNiew
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleNire(subdeviceRoleNire []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleNire = &subdeviceRoleNire
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleNisw(subdeviceRoleNisw []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleNisw = &subdeviceRoleNisw
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleNre(subdeviceRoleNre []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleNre = &subdeviceRoleNre
	return r
}

func (r ApiDcimDeviceTypesListRequest) SubdeviceRoleRe(subdeviceRoleRe []string) ApiDcimDeviceTypesListRequest {
	r.subdeviceRoleRe = &subdeviceRoleRe
	return r
}

func (r ApiDcimDeviceTypesListRequest) Tags(tags []string) ApiDcimDeviceTypesListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimDeviceTypesListRequest) TagsIsnull(tagsIsnull bool) ApiDcimDeviceTypesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimDeviceTypesListRequest) TagsN(tagsN []string) ApiDcimDeviceTypesListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeight(uHeight []int32) ApiDcimDeviceTypesListRequest {
	r.uHeight = &uHeight
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightGt(uHeightGt []int32) ApiDcimDeviceTypesListRequest {
	r.uHeightGt = &uHeightGt
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightGte(uHeightGte []int32) ApiDcimDeviceTypesListRequest {
	r.uHeightGte = &uHeightGte
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightLt(uHeightLt []int32) ApiDcimDeviceTypesListRequest {
	r.uHeightLt = &uHeightLt
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightLte(uHeightLte []int32) ApiDcimDeviceTypesListRequest {
	r.uHeightLte = &uHeightLte
	return r
}

func (r ApiDcimDeviceTypesListRequest) UHeightN(uHeightN []int32) ApiDcimDeviceTypesListRequest {
	r.uHeightN = &uHeightN
	return r
}

// Serializer Depth
func (r ApiDcimDeviceTypesListRequest) Depth(depth int32) ApiDcimDeviceTypesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceTypesListRequest) Execute() (*PaginatedDeviceTypeList, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesListExecute(r)
}

/*
DcimDeviceTypesList Method for DcimDeviceTypesList

Retrieve a list of device type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesListRequest
*/
func (a *DcimAPIService) DcimDeviceTypesList(ctx context.Context) ApiDcimDeviceTypesListRequest {
	return ApiDcimDeviceTypesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceTypeList
func (a *DcimAPIService) DcimDeviceTypesListExecute(r ApiDcimDeviceTypesListRequest) (*PaginatedDeviceTypeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceTypeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.comments != nil {
		t := *r.comments
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments", t, "multi")
		}
	}
	if r.commentsIc != nil {
		t := *r.commentsIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ic", t, "multi")
		}
	}
	if r.commentsIe != nil {
		t := *r.commentsIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ie", t, "multi")
		}
	}
	if r.commentsIew != nil {
		t := *r.commentsIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__iew", t, "multi")
		}
	}
	if r.commentsIre != nil {
		t := *r.commentsIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ire", t, "multi")
		}
	}
	if r.commentsIsw != nil {
		t := *r.commentsIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__isw", t, "multi")
		}
	}
	if r.commentsN != nil {
		t := *r.commentsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__n", t, "multi")
		}
	}
	if r.commentsNic != nil {
		t := *r.commentsNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nic", t, "multi")
		}
	}
	if r.commentsNie != nil {
		t := *r.commentsNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nie", t, "multi")
		}
	}
	if r.commentsNiew != nil {
		t := *r.commentsNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__niew", t, "multi")
		}
	}
	if r.commentsNire != nil {
		t := *r.commentsNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nire", t, "multi")
		}
	}
	if r.commentsNisw != nil {
		t := *r.commentsNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nisw", t, "multi")
		}
	}
	if r.commentsNre != nil {
		t := *r.commentsNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nre", t, "multi")
		}
	}
	if r.commentsRe != nil {
		t := *r.commentsRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__re", t, "multi")
		}
	}
	if r.consolePortTemplates != nil {
		t := *r.consolePortTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "console_port_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "console_port_templates", t, "multi")
		}
	}
	if r.consolePortTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "console_port_templates__isnull", r.consolePortTemplatesIsnull, "")
	}
	if r.consolePortTemplatesN != nil {
		t := *r.consolePortTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "console_port_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "console_port_templates__n", t, "multi")
		}
	}
	if r.consolePorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "console_ports", r.consolePorts, "")
	}
	if r.consoleServerPortTemplates != nil {
		t := *r.consoleServerPortTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_port_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_port_templates", t, "multi")
		}
	}
	if r.consoleServerPortTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_port_templates__isnull", r.consoleServerPortTemplatesIsnull, "")
	}
	if r.consoleServerPortTemplatesN != nil {
		t := *r.consoleServerPortTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_port_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_port_templates__n", t, "multi")
		}
	}
	if r.consoleServerPorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_ports", r.consoleServerPorts, "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.deviceBayTemplates != nil {
		t := *r.deviceBayTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_bay_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_bay_templates", t, "multi")
		}
	}
	if r.deviceBayTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_bay_templates__isnull", r.deviceBayTemplatesIsnull, "")
	}
	if r.deviceBayTemplatesN != nil {
		t := *r.deviceBayTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_bay_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_bay_templates__n", t, "multi")
		}
	}
	if r.deviceBays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_bays", r.deviceBays, "")
	}
	if r.deviceFamily != nil {
		t := *r.deviceFamily
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_family", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_family", t, "multi")
		}
	}
	if r.deviceFamilyIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_family__isnull", r.deviceFamilyIsnull, "")
	}
	if r.deviceFamilyN != nil {
		t := *r.deviceFamilyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_family__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_family__n", t, "multi")
		}
	}
	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices", t, "multi")
		}
	}
	if r.devicesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices__isnull", r.devicesIsnull, "")
	}
	if r.devicesN != nil {
		t := *r.devicesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.frontPortTemplates != nil {
		t := *r.frontPortTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates", t, "multi")
		}
	}
	if r.frontPortTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates__isnull", r.frontPortTemplatesIsnull, "")
	}
	if r.frontPortTemplatesN != nil {
		t := *r.frontPortTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates__n", t, "multi")
		}
	}
	if r.hasConsolePortTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_console_port_templates", r.hasConsolePortTemplates, "")
	}
	if r.hasConsoleServerPortTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_console_server_port_templates", r.hasConsoleServerPortTemplates, "")
	}
	if r.hasDeviceBayTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_device_bay_templates", r.hasDeviceBayTemplates, "")
	}
	if r.hasDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_devices", r.hasDevices, "")
	}
	if r.hasFrontPortTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_front_port_templates", r.hasFrontPortTemplates, "")
	}
	if r.hasInterfaceTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_interface_templates", r.hasInterfaceTemplates, "")
	}
	if r.hasPowerOutletTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_outlet_templates", r.hasPowerOutletTemplates, "")
	}
	if r.hasPowerPortTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_port_templates", r.hasPowerPortTemplates, "")
	}
	if r.hasRearPortTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_rear_port_templates", r.hasRearPortTemplates, "")
	}
	if r.hasSoftwareImageFiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_software_image_files", r.hasSoftwareImageFiles, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.interfaceTemplates != nil {
		t := *r.interfaceTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_templates", t, "multi")
		}
	}
	if r.interfaceTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_templates__isnull", r.interfaceTemplatesIsnull, "")
	}
	if r.interfaceTemplatesN != nil {
		t := *r.interfaceTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_templates__n", t, "multi")
		}
	}
	if r.interfaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces", r.interfaces, "")
	}
	if r.isFullDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_full_depth", r.isFullDepth, "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.manufacturer != nil {
		t := *r.manufacturer
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", t, "multi")
		}
	}
	if r.manufacturerN != nil {
		t := *r.manufacturerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__n", t, "multi")
		}
	}
	if r.model != nil {
		t := *r.model
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model", t, "multi")
		}
	}
	if r.modelIc != nil {
		t := *r.modelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__ic", t, "multi")
		}
	}
	if r.modelIe != nil {
		t := *r.modelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__ie", t, "multi")
		}
	}
	if r.modelIew != nil {
		t := *r.modelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__iew", t, "multi")
		}
	}
	if r.modelIre != nil {
		t := *r.modelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__ire", t, "multi")
		}
	}
	if r.modelIsw != nil {
		t := *r.modelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__isw", t, "multi")
		}
	}
	if r.modelN != nil {
		t := *r.modelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__n", t, "multi")
		}
	}
	if r.modelNic != nil {
		t := *r.modelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__nic", t, "multi")
		}
	}
	if r.modelNie != nil {
		t := *r.modelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__nie", t, "multi")
		}
	}
	if r.modelNiew != nil {
		t := *r.modelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__niew", t, "multi")
		}
	}
	if r.modelNire != nil {
		t := *r.modelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__nire", t, "multi")
		}
	}
	if r.modelNisw != nil {
		t := *r.modelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__nisw", t, "multi")
		}
	}
	if r.modelNre != nil {
		t := *r.modelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__nre", t, "multi")
		}
	}
	if r.modelRe != nil {
		t := *r.modelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "model__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "model__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.partNumber != nil {
		t := *r.partNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number", t, "multi")
		}
	}
	if r.partNumberIc != nil {
		t := *r.partNumberIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__ic", t, "multi")
		}
	}
	if r.partNumberIe != nil {
		t := *r.partNumberIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__ie", t, "multi")
		}
	}
	if r.partNumberIew != nil {
		t := *r.partNumberIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__iew", t, "multi")
		}
	}
	if r.partNumberIre != nil {
		t := *r.partNumberIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__ire", t, "multi")
		}
	}
	if r.partNumberIsw != nil {
		t := *r.partNumberIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__isw", t, "multi")
		}
	}
	if r.partNumberN != nil {
		t := *r.partNumberN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__n", t, "multi")
		}
	}
	if r.partNumberNic != nil {
		t := *r.partNumberNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nic", t, "multi")
		}
	}
	if r.partNumberNie != nil {
		t := *r.partNumberNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nie", t, "multi")
		}
	}
	if r.partNumberNiew != nil {
		t := *r.partNumberNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__niew", t, "multi")
		}
	}
	if r.partNumberNire != nil {
		t := *r.partNumberNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nire", t, "multi")
		}
	}
	if r.partNumberNisw != nil {
		t := *r.partNumberNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nisw", t, "multi")
		}
	}
	if r.partNumberNre != nil {
		t := *r.partNumberNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__nre", t, "multi")
		}
	}
	if r.partNumberRe != nil {
		t := *r.partNumberRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_number__re", t, "multi")
		}
	}
	if r.passThroughPorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pass_through_ports", r.passThroughPorts, "")
	}
	if r.powerOutletTemplates != nil {
		t := *r.powerOutletTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates", t, "multi")
		}
	}
	if r.powerOutletTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates__isnull", r.powerOutletTemplatesIsnull, "")
	}
	if r.powerOutletTemplatesN != nil {
		t := *r.powerOutletTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates__n", t, "multi")
		}
	}
	if r.powerOutlets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets", r.powerOutlets, "")
	}
	if r.powerPortTemplates != nil {
		t := *r.powerPortTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_templates", t, "multi")
		}
	}
	if r.powerPortTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_templates__isnull", r.powerPortTemplatesIsnull, "")
	}
	if r.powerPortTemplatesN != nil {
		t := *r.powerPortTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_templates__n", t, "multi")
		}
	}
	if r.powerPorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_ports", r.powerPorts, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rearPortTemplates != nil {
		t := *r.rearPortTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_templates", t, "multi")
		}
	}
	if r.rearPortTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_templates__isnull", r.rearPortTemplatesIsnull, "")
	}
	if r.rearPortTemplatesN != nil {
		t := *r.rearPortTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_templates__n", t, "multi")
		}
	}
	if r.softwareImageFiles != nil {
		t := *r.softwareImageFiles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files", t, "multi")
		}
	}
	if r.softwareImageFilesN != nil {
		t := *r.softwareImageFilesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.subdeviceRole != nil {
		t := *r.subdeviceRole
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role", t, "multi")
		}
	}
	if r.subdeviceRoleIc != nil {
		t := *r.subdeviceRoleIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__ic", t, "multi")
		}
	}
	if r.subdeviceRoleIe != nil {
		t := *r.subdeviceRoleIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__ie", t, "multi")
		}
	}
	if r.subdeviceRoleIew != nil {
		t := *r.subdeviceRoleIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__iew", t, "multi")
		}
	}
	if r.subdeviceRoleIre != nil {
		t := *r.subdeviceRoleIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__ire", t, "multi")
		}
	}
	if r.subdeviceRoleIsw != nil {
		t := *r.subdeviceRoleIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__isw", t, "multi")
		}
	}
	if r.subdeviceRoleN != nil {
		t := *r.subdeviceRoleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__n", t, "multi")
		}
	}
	if r.subdeviceRoleNic != nil {
		t := *r.subdeviceRoleNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nic", t, "multi")
		}
	}
	if r.subdeviceRoleNie != nil {
		t := *r.subdeviceRoleNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nie", t, "multi")
		}
	}
	if r.subdeviceRoleNiew != nil {
		t := *r.subdeviceRoleNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__niew", t, "multi")
		}
	}
	if r.subdeviceRoleNire != nil {
		t := *r.subdeviceRoleNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nire", t, "multi")
		}
	}
	if r.subdeviceRoleNisw != nil {
		t := *r.subdeviceRoleNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nisw", t, "multi")
		}
	}
	if r.subdeviceRoleNre != nil {
		t := *r.subdeviceRoleNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__nre", t, "multi")
		}
	}
	if r.subdeviceRoleRe != nil {
		t := *r.subdeviceRoleRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subdevice_role__re", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.uHeight != nil {
		t := *r.uHeight
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height", t, "multi")
		}
	}
	if r.uHeightGt != nil {
		t := *r.uHeightGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__gt", t, "multi")
		}
	}
	if r.uHeightGte != nil {
		t := *r.uHeightGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__gte", t, "multi")
		}
	}
	if r.uHeightLt != nil {
		t := *r.uHeightLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__lt", t, "multi")
		}
	}
	if r.uHeightLte != nil {
		t := *r.uHeightLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__lte", t, "multi")
		}
	}
	if r.uHeightN != nil {
		t := *r.uHeightN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimDeviceTypesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimDeviceTypesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesNotesCreateExecute(r)
}

/*
DcimDeviceTypesNotesCreate Method for DcimDeviceTypesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type.
 @return ApiDcimDeviceTypesNotesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesNotesCreate(ctx context.Context, id string) ApiDcimDeviceTypesNotesCreateRequest {
	return ApiDcimDeviceTypesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimDeviceTypesNotesCreateExecute(r ApiDcimDeviceTypesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimDeviceTypesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceTypesNotesListRequest) Limit(limit int32) ApiDcimDeviceTypesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceTypesNotesListRequest) Offset(offset int32) ApiDcimDeviceTypesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimDeviceTypesNotesListRequest) Depth(depth int32) ApiDcimDeviceTypesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceTypesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesNotesListExecute(r)
}

/*
DcimDeviceTypesNotesList Method for DcimDeviceTypesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type.
 @return ApiDcimDeviceTypesNotesListRequest
*/
func (a *DcimAPIService) DcimDeviceTypesNotesList(ctx context.Context, id string) ApiDcimDeviceTypesNotesListRequest {
	return ApiDcimDeviceTypesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimDeviceTypesNotesListExecute(r ApiDcimDeviceTypesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableDeviceTypeRequest *PatchedWritableDeviceTypeRequest
}

func (r ApiDcimDeviceTypesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesPartialUpdateRequest) PatchedWritableDeviceTypeRequest(patchedWritableDeviceTypeRequest PatchedWritableDeviceTypeRequest) ApiDcimDeviceTypesPartialUpdateRequest {
	r.patchedWritableDeviceTypeRequest = &patchedWritableDeviceTypeRequest
	return r
}

func (r ApiDcimDeviceTypesPartialUpdateRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesPartialUpdateExecute(r)
}

/*
DcimDeviceTypesPartialUpdate Method for DcimDeviceTypesPartialUpdate

Partial update a device type object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type.
 @return ApiDcimDeviceTypesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesPartialUpdate(ctx context.Context, id string) ApiDcimDeviceTypesPartialUpdateRequest {
	return ApiDcimDeviceTypesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimAPIService) DcimDeviceTypesPartialUpdateExecute(r ApiDcimDeviceTypesPartialUpdateRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableDeviceTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimDeviceTypesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimDeviceTypesRetrieveRequest) Depth(depth int32) ApiDcimDeviceTypesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceTypesRetrieveRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesRetrieveExecute(r)
}

/*
DcimDeviceTypesRetrieve Method for DcimDeviceTypesRetrieve

Retrieve a device type object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type.
 @return ApiDcimDeviceTypesRetrieveRequest
*/
func (a *DcimAPIService) DcimDeviceTypesRetrieve(ctx context.Context, id string) ApiDcimDeviceTypesRetrieveRequest {
	return ApiDcimDeviceTypesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimAPIService) DcimDeviceTypesRetrieveExecute(r ApiDcimDeviceTypesRetrieveRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesBulkDestroyExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesBulkDestroy Method for DcimDeviceTypesToSoftwareImageFilesBulkDestroy

Destroy a list of device type to software image file mapping objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesBulkDestroy(ctx context.Context) ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesBulkDestroyExecute(r ApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableDeviceTypeToSoftwareImageFileRequest *[]PatchedBulkWritableDeviceTypeToSoftwareImageFileRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest) PatchedBulkWritableDeviceTypeToSoftwareImageFileRequest(patchedBulkWritableDeviceTypeToSoftwareImageFileRequest []PatchedBulkWritableDeviceTypeToSoftwareImageFileRequest) ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest {
	r.patchedBulkWritableDeviceTypeToSoftwareImageFileRequest = &patchedBulkWritableDeviceTypeToSoftwareImageFileRequest
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest) Execute() ([]DeviceTypeToSoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesBulkPartialUpdate Method for DcimDeviceTypesToSoftwareImageFilesBulkPartialUpdate

Partial update a list of device type to software image file mapping objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesBulkPartialUpdate(ctx context.Context) ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceTypeToSoftwareImageFile
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateExecute(r ApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateRequest) ([]DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceTypeToSoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableDeviceTypeToSoftwareImageFileRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableDeviceTypeToSoftwareImageFileRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableDeviceTypeToSoftwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableDeviceTypeToSoftwareImageFileRequest *[]BulkWritableDeviceTypeToSoftwareImageFileRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest) BulkWritableDeviceTypeToSoftwareImageFileRequest(bulkWritableDeviceTypeToSoftwareImageFileRequest []BulkWritableDeviceTypeToSoftwareImageFileRequest) ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest {
	r.bulkWritableDeviceTypeToSoftwareImageFileRequest = &bulkWritableDeviceTypeToSoftwareImageFileRequest
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest) Execute() ([]DeviceTypeToSoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesBulkUpdateExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesBulkUpdate Method for DcimDeviceTypesToSoftwareImageFilesBulkUpdate

Update a list of device type to software image file mapping objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesBulkUpdate(ctx context.Context) ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeviceTypeToSoftwareImageFile
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesBulkUpdateExecute(r ApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateRequest) ([]DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceTypeToSoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableDeviceTypeToSoftwareImageFileRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableDeviceTypeToSoftwareImageFileRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableDeviceTypeToSoftwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	deviceTypeToSoftwareImageFileRequest *DeviceTypeToSoftwareImageFileRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest) DeviceTypeToSoftwareImageFileRequest(deviceTypeToSoftwareImageFileRequest DeviceTypeToSoftwareImageFileRequest) ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest {
	r.deviceTypeToSoftwareImageFileRequest = &deviceTypeToSoftwareImageFileRequest
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest) Execute() (*DeviceTypeToSoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesCreateExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesCreate Method for DcimDeviceTypesToSoftwareImageFilesCreate

Create one or more device type to software image file mapping objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesCreate(ctx context.Context) ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceTypeToSoftwareImageFile
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesCreateExecute(r ApiDcimDeviceTypesToSoftwareImageFilesCreateRequest) (*DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceTypeToSoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceTypeToSoftwareImageFileRequest == nil {
		return localVarReturnValue, nil, reportError("deviceTypeToSoftwareImageFileRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceTypeToSoftwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesDestroyExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesDestroy Method for DcimDeviceTypesToSoftwareImageFilesDestroy

Destroy a device type to software image file mapping object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type to software image file mapping.
 @return ApiDcimDeviceTypesToSoftwareImageFilesDestroyRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesDestroy(ctx context.Context, id string) ApiDcimDeviceTypesToSoftwareImageFilesDestroyRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesDestroyExecute(r ApiDcimDeviceTypesToSoftwareImageFilesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	deviceType *[]string
	deviceTypeN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	offset *int32
	q *string
	softwareImageFile *[]string
	softwareImageFileN *[]string
	sort *string
	depth *int32
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Created(created []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) CreatedGt(createdGt []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) CreatedGte(createdGte []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) CreatedIsnull(createdIsnull bool) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) CreatedLt(createdLt []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) CreatedLte(createdLte []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) CreatedN(createdN []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) DeviceType(deviceType []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Id(id []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdIc(idIc []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdIe(idIe []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdIew(idIew []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdIre(idIre []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdIsw(idIsw []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdN(idN []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdNic(idNic []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdNie(idNie []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdNiew(idNiew []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdNire(idNire []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdNisw(idNisw []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdNre(idNre []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) IdRe(idRe []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Limit(limit int32) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Offset(offset int32) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Q(q string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) SoftwareImageFile(softwareImageFile []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.softwareImageFile = &softwareImageFile
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) SoftwareImageFileN(softwareImageFileN []string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.softwareImageFileN = &softwareImageFileN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Sort(sort string) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Depth(depth int32) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) Execute() (*PaginatedDeviceTypeToSoftwareImageFileList, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesListExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesList Method for DcimDeviceTypesToSoftwareImageFilesList

Retrieve a list of device type to software image file mapping objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDeviceTypesToSoftwareImageFilesListRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesList(ctx context.Context) ApiDcimDeviceTypesToSoftwareImageFilesListRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceTypeToSoftwareImageFileList
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesListExecute(r ApiDcimDeviceTypesToSoftwareImageFilesListRequest) (*PaginatedDeviceTypeToSoftwareImageFileList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceTypeToSoftwareImageFileList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.softwareImageFile != nil {
		t := *r.softwareImageFile
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_file", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_file", t, "multi")
		}
	}
	if r.softwareImageFileN != nil {
		t := *r.softwareImageFileN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_file__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_file__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedDeviceTypeToSoftwareImageFileRequest *PatchedDeviceTypeToSoftwareImageFileRequest
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest) PatchedDeviceTypeToSoftwareImageFileRequest(patchedDeviceTypeToSoftwareImageFileRequest PatchedDeviceTypeToSoftwareImageFileRequest) ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest {
	r.patchedDeviceTypeToSoftwareImageFileRequest = &patchedDeviceTypeToSoftwareImageFileRequest
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest) Execute() (*DeviceTypeToSoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesPartialUpdateExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesPartialUpdate Method for DcimDeviceTypesToSoftwareImageFilesPartialUpdate

Partial update a device type to software image file mapping object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type to software image file mapping.
 @return ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesPartialUpdate(ctx context.Context, id string) ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceTypeToSoftwareImageFile
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesPartialUpdateExecute(r ApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateRequest) (*DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceTypeToSoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDeviceTypeToSoftwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest) Depth(depth int32) ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest) Execute() (*DeviceTypeToSoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesRetrieveExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesRetrieve Method for DcimDeviceTypesToSoftwareImageFilesRetrieve

Retrieve a device type to software image file mapping object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type to software image file mapping.
 @return ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesRetrieve(ctx context.Context, id string) ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceTypeToSoftwareImageFile
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesRetrieveExecute(r ApiDcimDeviceTypesToSoftwareImageFilesRetrieveRequest) (*DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceTypeToSoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	deviceTypeToSoftwareImageFileRequest *DeviceTypeToSoftwareImageFileRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest) DeviceTypeToSoftwareImageFileRequest(deviceTypeToSoftwareImageFileRequest DeviceTypeToSoftwareImageFileRequest) ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest {
	r.deviceTypeToSoftwareImageFileRequest = &deviceTypeToSoftwareImageFileRequest
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest) Execute() (*DeviceTypeToSoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesToSoftwareImageFilesUpdateExecute(r)
}

/*
DcimDeviceTypesToSoftwareImageFilesUpdate Method for DcimDeviceTypesToSoftwareImageFilesUpdate

Update a device type to software image file mapping object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type to software image file mapping.
 @return ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesUpdate(ctx context.Context, id string) ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest {
	return ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceTypeToSoftwareImageFile
func (a *DcimAPIService) DcimDeviceTypesToSoftwareImageFilesUpdateExecute(r ApiDcimDeviceTypesToSoftwareImageFilesUpdateRequest) (*DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceTypeToSoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesToSoftwareImageFilesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types-to-software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceTypeToSoftwareImageFileRequest == nil {
		return localVarReturnValue, nil, reportError("deviceTypeToSoftwareImageFileRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceTypeToSoftwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDeviceTypesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableDeviceTypeRequest *WritableDeviceTypeRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDeviceTypesUpdateRequest) WritableDeviceTypeRequest(writableDeviceTypeRequest WritableDeviceTypeRequest) ApiDcimDeviceTypesUpdateRequest {
	r.writableDeviceTypeRequest = &writableDeviceTypeRequest
	return r
}

func (r ApiDcimDeviceTypesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDeviceTypesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDeviceTypesUpdateRequest) Execute() (*DeviceType, *http.Response, error) {
	return r.ApiService.DcimDeviceTypesUpdateExecute(r)
}

/*
DcimDeviceTypesUpdate Method for DcimDeviceTypesUpdate

Update a device type object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device type.
 @return ApiDcimDeviceTypesUpdateRequest
*/
func (a *DcimAPIService) DcimDeviceTypesUpdate(ctx context.Context, id string) ApiDcimDeviceTypesUpdateRequest {
	return ApiDcimDeviceTypesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceType
func (a *DcimAPIService) DcimDeviceTypesUpdateExecute(r ApiDcimDeviceTypesUpdateRequest) (*DeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDeviceTypesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableDeviceTypeRequest == nil {
		return localVarReturnValue, nil, reportError("writableDeviceTypeRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableDeviceTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDevicesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimDevicesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimDevicesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDevicesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDevicesBulkDestroyExecute(r)
}

/*
DcimDevicesBulkDestroy Method for DcimDevicesBulkDestroy

Destroy a list of device objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimDevicesBulkDestroy(ctx context.Context) ApiDcimDevicesBulkDestroyRequest {
	return ApiDcimDevicesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDevicesBulkDestroyExecute(r ApiDcimDevicesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDevicesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableDeviceRequest *[]PatchedBulkWritableDeviceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDevicesBulkPartialUpdateRequest) PatchedBulkWritableDeviceRequest(patchedBulkWritableDeviceRequest []PatchedBulkWritableDeviceRequest) ApiDcimDevicesBulkPartialUpdateRequest {
	r.patchedBulkWritableDeviceRequest = &patchedBulkWritableDeviceRequest
	return r
}

func (r ApiDcimDevicesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDevicesBulkPartialUpdateRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.DcimDevicesBulkPartialUpdateExecute(r)
}

/*
DcimDevicesBulkPartialUpdate Method for DcimDevicesBulkPartialUpdate

Partial update a list of device objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDevicesBulkPartialUpdate(ctx context.Context) ApiDcimDevicesBulkPartialUpdateRequest {
	return ApiDcimDevicesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *DcimAPIService) DcimDevicesBulkPartialUpdateExecute(r ApiDcimDevicesBulkPartialUpdateRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableDeviceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableDeviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableDeviceRequest *[]BulkWritableDeviceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDevicesBulkUpdateRequest) BulkWritableDeviceRequest(bulkWritableDeviceRequest []BulkWritableDeviceRequest) ApiDcimDevicesBulkUpdateRequest {
	r.bulkWritableDeviceRequest = &bulkWritableDeviceRequest
	return r
}

func (r ApiDcimDevicesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDevicesBulkUpdateRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.DcimDevicesBulkUpdateExecute(r)
}

/*
DcimDevicesBulkUpdate Method for DcimDevicesBulkUpdate

Update a list of device objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimDevicesBulkUpdate(ctx context.Context) ApiDcimDevicesBulkUpdateRequest {
	return ApiDcimDevicesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *DcimAPIService) DcimDevicesBulkUpdateExecute(r ApiDcimDevicesBulkUpdateRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableDeviceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableDeviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableDeviceRequest *WritableDeviceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDevicesCreateRequest) WritableDeviceRequest(writableDeviceRequest WritableDeviceRequest) ApiDcimDevicesCreateRequest {
	r.writableDeviceRequest = &writableDeviceRequest
	return r
}

func (r ApiDcimDevicesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDevicesCreateRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.DcimDevicesCreateExecute(r)
}

/*
DcimDevicesCreate Method for DcimDevicesCreate

Create one or more device objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesCreateRequest
*/
func (a *DcimAPIService) DcimDevicesCreate(ctx context.Context) ApiDcimDevicesCreateRequest {
	return ApiDcimDevicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Device
func (a *DcimAPIService) DcimDevicesCreateExecute(r ApiDcimDevicesCreateRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("writableDeviceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableDeviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDevicesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimDevicesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimDevicesDestroyExecute(r)
}

/*
DcimDevicesDestroy Method for DcimDevicesDestroy

Destroy a device object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device.
 @return ApiDcimDevicesDestroyRequest
*/
func (a *DcimAPIService) DcimDevicesDestroy(ctx context.Context, id string) ApiDcimDevicesDestroyRequest {
	return ApiDcimDevicesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimDevicesDestroyExecute(r ApiDcimDevicesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimDevicesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	assetTag *[]string
	assetTagIc *[]string
	assetTagIe *[]string
	assetTagIew *[]string
	assetTagIre *[]string
	assetTagIsnull *bool
	assetTagIsw *[]string
	assetTagN *[]string
	assetTagNic *[]string
	assetTagNie *[]string
	assetTagNiew *[]string
	assetTagNire *[]string
	assetTagNisw *[]string
	assetTagNre *[]string
	assetTagRe *[]string
	cluster *[]string
	clusterIsnull *bool
	clusterN *[]string
	consolePorts *[]string
	consolePortsIsnull *bool
	consolePortsN *[]string
	consoleServerPorts *[]string
	consoleServerPortsIsnull *bool
	consoleServerPortsN *[]string
	controllerManagedDeviceGroup *[]string
	controllerManagedDeviceGroupIsnull *bool
	controllerManagedDeviceGroupN *[]string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	deviceBays *[]string
	deviceBaysIsnull *bool
	deviceBaysN *[]string
	deviceFamily *[]string
	deviceFamilyIsnull *bool
	deviceFamilyN *[]string
	deviceRedundancyGroup *[]string
	deviceRedundancyGroupIsnull *bool
	deviceRedundancyGroupN *[]string
	deviceRedundancyGroupPriority *[]int32
	deviceRedundancyGroupPriorityGt *[]int32
	deviceRedundancyGroupPriorityGte *[]int32
	deviceRedundancyGroupPriorityIsnull *bool
	deviceRedundancyGroupPriorityLt *[]int32
	deviceRedundancyGroupPriorityLte *[]int32
	deviceRedundancyGroupPriorityN *[]int32
	deviceType *[]string
	deviceTypeN *[]string
	face *[]string
	faceIc *[]string
	faceIe *[]string
	faceIew *[]string
	faceIre *[]string
	faceIsw *[]string
	faceN *[]string
	faceNic *[]string
	faceNie *[]string
	faceNiew *[]string
	faceNire *[]string
	faceNisw *[]string
	faceNre *[]string
	faceRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	frontPorts *[]string
	frontPortsIsnull *bool
	frontPortsN *[]string
	hasConsolePorts *bool
	hasConsoleServerPorts *bool
	hasDeviceBays *bool
	hasFrontPorts *bool
	hasInterfaces *bool
	hasPowerOutlets *bool
	hasPowerPorts *bool
	hasPrimaryIp *bool
	hasRearPorts *bool
	hasSoftwareImageFiles *bool
	hasSoftwareVersion *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interfaces *[]string
	interfacesIsnull *bool
	interfacesN *[]string
	isFullDepth *bool
	isVirtualChassisMember *bool
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	localConfigContextData *bool
	localConfigContextSchema *[]string
	localConfigContextSchemaIsnull *bool
	localConfigContextSchemaN *[]string
	localConfigContextSchemaId *[]*string
	localConfigContextSchemaIdIsnull *bool
	localConfigContextSchemaIdN *[]*string
	location *[]string
	locationN *[]string
	macAddress *[]string
	macAddressIc *[]string
	macAddressIe *[]string
	macAddressIew *[]string
	macAddressIre *[]string
	macAddressIsw *[]string
	macAddressN *[]string
	macAddressNic *[]string
	macAddressNie *[]string
	macAddressNiew *[]string
	macAddressNire *[]string
	macAddressNisw *[]string
	macAddressNre *[]string
	macAddressRe *[]string
	manufacturer *[]string
	manufacturerN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsnull *bool
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	platform *[]string
	platformIsnull *bool
	platformN *[]string
	position *[]int32
	positionGt *[]int32
	positionGte *[]int32
	positionIsnull *bool
	positionLt *[]int32
	positionLte *[]int32
	positionN *[]int32
	powerOutlets *[]string
	powerOutletsIsnull *bool
	powerOutletsN *[]string
	powerPorts *[]string
	powerPortsIsnull *bool
	powerPortsN *[]string
	q *string
	rack *[]string
	rackIsnull *bool
	rackN *[]string
	rackGroup *[]string
	rackGroupIsnull *bool
	rackGroupN *[]string
	rearPorts *[]string
	rearPortsIsnull *bool
	rearPortsN *[]string
	role *[]string
	roleN *[]string
	secretsGroup *[]string
	secretsGroupIsnull *bool
	secretsGroupN *[]string
	serial *[]string
	softwareImageFiles *[]string
	softwareImageFilesN *[]string
	softwareVersion *[]string
	softwareVersionIsnull *bool
	softwareVersionN *[]string
	sort *string
	status *[]string
	statusN *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	vcPosition *[]int32
	vcPositionGt *[]int32
	vcPositionGte *[]int32
	vcPositionIsnull *bool
	vcPositionLt *[]int32
	vcPositionLte *[]int32
	vcPositionN *[]int32
	vcPriority *[]int32
	vcPriorityGt *[]int32
	vcPriorityGte *[]int32
	vcPriorityIsnull *bool
	vcPriorityLt *[]int32
	vcPriorityLte *[]int32
	vcPriorityN *[]int32
	virtualChassis *[]string
	virtualChassisIsnull *bool
	virtualChassisN *[]string
	virtualChassisMember *bool
	depth *int32
}

func (r ApiDcimDevicesListRequest) AssetTag(assetTag []string) ApiDcimDevicesListRequest {
	r.assetTag = &assetTag
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIc(assetTagIc []string) ApiDcimDevicesListRequest {
	r.assetTagIc = &assetTagIc
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIe(assetTagIe []string) ApiDcimDevicesListRequest {
	r.assetTagIe = &assetTagIe
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIew(assetTagIew []string) ApiDcimDevicesListRequest {
	r.assetTagIew = &assetTagIew
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIre(assetTagIre []string) ApiDcimDevicesListRequest {
	r.assetTagIre = &assetTagIre
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIsnull(assetTagIsnull bool) ApiDcimDevicesListRequest {
	r.assetTagIsnull = &assetTagIsnull
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagIsw(assetTagIsw []string) ApiDcimDevicesListRequest {
	r.assetTagIsw = &assetTagIsw
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagN(assetTagN []string) ApiDcimDevicesListRequest {
	r.assetTagN = &assetTagN
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNic(assetTagNic []string) ApiDcimDevicesListRequest {
	r.assetTagNic = &assetTagNic
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNie(assetTagNie []string) ApiDcimDevicesListRequest {
	r.assetTagNie = &assetTagNie
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNiew(assetTagNiew []string) ApiDcimDevicesListRequest {
	r.assetTagNiew = &assetTagNiew
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNire(assetTagNire []string) ApiDcimDevicesListRequest {
	r.assetTagNire = &assetTagNire
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNisw(assetTagNisw []string) ApiDcimDevicesListRequest {
	r.assetTagNisw = &assetTagNisw
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagNre(assetTagNre []string) ApiDcimDevicesListRequest {
	r.assetTagNre = &assetTagNre
	return r
}

func (r ApiDcimDevicesListRequest) AssetTagRe(assetTagRe []string) ApiDcimDevicesListRequest {
	r.assetTagRe = &assetTagRe
	return r
}

func (r ApiDcimDevicesListRequest) Cluster(cluster []string) ApiDcimDevicesListRequest {
	r.cluster = &cluster
	return r
}

func (r ApiDcimDevicesListRequest) ClusterIsnull(clusterIsnull bool) ApiDcimDevicesListRequest {
	r.clusterIsnull = &clusterIsnull
	return r
}

func (r ApiDcimDevicesListRequest) ClusterN(clusterN []string) ApiDcimDevicesListRequest {
	r.clusterN = &clusterN
	return r
}

// Console Ports
func (r ApiDcimDevicesListRequest) ConsolePorts(consolePorts []string) ApiDcimDevicesListRequest {
	r.consolePorts = &consolePorts
	return r
}

func (r ApiDcimDevicesListRequest) ConsolePortsIsnull(consolePortsIsnull bool) ApiDcimDevicesListRequest {
	r.consolePortsIsnull = &consolePortsIsnull
	return r
}

// Console Ports
func (r ApiDcimDevicesListRequest) ConsolePortsN(consolePortsN []string) ApiDcimDevicesListRequest {
	r.consolePortsN = &consolePortsN
	return r
}

// Console Server Ports
func (r ApiDcimDevicesListRequest) ConsoleServerPorts(consoleServerPorts []string) ApiDcimDevicesListRequest {
	r.consoleServerPorts = &consoleServerPorts
	return r
}

func (r ApiDcimDevicesListRequest) ConsoleServerPortsIsnull(consoleServerPortsIsnull bool) ApiDcimDevicesListRequest {
	r.consoleServerPortsIsnull = &consoleServerPortsIsnull
	return r
}

// Console Server Ports
func (r ApiDcimDevicesListRequest) ConsoleServerPortsN(consoleServerPortsN []string) ApiDcimDevicesListRequest {
	r.consoleServerPortsN = &consoleServerPortsN
	return r
}

func (r ApiDcimDevicesListRequest) ControllerManagedDeviceGroup(controllerManagedDeviceGroup []string) ApiDcimDevicesListRequest {
	r.controllerManagedDeviceGroup = &controllerManagedDeviceGroup
	return r
}

func (r ApiDcimDevicesListRequest) ControllerManagedDeviceGroupIsnull(controllerManagedDeviceGroupIsnull bool) ApiDcimDevicesListRequest {
	r.controllerManagedDeviceGroupIsnull = &controllerManagedDeviceGroupIsnull
	return r
}

func (r ApiDcimDevicesListRequest) ControllerManagedDeviceGroupN(controllerManagedDeviceGroupN []string) ApiDcimDevicesListRequest {
	r.controllerManagedDeviceGroupN = &controllerManagedDeviceGroupN
	return r
}

func (r ApiDcimDevicesListRequest) Created(created []time.Time) ApiDcimDevicesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimDevicesListRequest) CreatedGt(createdGt []time.Time) ApiDcimDevicesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimDevicesListRequest) CreatedGte(createdGte []time.Time) ApiDcimDevicesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimDevicesListRequest) CreatedIsnull(createdIsnull bool) ApiDcimDevicesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimDevicesListRequest) CreatedLt(createdLt []time.Time) ApiDcimDevicesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimDevicesListRequest) CreatedLte(createdLte []time.Time) ApiDcimDevicesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimDevicesListRequest) CreatedN(createdN []time.Time) ApiDcimDevicesListRequest {
	r.createdN = &createdN
	return r
}

// Device Bays
func (r ApiDcimDevicesListRequest) DeviceBays(deviceBays []string) ApiDcimDevicesListRequest {
	r.deviceBays = &deviceBays
	return r
}

func (r ApiDcimDevicesListRequest) DeviceBaysIsnull(deviceBaysIsnull bool) ApiDcimDevicesListRequest {
	r.deviceBaysIsnull = &deviceBaysIsnull
	return r
}

// Device Bays
func (r ApiDcimDevicesListRequest) DeviceBaysN(deviceBaysN []string) ApiDcimDevicesListRequest {
	r.deviceBaysN = &deviceBaysN
	return r
}

func (r ApiDcimDevicesListRequest) DeviceFamily(deviceFamily []string) ApiDcimDevicesListRequest {
	r.deviceFamily = &deviceFamily
	return r
}

func (r ApiDcimDevicesListRequest) DeviceFamilyIsnull(deviceFamilyIsnull bool) ApiDcimDevicesListRequest {
	r.deviceFamilyIsnull = &deviceFamilyIsnull
	return r
}

func (r ApiDcimDevicesListRequest) DeviceFamilyN(deviceFamilyN []string) ApiDcimDevicesListRequest {
	r.deviceFamilyN = &deviceFamilyN
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroup(deviceRedundancyGroup []string) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroup = &deviceRedundancyGroup
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupIsnull(deviceRedundancyGroupIsnull bool) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupIsnull = &deviceRedundancyGroupIsnull
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupN(deviceRedundancyGroupN []string) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupN = &deviceRedundancyGroupN
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupPriority(deviceRedundancyGroupPriority []int32) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupPriority = &deviceRedundancyGroupPriority
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupPriorityGt(deviceRedundancyGroupPriorityGt []int32) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupPriorityGt = &deviceRedundancyGroupPriorityGt
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupPriorityGte(deviceRedundancyGroupPriorityGte []int32) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupPriorityGte = &deviceRedundancyGroupPriorityGte
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupPriorityIsnull(deviceRedundancyGroupPriorityIsnull bool) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupPriorityIsnull = &deviceRedundancyGroupPriorityIsnull
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupPriorityLt(deviceRedundancyGroupPriorityLt []int32) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupPriorityLt = &deviceRedundancyGroupPriorityLt
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupPriorityLte(deviceRedundancyGroupPriorityLte []int32) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupPriorityLte = &deviceRedundancyGroupPriorityLte
	return r
}

func (r ApiDcimDevicesListRequest) DeviceRedundancyGroupPriorityN(deviceRedundancyGroupPriorityN []int32) ApiDcimDevicesListRequest {
	r.deviceRedundancyGroupPriorityN = &deviceRedundancyGroupPriorityN
	return r
}

func (r ApiDcimDevicesListRequest) DeviceType(deviceType []string) ApiDcimDevicesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimDevicesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimDevicesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimDevicesListRequest) Face(face []string) ApiDcimDevicesListRequest {
	r.face = &face
	return r
}

func (r ApiDcimDevicesListRequest) FaceIc(faceIc []string) ApiDcimDevicesListRequest {
	r.faceIc = &faceIc
	return r
}

func (r ApiDcimDevicesListRequest) FaceIe(faceIe []string) ApiDcimDevicesListRequest {
	r.faceIe = &faceIe
	return r
}

func (r ApiDcimDevicesListRequest) FaceIew(faceIew []string) ApiDcimDevicesListRequest {
	r.faceIew = &faceIew
	return r
}

func (r ApiDcimDevicesListRequest) FaceIre(faceIre []string) ApiDcimDevicesListRequest {
	r.faceIre = &faceIre
	return r
}

func (r ApiDcimDevicesListRequest) FaceIsw(faceIsw []string) ApiDcimDevicesListRequest {
	r.faceIsw = &faceIsw
	return r
}

func (r ApiDcimDevicesListRequest) FaceN(faceN []string) ApiDcimDevicesListRequest {
	r.faceN = &faceN
	return r
}

func (r ApiDcimDevicesListRequest) FaceNic(faceNic []string) ApiDcimDevicesListRequest {
	r.faceNic = &faceNic
	return r
}

func (r ApiDcimDevicesListRequest) FaceNie(faceNie []string) ApiDcimDevicesListRequest {
	r.faceNie = &faceNie
	return r
}

func (r ApiDcimDevicesListRequest) FaceNiew(faceNiew []string) ApiDcimDevicesListRequest {
	r.faceNiew = &faceNiew
	return r
}

func (r ApiDcimDevicesListRequest) FaceNire(faceNire []string) ApiDcimDevicesListRequest {
	r.faceNire = &faceNire
	return r
}

func (r ApiDcimDevicesListRequest) FaceNisw(faceNisw []string) ApiDcimDevicesListRequest {
	r.faceNisw = &faceNisw
	return r
}

func (r ApiDcimDevicesListRequest) FaceNre(faceNre []string) ApiDcimDevicesListRequest {
	r.faceNre = &faceNre
	return r
}

func (r ApiDcimDevicesListRequest) FaceRe(faceRe []string) ApiDcimDevicesListRequest {
	r.faceRe = &faceRe
	return r
}

func (r ApiDcimDevicesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesListRequest {
	r.format = &format
	return r
}

// Front Port
func (r ApiDcimDevicesListRequest) FrontPorts(frontPorts []string) ApiDcimDevicesListRequest {
	r.frontPorts = &frontPorts
	return r
}

func (r ApiDcimDevicesListRequest) FrontPortsIsnull(frontPortsIsnull bool) ApiDcimDevicesListRequest {
	r.frontPortsIsnull = &frontPortsIsnull
	return r
}

// Front Port
func (r ApiDcimDevicesListRequest) FrontPortsN(frontPortsN []string) ApiDcimDevicesListRequest {
	r.frontPortsN = &frontPortsN
	return r
}

// Has console ports
func (r ApiDcimDevicesListRequest) HasConsolePorts(hasConsolePorts bool) ApiDcimDevicesListRequest {
	r.hasConsolePorts = &hasConsolePorts
	return r
}

// Has console server ports
func (r ApiDcimDevicesListRequest) HasConsoleServerPorts(hasConsoleServerPorts bool) ApiDcimDevicesListRequest {
	r.hasConsoleServerPorts = &hasConsoleServerPorts
	return r
}

// Has device bays
func (r ApiDcimDevicesListRequest) HasDeviceBays(hasDeviceBays bool) ApiDcimDevicesListRequest {
	r.hasDeviceBays = &hasDeviceBays
	return r
}

// Has front ports
func (r ApiDcimDevicesListRequest) HasFrontPorts(hasFrontPorts bool) ApiDcimDevicesListRequest {
	r.hasFrontPorts = &hasFrontPorts
	return r
}

// Has interfaces
func (r ApiDcimDevicesListRequest) HasInterfaces(hasInterfaces bool) ApiDcimDevicesListRequest {
	r.hasInterfaces = &hasInterfaces
	return r
}

// Has power outlets
func (r ApiDcimDevicesListRequest) HasPowerOutlets(hasPowerOutlets bool) ApiDcimDevicesListRequest {
	r.hasPowerOutlets = &hasPowerOutlets
	return r
}

// Has power ports
func (r ApiDcimDevicesListRequest) HasPowerPorts(hasPowerPorts bool) ApiDcimDevicesListRequest {
	r.hasPowerPorts = &hasPowerPorts
	return r
}

// Has a primary IP
func (r ApiDcimDevicesListRequest) HasPrimaryIp(hasPrimaryIp bool) ApiDcimDevicesListRequest {
	r.hasPrimaryIp = &hasPrimaryIp
	return r
}

// Has rear ports
func (r ApiDcimDevicesListRequest) HasRearPorts(hasRearPorts bool) ApiDcimDevicesListRequest {
	r.hasRearPorts = &hasRearPorts
	return r
}

// Has software image files
func (r ApiDcimDevicesListRequest) HasSoftwareImageFiles(hasSoftwareImageFiles bool) ApiDcimDevicesListRequest {
	r.hasSoftwareImageFiles = &hasSoftwareImageFiles
	return r
}

// Has software version
func (r ApiDcimDevicesListRequest) HasSoftwareVersion(hasSoftwareVersion bool) ApiDcimDevicesListRequest {
	r.hasSoftwareVersion = &hasSoftwareVersion
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimDevicesListRequest) Id(id []string) ApiDcimDevicesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimDevicesListRequest) IdIc(idIc []string) ApiDcimDevicesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimDevicesListRequest) IdIe(idIe []string) ApiDcimDevicesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimDevicesListRequest) IdIew(idIew []string) ApiDcimDevicesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimDevicesListRequest) IdIre(idIre []string) ApiDcimDevicesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimDevicesListRequest) IdIsw(idIsw []string) ApiDcimDevicesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimDevicesListRequest) IdN(idN []string) ApiDcimDevicesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimDevicesListRequest) IdNic(idNic []string) ApiDcimDevicesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimDevicesListRequest) IdNie(idNie []string) ApiDcimDevicesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimDevicesListRequest) IdNiew(idNiew []string) ApiDcimDevicesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimDevicesListRequest) IdNire(idNire []string) ApiDcimDevicesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimDevicesListRequest) IdNisw(idNisw []string) ApiDcimDevicesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimDevicesListRequest) IdNre(idNre []string) ApiDcimDevicesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimDevicesListRequest) IdRe(idRe []string) ApiDcimDevicesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimDevicesListRequest) Interfaces(interfaces []string) ApiDcimDevicesListRequest {
	r.interfaces = &interfaces
	return r
}

func (r ApiDcimDevicesListRequest) InterfacesIsnull(interfacesIsnull bool) ApiDcimDevicesListRequest {
	r.interfacesIsnull = &interfacesIsnull
	return r
}

func (r ApiDcimDevicesListRequest) InterfacesN(interfacesN []string) ApiDcimDevicesListRequest {
	r.interfacesN = &interfacesN
	return r
}

// Is full depth
func (r ApiDcimDevicesListRequest) IsFullDepth(isFullDepth bool) ApiDcimDevicesListRequest {
	r.isFullDepth = &isFullDepth
	return r
}

// Is a virtual chassis member
func (r ApiDcimDevicesListRequest) IsVirtualChassisMember(isVirtualChassisMember bool) ApiDcimDevicesListRequest {
	r.isVirtualChassisMember = &isVirtualChassisMember
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimDevicesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimDevicesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimDevicesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimDevicesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimDevicesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimDevicesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimDevicesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimDevicesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimDevicesListRequest) Limit(limit int32) ApiDcimDevicesListRequest {
	r.limit = &limit
	return r
}

// Has local config context data
func (r ApiDcimDevicesListRequest) LocalConfigContextData(localConfigContextData bool) ApiDcimDevicesListRequest {
	r.localConfigContextData = &localConfigContextData
	return r
}

func (r ApiDcimDevicesListRequest) LocalConfigContextSchema(localConfigContextSchema []string) ApiDcimDevicesListRequest {
	r.localConfigContextSchema = &localConfigContextSchema
	return r
}

func (r ApiDcimDevicesListRequest) LocalConfigContextSchemaIsnull(localConfigContextSchemaIsnull bool) ApiDcimDevicesListRequest {
	r.localConfigContextSchemaIsnull = &localConfigContextSchemaIsnull
	return r
}

func (r ApiDcimDevicesListRequest) LocalConfigContextSchemaN(localConfigContextSchemaN []string) ApiDcimDevicesListRequest {
	r.localConfigContextSchemaN = &localConfigContextSchemaN
	return r
}

// Schema (ID) - Deprecated (use local_context_schema filter)
func (r ApiDcimDevicesListRequest) LocalConfigContextSchemaId(localConfigContextSchemaId []*string) ApiDcimDevicesListRequest {
	r.localConfigContextSchemaId = &localConfigContextSchemaId
	return r
}

func (r ApiDcimDevicesListRequest) LocalConfigContextSchemaIdIsnull(localConfigContextSchemaIdIsnull bool) ApiDcimDevicesListRequest {
	r.localConfigContextSchemaIdIsnull = &localConfigContextSchemaIdIsnull
	return r
}

// Schema (ID) - Deprecated (use local_context_schema filter)
func (r ApiDcimDevicesListRequest) LocalConfigContextSchemaIdN(localConfigContextSchemaIdN []*string) ApiDcimDevicesListRequest {
	r.localConfigContextSchemaIdN = &localConfigContextSchemaIdN
	return r
}

func (r ApiDcimDevicesListRequest) Location(location []string) ApiDcimDevicesListRequest {
	r.location = &location
	return r
}

func (r ApiDcimDevicesListRequest) LocationN(locationN []string) ApiDcimDevicesListRequest {
	r.locationN = &locationN
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddress(macAddress []string) ApiDcimDevicesListRequest {
	r.macAddress = &macAddress
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressIc(macAddressIc []string) ApiDcimDevicesListRequest {
	r.macAddressIc = &macAddressIc
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressIe(macAddressIe []string) ApiDcimDevicesListRequest {
	r.macAddressIe = &macAddressIe
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressIew(macAddressIew []string) ApiDcimDevicesListRequest {
	r.macAddressIew = &macAddressIew
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressIre(macAddressIre []string) ApiDcimDevicesListRequest {
	r.macAddressIre = &macAddressIre
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressIsw(macAddressIsw []string) ApiDcimDevicesListRequest {
	r.macAddressIsw = &macAddressIsw
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressN(macAddressN []string) ApiDcimDevicesListRequest {
	r.macAddressN = &macAddressN
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressNic(macAddressNic []string) ApiDcimDevicesListRequest {
	r.macAddressNic = &macAddressNic
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressNie(macAddressNie []string) ApiDcimDevicesListRequest {
	r.macAddressNie = &macAddressNie
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressNiew(macAddressNiew []string) ApiDcimDevicesListRequest {
	r.macAddressNiew = &macAddressNiew
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressNire(macAddressNire []string) ApiDcimDevicesListRequest {
	r.macAddressNire = &macAddressNire
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressNisw(macAddressNisw []string) ApiDcimDevicesListRequest {
	r.macAddressNisw = &macAddressNisw
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressNre(macAddressNre []string) ApiDcimDevicesListRequest {
	r.macAddressNre = &macAddressNre
	return r
}

// MAC address
func (r ApiDcimDevicesListRequest) MacAddressRe(macAddressRe []string) ApiDcimDevicesListRequest {
	r.macAddressRe = &macAddressRe
	return r
}

func (r ApiDcimDevicesListRequest) Manufacturer(manufacturer []string) ApiDcimDevicesListRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiDcimDevicesListRequest) ManufacturerN(manufacturerN []string) ApiDcimDevicesListRequest {
	r.manufacturerN = &manufacturerN
	return r
}

func (r ApiDcimDevicesListRequest) Name(name []string) ApiDcimDevicesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimDevicesListRequest) NameIc(nameIc []string) ApiDcimDevicesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimDevicesListRequest) NameIe(nameIe []string) ApiDcimDevicesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimDevicesListRequest) NameIew(nameIew []string) ApiDcimDevicesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimDevicesListRequest) NameIre(nameIre []string) ApiDcimDevicesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimDevicesListRequest) NameIsnull(nameIsnull bool) ApiDcimDevicesListRequest {
	r.nameIsnull = &nameIsnull
	return r
}

func (r ApiDcimDevicesListRequest) NameIsw(nameIsw []string) ApiDcimDevicesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimDevicesListRequest) NameN(nameN []string) ApiDcimDevicesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimDevicesListRequest) NameNic(nameNic []string) ApiDcimDevicesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimDevicesListRequest) NameNie(nameNie []string) ApiDcimDevicesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimDevicesListRequest) NameNiew(nameNiew []string) ApiDcimDevicesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimDevicesListRequest) NameNire(nameNire []string) ApiDcimDevicesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimDevicesListRequest) NameNisw(nameNisw []string) ApiDcimDevicesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimDevicesListRequest) NameNre(nameNre []string) ApiDcimDevicesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimDevicesListRequest) NameRe(nameRe []string) ApiDcimDevicesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDevicesListRequest) Offset(offset int32) ApiDcimDevicesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimDevicesListRequest) Platform(platform []string) ApiDcimDevicesListRequest {
	r.platform = &platform
	return r
}

func (r ApiDcimDevicesListRequest) PlatformIsnull(platformIsnull bool) ApiDcimDevicesListRequest {
	r.platformIsnull = &platformIsnull
	return r
}

func (r ApiDcimDevicesListRequest) PlatformN(platformN []string) ApiDcimDevicesListRequest {
	r.platformN = &platformN
	return r
}

func (r ApiDcimDevicesListRequest) Position(position []int32) ApiDcimDevicesListRequest {
	r.position = &position
	return r
}

func (r ApiDcimDevicesListRequest) PositionGt(positionGt []int32) ApiDcimDevicesListRequest {
	r.positionGt = &positionGt
	return r
}

func (r ApiDcimDevicesListRequest) PositionGte(positionGte []int32) ApiDcimDevicesListRequest {
	r.positionGte = &positionGte
	return r
}

func (r ApiDcimDevicesListRequest) PositionIsnull(positionIsnull bool) ApiDcimDevicesListRequest {
	r.positionIsnull = &positionIsnull
	return r
}

func (r ApiDcimDevicesListRequest) PositionLt(positionLt []int32) ApiDcimDevicesListRequest {
	r.positionLt = &positionLt
	return r
}

func (r ApiDcimDevicesListRequest) PositionLte(positionLte []int32) ApiDcimDevicesListRequest {
	r.positionLte = &positionLte
	return r
}

func (r ApiDcimDevicesListRequest) PositionN(positionN []int32) ApiDcimDevicesListRequest {
	r.positionN = &positionN
	return r
}

// Power Outlets
func (r ApiDcimDevicesListRequest) PowerOutlets(powerOutlets []string) ApiDcimDevicesListRequest {
	r.powerOutlets = &powerOutlets
	return r
}

func (r ApiDcimDevicesListRequest) PowerOutletsIsnull(powerOutletsIsnull bool) ApiDcimDevicesListRequest {
	r.powerOutletsIsnull = &powerOutletsIsnull
	return r
}

// Power Outlets
func (r ApiDcimDevicesListRequest) PowerOutletsN(powerOutletsN []string) ApiDcimDevicesListRequest {
	r.powerOutletsN = &powerOutletsN
	return r
}

// Power Ports
func (r ApiDcimDevicesListRequest) PowerPorts(powerPorts []string) ApiDcimDevicesListRequest {
	r.powerPorts = &powerPorts
	return r
}

func (r ApiDcimDevicesListRequest) PowerPortsIsnull(powerPortsIsnull bool) ApiDcimDevicesListRequest {
	r.powerPortsIsnull = &powerPortsIsnull
	return r
}

// Power Ports
func (r ApiDcimDevicesListRequest) PowerPortsN(powerPortsN []string) ApiDcimDevicesListRequest {
	r.powerPortsN = &powerPortsN
	return r
}

// Search
func (r ApiDcimDevicesListRequest) Q(q string) ApiDcimDevicesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimDevicesListRequest) Rack(rack []string) ApiDcimDevicesListRequest {
	r.rack = &rack
	return r
}

func (r ApiDcimDevicesListRequest) RackIsnull(rackIsnull bool) ApiDcimDevicesListRequest {
	r.rackIsnull = &rackIsnull
	return r
}

func (r ApiDcimDevicesListRequest) RackN(rackN []string) ApiDcimDevicesListRequest {
	r.rackN = &rackN
	return r
}

func (r ApiDcimDevicesListRequest) RackGroup(rackGroup []string) ApiDcimDevicesListRequest {
	r.rackGroup = &rackGroup
	return r
}

func (r ApiDcimDevicesListRequest) RackGroupIsnull(rackGroupIsnull bool) ApiDcimDevicesListRequest {
	r.rackGroupIsnull = &rackGroupIsnull
	return r
}

func (r ApiDcimDevicesListRequest) RackGroupN(rackGroupN []string) ApiDcimDevicesListRequest {
	r.rackGroupN = &rackGroupN
	return r
}

// Rear Port
func (r ApiDcimDevicesListRequest) RearPorts(rearPorts []string) ApiDcimDevicesListRequest {
	r.rearPorts = &rearPorts
	return r
}

func (r ApiDcimDevicesListRequest) RearPortsIsnull(rearPortsIsnull bool) ApiDcimDevicesListRequest {
	r.rearPortsIsnull = &rearPortsIsnull
	return r
}

// Rear Port
func (r ApiDcimDevicesListRequest) RearPortsN(rearPortsN []string) ApiDcimDevicesListRequest {
	r.rearPortsN = &rearPortsN
	return r
}

func (r ApiDcimDevicesListRequest) Role(role []string) ApiDcimDevicesListRequest {
	r.role = &role
	return r
}

func (r ApiDcimDevicesListRequest) RoleN(roleN []string) ApiDcimDevicesListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiDcimDevicesListRequest) SecretsGroup(secretsGroup []string) ApiDcimDevicesListRequest {
	r.secretsGroup = &secretsGroup
	return r
}

func (r ApiDcimDevicesListRequest) SecretsGroupIsnull(secretsGroupIsnull bool) ApiDcimDevicesListRequest {
	r.secretsGroupIsnull = &secretsGroupIsnull
	return r
}

func (r ApiDcimDevicesListRequest) SecretsGroupN(secretsGroupN []string) ApiDcimDevicesListRequest {
	r.secretsGroupN = &secretsGroupN
	return r
}

func (r ApiDcimDevicesListRequest) Serial(serial []string) ApiDcimDevicesListRequest {
	r.serial = &serial
	return r
}

func (r ApiDcimDevicesListRequest) SoftwareImageFiles(softwareImageFiles []string) ApiDcimDevicesListRequest {
	r.softwareImageFiles = &softwareImageFiles
	return r
}

func (r ApiDcimDevicesListRequest) SoftwareImageFilesN(softwareImageFilesN []string) ApiDcimDevicesListRequest {
	r.softwareImageFilesN = &softwareImageFilesN
	return r
}

func (r ApiDcimDevicesListRequest) SoftwareVersion(softwareVersion []string) ApiDcimDevicesListRequest {
	r.softwareVersion = &softwareVersion
	return r
}

func (r ApiDcimDevicesListRequest) SoftwareVersionIsnull(softwareVersionIsnull bool) ApiDcimDevicesListRequest {
	r.softwareVersionIsnull = &softwareVersionIsnull
	return r
}

func (r ApiDcimDevicesListRequest) SoftwareVersionN(softwareVersionN []string) ApiDcimDevicesListRequest {
	r.softwareVersionN = &softwareVersionN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimDevicesListRequest) Sort(sort string) ApiDcimDevicesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimDevicesListRequest) Status(status []string) ApiDcimDevicesListRequest {
	r.status = &status
	return r
}

func (r ApiDcimDevicesListRequest) StatusN(statusN []string) ApiDcimDevicesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimDevicesListRequest) Tags(tags []string) ApiDcimDevicesListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimDevicesListRequest) TagsIsnull(tagsIsnull bool) ApiDcimDevicesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimDevicesListRequest) TagsN(tagsN []string) ApiDcimDevicesListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimDevicesListRequest) Tenant(tenant []string) ApiDcimDevicesListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimDevicesListRequest) TenantIsnull(tenantIsnull bool) ApiDcimDevicesListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiDcimDevicesListRequest) TenantN(tenantN []string) ApiDcimDevicesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimDevicesListRequest) TenantGroup(tenantGroup []string) ApiDcimDevicesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimDevicesListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiDcimDevicesListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiDcimDevicesListRequest) TenantGroupN(tenantGroupN []string) ApiDcimDevicesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimDevicesListRequest) TenantId(tenantId []*string) ApiDcimDevicesListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimDevicesListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiDcimDevicesListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimDevicesListRequest) TenantIdN(tenantIdN []*string) ApiDcimDevicesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiDcimDevicesListRequest) VcPosition(vcPosition []int32) ApiDcimDevicesListRequest {
	r.vcPosition = &vcPosition
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionGt(vcPositionGt []int32) ApiDcimDevicesListRequest {
	r.vcPositionGt = &vcPositionGt
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionGte(vcPositionGte []int32) ApiDcimDevicesListRequest {
	r.vcPositionGte = &vcPositionGte
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionIsnull(vcPositionIsnull bool) ApiDcimDevicesListRequest {
	r.vcPositionIsnull = &vcPositionIsnull
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionLt(vcPositionLt []int32) ApiDcimDevicesListRequest {
	r.vcPositionLt = &vcPositionLt
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionLte(vcPositionLte []int32) ApiDcimDevicesListRequest {
	r.vcPositionLte = &vcPositionLte
	return r
}

func (r ApiDcimDevicesListRequest) VcPositionN(vcPositionN []int32) ApiDcimDevicesListRequest {
	r.vcPositionN = &vcPositionN
	return r
}

func (r ApiDcimDevicesListRequest) VcPriority(vcPriority []int32) ApiDcimDevicesListRequest {
	r.vcPriority = &vcPriority
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityGt(vcPriorityGt []int32) ApiDcimDevicesListRequest {
	r.vcPriorityGt = &vcPriorityGt
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityGte(vcPriorityGte []int32) ApiDcimDevicesListRequest {
	r.vcPriorityGte = &vcPriorityGte
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityIsnull(vcPriorityIsnull bool) ApiDcimDevicesListRequest {
	r.vcPriorityIsnull = &vcPriorityIsnull
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityLt(vcPriorityLt []int32) ApiDcimDevicesListRequest {
	r.vcPriorityLt = &vcPriorityLt
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityLte(vcPriorityLte []int32) ApiDcimDevicesListRequest {
	r.vcPriorityLte = &vcPriorityLte
	return r
}

func (r ApiDcimDevicesListRequest) VcPriorityN(vcPriorityN []int32) ApiDcimDevicesListRequest {
	r.vcPriorityN = &vcPriorityN
	return r
}

func (r ApiDcimDevicesListRequest) VirtualChassis(virtualChassis []string) ApiDcimDevicesListRequest {
	r.virtualChassis = &virtualChassis
	return r
}

func (r ApiDcimDevicesListRequest) VirtualChassisIsnull(virtualChassisIsnull bool) ApiDcimDevicesListRequest {
	r.virtualChassisIsnull = &virtualChassisIsnull
	return r
}

func (r ApiDcimDevicesListRequest) VirtualChassisN(virtualChassisN []string) ApiDcimDevicesListRequest {
	r.virtualChassisN = &virtualChassisN
	return r
}

// Is a virtual chassis member
func (r ApiDcimDevicesListRequest) VirtualChassisMember(virtualChassisMember bool) ApiDcimDevicesListRequest {
	r.virtualChassisMember = &virtualChassisMember
	return r
}

// Serializer Depth
func (r ApiDcimDevicesListRequest) Depth(depth int32) ApiDcimDevicesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDevicesListRequest) Execute() (*PaginatedDeviceList, *http.Response, error) {
	return r.ApiService.DcimDevicesListExecute(r)
}

/*
DcimDevicesList Method for DcimDevicesList

Retrieve a list of device objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimDevicesListRequest
*/
func (a *DcimAPIService) DcimDevicesList(ctx context.Context) ApiDcimDevicesListRequest {
	return ApiDcimDevicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceList
func (a *DcimAPIService) DcimDevicesListExecute(r ApiDcimDevicesListRequest) (*PaginatedDeviceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.assetTag != nil {
		t := *r.assetTag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag", t, "multi")
		}
	}
	if r.assetTagIc != nil {
		t := *r.assetTagIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ic", t, "multi")
		}
	}
	if r.assetTagIe != nil {
		t := *r.assetTagIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ie", t, "multi")
		}
	}
	if r.assetTagIew != nil {
		t := *r.assetTagIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__iew", t, "multi")
		}
	}
	if r.assetTagIre != nil {
		t := *r.assetTagIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ire", t, "multi")
		}
	}
	if r.assetTagIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isnull", r.assetTagIsnull, "")
	}
	if r.assetTagIsw != nil {
		t := *r.assetTagIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isw", t, "multi")
		}
	}
	if r.assetTagN != nil {
		t := *r.assetTagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__n", t, "multi")
		}
	}
	if r.assetTagNic != nil {
		t := *r.assetTagNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nic", t, "multi")
		}
	}
	if r.assetTagNie != nil {
		t := *r.assetTagNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nie", t, "multi")
		}
	}
	if r.assetTagNiew != nil {
		t := *r.assetTagNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__niew", t, "multi")
		}
	}
	if r.assetTagNire != nil {
		t := *r.assetTagNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nire", t, "multi")
		}
	}
	if r.assetTagNisw != nil {
		t := *r.assetTagNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nisw", t, "multi")
		}
	}
	if r.assetTagNre != nil {
		t := *r.assetTagNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nre", t, "multi")
		}
	}
	if r.assetTagRe != nil {
		t := *r.assetTagRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__re", t, "multi")
		}
	}
	if r.cluster != nil {
		t := *r.cluster
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", t, "multi")
		}
	}
	if r.clusterIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster__isnull", r.clusterIsnull, "")
	}
	if r.clusterN != nil {
		t := *r.clusterN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cluster__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cluster__n", t, "multi")
		}
	}
	if r.consolePorts != nil {
		t := *r.consolePorts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "console_ports", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "console_ports", t, "multi")
		}
	}
	if r.consolePortsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "console_ports__isnull", r.consolePortsIsnull, "")
	}
	if r.consolePortsN != nil {
		t := *r.consolePortsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "console_ports__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "console_ports__n", t, "multi")
		}
	}
	if r.consoleServerPorts != nil {
		t := *r.consoleServerPorts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_ports", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_ports", t, "multi")
		}
	}
	if r.consoleServerPortsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_ports__isnull", r.consoleServerPortsIsnull, "")
	}
	if r.consoleServerPortsN != nil {
		t := *r.consoleServerPortsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_ports__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "console_server_ports__n", t, "multi")
		}
	}
	if r.controllerManagedDeviceGroup != nil {
		t := *r.controllerManagedDeviceGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "controller_managed_device_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "controller_managed_device_group", t, "multi")
		}
	}
	if r.controllerManagedDeviceGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "controller_managed_device_group__isnull", r.controllerManagedDeviceGroupIsnull, "")
	}
	if r.controllerManagedDeviceGroupN != nil {
		t := *r.controllerManagedDeviceGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "controller_managed_device_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "controller_managed_device_group__n", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.deviceBays != nil {
		t := *r.deviceBays
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_bays", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_bays", t, "multi")
		}
	}
	if r.deviceBaysIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_bays__isnull", r.deviceBaysIsnull, "")
	}
	if r.deviceBaysN != nil {
		t := *r.deviceBaysN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_bays__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_bays__n", t, "multi")
		}
	}
	if r.deviceFamily != nil {
		t := *r.deviceFamily
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_family", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_family", t, "multi")
		}
	}
	if r.deviceFamilyIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_family__isnull", r.deviceFamilyIsnull, "")
	}
	if r.deviceFamilyN != nil {
		t := *r.deviceFamilyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_family__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_family__n", t, "multi")
		}
	}
	if r.deviceRedundancyGroup != nil {
		t := *r.deviceRedundancyGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group", t, "multi")
		}
	}
	if r.deviceRedundancyGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group__isnull", r.deviceRedundancyGroupIsnull, "")
	}
	if r.deviceRedundancyGroupN != nil {
		t := *r.deviceRedundancyGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group__n", t, "multi")
		}
	}
	if r.deviceRedundancyGroupPriority != nil {
		t := *r.deviceRedundancyGroupPriority
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority", t, "multi")
		}
	}
	if r.deviceRedundancyGroupPriorityGt != nil {
		t := *r.deviceRedundancyGroupPriorityGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__gt", t, "multi")
		}
	}
	if r.deviceRedundancyGroupPriorityGte != nil {
		t := *r.deviceRedundancyGroupPriorityGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__gte", t, "multi")
		}
	}
	if r.deviceRedundancyGroupPriorityIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__isnull", r.deviceRedundancyGroupPriorityIsnull, "")
	}
	if r.deviceRedundancyGroupPriorityLt != nil {
		t := *r.deviceRedundancyGroupPriorityLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__lt", t, "multi")
		}
	}
	if r.deviceRedundancyGroupPriorityLte != nil {
		t := *r.deviceRedundancyGroupPriorityLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__lte", t, "multi")
		}
	}
	if r.deviceRedundancyGroupPriorityN != nil {
		t := *r.deviceRedundancyGroupPriorityN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_redundancy_group_priority__n", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.face != nil {
		t := *r.face
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face", t, "multi")
		}
	}
	if r.faceIc != nil {
		t := *r.faceIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__ic", t, "multi")
		}
	}
	if r.faceIe != nil {
		t := *r.faceIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__ie", t, "multi")
		}
	}
	if r.faceIew != nil {
		t := *r.faceIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__iew", t, "multi")
		}
	}
	if r.faceIre != nil {
		t := *r.faceIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__ire", t, "multi")
		}
	}
	if r.faceIsw != nil {
		t := *r.faceIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__isw", t, "multi")
		}
	}
	if r.faceN != nil {
		t := *r.faceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__n", t, "multi")
		}
	}
	if r.faceNic != nil {
		t := *r.faceNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__nic", t, "multi")
		}
	}
	if r.faceNie != nil {
		t := *r.faceNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__nie", t, "multi")
		}
	}
	if r.faceNiew != nil {
		t := *r.faceNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__niew", t, "multi")
		}
	}
	if r.faceNire != nil {
		t := *r.faceNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__nire", t, "multi")
		}
	}
	if r.faceNisw != nil {
		t := *r.faceNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__nisw", t, "multi")
		}
	}
	if r.faceNre != nil {
		t := *r.faceNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__nre", t, "multi")
		}
	}
	if r.faceRe != nil {
		t := *r.faceRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "face__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "face__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.frontPorts != nil {
		t := *r.frontPorts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports", t, "multi")
		}
	}
	if r.frontPortsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports__isnull", r.frontPortsIsnull, "")
	}
	if r.frontPortsN != nil {
		t := *r.frontPortsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports__n", t, "multi")
		}
	}
	if r.hasConsolePorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_console_ports", r.hasConsolePorts, "")
	}
	if r.hasConsoleServerPorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_console_server_ports", r.hasConsoleServerPorts, "")
	}
	if r.hasDeviceBays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_device_bays", r.hasDeviceBays, "")
	}
	if r.hasFrontPorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_front_ports", r.hasFrontPorts, "")
	}
	if r.hasInterfaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_interfaces", r.hasInterfaces, "")
	}
	if r.hasPowerOutlets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_outlets", r.hasPowerOutlets, "")
	}
	if r.hasPowerPorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_ports", r.hasPowerPorts, "")
	}
	if r.hasPrimaryIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_primary_ip", r.hasPrimaryIp, "")
	}
	if r.hasRearPorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_rear_ports", r.hasRearPorts, "")
	}
	if r.hasSoftwareImageFiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_software_image_files", r.hasSoftwareImageFiles, "")
	}
	if r.hasSoftwareVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_software_version", r.hasSoftwareVersion, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.interfaces != nil {
		t := *r.interfaces
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces", t, "multi")
		}
	}
	if r.interfacesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces__isnull", r.interfacesIsnull, "")
	}
	if r.interfacesN != nil {
		t := *r.interfacesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces__n", t, "multi")
		}
	}
	if r.isFullDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_full_depth", r.isFullDepth, "")
	}
	if r.isVirtualChassisMember != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_virtual_chassis_member", r.isVirtualChassisMember, "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.localConfigContextData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_data", r.localConfigContextData, "")
	}
	if r.localConfigContextSchema != nil {
		t := *r.localConfigContextSchema
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema", t, "multi")
		}
	}
	if r.localConfigContextSchemaIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema__isnull", r.localConfigContextSchemaIsnull, "")
	}
	if r.localConfigContextSchemaN != nil {
		t := *r.localConfigContextSchemaN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema__n", t, "multi")
		}
	}
	if r.localConfigContextSchemaId != nil {
		t := *r.localConfigContextSchemaId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema_id", t, "multi")
		}
	}
	if r.localConfigContextSchemaIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema_id__isnull", r.localConfigContextSchemaIdIsnull, "")
	}
	if r.localConfigContextSchemaIdN != nil {
		t := *r.localConfigContextSchemaIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_config_context_schema_id__n", t, "multi")
		}
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.macAddress != nil {
		t := *r.macAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address", t, "multi")
		}
	}
	if r.macAddressIc != nil {
		t := *r.macAddressIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ic", t, "multi")
		}
	}
	if r.macAddressIe != nil {
		t := *r.macAddressIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ie", t, "multi")
		}
	}
	if r.macAddressIew != nil {
		t := *r.macAddressIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__iew", t, "multi")
		}
	}
	if r.macAddressIre != nil {
		t := *r.macAddressIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ire", t, "multi")
		}
	}
	if r.macAddressIsw != nil {
		t := *r.macAddressIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__isw", t, "multi")
		}
	}
	if r.macAddressN != nil {
		t := *r.macAddressN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__n", t, "multi")
		}
	}
	if r.macAddressNic != nil {
		t := *r.macAddressNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nic", t, "multi")
		}
	}
	if r.macAddressNie != nil {
		t := *r.macAddressNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nie", t, "multi")
		}
	}
	if r.macAddressNiew != nil {
		t := *r.macAddressNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__niew", t, "multi")
		}
	}
	if r.macAddressNire != nil {
		t := *r.macAddressNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nire", t, "multi")
		}
	}
	if r.macAddressNisw != nil {
		t := *r.macAddressNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nisw", t, "multi")
		}
	}
	if r.macAddressNre != nil {
		t := *r.macAddressNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nre", t, "multi")
		}
	}
	if r.macAddressRe != nil {
		t := *r.macAddressRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__re", t, "multi")
		}
	}
	if r.manufacturer != nil {
		t := *r.manufacturer
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", t, "multi")
		}
	}
	if r.manufacturerN != nil {
		t := *r.manufacturerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__isnull", r.nameIsnull, "")
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.platform != nil {
		t := *r.platform
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "platform", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "platform", t, "multi")
		}
	}
	if r.platformIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platform__isnull", r.platformIsnull, "")
	}
	if r.platformN != nil {
		t := *r.platformN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "platform__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "platform__n", t, "multi")
		}
	}
	if r.position != nil {
		t := *r.position
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "position", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "position", t, "multi")
		}
	}
	if r.positionGt != nil {
		t := *r.positionGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "position__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "position__gt", t, "multi")
		}
	}
	if r.positionGte != nil {
		t := *r.positionGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "position__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "position__gte", t, "multi")
		}
	}
	if r.positionIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position__isnull", r.positionIsnull, "")
	}
	if r.positionLt != nil {
		t := *r.positionLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "position__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "position__lt", t, "multi")
		}
	}
	if r.positionLte != nil {
		t := *r.positionLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "position__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "position__lte", t, "multi")
		}
	}
	if r.positionN != nil {
		t := *r.positionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "position__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "position__n", t, "multi")
		}
	}
	if r.powerOutlets != nil {
		t := *r.powerOutlets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets", t, "multi")
		}
	}
	if r.powerOutletsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets__isnull", r.powerOutletsIsnull, "")
	}
	if r.powerOutletsN != nil {
		t := *r.powerOutletsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets__n", t, "multi")
		}
	}
	if r.powerPorts != nil {
		t := *r.powerPorts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_ports", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_ports", t, "multi")
		}
	}
	if r.powerPortsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_ports__isnull", r.powerPortsIsnull, "")
	}
	if r.powerPortsN != nil {
		t := *r.powerPortsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_ports__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_ports__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rack != nil {
		t := *r.rack
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack", t, "multi")
		}
	}
	if r.rackIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack__isnull", r.rackIsnull, "")
	}
	if r.rackN != nil {
		t := *r.rackN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack__n", t, "multi")
		}
	}
	if r.rackGroup != nil {
		t := *r.rackGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group", t, "multi")
		}
	}
	if r.rackGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__isnull", r.rackGroupIsnull, "")
	}
	if r.rackGroupN != nil {
		t := *r.rackGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__n", t, "multi")
		}
	}
	if r.rearPorts != nil {
		t := *r.rearPorts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_ports", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_ports", t, "multi")
		}
	}
	if r.rearPortsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rear_ports__isnull", r.rearPortsIsnull, "")
	}
	if r.rearPortsN != nil {
		t := *r.rearPortsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_ports__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_ports__n", t, "multi")
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "multi")
		}
	}
	if r.secretsGroup != nil {
		t := *r.secretsGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group", t, "multi")
		}
	}
	if r.secretsGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__isnull", r.secretsGroupIsnull, "")
	}
	if r.secretsGroupN != nil {
		t := *r.secretsGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__n", t, "multi")
		}
	}
	if r.serial != nil {
		t := *r.serial
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serial", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serial", t, "multi")
		}
	}
	if r.softwareImageFiles != nil {
		t := *r.softwareImageFiles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files", t, "multi")
		}
	}
	if r.softwareImageFilesN != nil {
		t := *r.softwareImageFilesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__n", t, "multi")
		}
	}
	if r.softwareVersion != nil {
		t := *r.softwareVersion
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_version", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_version", t, "multi")
		}
	}
	if r.softwareVersionIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "software_version__isnull", r.softwareVersionIsnull, "")
	}
	if r.softwareVersionN != nil {
		t := *r.softwareVersionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_version__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_version__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.vcPosition != nil {
		t := *r.vcPosition
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position", t, "multi")
		}
	}
	if r.vcPositionGt != nil {
		t := *r.vcPositionGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__gt", t, "multi")
		}
	}
	if r.vcPositionGte != nil {
		t := *r.vcPositionGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__gte", t, "multi")
		}
	}
	if r.vcPositionIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__isnull", r.vcPositionIsnull, "")
	}
	if r.vcPositionLt != nil {
		t := *r.vcPositionLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__lt", t, "multi")
		}
	}
	if r.vcPositionLte != nil {
		t := *r.vcPositionLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__lte", t, "multi")
		}
	}
	if r.vcPositionN != nil {
		t := *r.vcPositionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_position__n", t, "multi")
		}
	}
	if r.vcPriority != nil {
		t := *r.vcPriority
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority", t, "multi")
		}
	}
	if r.vcPriorityGt != nil {
		t := *r.vcPriorityGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__gt", t, "multi")
		}
	}
	if r.vcPriorityGte != nil {
		t := *r.vcPriorityGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__gte", t, "multi")
		}
	}
	if r.vcPriorityIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__isnull", r.vcPriorityIsnull, "")
	}
	if r.vcPriorityLt != nil {
		t := *r.vcPriorityLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__lt", t, "multi")
		}
	}
	if r.vcPriorityLte != nil {
		t := *r.vcPriorityLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__lte", t, "multi")
		}
	}
	if r.vcPriorityN != nil {
		t := *r.vcPriorityN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vc_priority__n", t, "multi")
		}
	}
	if r.virtualChassis != nil {
		t := *r.virtualChassis
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_chassis", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_chassis", t, "multi")
		}
	}
	if r.virtualChassisIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_chassis__isnull", r.virtualChassisIsnull, "")
	}
	if r.virtualChassisN != nil {
		t := *r.virtualChassisN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_chassis__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_chassis__n", t, "multi")
		}
	}
	if r.virtualChassisMember != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_chassis_member", r.virtualChassisMember, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesNapalmRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	method *string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimDevicesNapalmRetrieveRequest) Method(method string) ApiDcimDevicesNapalmRetrieveRequest {
	r.method = &method
	return r
}

func (r ApiDcimDevicesNapalmRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesNapalmRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimDevicesNapalmRetrieveRequest) Depth(depth int32) ApiDcimDevicesNapalmRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDevicesNapalmRetrieveRequest) Execute() (*DeviceNAPALM, *http.Response, error) {
	return r.ApiService.DcimDevicesNapalmRetrieveExecute(r)
}

/*
DcimDevicesNapalmRetrieve Method for DcimDevicesNapalmRetrieve

Execute a NAPALM method on a Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device.
 @return ApiDcimDevicesNapalmRetrieveRequest
*/
func (a *DcimAPIService) DcimDevicesNapalmRetrieve(ctx context.Context, id string) ApiDcimDevicesNapalmRetrieveRequest {
	return ApiDcimDevicesNapalmRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceNAPALM
func (a *DcimAPIService) DcimDevicesNapalmRetrieveExecute(r ApiDcimDevicesNapalmRetrieveRequest) (*DeviceNAPALM, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceNAPALM
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesNapalmRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/napalm/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.method == nil {
		return localVarReturnValue, nil, reportError("method is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "")
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDevicesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimDevicesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimDevicesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDevicesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimDevicesNotesCreateExecute(r)
}

/*
DcimDevicesNotesCreate Method for DcimDevicesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device.
 @return ApiDcimDevicesNotesCreateRequest
*/
func (a *DcimAPIService) DcimDevicesNotesCreate(ctx context.Context, id string) ApiDcimDevicesNotesCreateRequest {
	return ApiDcimDevicesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimDevicesNotesCreateExecute(r ApiDcimDevicesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimDevicesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimDevicesNotesListRequest) Limit(limit int32) ApiDcimDevicesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimDevicesNotesListRequest) Offset(offset int32) ApiDcimDevicesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimDevicesNotesListRequest) Depth(depth int32) ApiDcimDevicesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDevicesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimDevicesNotesListExecute(r)
}

/*
DcimDevicesNotesList Method for DcimDevicesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device.
 @return ApiDcimDevicesNotesListRequest
*/
func (a *DcimAPIService) DcimDevicesNotesList(ctx context.Context, id string) ApiDcimDevicesNotesListRequest {
	return ApiDcimDevicesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimDevicesNotesListExecute(r ApiDcimDevicesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableDeviceRequest *PatchedWritableDeviceRequest
}

func (r ApiDcimDevicesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDevicesPartialUpdateRequest) PatchedWritableDeviceRequest(patchedWritableDeviceRequest PatchedWritableDeviceRequest) ApiDcimDevicesPartialUpdateRequest {
	r.patchedWritableDeviceRequest = &patchedWritableDeviceRequest
	return r
}

func (r ApiDcimDevicesPartialUpdateRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.DcimDevicesPartialUpdateExecute(r)
}

/*
DcimDevicesPartialUpdate Method for DcimDevicesPartialUpdate

Partial update a device object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device.
 @return ApiDcimDevicesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimDevicesPartialUpdate(ctx context.Context, id string) ApiDcimDevicesPartialUpdateRequest {
	return ApiDcimDevicesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Device
func (a *DcimAPIService) DcimDevicesPartialUpdateExecute(r ApiDcimDevicesPartialUpdateRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableDeviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimDevicesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimDevicesRetrieveRequest) Depth(depth int32) ApiDcimDevicesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimDevicesRetrieveRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.DcimDevicesRetrieveExecute(r)
}

/*
DcimDevicesRetrieve Method for DcimDevicesRetrieve

Retrieve a device object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device.
 @return ApiDcimDevicesRetrieveRequest
*/
func (a *DcimAPIService) DcimDevicesRetrieve(ctx context.Context, id string) ApiDcimDevicesRetrieveRequest {
	return ApiDcimDevicesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Device
func (a *DcimAPIService) DcimDevicesRetrieveExecute(r ApiDcimDevicesRetrieveRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimDevicesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableDeviceRequest *WritableDeviceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimDevicesUpdateRequest) WritableDeviceRequest(writableDeviceRequest WritableDeviceRequest) ApiDcimDevicesUpdateRequest {
	r.writableDeviceRequest = &writableDeviceRequest
	return r
}

func (r ApiDcimDevicesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimDevicesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimDevicesUpdateRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.DcimDevicesUpdateExecute(r)
}

/*
DcimDevicesUpdate Method for DcimDevicesUpdate

Update a device object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this device.
 @return ApiDcimDevicesUpdateRequest
*/
func (a *DcimAPIService) DcimDevicesUpdate(ctx context.Context, id string) ApiDcimDevicesUpdateRequest {
	return ApiDcimDevicesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Device
func (a *DcimAPIService) DcimDevicesUpdateExecute(r ApiDcimDevicesUpdateRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimDevicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("writableDeviceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableDeviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortTemplatesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimFrontPortTemplatesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimFrontPortTemplatesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesBulkDestroyExecute(r)
}

/*
DcimFrontPortTemplatesBulkDestroy Method for DcimFrontPortTemplatesBulkDestroy

Destroy a list of front port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesBulkDestroy(ctx context.Context) ApiDcimFrontPortTemplatesBulkDestroyRequest {
	return ApiDcimFrontPortTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimFrontPortTemplatesBulkDestroyExecute(r ApiDcimFrontPortTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableFrontPortTemplateRequest *[]PatchedBulkWritableFrontPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortTemplatesBulkPartialUpdateRequest) PatchedBulkWritableFrontPortTemplateRequest(patchedBulkWritableFrontPortTemplateRequest []PatchedBulkWritableFrontPortTemplateRequest) ApiDcimFrontPortTemplatesBulkPartialUpdateRequest {
	r.patchedBulkWritableFrontPortTemplateRequest = &patchedBulkWritableFrontPortTemplateRequest
	return r
}

func (r ApiDcimFrontPortTemplatesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortTemplatesBulkPartialUpdateRequest) Execute() ([]FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimFrontPortTemplatesBulkPartialUpdate Method for DcimFrontPortTemplatesBulkPartialUpdate

Partial update a list of front port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimFrontPortTemplatesBulkPartialUpdateRequest {
	return ApiDcimFrontPortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FrontPortTemplate
func (a *DcimAPIService) DcimFrontPortTemplatesBulkPartialUpdateExecute(r ApiDcimFrontPortTemplatesBulkPartialUpdateRequest) ([]FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableFrontPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableFrontPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableFrontPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableFrontPortTemplateRequest *[]BulkWritableFrontPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortTemplatesBulkUpdateRequest) BulkWritableFrontPortTemplateRequest(bulkWritableFrontPortTemplateRequest []BulkWritableFrontPortTemplateRequest) ApiDcimFrontPortTemplatesBulkUpdateRequest {
	r.bulkWritableFrontPortTemplateRequest = &bulkWritableFrontPortTemplateRequest
	return r
}

func (r ApiDcimFrontPortTemplatesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortTemplatesBulkUpdateRequest) Execute() ([]FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesBulkUpdateExecute(r)
}

/*
DcimFrontPortTemplatesBulkUpdate Method for DcimFrontPortTemplatesBulkUpdate

Update a list of front port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesBulkUpdate(ctx context.Context) ApiDcimFrontPortTemplatesBulkUpdateRequest {
	return ApiDcimFrontPortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FrontPortTemplate
func (a *DcimAPIService) DcimFrontPortTemplatesBulkUpdateExecute(r ApiDcimFrontPortTemplatesBulkUpdateRequest) ([]FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableFrontPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableFrontPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableFrontPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableFrontPortTemplateRequest *WritableFrontPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortTemplatesCreateRequest) WritableFrontPortTemplateRequest(writableFrontPortTemplateRequest WritableFrontPortTemplateRequest) ApiDcimFrontPortTemplatesCreateRequest {
	r.writableFrontPortTemplateRequest = &writableFrontPortTemplateRequest
	return r
}

func (r ApiDcimFrontPortTemplatesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortTemplatesCreateRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesCreateExecute(r)
}

/*
DcimFrontPortTemplatesCreate Method for DcimFrontPortTemplatesCreate

Create one or more front port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesCreateRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesCreate(ctx context.Context) ApiDcimFrontPortTemplatesCreateRequest {
	return ApiDcimFrontPortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimAPIService) DcimFrontPortTemplatesCreateExecute(r ApiDcimFrontPortTemplatesCreateRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableFrontPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableFrontPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableFrontPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortTemplatesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesDestroyExecute(r)
}

/*
DcimFrontPortTemplatesDestroy Method for DcimFrontPortTemplatesDestroy

Destroy a front port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port template.
 @return ApiDcimFrontPortTemplatesDestroyRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesDestroy(ctx context.Context, id string) ApiDcimFrontPortTemplatesDestroyRequest {
	return ApiDcimFrontPortTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimFrontPortTemplatesDestroyExecute(r ApiDcimFrontPortTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceType *[]string
	deviceTypeN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	rearPortPosition *[]int32
	rearPortPositionGt *[]int32
	rearPortPositionGte *[]int32
	rearPortPositionLt *[]int32
	rearPortPositionLte *[]int32
	rearPortPositionN *[]int32
	rearPortTemplate *[]string
	rearPortTemplateN *[]string
	sort *string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) Description(description []string) ApiDcimFrontPortTemplatesListRequest {
	r.description = &description
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionIre(descriptionIre []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionN(descriptionN []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionNire(descriptionNire []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionNre(descriptionNre []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

// Description
func (r ApiDcimFrontPortTemplatesListRequest) DescriptionRe(descriptionRe []string) ApiDcimFrontPortTemplatesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) DeviceType(deviceType []string) ApiDcimFrontPortTemplatesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimFrontPortTemplatesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesListRequest {
	r.format = &format
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) Id(id []string) ApiDcimFrontPortTemplatesListRequest {
	r.id = &id
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdIc(idIc []string) ApiDcimFrontPortTemplatesListRequest {
	r.idIc = &idIc
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdIe(idIe []string) ApiDcimFrontPortTemplatesListRequest {
	r.idIe = &idIe
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdIew(idIew []string) ApiDcimFrontPortTemplatesListRequest {
	r.idIew = &idIew
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdIre(idIre []string) ApiDcimFrontPortTemplatesListRequest {
	r.idIre = &idIre
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdIsw(idIsw []string) ApiDcimFrontPortTemplatesListRequest {
	r.idIsw = &idIsw
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdN(idN []string) ApiDcimFrontPortTemplatesListRequest {
	r.idN = &idN
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdNic(idNic []string) ApiDcimFrontPortTemplatesListRequest {
	r.idNic = &idNic
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdNie(idNie []string) ApiDcimFrontPortTemplatesListRequest {
	r.idNie = &idNie
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdNiew(idNiew []string) ApiDcimFrontPortTemplatesListRequest {
	r.idNiew = &idNiew
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdNire(idNire []string) ApiDcimFrontPortTemplatesListRequest {
	r.idNire = &idNire
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdNisw(idNisw []string) ApiDcimFrontPortTemplatesListRequest {
	r.idNisw = &idNisw
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdNre(idNre []string) ApiDcimFrontPortTemplatesListRequest {
	r.idNre = &idNre
	return r
}

// ID
func (r ApiDcimFrontPortTemplatesListRequest) IdRe(idRe []string) ApiDcimFrontPortTemplatesListRequest {
	r.idRe = &idRe
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) Label(label []string) ApiDcimFrontPortTemplatesListRequest {
	r.label = &label
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelIc(labelIc []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelIc = &labelIc
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelIe(labelIe []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelIe = &labelIe
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelIew(labelIew []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelIew = &labelIew
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelIre(labelIre []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelIre = &labelIre
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelIsw(labelIsw []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelIsw = &labelIsw
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelN(labelN []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelN = &labelN
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelNic(labelNic []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelNic = &labelNic
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelNie(labelNie []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelNie = &labelNie
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelNiew(labelNiew []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelNiew = &labelNiew
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelNire(labelNire []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelNire = &labelNire
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelNisw(labelNisw []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelNisw = &labelNisw
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelNre(labelNre []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelNre = &labelNre
	return r
}

// Label
func (r ApiDcimFrontPortTemplatesListRequest) LabelRe(labelRe []string) ApiDcimFrontPortTemplatesListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimFrontPortTemplatesListRequest) Limit(limit int32) ApiDcimFrontPortTemplatesListRequest {
	r.limit = &limit
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) Name(name []string) ApiDcimFrontPortTemplatesListRequest {
	r.name = &name
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameIc(nameIc []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameIe(nameIe []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameIew(nameIew []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameIre(nameIre []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIre = &nameIre
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameIsw(nameIsw []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameN(nameN []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameNic(nameNic []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameNie(nameNie []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameNiew(nameNiew []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameNire(nameNire []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNire = &nameNire
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameNisw(nameNisw []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameNre(nameNre []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameNre = &nameNre
	return r
}

// Name
func (r ApiDcimFrontPortTemplatesListRequest) NameRe(nameRe []string) ApiDcimFrontPortTemplatesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimFrontPortTemplatesListRequest) Offset(offset int32) ApiDcimFrontPortTemplatesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimFrontPortTemplatesListRequest) Q(q string) ApiDcimFrontPortTemplatesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) RearPortPosition(rearPortPosition []int32) ApiDcimFrontPortTemplatesListRequest {
	r.rearPortPosition = &rearPortPosition
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) RearPortPositionGt(rearPortPositionGt []int32) ApiDcimFrontPortTemplatesListRequest {
	r.rearPortPositionGt = &rearPortPositionGt
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) RearPortPositionGte(rearPortPositionGte []int32) ApiDcimFrontPortTemplatesListRequest {
	r.rearPortPositionGte = &rearPortPositionGte
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) RearPortPositionLt(rearPortPositionLt []int32) ApiDcimFrontPortTemplatesListRequest {
	r.rearPortPositionLt = &rearPortPositionLt
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) RearPortPositionLte(rearPortPositionLte []int32) ApiDcimFrontPortTemplatesListRequest {
	r.rearPortPositionLte = &rearPortPositionLte
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) RearPortPositionN(rearPortPositionN []int32) ApiDcimFrontPortTemplatesListRequest {
	r.rearPortPositionN = &rearPortPositionN
	return r
}

// Rear port template
func (r ApiDcimFrontPortTemplatesListRequest) RearPortTemplate(rearPortTemplate []string) ApiDcimFrontPortTemplatesListRequest {
	r.rearPortTemplate = &rearPortTemplate
	return r
}

// Rear port template
func (r ApiDcimFrontPortTemplatesListRequest) RearPortTemplateN(rearPortTemplateN []string) ApiDcimFrontPortTemplatesListRequest {
	r.rearPortTemplateN = &rearPortTemplateN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimFrontPortTemplatesListRequest) Sort(sort string) ApiDcimFrontPortTemplatesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) Type_(type_ []string) ApiDcimFrontPortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeIc(typeIc []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeIe(typeIe []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeIew(typeIew []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeIre(typeIre []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeIsw(typeIsw []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeN(typeN []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeNic(typeNic []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeNie(typeNie []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeNiew(typeNiew []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeNire(typeNire []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeNisw(typeNisw []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeNre(typeNre []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) TypeRe(typeRe []string) ApiDcimFrontPortTemplatesListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimFrontPortTemplatesListRequest) Depth(depth int32) ApiDcimFrontPortTemplatesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimFrontPortTemplatesListRequest) Execute() (*PaginatedFrontPortTemplateList, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesListExecute(r)
}

/*
DcimFrontPortTemplatesList Method for DcimFrontPortTemplatesList

Retrieve a list of front port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortTemplatesListRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesList(ctx context.Context) ApiDcimFrontPortTemplatesListRequest {
	return ApiDcimFrontPortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedFrontPortTemplateList
func (a *DcimAPIService) DcimFrontPortTemplatesListExecute(r ApiDcimFrontPortTemplatesListRequest) (*PaginatedFrontPortTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFrontPortTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rearPortPosition != nil {
		t := *r.rearPortPosition
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position", t, "multi")
		}
	}
	if r.rearPortPositionGt != nil {
		t := *r.rearPortPositionGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__gt", t, "multi")
		}
	}
	if r.rearPortPositionGte != nil {
		t := *r.rearPortPositionGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__gte", t, "multi")
		}
	}
	if r.rearPortPositionLt != nil {
		t := *r.rearPortPositionLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__lt", t, "multi")
		}
	}
	if r.rearPortPositionLte != nil {
		t := *r.rearPortPositionLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__lte", t, "multi")
		}
	}
	if r.rearPortPositionN != nil {
		t := *r.rearPortPositionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__n", t, "multi")
		}
	}
	if r.rearPortTemplate != nil {
		t := *r.rearPortTemplate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_template", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_template", t, "multi")
		}
	}
	if r.rearPortTemplateN != nil {
		t := *r.rearPortTemplateN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_template__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_template__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortTemplatesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimFrontPortTemplatesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimFrontPortTemplatesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortTemplatesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesNotesCreateExecute(r)
}

/*
DcimFrontPortTemplatesNotesCreate Method for DcimFrontPortTemplatesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port template.
 @return ApiDcimFrontPortTemplatesNotesCreateRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesNotesCreate(ctx context.Context, id string) ApiDcimFrontPortTemplatesNotesCreateRequest {
	return ApiDcimFrontPortTemplatesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimFrontPortTemplatesNotesCreateExecute(r ApiDcimFrontPortTemplatesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimFrontPortTemplatesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimFrontPortTemplatesNotesListRequest) Limit(limit int32) ApiDcimFrontPortTemplatesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimFrontPortTemplatesNotesListRequest) Offset(offset int32) ApiDcimFrontPortTemplatesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimFrontPortTemplatesNotesListRequest) Depth(depth int32) ApiDcimFrontPortTemplatesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimFrontPortTemplatesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesNotesListExecute(r)
}

/*
DcimFrontPortTemplatesNotesList Method for DcimFrontPortTemplatesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port template.
 @return ApiDcimFrontPortTemplatesNotesListRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesNotesList(ctx context.Context, id string) ApiDcimFrontPortTemplatesNotesListRequest {
	return ApiDcimFrontPortTemplatesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimFrontPortTemplatesNotesListExecute(r ApiDcimFrontPortTemplatesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableFrontPortTemplateRequest *PatchedWritableFrontPortTemplateRequest
}

func (r ApiDcimFrontPortTemplatesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortTemplatesPartialUpdateRequest) PatchedWritableFrontPortTemplateRequest(patchedWritableFrontPortTemplateRequest PatchedWritableFrontPortTemplateRequest) ApiDcimFrontPortTemplatesPartialUpdateRequest {
	r.patchedWritableFrontPortTemplateRequest = &patchedWritableFrontPortTemplateRequest
	return r
}

func (r ApiDcimFrontPortTemplatesPartialUpdateRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesPartialUpdateExecute(r)
}

/*
DcimFrontPortTemplatesPartialUpdate Method for DcimFrontPortTemplatesPartialUpdate

Partial update a front port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port template.
 @return ApiDcimFrontPortTemplatesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesPartialUpdate(ctx context.Context, id string) ApiDcimFrontPortTemplatesPartialUpdateRequest {
	return ApiDcimFrontPortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimAPIService) DcimFrontPortTemplatesPartialUpdateExecute(r ApiDcimFrontPortTemplatesPartialUpdateRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableFrontPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimFrontPortTemplatesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimFrontPortTemplatesRetrieveRequest) Depth(depth int32) ApiDcimFrontPortTemplatesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimFrontPortTemplatesRetrieveRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesRetrieveExecute(r)
}

/*
DcimFrontPortTemplatesRetrieve Method for DcimFrontPortTemplatesRetrieve

Retrieve a front port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port template.
 @return ApiDcimFrontPortTemplatesRetrieveRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesRetrieve(ctx context.Context, id string) ApiDcimFrontPortTemplatesRetrieveRequest {
	return ApiDcimFrontPortTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimAPIService) DcimFrontPortTemplatesRetrieveExecute(r ApiDcimFrontPortTemplatesRetrieveRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableFrontPortTemplateRequest *WritableFrontPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortTemplatesUpdateRequest) WritableFrontPortTemplateRequest(writableFrontPortTemplateRequest WritableFrontPortTemplateRequest) ApiDcimFrontPortTemplatesUpdateRequest {
	r.writableFrontPortTemplateRequest = &writableFrontPortTemplateRequest
	return r
}

func (r ApiDcimFrontPortTemplatesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortTemplatesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortTemplatesUpdateRequest) Execute() (*FrontPortTemplate, *http.Response, error) {
	return r.ApiService.DcimFrontPortTemplatesUpdateExecute(r)
}

/*
DcimFrontPortTemplatesUpdate Method for DcimFrontPortTemplatesUpdate

Update a front port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port template.
 @return ApiDcimFrontPortTemplatesUpdateRequest
*/
func (a *DcimAPIService) DcimFrontPortTemplatesUpdate(ctx context.Context, id string) ApiDcimFrontPortTemplatesUpdateRequest {
	return ApiDcimFrontPortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPortTemplate
func (a *DcimAPIService) DcimFrontPortTemplatesUpdateExecute(r ApiDcimFrontPortTemplatesUpdateRequest) (*FrontPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableFrontPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableFrontPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableFrontPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimFrontPortsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimFrontPortsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimFrontPortsBulkDestroyExecute(r)
}

/*
DcimFrontPortsBulkDestroy Method for DcimFrontPortsBulkDestroy

Destroy a list of front port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimFrontPortsBulkDestroy(ctx context.Context) ApiDcimFrontPortsBulkDestroyRequest {
	return ApiDcimFrontPortsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimFrontPortsBulkDestroyExecute(r ApiDcimFrontPortsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimFrontPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableFrontPortRequest *[]PatchedBulkWritableFrontPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortsBulkPartialUpdateRequest) PatchedBulkWritableFrontPortRequest(patchedBulkWritableFrontPortRequest []PatchedBulkWritableFrontPortRequest) ApiDcimFrontPortsBulkPartialUpdateRequest {
	r.patchedBulkWritableFrontPortRequest = &patchedBulkWritableFrontPortRequest
	return r
}

func (r ApiDcimFrontPortsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortsBulkPartialUpdateRequest) Execute() ([]FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsBulkPartialUpdateExecute(r)
}

/*
DcimFrontPortsBulkPartialUpdate Method for DcimFrontPortsBulkPartialUpdate

Partial update a list of front port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimFrontPortsBulkPartialUpdate(ctx context.Context) ApiDcimFrontPortsBulkPartialUpdateRequest {
	return ApiDcimFrontPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FrontPort
func (a *DcimAPIService) DcimFrontPortsBulkPartialUpdateExecute(r ApiDcimFrontPortsBulkPartialUpdateRequest) ([]FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableFrontPortRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableFrontPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableFrontPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableFrontPortRequest *[]BulkWritableFrontPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortsBulkUpdateRequest) BulkWritableFrontPortRequest(bulkWritableFrontPortRequest []BulkWritableFrontPortRequest) ApiDcimFrontPortsBulkUpdateRequest {
	r.bulkWritableFrontPortRequest = &bulkWritableFrontPortRequest
	return r
}

func (r ApiDcimFrontPortsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortsBulkUpdateRequest) Execute() ([]FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsBulkUpdateExecute(r)
}

/*
DcimFrontPortsBulkUpdate Method for DcimFrontPortsBulkUpdate

Update a list of front port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimFrontPortsBulkUpdate(ctx context.Context) ApiDcimFrontPortsBulkUpdateRequest {
	return ApiDcimFrontPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FrontPort
func (a *DcimAPIService) DcimFrontPortsBulkUpdateExecute(r ApiDcimFrontPortsBulkUpdateRequest) ([]FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableFrontPortRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableFrontPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableFrontPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableFrontPortRequest *WritableFrontPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortsCreateRequest) WritableFrontPortRequest(writableFrontPortRequest WritableFrontPortRequest) ApiDcimFrontPortsCreateRequest {
	r.writableFrontPortRequest = &writableFrontPortRequest
	return r
}

func (r ApiDcimFrontPortsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortsCreateRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsCreateExecute(r)
}

/*
DcimFrontPortsCreate Method for DcimFrontPortsCreate

Create one or more front port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsCreateRequest
*/
func (a *DcimAPIService) DcimFrontPortsCreate(ctx context.Context) ApiDcimFrontPortsCreateRequest {
	return ApiDcimFrontPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimAPIService) DcimFrontPortsCreateExecute(r ApiDcimFrontPortsCreateRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableFrontPortRequest == nil {
		return localVarReturnValue, nil, reportError("writableFrontPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableFrontPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimFrontPortsDestroyExecute(r)
}

/*
DcimFrontPortsDestroy Method for DcimFrontPortsDestroy

Destroy a front port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port.
 @return ApiDcimFrontPortsDestroyRequest
*/
func (a *DcimAPIService) DcimFrontPortsDestroy(ctx context.Context, id string) ApiDcimFrontPortsDestroyRequest {
	return ApiDcimFrontPortsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimFrontPortsDestroyExecute(r ApiDcimFrontPortsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimFrontPortsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	cable *[]string
	cableIsnull *bool
	cableN *[]string
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasCable *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	rearPort *[]string
	rearPortN *[]string
	rearPortPosition *[]int32
	rearPortPositionGt *[]int32
	rearPortPositionGte *[]int32
	rearPortPositionLt *[]int32
	rearPortPositionLte *[]int32
	rearPortPositionN *[]int32
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Cable
func (r ApiDcimFrontPortsListRequest) Cable(cable []string) ApiDcimFrontPortsListRequest {
	r.cable = &cable
	return r
}

func (r ApiDcimFrontPortsListRequest) CableIsnull(cableIsnull bool) ApiDcimFrontPortsListRequest {
	r.cableIsnull = &cableIsnull
	return r
}

// Cable
func (r ApiDcimFrontPortsListRequest) CableN(cableN []string) ApiDcimFrontPortsListRequest {
	r.cableN = &cableN
	return r
}

func (r ApiDcimFrontPortsListRequest) Description(description []string) ApiDcimFrontPortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIc(descriptionIc []string) ApiDcimFrontPortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIe(descriptionIe []string) ApiDcimFrontPortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIew(descriptionIew []string) ApiDcimFrontPortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIre(descriptionIre []string) ApiDcimFrontPortsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimFrontPortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionN(descriptionN []string) ApiDcimFrontPortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNic(descriptionNic []string) ApiDcimFrontPortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNie(descriptionNie []string) ApiDcimFrontPortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimFrontPortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNire(descriptionNire []string) ApiDcimFrontPortsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimFrontPortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionNre(descriptionNre []string) ApiDcimFrontPortsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimFrontPortsListRequest) DescriptionRe(descriptionRe []string) ApiDcimFrontPortsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimFrontPortsListRequest) Device(device []string) ApiDcimFrontPortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimFrontPortsListRequest) DeviceN(deviceN []string) ApiDcimFrontPortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimFrontPortsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsListRequest {
	r.format = &format
	return r
}

// Has cable
func (r ApiDcimFrontPortsListRequest) HasCable(hasCable bool) ApiDcimFrontPortsListRequest {
	r.hasCable = &hasCable
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimFrontPortsListRequest) Id(id []string) ApiDcimFrontPortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimFrontPortsListRequest) IdIc(idIc []string) ApiDcimFrontPortsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimFrontPortsListRequest) IdIe(idIe []string) ApiDcimFrontPortsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimFrontPortsListRequest) IdIew(idIew []string) ApiDcimFrontPortsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimFrontPortsListRequest) IdIre(idIre []string) ApiDcimFrontPortsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimFrontPortsListRequest) IdIsw(idIsw []string) ApiDcimFrontPortsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimFrontPortsListRequest) IdN(idN []string) ApiDcimFrontPortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimFrontPortsListRequest) IdNic(idNic []string) ApiDcimFrontPortsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimFrontPortsListRequest) IdNie(idNie []string) ApiDcimFrontPortsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimFrontPortsListRequest) IdNiew(idNiew []string) ApiDcimFrontPortsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimFrontPortsListRequest) IdNire(idNire []string) ApiDcimFrontPortsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimFrontPortsListRequest) IdNisw(idNisw []string) ApiDcimFrontPortsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimFrontPortsListRequest) IdNre(idNre []string) ApiDcimFrontPortsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimFrontPortsListRequest) IdRe(idRe []string) ApiDcimFrontPortsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimFrontPortsListRequest) Label(label []string) ApiDcimFrontPortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIc(labelIc []string) ApiDcimFrontPortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIe(labelIe []string) ApiDcimFrontPortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIew(labelIew []string) ApiDcimFrontPortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIre(labelIre []string) ApiDcimFrontPortsListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelIsw(labelIsw []string) ApiDcimFrontPortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelN(labelN []string) ApiDcimFrontPortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNic(labelNic []string) ApiDcimFrontPortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNie(labelNie []string) ApiDcimFrontPortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNiew(labelNiew []string) ApiDcimFrontPortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNire(labelNire []string) ApiDcimFrontPortsListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNisw(labelNisw []string) ApiDcimFrontPortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelNre(labelNre []string) ApiDcimFrontPortsListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimFrontPortsListRequest) LabelRe(labelRe []string) ApiDcimFrontPortsListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimFrontPortsListRequest) Limit(limit int32) ApiDcimFrontPortsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimFrontPortsListRequest) Location(location []string) ApiDcimFrontPortsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimFrontPortsListRequest) LocationN(locationN []string) ApiDcimFrontPortsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimFrontPortsListRequest) Name(name []string) ApiDcimFrontPortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIc(nameIc []string) ApiDcimFrontPortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIe(nameIe []string) ApiDcimFrontPortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIew(nameIew []string) ApiDcimFrontPortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIre(nameIre []string) ApiDcimFrontPortsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimFrontPortsListRequest) NameIsw(nameIsw []string) ApiDcimFrontPortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimFrontPortsListRequest) NameN(nameN []string) ApiDcimFrontPortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNic(nameNic []string) ApiDcimFrontPortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNie(nameNie []string) ApiDcimFrontPortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNiew(nameNiew []string) ApiDcimFrontPortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNire(nameNire []string) ApiDcimFrontPortsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNisw(nameNisw []string) ApiDcimFrontPortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimFrontPortsListRequest) NameNre(nameNre []string) ApiDcimFrontPortsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimFrontPortsListRequest) NameRe(nameRe []string) ApiDcimFrontPortsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimFrontPortsListRequest) Offset(offset int32) ApiDcimFrontPortsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimFrontPortsListRequest) Q(q string) ApiDcimFrontPortsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimFrontPortsListRequest) RearPort(rearPort []string) ApiDcimFrontPortsListRequest {
	r.rearPort = &rearPort
	return r
}

func (r ApiDcimFrontPortsListRequest) RearPortN(rearPortN []string) ApiDcimFrontPortsListRequest {
	r.rearPortN = &rearPortN
	return r
}

func (r ApiDcimFrontPortsListRequest) RearPortPosition(rearPortPosition []int32) ApiDcimFrontPortsListRequest {
	r.rearPortPosition = &rearPortPosition
	return r
}

func (r ApiDcimFrontPortsListRequest) RearPortPositionGt(rearPortPositionGt []int32) ApiDcimFrontPortsListRequest {
	r.rearPortPositionGt = &rearPortPositionGt
	return r
}

func (r ApiDcimFrontPortsListRequest) RearPortPositionGte(rearPortPositionGte []int32) ApiDcimFrontPortsListRequest {
	r.rearPortPositionGte = &rearPortPositionGte
	return r
}

func (r ApiDcimFrontPortsListRequest) RearPortPositionLt(rearPortPositionLt []int32) ApiDcimFrontPortsListRequest {
	r.rearPortPositionLt = &rearPortPositionLt
	return r
}

func (r ApiDcimFrontPortsListRequest) RearPortPositionLte(rearPortPositionLte []int32) ApiDcimFrontPortsListRequest {
	r.rearPortPositionLte = &rearPortPositionLte
	return r
}

func (r ApiDcimFrontPortsListRequest) RearPortPositionN(rearPortPositionN []int32) ApiDcimFrontPortsListRequest {
	r.rearPortPositionN = &rearPortPositionN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimFrontPortsListRequest) Sort(sort string) ApiDcimFrontPortsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimFrontPortsListRequest) Tags(tags []string) ApiDcimFrontPortsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimFrontPortsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimFrontPortsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimFrontPortsListRequest) TagsN(tagsN []string) ApiDcimFrontPortsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimFrontPortsListRequest) Type_(type_ []string) ApiDcimFrontPortsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeIc(typeIc []string) ApiDcimFrontPortsListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeIe(typeIe []string) ApiDcimFrontPortsListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeIew(typeIew []string) ApiDcimFrontPortsListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeIre(typeIre []string) ApiDcimFrontPortsListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeIsw(typeIsw []string) ApiDcimFrontPortsListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeN(typeN []string) ApiDcimFrontPortsListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeNic(typeNic []string) ApiDcimFrontPortsListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeNie(typeNie []string) ApiDcimFrontPortsListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeNiew(typeNiew []string) ApiDcimFrontPortsListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeNire(typeNire []string) ApiDcimFrontPortsListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeNisw(typeNisw []string) ApiDcimFrontPortsListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeNre(typeNre []string) ApiDcimFrontPortsListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimFrontPortsListRequest) TypeRe(typeRe []string) ApiDcimFrontPortsListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimFrontPortsListRequest) Depth(depth int32) ApiDcimFrontPortsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimFrontPortsListRequest) Execute() (*PaginatedFrontPortList, *http.Response, error) {
	return r.ApiService.DcimFrontPortsListExecute(r)
}

/*
DcimFrontPortsList Method for DcimFrontPortsList

Retrieve a list of front port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimFrontPortsListRequest
*/
func (a *DcimAPIService) DcimFrontPortsList(ctx context.Context) ApiDcimFrontPortsListRequest {
	return ApiDcimFrontPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedFrontPortList
func (a *DcimAPIService) DcimFrontPortsListExecute(r ApiDcimFrontPortsListRequest) (*PaginatedFrontPortList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFrontPortList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cable != nil {
		t := *r.cable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable", t, "multi")
		}
	}
	if r.cableIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cable__isnull", r.cableIsnull, "")
	}
	if r.cableN != nil {
		t := *r.cableN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasCable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_cable", r.hasCable, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rearPort != nil {
		t := *r.rearPort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port", t, "multi")
		}
	}
	if r.rearPortN != nil {
		t := *r.rearPortN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port__n", t, "multi")
		}
	}
	if r.rearPortPosition != nil {
		t := *r.rearPortPosition
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position", t, "multi")
		}
	}
	if r.rearPortPositionGt != nil {
		t := *r.rearPortPositionGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__gt", t, "multi")
		}
	}
	if r.rearPortPositionGte != nil {
		t := *r.rearPortPositionGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__gte", t, "multi")
		}
	}
	if r.rearPortPositionLt != nil {
		t := *r.rearPortPositionLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__lt", t, "multi")
		}
	}
	if r.rearPortPositionLte != nil {
		t := *r.rearPortPositionLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__lte", t, "multi")
		}
	}
	if r.rearPortPositionN != nil {
		t := *r.rearPortPositionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rear_port_position__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimFrontPortsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimFrontPortsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimFrontPortsNotesCreateExecute(r)
}

/*
DcimFrontPortsNotesCreate Method for DcimFrontPortsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port.
 @return ApiDcimFrontPortsNotesCreateRequest
*/
func (a *DcimAPIService) DcimFrontPortsNotesCreate(ctx context.Context, id string) ApiDcimFrontPortsNotesCreateRequest {
	return ApiDcimFrontPortsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimFrontPortsNotesCreateExecute(r ApiDcimFrontPortsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimFrontPortsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimFrontPortsNotesListRequest) Limit(limit int32) ApiDcimFrontPortsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimFrontPortsNotesListRequest) Offset(offset int32) ApiDcimFrontPortsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimFrontPortsNotesListRequest) Depth(depth int32) ApiDcimFrontPortsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimFrontPortsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimFrontPortsNotesListExecute(r)
}

/*
DcimFrontPortsNotesList Method for DcimFrontPortsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port.
 @return ApiDcimFrontPortsNotesListRequest
*/
func (a *DcimAPIService) DcimFrontPortsNotesList(ctx context.Context, id string) ApiDcimFrontPortsNotesListRequest {
	return ApiDcimFrontPortsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimFrontPortsNotesListExecute(r ApiDcimFrontPortsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableFrontPortRequest *PatchedWritableFrontPortRequest
}

func (r ApiDcimFrontPortsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortsPartialUpdateRequest) PatchedWritableFrontPortRequest(patchedWritableFrontPortRequest PatchedWritableFrontPortRequest) ApiDcimFrontPortsPartialUpdateRequest {
	r.patchedWritableFrontPortRequest = &patchedWritableFrontPortRequest
	return r
}

func (r ApiDcimFrontPortsPartialUpdateRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsPartialUpdateExecute(r)
}

/*
DcimFrontPortsPartialUpdate Method for DcimFrontPortsPartialUpdate

Partial update a front port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port.
 @return ApiDcimFrontPortsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimFrontPortsPartialUpdate(ctx context.Context, id string) ApiDcimFrontPortsPartialUpdateRequest {
	return ApiDcimFrontPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimAPIService) DcimFrontPortsPartialUpdateExecute(r ApiDcimFrontPortsPartialUpdateRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableFrontPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsPathsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimFrontPortsPathsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsPathsListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimFrontPortsPathsListRequest) Limit(limit int32) ApiDcimFrontPortsPathsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimFrontPortsPathsListRequest) Offset(offset int32) ApiDcimFrontPortsPathsListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimFrontPortsPathsListRequest) Depth(depth int32) ApiDcimFrontPortsPathsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimFrontPortsPathsListRequest) Execute() (*PaginatedCablePathList, *http.Response, error) {
	return r.ApiService.DcimFrontPortsPathsListExecute(r)
}

/*
DcimFrontPortsPathsList Method for DcimFrontPortsPathsList

Return all CablePaths which traverse a given pass-through port.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port.
 @return ApiDcimFrontPortsPathsListRequest
*/
func (a *DcimAPIService) DcimFrontPortsPathsList(ctx context.Context, id string) ApiDcimFrontPortsPathsListRequest {
	return ApiDcimFrontPortsPathsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedCablePathList
func (a *DcimAPIService) DcimFrontPortsPathsListExecute(r ApiDcimFrontPortsPathsListRequest) (*PaginatedCablePathList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedCablePathList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsPathsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/paths/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimFrontPortsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimFrontPortsRetrieveRequest) Depth(depth int32) ApiDcimFrontPortsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimFrontPortsRetrieveRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsRetrieveExecute(r)
}

/*
DcimFrontPortsRetrieve Method for DcimFrontPortsRetrieve

Retrieve a front port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port.
 @return ApiDcimFrontPortsRetrieveRequest
*/
func (a *DcimAPIService) DcimFrontPortsRetrieve(ctx context.Context, id string) ApiDcimFrontPortsRetrieveRequest {
	return ApiDcimFrontPortsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimAPIService) DcimFrontPortsRetrieveExecute(r ApiDcimFrontPortsRetrieveRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimFrontPortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableFrontPortRequest *WritableFrontPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimFrontPortsUpdateRequest) WritableFrontPortRequest(writableFrontPortRequest WritableFrontPortRequest) ApiDcimFrontPortsUpdateRequest {
	r.writableFrontPortRequest = &writableFrontPortRequest
	return r
}

func (r ApiDcimFrontPortsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimFrontPortsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimFrontPortsUpdateRequest) Execute() (*FrontPort, *http.Response, error) {
	return r.ApiService.DcimFrontPortsUpdateExecute(r)
}

/*
DcimFrontPortsUpdate Method for DcimFrontPortsUpdate

Update a front port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this front port.
 @return ApiDcimFrontPortsUpdateRequest
*/
func (a *DcimAPIService) DcimFrontPortsUpdate(ctx context.Context, id string) ApiDcimFrontPortsUpdateRequest {
	return ApiDcimFrontPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FrontPort
func (a *DcimAPIService) DcimFrontPortsUpdateExecute(r ApiDcimFrontPortsUpdateRequest) (*FrontPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrontPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimFrontPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableFrontPortRequest == nil {
		return localVarReturnValue, nil, reportError("writableFrontPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableFrontPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceConnectionsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	device *[]string
	deviceId *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	limit *int32
	location *string
	offset *int32
	sort *string
	depth *int32
}

// Device (name)
func (r ApiDcimInterfaceConnectionsListRequest) Device(device []string) ApiDcimInterfaceConnectionsListRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiDcimInterfaceConnectionsListRequest) DeviceId(deviceId []string) ApiDcimInterfaceConnectionsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceConnectionsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimInterfaceConnectionsListRequest) Id(id []string) ApiDcimInterfaceConnectionsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdIc(idIc []string) ApiDcimInterfaceConnectionsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdIe(idIe []string) ApiDcimInterfaceConnectionsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdIew(idIew []string) ApiDcimInterfaceConnectionsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdIre(idIre []string) ApiDcimInterfaceConnectionsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdIsw(idIsw []string) ApiDcimInterfaceConnectionsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdN(idN []string) ApiDcimInterfaceConnectionsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdNic(idNic []string) ApiDcimInterfaceConnectionsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdNie(idNie []string) ApiDcimInterfaceConnectionsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdNiew(idNiew []string) ApiDcimInterfaceConnectionsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdNire(idNire []string) ApiDcimInterfaceConnectionsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdNisw(idNisw []string) ApiDcimInterfaceConnectionsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdNre(idNre []string) ApiDcimInterfaceConnectionsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) IdRe(idRe []string) ApiDcimInterfaceConnectionsListRequest {
	r.idRe = &idRe
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceConnectionsListRequest) Limit(limit int32) ApiDcimInterfaceConnectionsListRequest {
	r.limit = &limit
	return r
}

// Location (name)
func (r ApiDcimInterfaceConnectionsListRequest) Location(location string) ApiDcimInterfaceConnectionsListRequest {
	r.location = &location
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceConnectionsListRequest) Offset(offset int32) ApiDcimInterfaceConnectionsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimInterfaceConnectionsListRequest) Sort(sort string) ApiDcimInterfaceConnectionsListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceConnectionsListRequest) Depth(depth int32) ApiDcimInterfaceConnectionsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceConnectionsListRequest) Execute() (*PaginatedInterfaceConnectionList, *http.Response, error) {
	return r.ApiService.DcimInterfaceConnectionsListExecute(r)
}

/*
DcimInterfaceConnectionsList Method for DcimInterfaceConnectionsList

Retrieve a list of interface objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceConnectionsListRequest
*/
func (a *DcimAPIService) DcimInterfaceConnectionsList(ctx context.Context) ApiDcimInterfaceConnectionsListRequest {
	return ApiDcimInterfaceConnectionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedInterfaceConnectionList
func (a *DcimAPIService) DcimInterfaceConnectionsListExecute(r ApiDcimInterfaceConnectionsListRequest) (*PaginatedInterfaceConnectionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInterfaceConnectionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceConnectionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsBulkDestroyExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsBulkDestroy Method for DcimInterfaceRedundancyGroupAssociationsBulkDestroy

Destroy a list of interface redundancy group association objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsBulkDestroy(ctx context.Context) ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsBulkDestroyExecute(r ApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableInterfaceRedundancyGroupAssociationRequest *[]PatchedBulkWritableInterfaceRedundancyGroupAssociationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest) PatchedBulkWritableInterfaceRedundancyGroupAssociationRequest(patchedBulkWritableInterfaceRedundancyGroupAssociationRequest []PatchedBulkWritableInterfaceRedundancyGroupAssociationRequest) ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest {
	r.patchedBulkWritableInterfaceRedundancyGroupAssociationRequest = &patchedBulkWritableInterfaceRedundancyGroupAssociationRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest) Execute() ([]InterfaceRedundancyGroupAssociation, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsBulkPartialUpdate Method for DcimInterfaceRedundancyGroupAssociationsBulkPartialUpdate

Partial update a list of interface redundancy group association objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsBulkPartialUpdate(ctx context.Context) ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InterfaceRedundancyGroupAssociation
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateExecute(r ApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateRequest) ([]InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InterfaceRedundancyGroupAssociation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableInterfaceRedundancyGroupAssociationRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableInterfaceRedundancyGroupAssociationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableInterfaceRedundancyGroupAssociationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableInterfaceRedundancyGroupAssociationRequest *[]BulkWritableInterfaceRedundancyGroupAssociationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest) BulkWritableInterfaceRedundancyGroupAssociationRequest(bulkWritableInterfaceRedundancyGroupAssociationRequest []BulkWritableInterfaceRedundancyGroupAssociationRequest) ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest {
	r.bulkWritableInterfaceRedundancyGroupAssociationRequest = &bulkWritableInterfaceRedundancyGroupAssociationRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest) Execute() ([]InterfaceRedundancyGroupAssociation, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsBulkUpdateExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsBulkUpdate Method for DcimInterfaceRedundancyGroupAssociationsBulkUpdate

Update a list of interface redundancy group association objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsBulkUpdate(ctx context.Context) ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InterfaceRedundancyGroupAssociation
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsBulkUpdateExecute(r ApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateRequest) ([]InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InterfaceRedundancyGroupAssociation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableInterfaceRedundancyGroupAssociationRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableInterfaceRedundancyGroupAssociationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableInterfaceRedundancyGroupAssociationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	interfaceRedundancyGroupAssociationRequest *InterfaceRedundancyGroupAssociationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest) InterfaceRedundancyGroupAssociationRequest(interfaceRedundancyGroupAssociationRequest InterfaceRedundancyGroupAssociationRequest) ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest {
	r.interfaceRedundancyGroupAssociationRequest = &interfaceRedundancyGroupAssociationRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest) Execute() (*InterfaceRedundancyGroupAssociation, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsCreateExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsCreate Method for DcimInterfaceRedundancyGroupAssociationsCreate

Create one or more interface redundancy group association objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsCreate(ctx context.Context) ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InterfaceRedundancyGroupAssociation
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsCreateExecute(r ApiDcimInterfaceRedundancyGroupAssociationsCreateRequest) (*InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceRedundancyGroupAssociation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interfaceRedundancyGroupAssociationRequest == nil {
		return localVarReturnValue, nil, reportError("interfaceRedundancyGroupAssociationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interfaceRedundancyGroupAssociationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsDestroyExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsDestroy Method for DcimInterfaceRedundancyGroupAssociationsDestroy

Destroy a interface redundancy group association object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group association.
 @return ApiDcimInterfaceRedundancyGroupAssociationsDestroyRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsDestroy(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupAssociationsDestroyRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsDestroyExecute(r ApiDcimInterfaceRedundancyGroupAssociationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interface_ *[]string
	interfaceN *[]string
	interfaceRedundancyGroup *[]string
	interfaceRedundancyGroupN *[]string
	limit *int32
	offset *int32
	priority *[]int32
	priorityGt *[]int32
	priorityGte *[]int32
	priorityLt *[]int32
	priorityLte *[]int32
	priorityN *[]int32
	q *string
	sort *string
	depth *int32
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Id(id []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdIc(idIc []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdIe(idIe []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdIew(idIew []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdIre(idIre []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdIsw(idIsw []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdN(idN []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdNic(idNic []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdNie(idNie []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdNiew(idNiew []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdNire(idNire []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdNisw(idNisw []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdNre(idNre []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) IdRe(idRe []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Interface_(interface_ []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.interface_ = &interface_
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) InterfaceN(interfaceN []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.interfaceN = &interfaceN
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) InterfaceRedundancyGroup(interfaceRedundancyGroup []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.interfaceRedundancyGroup = &interfaceRedundancyGroup
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) InterfaceRedundancyGroupN(interfaceRedundancyGroupN []string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.interfaceRedundancyGroupN = &interfaceRedundancyGroupN
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Limit(limit int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Offset(offset int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Priority(priority []int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.priority = &priority
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) PriorityGt(priorityGt []int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.priorityGt = &priorityGt
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) PriorityGte(priorityGte []int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.priorityGte = &priorityGte
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) PriorityLt(priorityLt []int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.priorityLt = &priorityLt
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) PriorityLte(priorityLte []int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.priorityLte = &priorityLte
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) PriorityN(priorityN []int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.priorityN = &priorityN
	return r
}

// Search
func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Q(q string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Sort(sort string) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Depth(depth int32) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) Execute() (*PaginatedInterfaceRedundancyGroupAssociationList, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsListExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsList Method for DcimInterfaceRedundancyGroupAssociationsList

Retrieve a list of interface redundancy group association objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupAssociationsListRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsList(ctx context.Context) ApiDcimInterfaceRedundancyGroupAssociationsListRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedInterfaceRedundancyGroupAssociationList
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsListExecute(r ApiDcimInterfaceRedundancyGroupAssociationsListRequest) (*PaginatedInterfaceRedundancyGroupAssociationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInterfaceRedundancyGroupAssociationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface", t, "multi")
		}
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", t, "multi")
		}
	}
	if r.interfaceRedundancyGroup != nil {
		t := *r.interfaceRedundancyGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_group", t, "multi")
		}
	}
	if r.interfaceRedundancyGroupN != nil {
		t := *r.interfaceRedundancyGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_group__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.priority != nil {
		t := *r.priority
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority", t, "multi")
		}
	}
	if r.priorityGt != nil {
		t := *r.priorityGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gt", t, "multi")
		}
	}
	if r.priorityGte != nil {
		t := *r.priorityGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gte", t, "multi")
		}
	}
	if r.priorityLt != nil {
		t := *r.priorityLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lt", t, "multi")
		}
	}
	if r.priorityLte != nil {
		t := *r.priorityLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lte", t, "multi")
		}
	}
	if r.priorityN != nil {
		t := *r.priorityN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsNotesCreateExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsNotesCreate Method for DcimInterfaceRedundancyGroupAssociationsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group association.
 @return ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsNotesCreate(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsNotesCreateExecute(r ApiDcimInterfaceRedundancyGroupAssociationsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest) Limit(limit int32) ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest) Offset(offset int32) ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest) Depth(depth int32) ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsNotesListExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsNotesList Method for DcimInterfaceRedundancyGroupAssociationsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group association.
 @return ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsNotesList(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsNotesListExecute(r ApiDcimInterfaceRedundancyGroupAssociationsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedInterfaceRedundancyGroupAssociationRequest *PatchedInterfaceRedundancyGroupAssociationRequest
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest) PatchedInterfaceRedundancyGroupAssociationRequest(patchedInterfaceRedundancyGroupAssociationRequest PatchedInterfaceRedundancyGroupAssociationRequest) ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest {
	r.patchedInterfaceRedundancyGroupAssociationRequest = &patchedInterfaceRedundancyGroupAssociationRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest) Execute() (*InterfaceRedundancyGroupAssociation, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsPartialUpdateExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsPartialUpdate Method for DcimInterfaceRedundancyGroupAssociationsPartialUpdate

Partial update a interface redundancy group association object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group association.
 @return ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsPartialUpdate(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceRedundancyGroupAssociation
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsPartialUpdateExecute(r ApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateRequest) (*InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceRedundancyGroupAssociation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedInterfaceRedundancyGroupAssociationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest) Depth(depth int32) ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest) Execute() (*InterfaceRedundancyGroupAssociation, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsRetrieveExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsRetrieve Method for DcimInterfaceRedundancyGroupAssociationsRetrieve

Retrieve a interface redundancy group association object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group association.
 @return ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsRetrieve(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceRedundancyGroupAssociation
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsRetrieveExecute(r ApiDcimInterfaceRedundancyGroupAssociationsRetrieveRequest) (*InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceRedundancyGroupAssociation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	interfaceRedundancyGroupAssociationRequest *InterfaceRedundancyGroupAssociationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest) InterfaceRedundancyGroupAssociationRequest(interfaceRedundancyGroupAssociationRequest InterfaceRedundancyGroupAssociationRequest) ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest {
	r.interfaceRedundancyGroupAssociationRequest = &interfaceRedundancyGroupAssociationRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest) Execute() (*InterfaceRedundancyGroupAssociation, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupAssociationsUpdateExecute(r)
}

/*
DcimInterfaceRedundancyGroupAssociationsUpdate Method for DcimInterfaceRedundancyGroupAssociationsUpdate

Update a interface redundancy group association object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group association.
 @return ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsUpdate(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest {
	return ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceRedundancyGroupAssociation
func (a *DcimAPIService) DcimInterfaceRedundancyGroupAssociationsUpdateExecute(r ApiDcimInterfaceRedundancyGroupAssociationsUpdateRequest) (*InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceRedundancyGroupAssociation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupAssociationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-group-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interfaceRedundancyGroupAssociationRequest == nil {
		return localVarReturnValue, nil, reportError("interfaceRedundancyGroupAssociationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interfaceRedundancyGroupAssociationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsBulkDestroyExecute(r)
}

/*
DcimInterfaceRedundancyGroupsBulkDestroy Method for DcimInterfaceRedundancyGroupsBulkDestroy

Destroy a list of interface redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsBulkDestroy(ctx context.Context) ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest {
	return ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsBulkDestroyExecute(r ApiDcimInterfaceRedundancyGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableInterfaceRedundancyGroupRequest *[]PatchedBulkWritableInterfaceRedundancyGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest) PatchedBulkWritableInterfaceRedundancyGroupRequest(patchedBulkWritableInterfaceRedundancyGroupRequest []PatchedBulkWritableInterfaceRedundancyGroupRequest) ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest {
	r.patchedBulkWritableInterfaceRedundancyGroupRequest = &patchedBulkWritableInterfaceRedundancyGroupRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest) Execute() ([]InterfaceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsBulkPartialUpdateExecute(r)
}

/*
DcimInterfaceRedundancyGroupsBulkPartialUpdate Method for DcimInterfaceRedundancyGroupsBulkPartialUpdate

Partial update a list of interface redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsBulkPartialUpdate(ctx context.Context) ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest {
	return ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InterfaceRedundancyGroup
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsBulkPartialUpdateExecute(r ApiDcimInterfaceRedundancyGroupsBulkPartialUpdateRequest) ([]InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InterfaceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableInterfaceRedundancyGroupRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableInterfaceRedundancyGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableInterfaceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableInterfaceRedundancyGroupRequest *[]BulkWritableInterfaceRedundancyGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest) BulkWritableInterfaceRedundancyGroupRequest(bulkWritableInterfaceRedundancyGroupRequest []BulkWritableInterfaceRedundancyGroupRequest) ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest {
	r.bulkWritableInterfaceRedundancyGroupRequest = &bulkWritableInterfaceRedundancyGroupRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest) Execute() ([]InterfaceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsBulkUpdateExecute(r)
}

/*
DcimInterfaceRedundancyGroupsBulkUpdate Method for DcimInterfaceRedundancyGroupsBulkUpdate

Update a list of interface redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsBulkUpdate(ctx context.Context) ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest {
	return ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InterfaceRedundancyGroup
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsBulkUpdateExecute(r ApiDcimInterfaceRedundancyGroupsBulkUpdateRequest) ([]InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InterfaceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableInterfaceRedundancyGroupRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableInterfaceRedundancyGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableInterfaceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableInterfaceRedundancyGroupRequest *WritableInterfaceRedundancyGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupsCreateRequest) WritableInterfaceRedundancyGroupRequest(writableInterfaceRedundancyGroupRequest WritableInterfaceRedundancyGroupRequest) ApiDcimInterfaceRedundancyGroupsCreateRequest {
	r.writableInterfaceRedundancyGroupRequest = &writableInterfaceRedundancyGroupRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsCreateRequest) Execute() (*InterfaceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsCreateExecute(r)
}

/*
DcimInterfaceRedundancyGroupsCreate Method for DcimInterfaceRedundancyGroupsCreate

Create one or more interface redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupsCreateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsCreate(ctx context.Context) ApiDcimInterfaceRedundancyGroupsCreateRequest {
	return ApiDcimInterfaceRedundancyGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InterfaceRedundancyGroup
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsCreateExecute(r ApiDcimInterfaceRedundancyGroupsCreateRequest) (*InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableInterfaceRedundancyGroupRequest == nil {
		return localVarReturnValue, nil, reportError("writableInterfaceRedundancyGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableInterfaceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsDestroyExecute(r)
}

/*
DcimInterfaceRedundancyGroupsDestroy Method for DcimInterfaceRedundancyGroupsDestroy

Destroy a interface redundancy group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group.
 @return ApiDcimInterfaceRedundancyGroupsDestroyRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsDestroy(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupsDestroyRequest {
	return ApiDcimInterfaceRedundancyGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsDestroyExecute(r ApiDcimInterfaceRedundancyGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	protocol *[]string
	protocolIc *[]string
	protocolIe *[]string
	protocolIew *[]string
	protocolIre *[]string
	protocolIsw *[]string
	protocolN *[]string
	protocolNic *[]string
	protocolNie *[]string
	protocolNiew *[]string
	protocolNire *[]string
	protocolNisw *[]string
	protocolNre *[]string
	protocolRe *[]string
	protocolGroupId *[]string
	protocolGroupIdIc *[]string
	protocolGroupIdIe *[]string
	protocolGroupIdIew *[]string
	protocolGroupIdIre *[]string
	protocolGroupIdIsw *[]string
	protocolGroupIdN *[]string
	protocolGroupIdNic *[]string
	protocolGroupIdNie *[]string
	protocolGroupIdNiew *[]string
	protocolGroupIdNire *[]string
	protocolGroupIdNisw *[]string
	protocolGroupIdNre *[]string
	protocolGroupIdRe *[]string
	q *string
	secretsGroup *[]string
	secretsGroupIsnull *bool
	secretsGroupN *[]string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	virtualIp *[]string
	depth *int32
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) Description(description []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionIc(descriptionIc []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionIe(descriptionIe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionIew(descriptionIew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionIre(descriptionIre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionN(descriptionN []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionNic(descriptionNic []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionNie(descriptionNie []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionNire(descriptionNire []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionNre(descriptionNre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) DescriptionRe(descriptionRe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimInterfaceRedundancyGroupsListRequest) Id(id []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdIc(idIc []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdIe(idIe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdIew(idIew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdIre(idIre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdIsw(idIsw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdN(idN []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdNic(idNic []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdNie(idNie []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdNiew(idNiew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdNire(idNire []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdNisw(idNisw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdNre(idNre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) IdRe(idRe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.idRe = &idRe
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceRedundancyGroupsListRequest) Limit(limit int32) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) Name(name []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameIc(nameIc []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameIe(nameIe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameIew(nameIew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameIre(nameIre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameIsw(nameIsw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameN(nameN []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameNic(nameNic []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameNie(nameNie []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameNiew(nameNiew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameNire(nameNire []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameNisw(nameNisw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameNre(nameNre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) NameRe(nameRe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceRedundancyGroupsListRequest) Offset(offset int32) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) Protocol(protocol []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocol = &protocol
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolIc(protocolIc []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolIc = &protocolIc
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolIe(protocolIe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolIe = &protocolIe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolIew(protocolIew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolIew = &protocolIew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolIre(protocolIre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolIre = &protocolIre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolIsw(protocolIsw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolIsw = &protocolIsw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolN(protocolN []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolN = &protocolN
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolNic(protocolNic []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolNic = &protocolNic
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolNie(protocolNie []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolNie = &protocolNie
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolNiew(protocolNiew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolNiew = &protocolNiew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolNire(protocolNire []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolNire = &protocolNire
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolNisw(protocolNisw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolNisw = &protocolNisw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolNre(protocolNre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolNre = &protocolNre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolRe(protocolRe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolRe = &protocolRe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupId(protocolGroupId []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupId = &protocolGroupId
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdIc(protocolGroupIdIc []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdIc = &protocolGroupIdIc
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdIe(protocolGroupIdIe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdIe = &protocolGroupIdIe
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdIew(protocolGroupIdIew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdIew = &protocolGroupIdIew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdIre(protocolGroupIdIre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdIre = &protocolGroupIdIre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdIsw(protocolGroupIdIsw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdIsw = &protocolGroupIdIsw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdN(protocolGroupIdN []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdN = &protocolGroupIdN
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdNic(protocolGroupIdNic []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdNic = &protocolGroupIdNic
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdNie(protocolGroupIdNie []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdNie = &protocolGroupIdNie
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdNiew(protocolGroupIdNiew []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdNiew = &protocolGroupIdNiew
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdNire(protocolGroupIdNire []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdNire = &protocolGroupIdNire
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdNisw(protocolGroupIdNisw []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdNisw = &protocolGroupIdNisw
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdNre(protocolGroupIdNre []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdNre = &protocolGroupIdNre
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) ProtocolGroupIdRe(protocolGroupIdRe []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.protocolGroupIdRe = &protocolGroupIdRe
	return r
}

// Search
func (r ApiDcimInterfaceRedundancyGroupsListRequest) Q(q string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) SecretsGroup(secretsGroup []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.secretsGroup = &secretsGroup
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) SecretsGroupIsnull(secretsGroupIsnull bool) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.secretsGroupIsnull = &secretsGroupIsnull
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) SecretsGroupN(secretsGroupN []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.secretsGroupN = &secretsGroupN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimInterfaceRedundancyGroupsListRequest) Sort(sort string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) Tags(tags []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) TagsN(tagsN []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.tagsN = &tagsN
	return r
}

// Virtual IP Address (address or ID)
func (r ApiDcimInterfaceRedundancyGroupsListRequest) VirtualIp(virtualIp []string) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.virtualIp = &virtualIp
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceRedundancyGroupsListRequest) Depth(depth int32) ApiDcimInterfaceRedundancyGroupsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsListRequest) Execute() (*PaginatedInterfaceRedundancyGroupList, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsListExecute(r)
}

/*
DcimInterfaceRedundancyGroupsList Method for DcimInterfaceRedundancyGroupsList

Retrieve a list of interface redundancy group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceRedundancyGroupsListRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsList(ctx context.Context) ApiDcimInterfaceRedundancyGroupsListRequest {
	return ApiDcimInterfaceRedundancyGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedInterfaceRedundancyGroupList
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsListExecute(r ApiDcimInterfaceRedundancyGroupsListRequest) (*PaginatedInterfaceRedundancyGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInterfaceRedundancyGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.protocol != nil {
		t := *r.protocol
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", t, "multi")
		}
	}
	if r.protocolIc != nil {
		t := *r.protocolIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ic", t, "multi")
		}
	}
	if r.protocolIe != nil {
		t := *r.protocolIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ie", t, "multi")
		}
	}
	if r.protocolIew != nil {
		t := *r.protocolIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__iew", t, "multi")
		}
	}
	if r.protocolIre != nil {
		t := *r.protocolIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ire", t, "multi")
		}
	}
	if r.protocolIsw != nil {
		t := *r.protocolIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__isw", t, "multi")
		}
	}
	if r.protocolN != nil {
		t := *r.protocolN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", t, "multi")
		}
	}
	if r.protocolNic != nil {
		t := *r.protocolNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nic", t, "multi")
		}
	}
	if r.protocolNie != nil {
		t := *r.protocolNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nie", t, "multi")
		}
	}
	if r.protocolNiew != nil {
		t := *r.protocolNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__niew", t, "multi")
		}
	}
	if r.protocolNire != nil {
		t := *r.protocolNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nire", t, "multi")
		}
	}
	if r.protocolNisw != nil {
		t := *r.protocolNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nisw", t, "multi")
		}
	}
	if r.protocolNre != nil {
		t := *r.protocolNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nre", t, "multi")
		}
	}
	if r.protocolRe != nil {
		t := *r.protocolRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__re", t, "multi")
		}
	}
	if r.protocolGroupId != nil {
		t := *r.protocolGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id", t, "multi")
		}
	}
	if r.protocolGroupIdIc != nil {
		t := *r.protocolGroupIdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__ic", t, "multi")
		}
	}
	if r.protocolGroupIdIe != nil {
		t := *r.protocolGroupIdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__ie", t, "multi")
		}
	}
	if r.protocolGroupIdIew != nil {
		t := *r.protocolGroupIdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__iew", t, "multi")
		}
	}
	if r.protocolGroupIdIre != nil {
		t := *r.protocolGroupIdIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__ire", t, "multi")
		}
	}
	if r.protocolGroupIdIsw != nil {
		t := *r.protocolGroupIdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__isw", t, "multi")
		}
	}
	if r.protocolGroupIdN != nil {
		t := *r.protocolGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__n", t, "multi")
		}
	}
	if r.protocolGroupIdNic != nil {
		t := *r.protocolGroupIdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nic", t, "multi")
		}
	}
	if r.protocolGroupIdNie != nil {
		t := *r.protocolGroupIdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nie", t, "multi")
		}
	}
	if r.protocolGroupIdNiew != nil {
		t := *r.protocolGroupIdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__niew", t, "multi")
		}
	}
	if r.protocolGroupIdNire != nil {
		t := *r.protocolGroupIdNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nire", t, "multi")
		}
	}
	if r.protocolGroupIdNisw != nil {
		t := *r.protocolGroupIdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nisw", t, "multi")
		}
	}
	if r.protocolGroupIdNre != nil {
		t := *r.protocolGroupIdNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__nre", t, "multi")
		}
	}
	if r.protocolGroupIdRe != nil {
		t := *r.protocolGroupIdRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_group_id__re", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.secretsGroup != nil {
		t := *r.secretsGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group", t, "multi")
		}
	}
	if r.secretsGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__isnull", r.secretsGroupIsnull, "")
	}
	if r.secretsGroupN != nil {
		t := *r.secretsGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "secrets_group__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.virtualIp != nil {
		t := *r.virtualIp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_ip", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_ip", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimInterfaceRedundancyGroupsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsNotesCreateExecute(r)
}

/*
DcimInterfaceRedundancyGroupsNotesCreate Method for DcimInterfaceRedundancyGroupsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group.
 @return ApiDcimInterfaceRedundancyGroupsNotesCreateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsNotesCreate(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupsNotesCreateRequest {
	return ApiDcimInterfaceRedundancyGroupsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsNotesCreateExecute(r ApiDcimInterfaceRedundancyGroupsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimInterfaceRedundancyGroupsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceRedundancyGroupsNotesListRequest) Limit(limit int32) ApiDcimInterfaceRedundancyGroupsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceRedundancyGroupsNotesListRequest) Offset(offset int32) ApiDcimInterfaceRedundancyGroupsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceRedundancyGroupsNotesListRequest) Depth(depth int32) ApiDcimInterfaceRedundancyGroupsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsNotesListExecute(r)
}

/*
DcimInterfaceRedundancyGroupsNotesList Method for DcimInterfaceRedundancyGroupsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group.
 @return ApiDcimInterfaceRedundancyGroupsNotesListRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsNotesList(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupsNotesListRequest {
	return ApiDcimInterfaceRedundancyGroupsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsNotesListExecute(r ApiDcimInterfaceRedundancyGroupsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableInterfaceRedundancyGroupRequest *PatchedWritableInterfaceRedundancyGroupRequest
}

func (r ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest) PatchedWritableInterfaceRedundancyGroupRequest(patchedWritableInterfaceRedundancyGroupRequest PatchedWritableInterfaceRedundancyGroupRequest) ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest {
	r.patchedWritableInterfaceRedundancyGroupRequest = &patchedWritableInterfaceRedundancyGroupRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest) Execute() (*InterfaceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsPartialUpdateExecute(r)
}

/*
DcimInterfaceRedundancyGroupsPartialUpdate Method for DcimInterfaceRedundancyGroupsPartialUpdate

Partial update a interface redundancy group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group.
 @return ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsPartialUpdate(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest {
	return ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceRedundancyGroup
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsPartialUpdateExecute(r ApiDcimInterfaceRedundancyGroupsPartialUpdateRequest) (*InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableInterfaceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimInterfaceRedundancyGroupsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceRedundancyGroupsRetrieveRequest) Depth(depth int32) ApiDcimInterfaceRedundancyGroupsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsRetrieveRequest) Execute() (*InterfaceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsRetrieveExecute(r)
}

/*
DcimInterfaceRedundancyGroupsRetrieve Method for DcimInterfaceRedundancyGroupsRetrieve

Retrieve a interface redundancy group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group.
 @return ApiDcimInterfaceRedundancyGroupsRetrieveRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsRetrieve(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupsRetrieveRequest {
	return ApiDcimInterfaceRedundancyGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceRedundancyGroup
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsRetrieveExecute(r ApiDcimInterfaceRedundancyGroupsRetrieveRequest) (*InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceRedundancyGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableInterfaceRedundancyGroupRequest *WritableInterfaceRedundancyGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceRedundancyGroupsUpdateRequest) WritableInterfaceRedundancyGroupRequest(writableInterfaceRedundancyGroupRequest WritableInterfaceRedundancyGroupRequest) ApiDcimInterfaceRedundancyGroupsUpdateRequest {
	r.writableInterfaceRedundancyGroupRequest = &writableInterfaceRedundancyGroupRequest
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceRedundancyGroupsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceRedundancyGroupsUpdateRequest) Execute() (*InterfaceRedundancyGroup, *http.Response, error) {
	return r.ApiService.DcimInterfaceRedundancyGroupsUpdateExecute(r)
}

/*
DcimInterfaceRedundancyGroupsUpdate Method for DcimInterfaceRedundancyGroupsUpdate

Update a interface redundancy group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface redundancy group.
 @return ApiDcimInterfaceRedundancyGroupsUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsUpdate(ctx context.Context, id string) ApiDcimInterfaceRedundancyGroupsUpdateRequest {
	return ApiDcimInterfaceRedundancyGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceRedundancyGroup
func (a *DcimAPIService) DcimInterfaceRedundancyGroupsUpdateExecute(r ApiDcimInterfaceRedundancyGroupsUpdateRequest) (*InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceRedundancyGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceRedundancyGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableInterfaceRedundancyGroupRequest == nil {
		return localVarReturnValue, nil, reportError("writableInterfaceRedundancyGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableInterfaceRedundancyGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceTemplatesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimInterfaceTemplatesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimInterfaceTemplatesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesBulkDestroyExecute(r)
}

/*
DcimInterfaceTemplatesBulkDestroy Method for DcimInterfaceTemplatesBulkDestroy

Destroy a list of interface template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesBulkDestroy(ctx context.Context) ApiDcimInterfaceTemplatesBulkDestroyRequest {
	return ApiDcimInterfaceTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInterfaceTemplatesBulkDestroyExecute(r ApiDcimInterfaceTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableInterfaceTemplateRequest *[]PatchedBulkWritableInterfaceTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceTemplatesBulkPartialUpdateRequest) PatchedBulkWritableInterfaceTemplateRequest(patchedBulkWritableInterfaceTemplateRequest []PatchedBulkWritableInterfaceTemplateRequest) ApiDcimInterfaceTemplatesBulkPartialUpdateRequest {
	r.patchedBulkWritableInterfaceTemplateRequest = &patchedBulkWritableInterfaceTemplateRequest
	return r
}

func (r ApiDcimInterfaceTemplatesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceTemplatesBulkPartialUpdateRequest) Execute() ([]InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimInterfaceTemplatesBulkPartialUpdate Method for DcimInterfaceTemplatesBulkPartialUpdate

Partial update a list of interface template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimInterfaceTemplatesBulkPartialUpdateRequest {
	return ApiDcimInterfaceTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InterfaceTemplate
func (a *DcimAPIService) DcimInterfaceTemplatesBulkPartialUpdateExecute(r ApiDcimInterfaceTemplatesBulkPartialUpdateRequest) ([]InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableInterfaceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableInterfaceTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableInterfaceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableInterfaceTemplateRequest *[]BulkWritableInterfaceTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceTemplatesBulkUpdateRequest) BulkWritableInterfaceTemplateRequest(bulkWritableInterfaceTemplateRequest []BulkWritableInterfaceTemplateRequest) ApiDcimInterfaceTemplatesBulkUpdateRequest {
	r.bulkWritableInterfaceTemplateRequest = &bulkWritableInterfaceTemplateRequest
	return r
}

func (r ApiDcimInterfaceTemplatesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceTemplatesBulkUpdateRequest) Execute() ([]InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesBulkUpdateExecute(r)
}

/*
DcimInterfaceTemplatesBulkUpdate Method for DcimInterfaceTemplatesBulkUpdate

Update a list of interface template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesBulkUpdate(ctx context.Context) ApiDcimInterfaceTemplatesBulkUpdateRequest {
	return ApiDcimInterfaceTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InterfaceTemplate
func (a *DcimAPIService) DcimInterfaceTemplatesBulkUpdateExecute(r ApiDcimInterfaceTemplatesBulkUpdateRequest) ([]InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableInterfaceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableInterfaceTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableInterfaceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableInterfaceTemplateRequest *WritableInterfaceTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceTemplatesCreateRequest) WritableInterfaceTemplateRequest(writableInterfaceTemplateRequest WritableInterfaceTemplateRequest) ApiDcimInterfaceTemplatesCreateRequest {
	r.writableInterfaceTemplateRequest = &writableInterfaceTemplateRequest
	return r
}

func (r ApiDcimInterfaceTemplatesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceTemplatesCreateRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesCreateExecute(r)
}

/*
DcimInterfaceTemplatesCreate Method for DcimInterfaceTemplatesCreate

Create one or more interface template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesCreateRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesCreate(ctx context.Context) ApiDcimInterfaceTemplatesCreateRequest {
	return ApiDcimInterfaceTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimAPIService) DcimInterfaceTemplatesCreateExecute(r ApiDcimInterfaceTemplatesCreateRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableInterfaceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableInterfaceTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableInterfaceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceTemplatesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesDestroyExecute(r)
}

/*
DcimInterfaceTemplatesDestroy Method for DcimInterfaceTemplatesDestroy

Destroy a interface template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface template.
 @return ApiDcimInterfaceTemplatesDestroyRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesDestroy(ctx context.Context, id string) ApiDcimInterfaceTemplatesDestroyRequest {
	return ApiDcimInterfaceTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInterfaceTemplatesDestroyExecute(r ApiDcimInterfaceTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceType *[]string
	deviceTypeN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	mgmtOnly *bool
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) Description(description []string) ApiDcimInterfaceTemplatesListRequest {
	r.description = &description
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionIre(descriptionIre []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionN(descriptionN []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionNire(descriptionNire []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionNre(descriptionNre []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

// Description
func (r ApiDcimInterfaceTemplatesListRequest) DescriptionRe(descriptionRe []string) ApiDcimInterfaceTemplatesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) DeviceType(deviceType []string) ApiDcimInterfaceTemplatesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimInterfaceTemplatesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesListRequest {
	r.format = &format
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) Id(id []string) ApiDcimInterfaceTemplatesListRequest {
	r.id = &id
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdIc(idIc []string) ApiDcimInterfaceTemplatesListRequest {
	r.idIc = &idIc
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdIe(idIe []string) ApiDcimInterfaceTemplatesListRequest {
	r.idIe = &idIe
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdIew(idIew []string) ApiDcimInterfaceTemplatesListRequest {
	r.idIew = &idIew
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdIre(idIre []string) ApiDcimInterfaceTemplatesListRequest {
	r.idIre = &idIre
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdIsw(idIsw []string) ApiDcimInterfaceTemplatesListRequest {
	r.idIsw = &idIsw
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdN(idN []string) ApiDcimInterfaceTemplatesListRequest {
	r.idN = &idN
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdNic(idNic []string) ApiDcimInterfaceTemplatesListRequest {
	r.idNic = &idNic
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdNie(idNie []string) ApiDcimInterfaceTemplatesListRequest {
	r.idNie = &idNie
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdNiew(idNiew []string) ApiDcimInterfaceTemplatesListRequest {
	r.idNiew = &idNiew
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdNire(idNire []string) ApiDcimInterfaceTemplatesListRequest {
	r.idNire = &idNire
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdNisw(idNisw []string) ApiDcimInterfaceTemplatesListRequest {
	r.idNisw = &idNisw
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdNre(idNre []string) ApiDcimInterfaceTemplatesListRequest {
	r.idNre = &idNre
	return r
}

// ID
func (r ApiDcimInterfaceTemplatesListRequest) IdRe(idRe []string) ApiDcimInterfaceTemplatesListRequest {
	r.idRe = &idRe
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) Label(label []string) ApiDcimInterfaceTemplatesListRequest {
	r.label = &label
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelIc(labelIc []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelIc = &labelIc
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelIe(labelIe []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelIe = &labelIe
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelIew(labelIew []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelIew = &labelIew
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelIre(labelIre []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelIre = &labelIre
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelIsw(labelIsw []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelIsw = &labelIsw
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelN(labelN []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelN = &labelN
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelNic(labelNic []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelNic = &labelNic
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelNie(labelNie []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelNie = &labelNie
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelNiew(labelNiew []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelNiew = &labelNiew
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelNire(labelNire []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelNire = &labelNire
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelNisw(labelNisw []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelNisw = &labelNisw
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelNre(labelNre []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelNre = &labelNre
	return r
}

// Label
func (r ApiDcimInterfaceTemplatesListRequest) LabelRe(labelRe []string) ApiDcimInterfaceTemplatesListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceTemplatesListRequest) Limit(limit int32) ApiDcimInterfaceTemplatesListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) MgmtOnly(mgmtOnly bool) ApiDcimInterfaceTemplatesListRequest {
	r.mgmtOnly = &mgmtOnly
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) Name(name []string) ApiDcimInterfaceTemplatesListRequest {
	r.name = &name
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameIc(nameIc []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameIe(nameIe []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameIew(nameIew []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameIre(nameIre []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIre = &nameIre
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameIsw(nameIsw []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameN(nameN []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameN = &nameN
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameNic(nameNic []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameNie(nameNie []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameNiew(nameNiew []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameNire(nameNire []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNire = &nameNire
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameNisw(nameNisw []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameNre(nameNre []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameNre = &nameNre
	return r
}

// Name
func (r ApiDcimInterfaceTemplatesListRequest) NameRe(nameRe []string) ApiDcimInterfaceTemplatesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceTemplatesListRequest) Offset(offset int32) ApiDcimInterfaceTemplatesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimInterfaceTemplatesListRequest) Q(q string) ApiDcimInterfaceTemplatesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimInterfaceTemplatesListRequest) Sort(sort string) ApiDcimInterfaceTemplatesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) Type_(type_ []string) ApiDcimInterfaceTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeIc(typeIc []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeIe(typeIe []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeIew(typeIew []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeIre(typeIre []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeIsw(typeIsw []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeN(typeN []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeNic(typeNic []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeNie(typeNie []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeNiew(typeNiew []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeNire(typeNire []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeNisw(typeNisw []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeNre(typeNre []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) TypeRe(typeRe []string) ApiDcimInterfaceTemplatesListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceTemplatesListRequest) Depth(depth int32) ApiDcimInterfaceTemplatesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceTemplatesListRequest) Execute() (*PaginatedInterfaceTemplateList, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesListExecute(r)
}

/*
DcimInterfaceTemplatesList Method for DcimInterfaceTemplatesList

Retrieve a list of interface template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfaceTemplatesListRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesList(ctx context.Context) ApiDcimInterfaceTemplatesListRequest {
	return ApiDcimInterfaceTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedInterfaceTemplateList
func (a *DcimAPIService) DcimInterfaceTemplatesListExecute(r ApiDcimInterfaceTemplatesListRequest) (*PaginatedInterfaceTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInterfaceTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.mgmtOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mgmt_only", r.mgmtOnly, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceTemplatesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimInterfaceTemplatesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimInterfaceTemplatesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceTemplatesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesNotesCreateExecute(r)
}

/*
DcimInterfaceTemplatesNotesCreate Method for DcimInterfaceTemplatesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface template.
 @return ApiDcimInterfaceTemplatesNotesCreateRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesNotesCreate(ctx context.Context, id string) ApiDcimInterfaceTemplatesNotesCreateRequest {
	return ApiDcimInterfaceTemplatesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimInterfaceTemplatesNotesCreateExecute(r ApiDcimInterfaceTemplatesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimInterfaceTemplatesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfaceTemplatesNotesListRequest) Limit(limit int32) ApiDcimInterfaceTemplatesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfaceTemplatesNotesListRequest) Offset(offset int32) ApiDcimInterfaceTemplatesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceTemplatesNotesListRequest) Depth(depth int32) ApiDcimInterfaceTemplatesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceTemplatesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesNotesListExecute(r)
}

/*
DcimInterfaceTemplatesNotesList Method for DcimInterfaceTemplatesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface template.
 @return ApiDcimInterfaceTemplatesNotesListRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesNotesList(ctx context.Context, id string) ApiDcimInterfaceTemplatesNotesListRequest {
	return ApiDcimInterfaceTemplatesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimInterfaceTemplatesNotesListExecute(r ApiDcimInterfaceTemplatesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableInterfaceTemplateRequest *PatchedWritableInterfaceTemplateRequest
}

func (r ApiDcimInterfaceTemplatesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceTemplatesPartialUpdateRequest) PatchedWritableInterfaceTemplateRequest(patchedWritableInterfaceTemplateRequest PatchedWritableInterfaceTemplateRequest) ApiDcimInterfaceTemplatesPartialUpdateRequest {
	r.patchedWritableInterfaceTemplateRequest = &patchedWritableInterfaceTemplateRequest
	return r
}

func (r ApiDcimInterfaceTemplatesPartialUpdateRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesPartialUpdateExecute(r)
}

/*
DcimInterfaceTemplatesPartialUpdate Method for DcimInterfaceTemplatesPartialUpdate

Partial update a interface template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface template.
 @return ApiDcimInterfaceTemplatesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesPartialUpdate(ctx context.Context, id string) ApiDcimInterfaceTemplatesPartialUpdateRequest {
	return ApiDcimInterfaceTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimAPIService) DcimInterfaceTemplatesPartialUpdateExecute(r ApiDcimInterfaceTemplatesPartialUpdateRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableInterfaceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimInterfaceTemplatesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimInterfaceTemplatesRetrieveRequest) Depth(depth int32) ApiDcimInterfaceTemplatesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfaceTemplatesRetrieveRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesRetrieveExecute(r)
}

/*
DcimInterfaceTemplatesRetrieve Method for DcimInterfaceTemplatesRetrieve

Retrieve a interface template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface template.
 @return ApiDcimInterfaceTemplatesRetrieveRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesRetrieve(ctx context.Context, id string) ApiDcimInterfaceTemplatesRetrieveRequest {
	return ApiDcimInterfaceTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimAPIService) DcimInterfaceTemplatesRetrieveExecute(r ApiDcimInterfaceTemplatesRetrieveRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfaceTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableInterfaceTemplateRequest *WritableInterfaceTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfaceTemplatesUpdateRequest) WritableInterfaceTemplateRequest(writableInterfaceTemplateRequest WritableInterfaceTemplateRequest) ApiDcimInterfaceTemplatesUpdateRequest {
	r.writableInterfaceTemplateRequest = &writableInterfaceTemplateRequest
	return r
}

func (r ApiDcimInterfaceTemplatesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfaceTemplatesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfaceTemplatesUpdateRequest) Execute() (*InterfaceTemplate, *http.Response, error) {
	return r.ApiService.DcimInterfaceTemplatesUpdateExecute(r)
}

/*
DcimInterfaceTemplatesUpdate Method for DcimInterfaceTemplatesUpdate

Update a interface template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface template.
 @return ApiDcimInterfaceTemplatesUpdateRequest
*/
func (a *DcimAPIService) DcimInterfaceTemplatesUpdate(ctx context.Context, id string) ApiDcimInterfaceTemplatesUpdateRequest {
	return ApiDcimInterfaceTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InterfaceTemplate
func (a *DcimAPIService) DcimInterfaceTemplatesUpdateExecute(r ApiDcimInterfaceTemplatesUpdateRequest) (*InterfaceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterfaceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfaceTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableInterfaceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableInterfaceTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableInterfaceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfacesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimInterfacesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimInterfacesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfacesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfacesBulkDestroyExecute(r)
}

/*
DcimInterfacesBulkDestroy Method for DcimInterfacesBulkDestroy

Destroy a list of interface objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimInterfacesBulkDestroy(ctx context.Context) ApiDcimInterfacesBulkDestroyRequest {
	return ApiDcimInterfacesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInterfacesBulkDestroyExecute(r ApiDcimInterfacesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfacesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableInterfaceRequest *[]PatchedBulkWritableInterfaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfacesBulkPartialUpdateRequest) PatchedBulkWritableInterfaceRequest(patchedBulkWritableInterfaceRequest []PatchedBulkWritableInterfaceRequest) ApiDcimInterfacesBulkPartialUpdateRequest {
	r.patchedBulkWritableInterfaceRequest = &patchedBulkWritableInterfaceRequest
	return r
}

func (r ApiDcimInterfacesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfacesBulkPartialUpdateRequest) Execute() ([]Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesBulkPartialUpdateExecute(r)
}

/*
DcimInterfacesBulkPartialUpdate Method for DcimInterfacesBulkPartialUpdate

Partial update a list of interface objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInterfacesBulkPartialUpdate(ctx context.Context) ApiDcimInterfacesBulkPartialUpdateRequest {
	return ApiDcimInterfacesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Interface
func (a *DcimAPIService) DcimInterfacesBulkPartialUpdateExecute(r ApiDcimInterfacesBulkPartialUpdateRequest) ([]Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableInterfaceRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableInterfaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableInterfaceRequest *[]BulkWritableInterfaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfacesBulkUpdateRequest) BulkWritableInterfaceRequest(bulkWritableInterfaceRequest []BulkWritableInterfaceRequest) ApiDcimInterfacesBulkUpdateRequest {
	r.bulkWritableInterfaceRequest = &bulkWritableInterfaceRequest
	return r
}

func (r ApiDcimInterfacesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfacesBulkUpdateRequest) Execute() ([]Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesBulkUpdateExecute(r)
}

/*
DcimInterfacesBulkUpdate Method for DcimInterfacesBulkUpdate

Update a list of interface objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimInterfacesBulkUpdate(ctx context.Context) ApiDcimInterfacesBulkUpdateRequest {
	return ApiDcimInterfacesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Interface
func (a *DcimAPIService) DcimInterfacesBulkUpdateExecute(r ApiDcimInterfacesBulkUpdateRequest) ([]Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableInterfaceRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableInterfaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableInterfaceRequest *WritableInterfaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfacesCreateRequest) WritableInterfaceRequest(writableInterfaceRequest WritableInterfaceRequest) ApiDcimInterfacesCreateRequest {
	r.writableInterfaceRequest = &writableInterfaceRequest
	return r
}

func (r ApiDcimInterfacesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfacesCreateRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesCreateExecute(r)
}

/*
DcimInterfacesCreate Method for DcimInterfacesCreate

Create one or more interface objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesCreateRequest
*/
func (a *DcimAPIService) DcimInterfacesCreate(ctx context.Context) ApiDcimInterfacesCreateRequest {
	return ApiDcimInterfacesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimAPIService) DcimInterfacesCreateExecute(r ApiDcimInterfacesCreateRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableInterfaceRequest == nil {
		return localVarReturnValue, nil, reportError("writableInterfaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfacesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfacesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInterfacesDestroyExecute(r)
}

/*
DcimInterfacesDestroy Method for DcimInterfacesDestroy

Destroy a interface object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface.
 @return ApiDcimInterfacesDestroyRequest
*/
func (a *DcimAPIService) DcimInterfacesDestroy(ctx context.Context, id string) ApiDcimInterfacesDestroyRequest {
	return ApiDcimInterfacesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInterfacesDestroyExecute(r ApiDcimInterfacesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInterfacesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bridge *[]string
	bridgeIsnull *bool
	bridgeN *[]string
	bridgedInterfaces *[]string
	bridgedInterfacesIsnull *bool
	bridgedInterfacesN *[]string
	cable *[]string
	cableIsnull *bool
	cableN *[]string
	childInterfaces *[]string
	childInterfacesIsnull *bool
	childInterfacesN *[]string
	connected *bool
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceId *[]string
	deviceWithCommonVc *string
	enabled *bool
	format *CircuitsCircuitTerminationsListFormatParameter
	hasBridgedInterfaces *bool
	hasCable *bool
	hasChildInterfaces *bool
	hasMemberInterfaces *bool
	hasTaggedVlans *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interfaceRedundancyGroups *[]string
	interfaceRedundancyGroupsIsnull *bool
	interfaceRedundancyGroupsN *[]string
	kind *string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	lag *[]string
	lagIsnull *bool
	lagN *[]string
	limit *int32
	location *[]string
	locationN *[]string
	macAddress *[]string
	macAddressIc *[]string
	macAddressIe *[]string
	macAddressIew *[]string
	macAddressIre *[]string
	macAddressIsw *[]string
	macAddressN *[]string
	macAddressNic *[]string
	macAddressNie *[]string
	macAddressNiew *[]string
	macAddressNire *[]string
	macAddressNisw *[]string
	macAddressNre *[]string
	macAddressRe *[]string
	memberInterfaces *[]string
	memberInterfacesIsnull *bool
	memberInterfacesN *[]string
	mgmtOnly *bool
	mode *[]string
	modeIc *[]string
	modeIe *[]string
	modeIew *[]string
	modeIre *[]string
	modeIsw *[]string
	modeN *[]string
	modeNic *[]string
	modeNie *[]string
	modeNiew *[]string
	modeNire *[]string
	modeNisw *[]string
	modeNre *[]string
	modeRe *[]string
	mtu *[]int32
	mtuGt *[]int32
	mtuGte *[]int32
	mtuIsnull *bool
	mtuLt *[]int32
	mtuLte *[]int32
	mtuN *[]int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	parentInterface *[]string
	parentInterfaceIsnull *bool
	parentInterfaceN *[]string
	q *string
	sort *string
	status *[]string
	statusN *[]string
	taggedVlans *[]string
	taggedVlansN *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	untaggedVlan *[]string
	untaggedVlanIsnull *bool
	untaggedVlanN *[]string
	vlan *float32
	vlanId *string
	depth *int32
}

func (r ApiDcimInterfacesListRequest) Bridge(bridge []string) ApiDcimInterfacesListRequest {
	r.bridge = &bridge
	return r
}

func (r ApiDcimInterfacesListRequest) BridgeIsnull(bridgeIsnull bool) ApiDcimInterfacesListRequest {
	r.bridgeIsnull = &bridgeIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) BridgeN(bridgeN []string) ApiDcimInterfacesListRequest {
	r.bridgeN = &bridgeN
	return r
}

func (r ApiDcimInterfacesListRequest) BridgedInterfaces(bridgedInterfaces []string) ApiDcimInterfacesListRequest {
	r.bridgedInterfaces = &bridgedInterfaces
	return r
}

func (r ApiDcimInterfacesListRequest) BridgedInterfacesIsnull(bridgedInterfacesIsnull bool) ApiDcimInterfacesListRequest {
	r.bridgedInterfacesIsnull = &bridgedInterfacesIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) BridgedInterfacesN(bridgedInterfacesN []string) ApiDcimInterfacesListRequest {
	r.bridgedInterfacesN = &bridgedInterfacesN
	return r
}

// Cable
func (r ApiDcimInterfacesListRequest) Cable(cable []string) ApiDcimInterfacesListRequest {
	r.cable = &cable
	return r
}

func (r ApiDcimInterfacesListRequest) CableIsnull(cableIsnull bool) ApiDcimInterfacesListRequest {
	r.cableIsnull = &cableIsnull
	return r
}

// Cable
func (r ApiDcimInterfacesListRequest) CableN(cableN []string) ApiDcimInterfacesListRequest {
	r.cableN = &cableN
	return r
}

func (r ApiDcimInterfacesListRequest) ChildInterfaces(childInterfaces []string) ApiDcimInterfacesListRequest {
	r.childInterfaces = &childInterfaces
	return r
}

func (r ApiDcimInterfacesListRequest) ChildInterfacesIsnull(childInterfacesIsnull bool) ApiDcimInterfacesListRequest {
	r.childInterfacesIsnull = &childInterfacesIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) ChildInterfacesN(childInterfacesN []string) ApiDcimInterfacesListRequest {
	r.childInterfacesN = &childInterfacesN
	return r
}

// Connected status (bool)
func (r ApiDcimInterfacesListRequest) Connected(connected bool) ApiDcimInterfacesListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimInterfacesListRequest) Description(description []string) ApiDcimInterfacesListRequest {
	r.description = &description
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIc(descriptionIc []string) ApiDcimInterfacesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIe(descriptionIe []string) ApiDcimInterfacesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIew(descriptionIew []string) ApiDcimInterfacesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIre(descriptionIre []string) ApiDcimInterfacesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimInterfacesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionN(descriptionN []string) ApiDcimInterfacesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNic(descriptionNic []string) ApiDcimInterfacesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNie(descriptionNie []string) ApiDcimInterfacesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimInterfacesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNire(descriptionNire []string) ApiDcimInterfacesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimInterfacesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionNre(descriptionNre []string) ApiDcimInterfacesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimInterfacesListRequest) DescriptionRe(descriptionRe []string) ApiDcimInterfacesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

// Device (name)
func (r ApiDcimInterfacesListRequest) Device(device []string) ApiDcimInterfacesListRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiDcimInterfacesListRequest) DeviceId(deviceId []string) ApiDcimInterfacesListRequest {
	r.deviceId = &deviceId
	return r
}

// Virtual Chassis member Device (ID)
func (r ApiDcimInterfacesListRequest) DeviceWithCommonVc(deviceWithCommonVc string) ApiDcimInterfacesListRequest {
	r.deviceWithCommonVc = &deviceWithCommonVc
	return r
}

func (r ApiDcimInterfacesListRequest) Enabled(enabled bool) ApiDcimInterfacesListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiDcimInterfacesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesListRequest {
	r.format = &format
	return r
}

// Has bridged interfaces
func (r ApiDcimInterfacesListRequest) HasBridgedInterfaces(hasBridgedInterfaces bool) ApiDcimInterfacesListRequest {
	r.hasBridgedInterfaces = &hasBridgedInterfaces
	return r
}

// Has cable
func (r ApiDcimInterfacesListRequest) HasCable(hasCable bool) ApiDcimInterfacesListRequest {
	r.hasCable = &hasCable
	return r
}

// Has child interfaces
func (r ApiDcimInterfacesListRequest) HasChildInterfaces(hasChildInterfaces bool) ApiDcimInterfacesListRequest {
	r.hasChildInterfaces = &hasChildInterfaces
	return r
}

// Has member interfaces
func (r ApiDcimInterfacesListRequest) HasMemberInterfaces(hasMemberInterfaces bool) ApiDcimInterfacesListRequest {
	r.hasMemberInterfaces = &hasMemberInterfaces
	return r
}

// Has tagged VLANs
func (r ApiDcimInterfacesListRequest) HasTaggedVlans(hasTaggedVlans bool) ApiDcimInterfacesListRequest {
	r.hasTaggedVlans = &hasTaggedVlans
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimInterfacesListRequest) Id(id []string) ApiDcimInterfacesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimInterfacesListRequest) IdIc(idIc []string) ApiDcimInterfacesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimInterfacesListRequest) IdIe(idIe []string) ApiDcimInterfacesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimInterfacesListRequest) IdIew(idIew []string) ApiDcimInterfacesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimInterfacesListRequest) IdIre(idIre []string) ApiDcimInterfacesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimInterfacesListRequest) IdIsw(idIsw []string) ApiDcimInterfacesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimInterfacesListRequest) IdN(idN []string) ApiDcimInterfacesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimInterfacesListRequest) IdNic(idNic []string) ApiDcimInterfacesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimInterfacesListRequest) IdNie(idNie []string) ApiDcimInterfacesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimInterfacesListRequest) IdNiew(idNiew []string) ApiDcimInterfacesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimInterfacesListRequest) IdNire(idNire []string) ApiDcimInterfacesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimInterfacesListRequest) IdNisw(idNisw []string) ApiDcimInterfacesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimInterfacesListRequest) IdNre(idNre []string) ApiDcimInterfacesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimInterfacesListRequest) IdRe(idRe []string) ApiDcimInterfacesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimInterfacesListRequest) InterfaceRedundancyGroups(interfaceRedundancyGroups []string) ApiDcimInterfacesListRequest {
	r.interfaceRedundancyGroups = &interfaceRedundancyGroups
	return r
}

func (r ApiDcimInterfacesListRequest) InterfaceRedundancyGroupsIsnull(interfaceRedundancyGroupsIsnull bool) ApiDcimInterfacesListRequest {
	r.interfaceRedundancyGroupsIsnull = &interfaceRedundancyGroupsIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) InterfaceRedundancyGroupsN(interfaceRedundancyGroupsN []string) ApiDcimInterfacesListRequest {
	r.interfaceRedundancyGroupsN = &interfaceRedundancyGroupsN
	return r
}

// Kind of interface
func (r ApiDcimInterfacesListRequest) Kind(kind string) ApiDcimInterfacesListRequest {
	r.kind = &kind
	return r
}

func (r ApiDcimInterfacesListRequest) Label(label []string) ApiDcimInterfacesListRequest {
	r.label = &label
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIc(labelIc []string) ApiDcimInterfacesListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIe(labelIe []string) ApiDcimInterfacesListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIew(labelIew []string) ApiDcimInterfacesListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIre(labelIre []string) ApiDcimInterfacesListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimInterfacesListRequest) LabelIsw(labelIsw []string) ApiDcimInterfacesListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimInterfacesListRequest) LabelN(labelN []string) ApiDcimInterfacesListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNic(labelNic []string) ApiDcimInterfacesListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNie(labelNie []string) ApiDcimInterfacesListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNiew(labelNiew []string) ApiDcimInterfacesListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNire(labelNire []string) ApiDcimInterfacesListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNisw(labelNisw []string) ApiDcimInterfacesListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimInterfacesListRequest) LabelNre(labelNre []string) ApiDcimInterfacesListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimInterfacesListRequest) LabelRe(labelRe []string) ApiDcimInterfacesListRequest {
	r.labelRe = &labelRe
	return r
}

func (r ApiDcimInterfacesListRequest) Lag(lag []string) ApiDcimInterfacesListRequest {
	r.lag = &lag
	return r
}

func (r ApiDcimInterfacesListRequest) LagIsnull(lagIsnull bool) ApiDcimInterfacesListRequest {
	r.lagIsnull = &lagIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) LagN(lagN []string) ApiDcimInterfacesListRequest {
	r.lagN = &lagN
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfacesListRequest) Limit(limit int32) ApiDcimInterfacesListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimInterfacesListRequest) Location(location []string) ApiDcimInterfacesListRequest {
	r.location = &location
	return r
}

func (r ApiDcimInterfacesListRequest) LocationN(locationN []string) ApiDcimInterfacesListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddress(macAddress []string) ApiDcimInterfacesListRequest {
	r.macAddress = &macAddress
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIc(macAddressIc []string) ApiDcimInterfacesListRequest {
	r.macAddressIc = &macAddressIc
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIe(macAddressIe []string) ApiDcimInterfacesListRequest {
	r.macAddressIe = &macAddressIe
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIew(macAddressIew []string) ApiDcimInterfacesListRequest {
	r.macAddressIew = &macAddressIew
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIre(macAddressIre []string) ApiDcimInterfacesListRequest {
	r.macAddressIre = &macAddressIre
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressIsw(macAddressIsw []string) ApiDcimInterfacesListRequest {
	r.macAddressIsw = &macAddressIsw
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressN(macAddressN []string) ApiDcimInterfacesListRequest {
	r.macAddressN = &macAddressN
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNic(macAddressNic []string) ApiDcimInterfacesListRequest {
	r.macAddressNic = &macAddressNic
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNie(macAddressNie []string) ApiDcimInterfacesListRequest {
	r.macAddressNie = &macAddressNie
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNiew(macAddressNiew []string) ApiDcimInterfacesListRequest {
	r.macAddressNiew = &macAddressNiew
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNire(macAddressNire []string) ApiDcimInterfacesListRequest {
	r.macAddressNire = &macAddressNire
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNisw(macAddressNisw []string) ApiDcimInterfacesListRequest {
	r.macAddressNisw = &macAddressNisw
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressNre(macAddressNre []string) ApiDcimInterfacesListRequest {
	r.macAddressNre = &macAddressNre
	return r
}

func (r ApiDcimInterfacesListRequest) MacAddressRe(macAddressRe []string) ApiDcimInterfacesListRequest {
	r.macAddressRe = &macAddressRe
	return r
}

func (r ApiDcimInterfacesListRequest) MemberInterfaces(memberInterfaces []string) ApiDcimInterfacesListRequest {
	r.memberInterfaces = &memberInterfaces
	return r
}

func (r ApiDcimInterfacesListRequest) MemberInterfacesIsnull(memberInterfacesIsnull bool) ApiDcimInterfacesListRequest {
	r.memberInterfacesIsnull = &memberInterfacesIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) MemberInterfacesN(memberInterfacesN []string) ApiDcimInterfacesListRequest {
	r.memberInterfacesN = &memberInterfacesN
	return r
}

func (r ApiDcimInterfacesListRequest) MgmtOnly(mgmtOnly bool) ApiDcimInterfacesListRequest {
	r.mgmtOnly = &mgmtOnly
	return r
}

func (r ApiDcimInterfacesListRequest) Mode(mode []string) ApiDcimInterfacesListRequest {
	r.mode = &mode
	return r
}

func (r ApiDcimInterfacesListRequest) ModeIc(modeIc []string) ApiDcimInterfacesListRequest {
	r.modeIc = &modeIc
	return r
}

func (r ApiDcimInterfacesListRequest) ModeIe(modeIe []string) ApiDcimInterfacesListRequest {
	r.modeIe = &modeIe
	return r
}

func (r ApiDcimInterfacesListRequest) ModeIew(modeIew []string) ApiDcimInterfacesListRequest {
	r.modeIew = &modeIew
	return r
}

func (r ApiDcimInterfacesListRequest) ModeIre(modeIre []string) ApiDcimInterfacesListRequest {
	r.modeIre = &modeIre
	return r
}

func (r ApiDcimInterfacesListRequest) ModeIsw(modeIsw []string) ApiDcimInterfacesListRequest {
	r.modeIsw = &modeIsw
	return r
}

func (r ApiDcimInterfacesListRequest) ModeN(modeN []string) ApiDcimInterfacesListRequest {
	r.modeN = &modeN
	return r
}

func (r ApiDcimInterfacesListRequest) ModeNic(modeNic []string) ApiDcimInterfacesListRequest {
	r.modeNic = &modeNic
	return r
}

func (r ApiDcimInterfacesListRequest) ModeNie(modeNie []string) ApiDcimInterfacesListRequest {
	r.modeNie = &modeNie
	return r
}

func (r ApiDcimInterfacesListRequest) ModeNiew(modeNiew []string) ApiDcimInterfacesListRequest {
	r.modeNiew = &modeNiew
	return r
}

func (r ApiDcimInterfacesListRequest) ModeNire(modeNire []string) ApiDcimInterfacesListRequest {
	r.modeNire = &modeNire
	return r
}

func (r ApiDcimInterfacesListRequest) ModeNisw(modeNisw []string) ApiDcimInterfacesListRequest {
	r.modeNisw = &modeNisw
	return r
}

func (r ApiDcimInterfacesListRequest) ModeNre(modeNre []string) ApiDcimInterfacesListRequest {
	r.modeNre = &modeNre
	return r
}

func (r ApiDcimInterfacesListRequest) ModeRe(modeRe []string) ApiDcimInterfacesListRequest {
	r.modeRe = &modeRe
	return r
}

func (r ApiDcimInterfacesListRequest) Mtu(mtu []int32) ApiDcimInterfacesListRequest {
	r.mtu = &mtu
	return r
}

func (r ApiDcimInterfacesListRequest) MtuGt(mtuGt []int32) ApiDcimInterfacesListRequest {
	r.mtuGt = &mtuGt
	return r
}

func (r ApiDcimInterfacesListRequest) MtuGte(mtuGte []int32) ApiDcimInterfacesListRequest {
	r.mtuGte = &mtuGte
	return r
}

func (r ApiDcimInterfacesListRequest) MtuIsnull(mtuIsnull bool) ApiDcimInterfacesListRequest {
	r.mtuIsnull = &mtuIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) MtuLt(mtuLt []int32) ApiDcimInterfacesListRequest {
	r.mtuLt = &mtuLt
	return r
}

func (r ApiDcimInterfacesListRequest) MtuLte(mtuLte []int32) ApiDcimInterfacesListRequest {
	r.mtuLte = &mtuLte
	return r
}

func (r ApiDcimInterfacesListRequest) MtuN(mtuN []int32) ApiDcimInterfacesListRequest {
	r.mtuN = &mtuN
	return r
}

func (r ApiDcimInterfacesListRequest) Name(name []string) ApiDcimInterfacesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimInterfacesListRequest) NameIc(nameIc []string) ApiDcimInterfacesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimInterfacesListRequest) NameIe(nameIe []string) ApiDcimInterfacesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimInterfacesListRequest) NameIew(nameIew []string) ApiDcimInterfacesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimInterfacesListRequest) NameIre(nameIre []string) ApiDcimInterfacesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimInterfacesListRequest) NameIsw(nameIsw []string) ApiDcimInterfacesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimInterfacesListRequest) NameN(nameN []string) ApiDcimInterfacesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimInterfacesListRequest) NameNic(nameNic []string) ApiDcimInterfacesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimInterfacesListRequest) NameNie(nameNie []string) ApiDcimInterfacesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimInterfacesListRequest) NameNiew(nameNiew []string) ApiDcimInterfacesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimInterfacesListRequest) NameNire(nameNire []string) ApiDcimInterfacesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimInterfacesListRequest) NameNisw(nameNisw []string) ApiDcimInterfacesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimInterfacesListRequest) NameNre(nameNre []string) ApiDcimInterfacesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimInterfacesListRequest) NameRe(nameRe []string) ApiDcimInterfacesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfacesListRequest) Offset(offset int32) ApiDcimInterfacesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimInterfacesListRequest) ParentInterface(parentInterface []string) ApiDcimInterfacesListRequest {
	r.parentInterface = &parentInterface
	return r
}

func (r ApiDcimInterfacesListRequest) ParentInterfaceIsnull(parentInterfaceIsnull bool) ApiDcimInterfacesListRequest {
	r.parentInterfaceIsnull = &parentInterfaceIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) ParentInterfaceN(parentInterfaceN []string) ApiDcimInterfacesListRequest {
	r.parentInterfaceN = &parentInterfaceN
	return r
}

// Search
func (r ApiDcimInterfacesListRequest) Q(q string) ApiDcimInterfacesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimInterfacesListRequest) Sort(sort string) ApiDcimInterfacesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimInterfacesListRequest) Status(status []string) ApiDcimInterfacesListRequest {
	r.status = &status
	return r
}

func (r ApiDcimInterfacesListRequest) StatusN(statusN []string) ApiDcimInterfacesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimInterfacesListRequest) TaggedVlans(taggedVlans []string) ApiDcimInterfacesListRequest {
	r.taggedVlans = &taggedVlans
	return r
}

func (r ApiDcimInterfacesListRequest) TaggedVlansN(taggedVlansN []string) ApiDcimInterfacesListRequest {
	r.taggedVlansN = &taggedVlansN
	return r
}

func (r ApiDcimInterfacesListRequest) Tags(tags []string) ApiDcimInterfacesListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimInterfacesListRequest) TagsIsnull(tagsIsnull bool) ApiDcimInterfacesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) TagsN(tagsN []string) ApiDcimInterfacesListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimInterfacesListRequest) Type_(type_ []string) ApiDcimInterfacesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimInterfacesListRequest) TypeIc(typeIc []string) ApiDcimInterfacesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimInterfacesListRequest) TypeIe(typeIe []string) ApiDcimInterfacesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimInterfacesListRequest) TypeIew(typeIew []string) ApiDcimInterfacesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimInterfacesListRequest) TypeIre(typeIre []string) ApiDcimInterfacesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimInterfacesListRequest) TypeIsw(typeIsw []string) ApiDcimInterfacesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimInterfacesListRequest) TypeN(typeN []string) ApiDcimInterfacesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimInterfacesListRequest) TypeNic(typeNic []string) ApiDcimInterfacesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimInterfacesListRequest) TypeNie(typeNie []string) ApiDcimInterfacesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimInterfacesListRequest) TypeNiew(typeNiew []string) ApiDcimInterfacesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimInterfacesListRequest) TypeNire(typeNire []string) ApiDcimInterfacesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimInterfacesListRequest) TypeNisw(typeNisw []string) ApiDcimInterfacesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimInterfacesListRequest) TypeNre(typeNre []string) ApiDcimInterfacesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimInterfacesListRequest) TypeRe(typeRe []string) ApiDcimInterfacesListRequest {
	r.typeRe = &typeRe
	return r
}

func (r ApiDcimInterfacesListRequest) UntaggedVlan(untaggedVlan []string) ApiDcimInterfacesListRequest {
	r.untaggedVlan = &untaggedVlan
	return r
}

func (r ApiDcimInterfacesListRequest) UntaggedVlanIsnull(untaggedVlanIsnull bool) ApiDcimInterfacesListRequest {
	r.untaggedVlanIsnull = &untaggedVlanIsnull
	return r
}

func (r ApiDcimInterfacesListRequest) UntaggedVlanN(untaggedVlanN []string) ApiDcimInterfacesListRequest {
	r.untaggedVlanN = &untaggedVlanN
	return r
}

// Assigned VID
func (r ApiDcimInterfacesListRequest) Vlan(vlan float32) ApiDcimInterfacesListRequest {
	r.vlan = &vlan
	return r
}

// Assigned VLAN
func (r ApiDcimInterfacesListRequest) VlanId(vlanId string) ApiDcimInterfacesListRequest {
	r.vlanId = &vlanId
	return r
}

// Serializer Depth
func (r ApiDcimInterfacesListRequest) Depth(depth int32) ApiDcimInterfacesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfacesListRequest) Execute() (*PaginatedInterfaceList, *http.Response, error) {
	return r.ApiService.DcimInterfacesListExecute(r)
}

/*
DcimInterfacesList Method for DcimInterfacesList

Retrieve a list of interface objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInterfacesListRequest
*/
func (a *DcimAPIService) DcimInterfacesList(ctx context.Context) ApiDcimInterfacesListRequest {
	return ApiDcimInterfacesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedInterfaceList
func (a *DcimAPIService) DcimInterfacesListExecute(r ApiDcimInterfacesListRequest) (*PaginatedInterfaceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInterfaceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bridge != nil {
		t := *r.bridge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bridge", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bridge", t, "multi")
		}
	}
	if r.bridgeIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bridge__isnull", r.bridgeIsnull, "")
	}
	if r.bridgeN != nil {
		t := *r.bridgeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bridge__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bridge__n", t, "multi")
		}
	}
	if r.bridgedInterfaces != nil {
		t := *r.bridgedInterfaces
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bridged_interfaces", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bridged_interfaces", t, "multi")
		}
	}
	if r.bridgedInterfacesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bridged_interfaces__isnull", r.bridgedInterfacesIsnull, "")
	}
	if r.bridgedInterfacesN != nil {
		t := *r.bridgedInterfacesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bridged_interfaces__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bridged_interfaces__n", t, "multi")
		}
	}
	if r.cable != nil {
		t := *r.cable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable", t, "multi")
		}
	}
	if r.cableIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cable__isnull", r.cableIsnull, "")
	}
	if r.cableN != nil {
		t := *r.cableN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", t, "multi")
		}
	}
	if r.childInterfaces != nil {
		t := *r.childInterfaces
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "child_interfaces", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "child_interfaces", t, "multi")
		}
	}
	if r.childInterfacesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "child_interfaces__isnull", r.childInterfacesIsnull, "")
	}
	if r.childInterfacesN != nil {
		t := *r.childInterfacesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "child_interfaces__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "child_interfaces__n", t, "multi")
		}
	}
	if r.connected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connected", r.connected, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "multi")
		}
	}
	if r.deviceWithCommonVc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_with_common_vc", r.deviceWithCommonVc, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasBridgedInterfaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_bridged_interfaces", r.hasBridgedInterfaces, "")
	}
	if r.hasCable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_cable", r.hasCable, "")
	}
	if r.hasChildInterfaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_child_interfaces", r.hasChildInterfaces, "")
	}
	if r.hasMemberInterfaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_member_interfaces", r.hasMemberInterfaces, "")
	}
	if r.hasTaggedVlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_tagged_vlans", r.hasTaggedVlans, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.interfaceRedundancyGroups != nil {
		t := *r.interfaceRedundancyGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_groups", t, "multi")
		}
	}
	if r.interfaceRedundancyGroupsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_groups__isnull", r.interfaceRedundancyGroupsIsnull, "")
	}
	if r.interfaceRedundancyGroupsN != nil {
		t := *r.interfaceRedundancyGroupsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_groups__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_redundancy_groups__n", t, "multi")
		}
	}
	if r.kind != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.lag != nil {
		t := *r.lag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lag", t, "multi")
		}
	}
	if r.lagIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lag__isnull", r.lagIsnull, "")
	}
	if r.lagN != nil {
		t := *r.lagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lag__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.macAddress != nil {
		t := *r.macAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address", t, "multi")
		}
	}
	if r.macAddressIc != nil {
		t := *r.macAddressIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ic", t, "multi")
		}
	}
	if r.macAddressIe != nil {
		t := *r.macAddressIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ie", t, "multi")
		}
	}
	if r.macAddressIew != nil {
		t := *r.macAddressIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__iew", t, "multi")
		}
	}
	if r.macAddressIre != nil {
		t := *r.macAddressIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__ire", t, "multi")
		}
	}
	if r.macAddressIsw != nil {
		t := *r.macAddressIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__isw", t, "multi")
		}
	}
	if r.macAddressN != nil {
		t := *r.macAddressN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__n", t, "multi")
		}
	}
	if r.macAddressNic != nil {
		t := *r.macAddressNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nic", t, "multi")
		}
	}
	if r.macAddressNie != nil {
		t := *r.macAddressNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nie", t, "multi")
		}
	}
	if r.macAddressNiew != nil {
		t := *r.macAddressNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__niew", t, "multi")
		}
	}
	if r.macAddressNire != nil {
		t := *r.macAddressNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nire", t, "multi")
		}
	}
	if r.macAddressNisw != nil {
		t := *r.macAddressNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nisw", t, "multi")
		}
	}
	if r.macAddressNre != nil {
		t := *r.macAddressNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__nre", t, "multi")
		}
	}
	if r.macAddressRe != nil {
		t := *r.macAddressRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mac_address__re", t, "multi")
		}
	}
	if r.memberInterfaces != nil {
		t := *r.memberInterfaces
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "member_interfaces", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "member_interfaces", t, "multi")
		}
	}
	if r.memberInterfacesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "member_interfaces__isnull", r.memberInterfacesIsnull, "")
	}
	if r.memberInterfacesN != nil {
		t := *r.memberInterfacesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "member_interfaces__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "member_interfaces__n", t, "multi")
		}
	}
	if r.mgmtOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mgmt_only", r.mgmtOnly, "")
	}
	if r.mode != nil {
		t := *r.mode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode", t, "multi")
		}
	}
	if r.modeIc != nil {
		t := *r.modeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ic", t, "multi")
		}
	}
	if r.modeIe != nil {
		t := *r.modeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ie", t, "multi")
		}
	}
	if r.modeIew != nil {
		t := *r.modeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__iew", t, "multi")
		}
	}
	if r.modeIre != nil {
		t := *r.modeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ire", t, "multi")
		}
	}
	if r.modeIsw != nil {
		t := *r.modeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__isw", t, "multi")
		}
	}
	if r.modeN != nil {
		t := *r.modeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__n", t, "multi")
		}
	}
	if r.modeNic != nil {
		t := *r.modeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nic", t, "multi")
		}
	}
	if r.modeNie != nil {
		t := *r.modeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nie", t, "multi")
		}
	}
	if r.modeNiew != nil {
		t := *r.modeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__niew", t, "multi")
		}
	}
	if r.modeNire != nil {
		t := *r.modeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nire", t, "multi")
		}
	}
	if r.modeNisw != nil {
		t := *r.modeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nisw", t, "multi")
		}
	}
	if r.modeNre != nil {
		t := *r.modeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nre", t, "multi")
		}
	}
	if r.modeRe != nil {
		t := *r.modeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__re", t, "multi")
		}
	}
	if r.mtu != nil {
		t := *r.mtu
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mtu", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mtu", t, "multi")
		}
	}
	if r.mtuGt != nil {
		t := *r.mtuGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__gt", t, "multi")
		}
	}
	if r.mtuGte != nil {
		t := *r.mtuGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__gte", t, "multi")
		}
	}
	if r.mtuIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__isnull", r.mtuIsnull, "")
	}
	if r.mtuLt != nil {
		t := *r.mtuLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__lt", t, "multi")
		}
	}
	if r.mtuLte != nil {
		t := *r.mtuLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__lte", t, "multi")
		}
	}
	if r.mtuN != nil {
		t := *r.mtuN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mtu__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.parentInterface != nil {
		t := *r.parentInterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent_interface", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent_interface", t, "multi")
		}
	}
	if r.parentInterfaceIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_interface__isnull", r.parentInterfaceIsnull, "")
	}
	if r.parentInterfaceN != nil {
		t := *r.parentInterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent_interface__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent_interface__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.taggedVlans != nil {
		t := *r.taggedVlans
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tagged_vlans", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tagged_vlans", t, "multi")
		}
	}
	if r.taggedVlansN != nil {
		t := *r.taggedVlansN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tagged_vlans__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tagged_vlans__n", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.untaggedVlan != nil {
		t := *r.untaggedVlan
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "untagged_vlan", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "untagged_vlan", t, "multi")
		}
	}
	if r.untaggedVlanIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "untagged_vlan__isnull", r.untaggedVlanIsnull, "")
	}
	if r.untaggedVlanN != nil {
		t := *r.untaggedVlanN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "untagged_vlan__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "untagged_vlan__n", t, "multi")
		}
	}
	if r.vlan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan", r.vlan, "")
	}
	if r.vlanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", r.vlanId, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfacesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimInterfacesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimInterfacesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfacesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimInterfacesNotesCreateExecute(r)
}

/*
DcimInterfacesNotesCreate Method for DcimInterfacesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface.
 @return ApiDcimInterfacesNotesCreateRequest
*/
func (a *DcimAPIService) DcimInterfacesNotesCreate(ctx context.Context, id string) ApiDcimInterfacesNotesCreateRequest {
	return ApiDcimInterfacesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimInterfacesNotesCreateExecute(r ApiDcimInterfacesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimInterfacesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimInterfacesNotesListRequest) Limit(limit int32) ApiDcimInterfacesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInterfacesNotesListRequest) Offset(offset int32) ApiDcimInterfacesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimInterfacesNotesListRequest) Depth(depth int32) ApiDcimInterfacesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfacesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimInterfacesNotesListExecute(r)
}

/*
DcimInterfacesNotesList Method for DcimInterfacesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface.
 @return ApiDcimInterfacesNotesListRequest
*/
func (a *DcimAPIService) DcimInterfacesNotesList(ctx context.Context, id string) ApiDcimInterfacesNotesListRequest {
	return ApiDcimInterfacesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimInterfacesNotesListExecute(r ApiDcimInterfacesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableInterfaceRequest *PatchedWritableInterfaceRequest
}

func (r ApiDcimInterfacesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfacesPartialUpdateRequest) PatchedWritableInterfaceRequest(patchedWritableInterfaceRequest PatchedWritableInterfaceRequest) ApiDcimInterfacesPartialUpdateRequest {
	r.patchedWritableInterfaceRequest = &patchedWritableInterfaceRequest
	return r
}

func (r ApiDcimInterfacesPartialUpdateRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesPartialUpdateExecute(r)
}

/*
DcimInterfacesPartialUpdate Method for DcimInterfacesPartialUpdate

Partial update a interface object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface.
 @return ApiDcimInterfacesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInterfacesPartialUpdate(ctx context.Context, id string) ApiDcimInterfacesPartialUpdateRequest {
	return ApiDcimInterfacesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimAPIService) DcimInterfacesPartialUpdateExecute(r ApiDcimInterfacesPartialUpdateRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimInterfacesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimInterfacesRetrieveRequest) Depth(depth int32) ApiDcimInterfacesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfacesRetrieveRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesRetrieveExecute(r)
}

/*
DcimInterfacesRetrieve Method for DcimInterfacesRetrieve

Retrieve a interface object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface.
 @return ApiDcimInterfacesRetrieveRequest
*/
func (a *DcimAPIService) DcimInterfacesRetrieve(ctx context.Context, id string) ApiDcimInterfacesRetrieveRequest {
	return ApiDcimInterfacesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimAPIService) DcimInterfacesRetrieveExecute(r ApiDcimInterfacesRetrieveRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesTraceRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimInterfacesTraceRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesTraceRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimInterfacesTraceRetrieveRequest) Depth(depth int32) ApiDcimInterfacesTraceRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInterfacesTraceRetrieveRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesTraceRetrieveExecute(r)
}

/*
DcimInterfacesTraceRetrieve Method for DcimInterfacesTraceRetrieve

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface.
 @return ApiDcimInterfacesTraceRetrieveRequest
*/
func (a *DcimAPIService) DcimInterfacesTraceRetrieve(ctx context.Context, id string) ApiDcimInterfacesTraceRetrieveRequest {
	return ApiDcimInterfacesTraceRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimAPIService) DcimInterfacesTraceRetrieveExecute(r ApiDcimInterfacesTraceRetrieveRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesTraceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInterfacesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableInterfaceRequest *WritableInterfaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInterfacesUpdateRequest) WritableInterfaceRequest(writableInterfaceRequest WritableInterfaceRequest) ApiDcimInterfacesUpdateRequest {
	r.writableInterfaceRequest = &writableInterfaceRequest
	return r
}

func (r ApiDcimInterfacesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInterfacesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInterfacesUpdateRequest) Execute() (*Interface, *http.Response, error) {
	return r.ApiService.DcimInterfacesUpdateExecute(r)
}

/*
DcimInterfacesUpdate Method for DcimInterfacesUpdate

Update a interface object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this interface.
 @return ApiDcimInterfacesUpdateRequest
*/
func (a *DcimAPIService) DcimInterfacesUpdate(ctx context.Context, id string) ApiDcimInterfacesUpdateRequest {
	return ApiDcimInterfacesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Interface
func (a *DcimAPIService) DcimInterfacesUpdateExecute(r ApiDcimInterfacesUpdateRequest) (*Interface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInterfacesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableInterfaceRequest == nil {
		return localVarReturnValue, nil, reportError("writableInterfaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInventoryItemsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimInventoryItemsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimInventoryItemsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInventoryItemsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInventoryItemsBulkDestroyExecute(r)
}

/*
DcimInventoryItemsBulkDestroy Method for DcimInventoryItemsBulkDestroy

Destroy a list of inventory item objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimInventoryItemsBulkDestroy(ctx context.Context) ApiDcimInventoryItemsBulkDestroyRequest {
	return ApiDcimInventoryItemsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInventoryItemsBulkDestroyExecute(r ApiDcimInventoryItemsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableInventoryItemRequest *[]PatchedBulkWritableInventoryItemRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInventoryItemsBulkPartialUpdateRequest) PatchedBulkWritableInventoryItemRequest(patchedBulkWritableInventoryItemRequest []PatchedBulkWritableInventoryItemRequest) ApiDcimInventoryItemsBulkPartialUpdateRequest {
	r.patchedBulkWritableInventoryItemRequest = &patchedBulkWritableInventoryItemRequest
	return r
}

func (r ApiDcimInventoryItemsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInventoryItemsBulkPartialUpdateRequest) Execute() ([]InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsBulkPartialUpdateExecute(r)
}

/*
DcimInventoryItemsBulkPartialUpdate Method for DcimInventoryItemsBulkPartialUpdate

Partial update a list of inventory item objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInventoryItemsBulkPartialUpdate(ctx context.Context) ApiDcimInventoryItemsBulkPartialUpdateRequest {
	return ApiDcimInventoryItemsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InventoryItem
func (a *DcimAPIService) DcimInventoryItemsBulkPartialUpdateExecute(r ApiDcimInventoryItemsBulkPartialUpdateRequest) ([]InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableInventoryItemRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableInventoryItemRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableInventoryItemRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableInventoryItemRequest *[]BulkWritableInventoryItemRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInventoryItemsBulkUpdateRequest) BulkWritableInventoryItemRequest(bulkWritableInventoryItemRequest []BulkWritableInventoryItemRequest) ApiDcimInventoryItemsBulkUpdateRequest {
	r.bulkWritableInventoryItemRequest = &bulkWritableInventoryItemRequest
	return r
}

func (r ApiDcimInventoryItemsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInventoryItemsBulkUpdateRequest) Execute() ([]InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsBulkUpdateExecute(r)
}

/*
DcimInventoryItemsBulkUpdate Method for DcimInventoryItemsBulkUpdate

Update a list of inventory item objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimInventoryItemsBulkUpdate(ctx context.Context) ApiDcimInventoryItemsBulkUpdateRequest {
	return ApiDcimInventoryItemsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InventoryItem
func (a *DcimAPIService) DcimInventoryItemsBulkUpdateExecute(r ApiDcimInventoryItemsBulkUpdateRequest) ([]InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableInventoryItemRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableInventoryItemRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableInventoryItemRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	inventoryItemRequest *InventoryItemRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInventoryItemsCreateRequest) InventoryItemRequest(inventoryItemRequest InventoryItemRequest) ApiDcimInventoryItemsCreateRequest {
	r.inventoryItemRequest = &inventoryItemRequest
	return r
}

func (r ApiDcimInventoryItemsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInventoryItemsCreateRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsCreateExecute(r)
}

/*
DcimInventoryItemsCreate Method for DcimInventoryItemsCreate

Create one or more inventory item objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsCreateRequest
*/
func (a *DcimAPIService) DcimInventoryItemsCreate(ctx context.Context) ApiDcimInventoryItemsCreateRequest {
	return ApiDcimInventoryItemsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimAPIService) DcimInventoryItemsCreateExecute(r ApiDcimInventoryItemsCreateRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryItemRequest == nil {
		return localVarReturnValue, nil, reportError("inventoryItemRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventoryItemRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInventoryItemsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimInventoryItemsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimInventoryItemsDestroyExecute(r)
}

/*
DcimInventoryItemsDestroy Method for DcimInventoryItemsDestroy

Destroy a inventory item object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this inventory item.
 @return ApiDcimInventoryItemsDestroyRequest
*/
func (a *DcimAPIService) DcimInventoryItemsDestroy(ctx context.Context, id string) ApiDcimInventoryItemsDestroyRequest {
	return ApiDcimInventoryItemsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimInventoryItemsDestroyExecute(r ApiDcimInventoryItemsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	assetTag *[]string
	assetTagIc *[]string
	assetTagIe *[]string
	assetTagIew *[]string
	assetTagIre *[]string
	assetTagIsnull *bool
	assetTagIsw *[]string
	assetTagN *[]string
	assetTagNic *[]string
	assetTagNie *[]string
	assetTagNiew *[]string
	assetTagNire *[]string
	assetTagNisw *[]string
	assetTagNre *[]string
	assetTagRe *[]string
	children *[]string
	childrenIsnull *bool
	childrenN *[]string
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceN *[]string
	discovered *bool
	format *CircuitsCircuitTerminationsListFormatParameter
	hasChildren *bool
	hasSoftwareImageFiles *bool
	hasSoftwareVersion *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	location *[]string
	locationN *[]string
	manufacturer *[]string
	manufacturerIsnull *bool
	manufacturerN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	parent *[]string
	parentIsnull *bool
	parentN *[]string
	partId *[]string
	partIdIc *[]string
	partIdIe *[]string
	partIdIew *[]string
	partIdIre *[]string
	partIdIsw *[]string
	partIdN *[]string
	partIdNic *[]string
	partIdNie *[]string
	partIdNiew *[]string
	partIdNire *[]string
	partIdNisw *[]string
	partIdNre *[]string
	partIdRe *[]string
	q *string
	serial *[]string
	softwareImageFiles *[]string
	softwareImageFilesN *[]string
	softwareVersion *[]string
	softwareVersionIsnull *bool
	softwareVersionN *[]string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	depth *int32
}

func (r ApiDcimInventoryItemsListRequest) AssetTag(assetTag []string) ApiDcimInventoryItemsListRequest {
	r.assetTag = &assetTag
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIc(assetTagIc []string) ApiDcimInventoryItemsListRequest {
	r.assetTagIc = &assetTagIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIe(assetTagIe []string) ApiDcimInventoryItemsListRequest {
	r.assetTagIe = &assetTagIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIew(assetTagIew []string) ApiDcimInventoryItemsListRequest {
	r.assetTagIew = &assetTagIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIre(assetTagIre []string) ApiDcimInventoryItemsListRequest {
	r.assetTagIre = &assetTagIre
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIsnull(assetTagIsnull bool) ApiDcimInventoryItemsListRequest {
	r.assetTagIsnull = &assetTagIsnull
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagIsw(assetTagIsw []string) ApiDcimInventoryItemsListRequest {
	r.assetTagIsw = &assetTagIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagN(assetTagN []string) ApiDcimInventoryItemsListRequest {
	r.assetTagN = &assetTagN
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNic(assetTagNic []string) ApiDcimInventoryItemsListRequest {
	r.assetTagNic = &assetTagNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNie(assetTagNie []string) ApiDcimInventoryItemsListRequest {
	r.assetTagNie = &assetTagNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNiew(assetTagNiew []string) ApiDcimInventoryItemsListRequest {
	r.assetTagNiew = &assetTagNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNire(assetTagNire []string) ApiDcimInventoryItemsListRequest {
	r.assetTagNire = &assetTagNire
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNisw(assetTagNisw []string) ApiDcimInventoryItemsListRequest {
	r.assetTagNisw = &assetTagNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagNre(assetTagNre []string) ApiDcimInventoryItemsListRequest {
	r.assetTagNre = &assetTagNre
	return r
}

func (r ApiDcimInventoryItemsListRequest) AssetTagRe(assetTagRe []string) ApiDcimInventoryItemsListRequest {
	r.assetTagRe = &assetTagRe
	return r
}

func (r ApiDcimInventoryItemsListRequest) Children(children []string) ApiDcimInventoryItemsListRequest {
	r.children = &children
	return r
}

func (r ApiDcimInventoryItemsListRequest) ChildrenIsnull(childrenIsnull bool) ApiDcimInventoryItemsListRequest {
	r.childrenIsnull = &childrenIsnull
	return r
}

func (r ApiDcimInventoryItemsListRequest) ChildrenN(childrenN []string) ApiDcimInventoryItemsListRequest {
	r.childrenN = &childrenN
	return r
}

func (r ApiDcimInventoryItemsListRequest) Description(description []string) ApiDcimInventoryItemsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionIc(descriptionIc []string) ApiDcimInventoryItemsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionIe(descriptionIe []string) ApiDcimInventoryItemsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionIew(descriptionIew []string) ApiDcimInventoryItemsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionIre(descriptionIre []string) ApiDcimInventoryItemsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimInventoryItemsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionN(descriptionN []string) ApiDcimInventoryItemsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionNic(descriptionNic []string) ApiDcimInventoryItemsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionNie(descriptionNie []string) ApiDcimInventoryItemsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimInventoryItemsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionNire(descriptionNire []string) ApiDcimInventoryItemsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimInventoryItemsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionNre(descriptionNre []string) ApiDcimInventoryItemsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimInventoryItemsListRequest) DescriptionRe(descriptionRe []string) ApiDcimInventoryItemsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimInventoryItemsListRequest) Device(device []string) ApiDcimInventoryItemsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimInventoryItemsListRequest) DeviceN(deviceN []string) ApiDcimInventoryItemsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimInventoryItemsListRequest) Discovered(discovered bool) ApiDcimInventoryItemsListRequest {
	r.discovered = &discovered
	return r
}

func (r ApiDcimInventoryItemsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsListRequest {
	r.format = &format
	return r
}

// Has child items
func (r ApiDcimInventoryItemsListRequest) HasChildren(hasChildren bool) ApiDcimInventoryItemsListRequest {
	r.hasChildren = &hasChildren
	return r
}

// Has software image files
func (r ApiDcimInventoryItemsListRequest) HasSoftwareImageFiles(hasSoftwareImageFiles bool) ApiDcimInventoryItemsListRequest {
	r.hasSoftwareImageFiles = &hasSoftwareImageFiles
	return r
}

// Has software version
func (r ApiDcimInventoryItemsListRequest) HasSoftwareVersion(hasSoftwareVersion bool) ApiDcimInventoryItemsListRequest {
	r.hasSoftwareVersion = &hasSoftwareVersion
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimInventoryItemsListRequest) Id(id []string) ApiDcimInventoryItemsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdIc(idIc []string) ApiDcimInventoryItemsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdIe(idIe []string) ApiDcimInventoryItemsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdIew(idIew []string) ApiDcimInventoryItemsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdIre(idIre []string) ApiDcimInventoryItemsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdIsw(idIsw []string) ApiDcimInventoryItemsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdN(idN []string) ApiDcimInventoryItemsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdNic(idNic []string) ApiDcimInventoryItemsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdNie(idNie []string) ApiDcimInventoryItemsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdNiew(idNiew []string) ApiDcimInventoryItemsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdNire(idNire []string) ApiDcimInventoryItemsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdNisw(idNisw []string) ApiDcimInventoryItemsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdNre(idNre []string) ApiDcimInventoryItemsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimInventoryItemsListRequest) IdRe(idRe []string) ApiDcimInventoryItemsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimInventoryItemsListRequest) Label(label []string) ApiDcimInventoryItemsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIc(labelIc []string) ApiDcimInventoryItemsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIe(labelIe []string) ApiDcimInventoryItemsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIew(labelIew []string) ApiDcimInventoryItemsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIre(labelIre []string) ApiDcimInventoryItemsListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelIsw(labelIsw []string) ApiDcimInventoryItemsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelN(labelN []string) ApiDcimInventoryItemsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNic(labelNic []string) ApiDcimInventoryItemsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNie(labelNie []string) ApiDcimInventoryItemsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNiew(labelNiew []string) ApiDcimInventoryItemsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNire(labelNire []string) ApiDcimInventoryItemsListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNisw(labelNisw []string) ApiDcimInventoryItemsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelNre(labelNre []string) ApiDcimInventoryItemsListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimInventoryItemsListRequest) LabelRe(labelRe []string) ApiDcimInventoryItemsListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimInventoryItemsListRequest) Limit(limit int32) ApiDcimInventoryItemsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimInventoryItemsListRequest) Location(location []string) ApiDcimInventoryItemsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimInventoryItemsListRequest) LocationN(locationN []string) ApiDcimInventoryItemsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimInventoryItemsListRequest) Manufacturer(manufacturer []string) ApiDcimInventoryItemsListRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiDcimInventoryItemsListRequest) ManufacturerIsnull(manufacturerIsnull bool) ApiDcimInventoryItemsListRequest {
	r.manufacturerIsnull = &manufacturerIsnull
	return r
}

func (r ApiDcimInventoryItemsListRequest) ManufacturerN(manufacturerN []string) ApiDcimInventoryItemsListRequest {
	r.manufacturerN = &manufacturerN
	return r
}

func (r ApiDcimInventoryItemsListRequest) Name(name []string) ApiDcimInventoryItemsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIc(nameIc []string) ApiDcimInventoryItemsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIe(nameIe []string) ApiDcimInventoryItemsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIew(nameIew []string) ApiDcimInventoryItemsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIre(nameIre []string) ApiDcimInventoryItemsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameIsw(nameIsw []string) ApiDcimInventoryItemsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameN(nameN []string) ApiDcimInventoryItemsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNic(nameNic []string) ApiDcimInventoryItemsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNie(nameNie []string) ApiDcimInventoryItemsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNiew(nameNiew []string) ApiDcimInventoryItemsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNire(nameNire []string) ApiDcimInventoryItemsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNisw(nameNisw []string) ApiDcimInventoryItemsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameNre(nameNre []string) ApiDcimInventoryItemsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimInventoryItemsListRequest) NameRe(nameRe []string) ApiDcimInventoryItemsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInventoryItemsListRequest) Offset(offset int32) ApiDcimInventoryItemsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimInventoryItemsListRequest) Parent(parent []string) ApiDcimInventoryItemsListRequest {
	r.parent = &parent
	return r
}

func (r ApiDcimInventoryItemsListRequest) ParentIsnull(parentIsnull bool) ApiDcimInventoryItemsListRequest {
	r.parentIsnull = &parentIsnull
	return r
}

func (r ApiDcimInventoryItemsListRequest) ParentN(parentN []string) ApiDcimInventoryItemsListRequest {
	r.parentN = &parentN
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartId(partId []string) ApiDcimInventoryItemsListRequest {
	r.partId = &partId
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIc(partIdIc []string) ApiDcimInventoryItemsListRequest {
	r.partIdIc = &partIdIc
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIe(partIdIe []string) ApiDcimInventoryItemsListRequest {
	r.partIdIe = &partIdIe
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIew(partIdIew []string) ApiDcimInventoryItemsListRequest {
	r.partIdIew = &partIdIew
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIre(partIdIre []string) ApiDcimInventoryItemsListRequest {
	r.partIdIre = &partIdIre
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdIsw(partIdIsw []string) ApiDcimInventoryItemsListRequest {
	r.partIdIsw = &partIdIsw
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdN(partIdN []string) ApiDcimInventoryItemsListRequest {
	r.partIdN = &partIdN
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNic(partIdNic []string) ApiDcimInventoryItemsListRequest {
	r.partIdNic = &partIdNic
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNie(partIdNie []string) ApiDcimInventoryItemsListRequest {
	r.partIdNie = &partIdNie
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNiew(partIdNiew []string) ApiDcimInventoryItemsListRequest {
	r.partIdNiew = &partIdNiew
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNire(partIdNire []string) ApiDcimInventoryItemsListRequest {
	r.partIdNire = &partIdNire
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNisw(partIdNisw []string) ApiDcimInventoryItemsListRequest {
	r.partIdNisw = &partIdNisw
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdNre(partIdNre []string) ApiDcimInventoryItemsListRequest {
	r.partIdNre = &partIdNre
	return r
}

func (r ApiDcimInventoryItemsListRequest) PartIdRe(partIdRe []string) ApiDcimInventoryItemsListRequest {
	r.partIdRe = &partIdRe
	return r
}

// Search
func (r ApiDcimInventoryItemsListRequest) Q(q string) ApiDcimInventoryItemsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimInventoryItemsListRequest) Serial(serial []string) ApiDcimInventoryItemsListRequest {
	r.serial = &serial
	return r
}

func (r ApiDcimInventoryItemsListRequest) SoftwareImageFiles(softwareImageFiles []string) ApiDcimInventoryItemsListRequest {
	r.softwareImageFiles = &softwareImageFiles
	return r
}

func (r ApiDcimInventoryItemsListRequest) SoftwareImageFilesN(softwareImageFilesN []string) ApiDcimInventoryItemsListRequest {
	r.softwareImageFilesN = &softwareImageFilesN
	return r
}

func (r ApiDcimInventoryItemsListRequest) SoftwareVersion(softwareVersion []string) ApiDcimInventoryItemsListRequest {
	r.softwareVersion = &softwareVersion
	return r
}

func (r ApiDcimInventoryItemsListRequest) SoftwareVersionIsnull(softwareVersionIsnull bool) ApiDcimInventoryItemsListRequest {
	r.softwareVersionIsnull = &softwareVersionIsnull
	return r
}

func (r ApiDcimInventoryItemsListRequest) SoftwareVersionN(softwareVersionN []string) ApiDcimInventoryItemsListRequest {
	r.softwareVersionN = &softwareVersionN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimInventoryItemsListRequest) Sort(sort string) ApiDcimInventoryItemsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimInventoryItemsListRequest) Tags(tags []string) ApiDcimInventoryItemsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimInventoryItemsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimInventoryItemsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimInventoryItemsListRequest) TagsN(tagsN []string) ApiDcimInventoryItemsListRequest {
	r.tagsN = &tagsN
	return r
}

// Serializer Depth
func (r ApiDcimInventoryItemsListRequest) Depth(depth int32) ApiDcimInventoryItemsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInventoryItemsListRequest) Execute() (*PaginatedInventoryItemList, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsListExecute(r)
}

/*
DcimInventoryItemsList Method for DcimInventoryItemsList

Retrieve a list of inventory item objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimInventoryItemsListRequest
*/
func (a *DcimAPIService) DcimInventoryItemsList(ctx context.Context) ApiDcimInventoryItemsListRequest {
	return ApiDcimInventoryItemsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedInventoryItemList
func (a *DcimAPIService) DcimInventoryItemsListExecute(r ApiDcimInventoryItemsListRequest) (*PaginatedInventoryItemList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInventoryItemList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.assetTag != nil {
		t := *r.assetTag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag", t, "multi")
		}
	}
	if r.assetTagIc != nil {
		t := *r.assetTagIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ic", t, "multi")
		}
	}
	if r.assetTagIe != nil {
		t := *r.assetTagIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ie", t, "multi")
		}
	}
	if r.assetTagIew != nil {
		t := *r.assetTagIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__iew", t, "multi")
		}
	}
	if r.assetTagIre != nil {
		t := *r.assetTagIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ire", t, "multi")
		}
	}
	if r.assetTagIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isnull", r.assetTagIsnull, "")
	}
	if r.assetTagIsw != nil {
		t := *r.assetTagIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isw", t, "multi")
		}
	}
	if r.assetTagN != nil {
		t := *r.assetTagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__n", t, "multi")
		}
	}
	if r.assetTagNic != nil {
		t := *r.assetTagNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nic", t, "multi")
		}
	}
	if r.assetTagNie != nil {
		t := *r.assetTagNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nie", t, "multi")
		}
	}
	if r.assetTagNiew != nil {
		t := *r.assetTagNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__niew", t, "multi")
		}
	}
	if r.assetTagNire != nil {
		t := *r.assetTagNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nire", t, "multi")
		}
	}
	if r.assetTagNisw != nil {
		t := *r.assetTagNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nisw", t, "multi")
		}
	}
	if r.assetTagNre != nil {
		t := *r.assetTagNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nre", t, "multi")
		}
	}
	if r.assetTagRe != nil {
		t := *r.assetTagRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__re", t, "multi")
		}
	}
	if r.children != nil {
		t := *r.children
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children", t, "multi")
		}
	}
	if r.childrenIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children__isnull", r.childrenIsnull, "")
	}
	if r.childrenN != nil {
		t := *r.childrenN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.discovered != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discovered", r.discovered, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_children", r.hasChildren, "")
	}
	if r.hasSoftwareImageFiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_software_image_files", r.hasSoftwareImageFiles, "")
	}
	if r.hasSoftwareVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_software_version", r.hasSoftwareVersion, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.manufacturer != nil {
		t := *r.manufacturer
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", t, "multi")
		}
	}
	if r.manufacturerIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__isnull", r.manufacturerIsnull, "")
	}
	if r.manufacturerN != nil {
		t := *r.manufacturerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "multi")
		}
	}
	if r.parentIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent__isnull", r.parentIsnull, "")
	}
	if r.parentN != nil {
		t := *r.parentN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", t, "multi")
		}
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id", t, "multi")
		}
	}
	if r.partIdIc != nil {
		t := *r.partIdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__ic", t, "multi")
		}
	}
	if r.partIdIe != nil {
		t := *r.partIdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__ie", t, "multi")
		}
	}
	if r.partIdIew != nil {
		t := *r.partIdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__iew", t, "multi")
		}
	}
	if r.partIdIre != nil {
		t := *r.partIdIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__ire", t, "multi")
		}
	}
	if r.partIdIsw != nil {
		t := *r.partIdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__isw", t, "multi")
		}
	}
	if r.partIdN != nil {
		t := *r.partIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__n", t, "multi")
		}
	}
	if r.partIdNic != nil {
		t := *r.partIdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nic", t, "multi")
		}
	}
	if r.partIdNie != nil {
		t := *r.partIdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nie", t, "multi")
		}
	}
	if r.partIdNiew != nil {
		t := *r.partIdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__niew", t, "multi")
		}
	}
	if r.partIdNire != nil {
		t := *r.partIdNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nire", t, "multi")
		}
	}
	if r.partIdNisw != nil {
		t := *r.partIdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nisw", t, "multi")
		}
	}
	if r.partIdNre != nil {
		t := *r.partIdNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__nre", t, "multi")
		}
	}
	if r.partIdRe != nil {
		t := *r.partIdRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "part_id__re", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.serial != nil {
		t := *r.serial
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serial", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serial", t, "multi")
		}
	}
	if r.softwareImageFiles != nil {
		t := *r.softwareImageFiles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files", t, "multi")
		}
	}
	if r.softwareImageFilesN != nil {
		t := *r.softwareImageFilesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__n", t, "multi")
		}
	}
	if r.softwareVersion != nil {
		t := *r.softwareVersion
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_version", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_version", t, "multi")
		}
	}
	if r.softwareVersionIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "software_version__isnull", r.softwareVersionIsnull, "")
	}
	if r.softwareVersionN != nil {
		t := *r.softwareVersionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_version__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_version__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInventoryItemsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimInventoryItemsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimInventoryItemsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInventoryItemsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsNotesCreateExecute(r)
}

/*
DcimInventoryItemsNotesCreate Method for DcimInventoryItemsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this inventory item.
 @return ApiDcimInventoryItemsNotesCreateRequest
*/
func (a *DcimAPIService) DcimInventoryItemsNotesCreate(ctx context.Context, id string) ApiDcimInventoryItemsNotesCreateRequest {
	return ApiDcimInventoryItemsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimInventoryItemsNotesCreateExecute(r ApiDcimInventoryItemsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimInventoryItemsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimInventoryItemsNotesListRequest) Limit(limit int32) ApiDcimInventoryItemsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimInventoryItemsNotesListRequest) Offset(offset int32) ApiDcimInventoryItemsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimInventoryItemsNotesListRequest) Depth(depth int32) ApiDcimInventoryItemsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInventoryItemsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsNotesListExecute(r)
}

/*
DcimInventoryItemsNotesList Method for DcimInventoryItemsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this inventory item.
 @return ApiDcimInventoryItemsNotesListRequest
*/
func (a *DcimAPIService) DcimInventoryItemsNotesList(ctx context.Context, id string) ApiDcimInventoryItemsNotesListRequest {
	return ApiDcimInventoryItemsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimInventoryItemsNotesListExecute(r ApiDcimInventoryItemsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedInventoryItemRequest *PatchedInventoryItemRequest
}

func (r ApiDcimInventoryItemsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInventoryItemsPartialUpdateRequest) PatchedInventoryItemRequest(patchedInventoryItemRequest PatchedInventoryItemRequest) ApiDcimInventoryItemsPartialUpdateRequest {
	r.patchedInventoryItemRequest = &patchedInventoryItemRequest
	return r
}

func (r ApiDcimInventoryItemsPartialUpdateRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsPartialUpdateExecute(r)
}

/*
DcimInventoryItemsPartialUpdate Method for DcimInventoryItemsPartialUpdate

Partial update a inventory item object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this inventory item.
 @return ApiDcimInventoryItemsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimInventoryItemsPartialUpdate(ctx context.Context, id string) ApiDcimInventoryItemsPartialUpdateRequest {
	return ApiDcimInventoryItemsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimAPIService) DcimInventoryItemsPartialUpdateExecute(r ApiDcimInventoryItemsPartialUpdateRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedInventoryItemRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimInventoryItemsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimInventoryItemsRetrieveRequest) Depth(depth int32) ApiDcimInventoryItemsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimInventoryItemsRetrieveRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsRetrieveExecute(r)
}

/*
DcimInventoryItemsRetrieve Method for DcimInventoryItemsRetrieve

Retrieve a inventory item object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this inventory item.
 @return ApiDcimInventoryItemsRetrieveRequest
*/
func (a *DcimAPIService) DcimInventoryItemsRetrieve(ctx context.Context, id string) ApiDcimInventoryItemsRetrieveRequest {
	return ApiDcimInventoryItemsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimAPIService) DcimInventoryItemsRetrieveExecute(r ApiDcimInventoryItemsRetrieveRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimInventoryItemsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	inventoryItemRequest *InventoryItemRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimInventoryItemsUpdateRequest) InventoryItemRequest(inventoryItemRequest InventoryItemRequest) ApiDcimInventoryItemsUpdateRequest {
	r.inventoryItemRequest = &inventoryItemRequest
	return r
}

func (r ApiDcimInventoryItemsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimInventoryItemsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimInventoryItemsUpdateRequest) Execute() (*InventoryItem, *http.Response, error) {
	return r.ApiService.DcimInventoryItemsUpdateExecute(r)
}

/*
DcimInventoryItemsUpdate Method for DcimInventoryItemsUpdate

Update a inventory item object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this inventory item.
 @return ApiDcimInventoryItemsUpdateRequest
*/
func (a *DcimAPIService) DcimInventoryItemsUpdate(ctx context.Context, id string) ApiDcimInventoryItemsUpdateRequest {
	return ApiDcimInventoryItemsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InventoryItem
func (a *DcimAPIService) DcimInventoryItemsUpdateExecute(r ApiDcimInventoryItemsUpdateRequest) (*InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimInventoryItemsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryItemRequest == nil {
		return localVarReturnValue, nil, reportError("inventoryItemRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventoryItemRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationTypesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimLocationTypesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimLocationTypesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationTypesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimLocationTypesBulkDestroyExecute(r)
}

/*
DcimLocationTypesBulkDestroy Method for DcimLocationTypesBulkDestroy

Destroy a list of location type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationTypesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimLocationTypesBulkDestroy(ctx context.Context) ApiDcimLocationTypesBulkDestroyRequest {
	return ApiDcimLocationTypesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimLocationTypesBulkDestroyExecute(r ApiDcimLocationTypesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimLocationTypesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableLocationTypeRequest *[]PatchedBulkWritableLocationTypeRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationTypesBulkPartialUpdateRequest) PatchedBulkWritableLocationTypeRequest(patchedBulkWritableLocationTypeRequest []PatchedBulkWritableLocationTypeRequest) ApiDcimLocationTypesBulkPartialUpdateRequest {
	r.patchedBulkWritableLocationTypeRequest = &patchedBulkWritableLocationTypeRequest
	return r
}

func (r ApiDcimLocationTypesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationTypesBulkPartialUpdateRequest) Execute() ([]LocationType, *http.Response, error) {
	return r.ApiService.DcimLocationTypesBulkPartialUpdateExecute(r)
}

/*
DcimLocationTypesBulkPartialUpdate Method for DcimLocationTypesBulkPartialUpdate

Partial update a list of location type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationTypesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimLocationTypesBulkPartialUpdate(ctx context.Context) ApiDcimLocationTypesBulkPartialUpdateRequest {
	return ApiDcimLocationTypesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LocationType
func (a *DcimAPIService) DcimLocationTypesBulkPartialUpdateExecute(r ApiDcimLocationTypesBulkPartialUpdateRequest) ([]LocationType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LocationType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableLocationTypeRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableLocationTypeRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableLocationTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableLocationTypeRequest *[]BulkWritableLocationTypeRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationTypesBulkUpdateRequest) BulkWritableLocationTypeRequest(bulkWritableLocationTypeRequest []BulkWritableLocationTypeRequest) ApiDcimLocationTypesBulkUpdateRequest {
	r.bulkWritableLocationTypeRequest = &bulkWritableLocationTypeRequest
	return r
}

func (r ApiDcimLocationTypesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationTypesBulkUpdateRequest) Execute() ([]LocationType, *http.Response, error) {
	return r.ApiService.DcimLocationTypesBulkUpdateExecute(r)
}

/*
DcimLocationTypesBulkUpdate Method for DcimLocationTypesBulkUpdate

Update a list of location type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationTypesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimLocationTypesBulkUpdate(ctx context.Context) ApiDcimLocationTypesBulkUpdateRequest {
	return ApiDcimLocationTypesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LocationType
func (a *DcimAPIService) DcimLocationTypesBulkUpdateExecute(r ApiDcimLocationTypesBulkUpdateRequest) ([]LocationType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LocationType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableLocationTypeRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableLocationTypeRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableLocationTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	locationTypeRequest *LocationTypeRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationTypesCreateRequest) LocationTypeRequest(locationTypeRequest LocationTypeRequest) ApiDcimLocationTypesCreateRequest {
	r.locationTypeRequest = &locationTypeRequest
	return r
}

func (r ApiDcimLocationTypesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationTypesCreateRequest) Execute() (*LocationType, *http.Response, error) {
	return r.ApiService.DcimLocationTypesCreateExecute(r)
}

/*
DcimLocationTypesCreate Method for DcimLocationTypesCreate

Create one or more location type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationTypesCreateRequest
*/
func (a *DcimAPIService) DcimLocationTypesCreate(ctx context.Context) ApiDcimLocationTypesCreateRequest {
	return ApiDcimLocationTypesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LocationType
func (a *DcimAPIService) DcimLocationTypesCreateExecute(r ApiDcimLocationTypesCreateRequest) (*LocationType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LocationType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.locationTypeRequest == nil {
		return localVarReturnValue, nil, reportError("locationTypeRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.locationTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationTypesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationTypesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimLocationTypesDestroyExecute(r)
}

/*
DcimLocationTypesDestroy Method for DcimLocationTypesDestroy

Destroy a location type object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location type.
 @return ApiDcimLocationTypesDestroyRequest
*/
func (a *DcimAPIService) DcimLocationTypesDestroy(ctx context.Context, id string) ApiDcimLocationTypesDestroyRequest {
	return ApiDcimLocationTypesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimLocationTypesDestroyExecute(r ApiDcimLocationTypesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimLocationTypesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	contentTypes *[]int32
	contentTypesIc *[]int32
	contentTypesIe *[]int32
	contentTypesIew *[]int32
	contentTypesIre *[]int32
	contentTypesIsw *[]int32
	contentTypesN *[]int32
	contentTypesNic *[]int32
	contentTypesNie *[]int32
	contentTypesNiew *[]int32
	contentTypesNire *[]int32
	contentTypesNisw *[]int32
	contentTypesNre *[]int32
	contentTypesRe *[]int32
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	nestable *bool
	offset *int32
	parent *[]string
	parentIsnull *bool
	parentN *[]string
	q *string
	sort *string
	depth *int32
}

func (r ApiDcimLocationTypesListRequest) ContentTypes(contentTypes []int32) ApiDcimLocationTypesListRequest {
	r.contentTypes = &contentTypes
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesIc(contentTypesIc []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesIc = &contentTypesIc
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesIe(contentTypesIe []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesIe = &contentTypesIe
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesIew(contentTypesIew []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesIew = &contentTypesIew
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesIre(contentTypesIre []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesIre = &contentTypesIre
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesIsw(contentTypesIsw []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesIsw = &contentTypesIsw
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesN(contentTypesN []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesN = &contentTypesN
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesNic(contentTypesNic []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesNic = &contentTypesNic
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesNie(contentTypesNie []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesNie = &contentTypesNie
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesNiew(contentTypesNiew []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesNiew = &contentTypesNiew
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesNire(contentTypesNire []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesNire = &contentTypesNire
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesNisw(contentTypesNisw []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesNisw = &contentTypesNisw
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesNre(contentTypesNre []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesNre = &contentTypesNre
	return r
}

func (r ApiDcimLocationTypesListRequest) ContentTypesRe(contentTypesRe []int32) ApiDcimLocationTypesListRequest {
	r.contentTypesRe = &contentTypesRe
	return r
}

func (r ApiDcimLocationTypesListRequest) Created(created []time.Time) ApiDcimLocationTypesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimLocationTypesListRequest) CreatedGt(createdGt []time.Time) ApiDcimLocationTypesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimLocationTypesListRequest) CreatedGte(createdGte []time.Time) ApiDcimLocationTypesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimLocationTypesListRequest) CreatedIsnull(createdIsnull bool) ApiDcimLocationTypesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimLocationTypesListRequest) CreatedLt(createdLt []time.Time) ApiDcimLocationTypesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimLocationTypesListRequest) CreatedLte(createdLte []time.Time) ApiDcimLocationTypesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimLocationTypesListRequest) CreatedN(createdN []time.Time) ApiDcimLocationTypesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimLocationTypesListRequest) Description(description []string) ApiDcimLocationTypesListRequest {
	r.description = &description
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionIc(descriptionIc []string) ApiDcimLocationTypesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionIe(descriptionIe []string) ApiDcimLocationTypesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionIew(descriptionIew []string) ApiDcimLocationTypesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionIre(descriptionIre []string) ApiDcimLocationTypesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimLocationTypesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionN(descriptionN []string) ApiDcimLocationTypesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionNic(descriptionNic []string) ApiDcimLocationTypesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionNie(descriptionNie []string) ApiDcimLocationTypesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimLocationTypesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionNire(descriptionNire []string) ApiDcimLocationTypesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimLocationTypesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionNre(descriptionNre []string) ApiDcimLocationTypesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimLocationTypesListRequest) DescriptionRe(descriptionRe []string) ApiDcimLocationTypesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimLocationTypesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimLocationTypesListRequest) Id(id []string) ApiDcimLocationTypesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimLocationTypesListRequest) IdIc(idIc []string) ApiDcimLocationTypesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimLocationTypesListRequest) IdIe(idIe []string) ApiDcimLocationTypesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimLocationTypesListRequest) IdIew(idIew []string) ApiDcimLocationTypesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimLocationTypesListRequest) IdIre(idIre []string) ApiDcimLocationTypesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimLocationTypesListRequest) IdIsw(idIsw []string) ApiDcimLocationTypesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimLocationTypesListRequest) IdN(idN []string) ApiDcimLocationTypesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimLocationTypesListRequest) IdNic(idNic []string) ApiDcimLocationTypesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimLocationTypesListRequest) IdNie(idNie []string) ApiDcimLocationTypesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimLocationTypesListRequest) IdNiew(idNiew []string) ApiDcimLocationTypesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimLocationTypesListRequest) IdNire(idNire []string) ApiDcimLocationTypesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimLocationTypesListRequest) IdNisw(idNisw []string) ApiDcimLocationTypesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimLocationTypesListRequest) IdNre(idNre []string) ApiDcimLocationTypesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimLocationTypesListRequest) IdRe(idRe []string) ApiDcimLocationTypesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimLocationTypesListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimLocationTypesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimLocationTypesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimLocationTypesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimLocationTypesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimLocationTypesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimLocationTypesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimLocationTypesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimLocationTypesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimLocationTypesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimLocationTypesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimLocationTypesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimLocationTypesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimLocationTypesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimLocationTypesListRequest) Limit(limit int32) ApiDcimLocationTypesListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimLocationTypesListRequest) Name(name []string) ApiDcimLocationTypesListRequest {
	r.name = &name
	return r
}

func (r ApiDcimLocationTypesListRequest) NameIc(nameIc []string) ApiDcimLocationTypesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimLocationTypesListRequest) NameIe(nameIe []string) ApiDcimLocationTypesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimLocationTypesListRequest) NameIew(nameIew []string) ApiDcimLocationTypesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimLocationTypesListRequest) NameIre(nameIre []string) ApiDcimLocationTypesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimLocationTypesListRequest) NameIsw(nameIsw []string) ApiDcimLocationTypesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimLocationTypesListRequest) NameN(nameN []string) ApiDcimLocationTypesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimLocationTypesListRequest) NameNic(nameNic []string) ApiDcimLocationTypesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimLocationTypesListRequest) NameNie(nameNie []string) ApiDcimLocationTypesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimLocationTypesListRequest) NameNiew(nameNiew []string) ApiDcimLocationTypesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimLocationTypesListRequest) NameNire(nameNire []string) ApiDcimLocationTypesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimLocationTypesListRequest) NameNisw(nameNisw []string) ApiDcimLocationTypesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimLocationTypesListRequest) NameNre(nameNre []string) ApiDcimLocationTypesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimLocationTypesListRequest) NameRe(nameRe []string) ApiDcimLocationTypesListRequest {
	r.nameRe = &nameRe
	return r
}

func (r ApiDcimLocationTypesListRequest) Nestable(nestable bool) ApiDcimLocationTypesListRequest {
	r.nestable = &nestable
	return r
}

// The initial index from which to return the results.
func (r ApiDcimLocationTypesListRequest) Offset(offset int32) ApiDcimLocationTypesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimLocationTypesListRequest) Parent(parent []string) ApiDcimLocationTypesListRequest {
	r.parent = &parent
	return r
}

func (r ApiDcimLocationTypesListRequest) ParentIsnull(parentIsnull bool) ApiDcimLocationTypesListRequest {
	r.parentIsnull = &parentIsnull
	return r
}

func (r ApiDcimLocationTypesListRequest) ParentN(parentN []string) ApiDcimLocationTypesListRequest {
	r.parentN = &parentN
	return r
}

// Search
func (r ApiDcimLocationTypesListRequest) Q(q string) ApiDcimLocationTypesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimLocationTypesListRequest) Sort(sort string) ApiDcimLocationTypesListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimLocationTypesListRequest) Depth(depth int32) ApiDcimLocationTypesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimLocationTypesListRequest) Execute() (*PaginatedLocationTypeList, *http.Response, error) {
	return r.ApiService.DcimLocationTypesListExecute(r)
}

/*
DcimLocationTypesList Method for DcimLocationTypesList

Retrieve a list of location type objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationTypesListRequest
*/
func (a *DcimAPIService) DcimLocationTypesList(ctx context.Context) ApiDcimLocationTypesListRequest {
	return ApiDcimLocationTypesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedLocationTypeList
func (a *DcimAPIService) DcimLocationTypesListExecute(r ApiDcimLocationTypesListRequest) (*PaginatedLocationTypeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedLocationTypeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contentTypes != nil {
		t := *r.contentTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types", t, "multi")
		}
	}
	if r.contentTypesIc != nil {
		t := *r.contentTypesIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__ic", t, "multi")
		}
	}
	if r.contentTypesIe != nil {
		t := *r.contentTypesIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__ie", t, "multi")
		}
	}
	if r.contentTypesIew != nil {
		t := *r.contentTypesIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__iew", t, "multi")
		}
	}
	if r.contentTypesIre != nil {
		t := *r.contentTypesIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__ire", t, "multi")
		}
	}
	if r.contentTypesIsw != nil {
		t := *r.contentTypesIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__isw", t, "multi")
		}
	}
	if r.contentTypesN != nil {
		t := *r.contentTypesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__n", t, "multi")
		}
	}
	if r.contentTypesNic != nil {
		t := *r.contentTypesNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nic", t, "multi")
		}
	}
	if r.contentTypesNie != nil {
		t := *r.contentTypesNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nie", t, "multi")
		}
	}
	if r.contentTypesNiew != nil {
		t := *r.contentTypesNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__niew", t, "multi")
		}
	}
	if r.contentTypesNire != nil {
		t := *r.contentTypesNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nire", t, "multi")
		}
	}
	if r.contentTypesNisw != nil {
		t := *r.contentTypesNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nisw", t, "multi")
		}
	}
	if r.contentTypesNre != nil {
		t := *r.contentTypesNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__nre", t, "multi")
		}
	}
	if r.contentTypesRe != nil {
		t := *r.contentTypesRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_types__re", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.nestable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nestable", r.nestable, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "multi")
		}
	}
	if r.parentIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent__isnull", r.parentIsnull, "")
	}
	if r.parentN != nil {
		t := *r.parentN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationTypesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimLocationTypesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimLocationTypesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationTypesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimLocationTypesNotesCreateExecute(r)
}

/*
DcimLocationTypesNotesCreate Method for DcimLocationTypesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location type.
 @return ApiDcimLocationTypesNotesCreateRequest
*/
func (a *DcimAPIService) DcimLocationTypesNotesCreate(ctx context.Context, id string) ApiDcimLocationTypesNotesCreateRequest {
	return ApiDcimLocationTypesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimLocationTypesNotesCreateExecute(r ApiDcimLocationTypesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimLocationTypesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimLocationTypesNotesListRequest) Limit(limit int32) ApiDcimLocationTypesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimLocationTypesNotesListRequest) Offset(offset int32) ApiDcimLocationTypesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimLocationTypesNotesListRequest) Depth(depth int32) ApiDcimLocationTypesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimLocationTypesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimLocationTypesNotesListExecute(r)
}

/*
DcimLocationTypesNotesList Method for DcimLocationTypesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location type.
 @return ApiDcimLocationTypesNotesListRequest
*/
func (a *DcimAPIService) DcimLocationTypesNotesList(ctx context.Context, id string) ApiDcimLocationTypesNotesListRequest {
	return ApiDcimLocationTypesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimLocationTypesNotesListExecute(r ApiDcimLocationTypesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedLocationTypeRequest *PatchedLocationTypeRequest
}

func (r ApiDcimLocationTypesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationTypesPartialUpdateRequest) PatchedLocationTypeRequest(patchedLocationTypeRequest PatchedLocationTypeRequest) ApiDcimLocationTypesPartialUpdateRequest {
	r.patchedLocationTypeRequest = &patchedLocationTypeRequest
	return r
}

func (r ApiDcimLocationTypesPartialUpdateRequest) Execute() (*LocationType, *http.Response, error) {
	return r.ApiService.DcimLocationTypesPartialUpdateExecute(r)
}

/*
DcimLocationTypesPartialUpdate Method for DcimLocationTypesPartialUpdate

Partial update a location type object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location type.
 @return ApiDcimLocationTypesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimLocationTypesPartialUpdate(ctx context.Context, id string) ApiDcimLocationTypesPartialUpdateRequest {
	return ApiDcimLocationTypesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LocationType
func (a *DcimAPIService) DcimLocationTypesPartialUpdateExecute(r ApiDcimLocationTypesPartialUpdateRequest) (*LocationType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LocationType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedLocationTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimLocationTypesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimLocationTypesRetrieveRequest) Depth(depth int32) ApiDcimLocationTypesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimLocationTypesRetrieveRequest) Execute() (*LocationType, *http.Response, error) {
	return r.ApiService.DcimLocationTypesRetrieveExecute(r)
}

/*
DcimLocationTypesRetrieve Method for DcimLocationTypesRetrieve

Retrieve a location type object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location type.
 @return ApiDcimLocationTypesRetrieveRequest
*/
func (a *DcimAPIService) DcimLocationTypesRetrieve(ctx context.Context, id string) ApiDcimLocationTypesRetrieveRequest {
	return ApiDcimLocationTypesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LocationType
func (a *DcimAPIService) DcimLocationTypesRetrieveExecute(r ApiDcimLocationTypesRetrieveRequest) (*LocationType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LocationType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationTypesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	locationTypeRequest *LocationTypeRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationTypesUpdateRequest) LocationTypeRequest(locationTypeRequest LocationTypeRequest) ApiDcimLocationTypesUpdateRequest {
	r.locationTypeRequest = &locationTypeRequest
	return r
}

func (r ApiDcimLocationTypesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationTypesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationTypesUpdateRequest) Execute() (*LocationType, *http.Response, error) {
	return r.ApiService.DcimLocationTypesUpdateExecute(r)
}

/*
DcimLocationTypesUpdate Method for DcimLocationTypesUpdate

Update a location type object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location type.
 @return ApiDcimLocationTypesUpdateRequest
*/
func (a *DcimAPIService) DcimLocationTypesUpdate(ctx context.Context, id string) ApiDcimLocationTypesUpdateRequest {
	return ApiDcimLocationTypesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LocationType
func (a *DcimAPIService) DcimLocationTypesUpdateExecute(r ApiDcimLocationTypesUpdateRequest) (*LocationType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LocationType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationTypesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/location-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.locationTypeRequest == nil {
		return localVarReturnValue, nil, reportError("locationTypeRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.locationTypeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimLocationsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimLocationsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimLocationsBulkDestroyExecute(r)
}

/*
DcimLocationsBulkDestroy Method for DcimLocationsBulkDestroy

Destroy a list of location objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimLocationsBulkDestroy(ctx context.Context) ApiDcimLocationsBulkDestroyRequest {
	return ApiDcimLocationsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimLocationsBulkDestroyExecute(r ApiDcimLocationsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimLocationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableLocationRequest *[]PatchedBulkWritableLocationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationsBulkPartialUpdateRequest) PatchedBulkWritableLocationRequest(patchedBulkWritableLocationRequest []PatchedBulkWritableLocationRequest) ApiDcimLocationsBulkPartialUpdateRequest {
	r.patchedBulkWritableLocationRequest = &patchedBulkWritableLocationRequest
	return r
}

func (r ApiDcimLocationsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationsBulkPartialUpdateRequest) Execute() ([]Location, *http.Response, error) {
	return r.ApiService.DcimLocationsBulkPartialUpdateExecute(r)
}

/*
DcimLocationsBulkPartialUpdate Method for DcimLocationsBulkPartialUpdate

Partial update a list of location objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimLocationsBulkPartialUpdate(ctx context.Context) ApiDcimLocationsBulkPartialUpdateRequest {
	return ApiDcimLocationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Location
func (a *DcimAPIService) DcimLocationsBulkPartialUpdateExecute(r ApiDcimLocationsBulkPartialUpdateRequest) ([]Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableLocationRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableLocationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableLocationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableLocationRequest *[]BulkWritableLocationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationsBulkUpdateRequest) BulkWritableLocationRequest(bulkWritableLocationRequest []BulkWritableLocationRequest) ApiDcimLocationsBulkUpdateRequest {
	r.bulkWritableLocationRequest = &bulkWritableLocationRequest
	return r
}

func (r ApiDcimLocationsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationsBulkUpdateRequest) Execute() ([]Location, *http.Response, error) {
	return r.ApiService.DcimLocationsBulkUpdateExecute(r)
}

/*
DcimLocationsBulkUpdate Method for DcimLocationsBulkUpdate

Update a list of location objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimLocationsBulkUpdate(ctx context.Context) ApiDcimLocationsBulkUpdateRequest {
	return ApiDcimLocationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Location
func (a *DcimAPIService) DcimLocationsBulkUpdateExecute(r ApiDcimLocationsBulkUpdateRequest) ([]Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableLocationRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableLocationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableLocationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	locationRequest *LocationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationsCreateRequest) LocationRequest(locationRequest LocationRequest) ApiDcimLocationsCreateRequest {
	r.locationRequest = &locationRequest
	return r
}

func (r ApiDcimLocationsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationsCreateRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsCreateExecute(r)
}

/*
DcimLocationsCreate Method for DcimLocationsCreate

Create one or more location objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsCreateRequest
*/
func (a *DcimAPIService) DcimLocationsCreate(ctx context.Context) ApiDcimLocationsCreateRequest {
	return ApiDcimLocationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimAPIService) DcimLocationsCreateExecute(r ApiDcimLocationsCreateRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.locationRequest == nil {
		return localVarReturnValue, nil, reportError("locationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.locationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimLocationsDestroyExecute(r)
}

/*
DcimLocationsDestroy Method for DcimLocationsDestroy

Destroy a location object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location.
 @return ApiDcimLocationsDestroyRequest
*/
func (a *DcimAPIService) DcimLocationsDestroy(ctx context.Context, id string) ApiDcimLocationsDestroyRequest {
	return ApiDcimLocationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimLocationsDestroyExecute(r ApiDcimLocationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimLocationsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	asn *[]int32
	asnGt *[]int32
	asnGte *[]int32
	asnIsnull *bool
	asnLt *[]int32
	asnLte *[]int32
	asnN *[]int32
	childLocationType *[]string
	circuitTerminations *[]string
	circuitTerminationsIsnull *bool
	circuitTerminationsN *[]string
	clusters *[]string
	clustersIsnull *bool
	clustersN *[]string
	comments *[]string
	commentsIc *[]string
	commentsIe *[]string
	commentsIew *[]string
	commentsIre *[]string
	commentsIsw *[]string
	commentsN *[]string
	commentsNic *[]string
	commentsNie *[]string
	commentsNiew *[]string
	commentsNire *[]string
	commentsNisw *[]string
	commentsNre *[]string
	commentsRe *[]string
	contactEmail *[]string
	contactEmailIc *[]string
	contactEmailIe *[]string
	contactEmailIew *[]string
	contactEmailIre *[]string
	contactEmailIsw *[]string
	contactEmailN *[]string
	contactEmailNic *[]string
	contactEmailNie *[]string
	contactEmailNiew *[]string
	contactEmailNire *[]string
	contactEmailNisw *[]string
	contactEmailNre *[]string
	contactEmailRe *[]string
	contactName *[]string
	contactNameIc *[]string
	contactNameIe *[]string
	contactNameIew *[]string
	contactNameIre *[]string
	contactNameIsw *[]string
	contactNameN *[]string
	contactNameNic *[]string
	contactNameNie *[]string
	contactNameNiew *[]string
	contactNameNire *[]string
	contactNameNisw *[]string
	contactNameNre *[]string
	contactNameRe *[]string
	contactPhone *[]string
	contactPhoneIc *[]string
	contactPhoneIe *[]string
	contactPhoneIew *[]string
	contactPhoneIre *[]string
	contactPhoneIsw *[]string
	contactPhoneN *[]string
	contactPhoneNic *[]string
	contactPhoneNie *[]string
	contactPhoneNiew *[]string
	contactPhoneNire *[]string
	contactPhoneNisw *[]string
	contactPhoneNre *[]string
	contactPhoneRe *[]string
	contentType *[]int32
	contentTypeIc *[]int32
	contentTypeIe *[]int32
	contentTypeIew *[]int32
	contentTypeIre *[]int32
	contentTypeIsw *[]int32
	contentTypeN *[]int32
	contentTypeNic *[]int32
	contentTypeNie *[]int32
	contentTypeNiew *[]int32
	contentTypeNire *[]int32
	contentTypeNisw *[]int32
	contentTypeNre *[]int32
	contentTypeRe *[]int32
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	devices *[]string
	devicesIsnull *bool
	devicesN *[]string
	facility *[]string
	facilityIc *[]string
	facilityIe *[]string
	facilityIew *[]string
	facilityIre *[]string
	facilityIsw *[]string
	facilityN *[]string
	facilityNic *[]string
	facilityNie *[]string
	facilityNiew *[]string
	facilityNire *[]string
	facilityNisw *[]string
	facilityNre *[]string
	facilityRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasCircuitTerminations *bool
	hasClusters *bool
	hasDevices *bool
	hasPowerPanels *bool
	hasPrefixes *bool
	hasRackGroups *bool
	hasRacks *bool
	hasVlanGroups *bool
	hasVlans *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	latitude *[]float32
	latitudeGt *[]float32
	latitudeGte *[]float32
	latitudeIsnull *bool
	latitudeLt *[]float32
	latitudeLte *[]float32
	latitudeN *[]float32
	limit *int32
	locationType *[]string
	locationTypeN *[]string
	longitude *[]float32
	longitudeGt *[]float32
	longitudeGte *[]float32
	longitudeIsnull *bool
	longitudeLt *[]float32
	longitudeLte *[]float32
	longitudeN *[]float32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	parent *[]string
	parentIsnull *bool
	parentN *[]string
	physicalAddress *[]string
	physicalAddressIc *[]string
	physicalAddressIe *[]string
	physicalAddressIew *[]string
	physicalAddressIre *[]string
	physicalAddressIsw *[]string
	physicalAddressN *[]string
	physicalAddressNic *[]string
	physicalAddressNie *[]string
	physicalAddressNiew *[]string
	physicalAddressNire *[]string
	physicalAddressNisw *[]string
	physicalAddressNre *[]string
	physicalAddressRe *[]string
	powerPanels *[]string
	powerPanelsIsnull *bool
	powerPanelsN *[]string
	prefixes *[]string
	prefixesIsnull *bool
	prefixesN *[]string
	q *string
	rackGroups *[]string
	rackGroupsIsnull *bool
	rackGroupsN *[]string
	racks *[]string
	racksIsnull *bool
	racksN *[]string
	shippingAddress *[]string
	shippingAddressIc *[]string
	shippingAddressIe *[]string
	shippingAddressIew *[]string
	shippingAddressIre *[]string
	shippingAddressIsw *[]string
	shippingAddressN *[]string
	shippingAddressNic *[]string
	shippingAddressNie *[]string
	shippingAddressNiew *[]string
	shippingAddressNire *[]string
	shippingAddressNisw *[]string
	shippingAddressNre *[]string
	shippingAddressRe *[]string
	sort *string
	status *[]string
	statusN *[]string
	subtree *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	timeZone *[]DcimLocationsListTimeZoneParameterInner
	timeZoneIc *[]DcimLocationsListTimeZoneParameterInner
	timeZoneIe *[]DcimLocationsListTimeZoneParameterInner
	timeZoneIew *[]DcimLocationsListTimeZoneParameterInner
	timeZoneIre *[]DcimLocationsListTimeZoneParameterInner
	timeZoneIsw *[]DcimLocationsListTimeZoneParameterInner
	timeZoneN *[]DcimLocationsListTimeZoneParameterInner
	timeZoneNic *[]DcimLocationsListTimeZoneParameterInner
	timeZoneNie *[]DcimLocationsListTimeZoneParameterInner
	timeZoneNiew *[]DcimLocationsListTimeZoneParameterInner
	timeZoneNire *[]DcimLocationsListTimeZoneParameterInner
	timeZoneNisw *[]DcimLocationsListTimeZoneParameterInner
	timeZoneNre *[]DcimLocationsListTimeZoneParameterInner
	timeZoneRe *[]DcimLocationsListTimeZoneParameterInner
	vlanGroups *[]string
	vlanGroupsIsnull *bool
	vlanGroupsN *[]string
	vlans *[]string
	vlansIsnull *bool
	vlansN *[]string
	depth *int32
}

func (r ApiDcimLocationsListRequest) Asn(asn []int32) ApiDcimLocationsListRequest {
	r.asn = &asn
	return r
}

func (r ApiDcimLocationsListRequest) AsnGt(asnGt []int32) ApiDcimLocationsListRequest {
	r.asnGt = &asnGt
	return r
}

func (r ApiDcimLocationsListRequest) AsnGte(asnGte []int32) ApiDcimLocationsListRequest {
	r.asnGte = &asnGte
	return r
}

func (r ApiDcimLocationsListRequest) AsnIsnull(asnIsnull bool) ApiDcimLocationsListRequest {
	r.asnIsnull = &asnIsnull
	return r
}

func (r ApiDcimLocationsListRequest) AsnLt(asnLt []int32) ApiDcimLocationsListRequest {
	r.asnLt = &asnLt
	return r
}

func (r ApiDcimLocationsListRequest) AsnLte(asnLte []int32) ApiDcimLocationsListRequest {
	r.asnLte = &asnLte
	return r
}

func (r ApiDcimLocationsListRequest) AsnN(asnN []int32) ApiDcimLocationsListRequest {
	r.asnN = &asnN
	return r
}

func (r ApiDcimLocationsListRequest) ChildLocationType(childLocationType []string) ApiDcimLocationsListRequest {
	r.childLocationType = &childLocationType
	return r
}

func (r ApiDcimLocationsListRequest) CircuitTerminations(circuitTerminations []string) ApiDcimLocationsListRequest {
	r.circuitTerminations = &circuitTerminations
	return r
}

func (r ApiDcimLocationsListRequest) CircuitTerminationsIsnull(circuitTerminationsIsnull bool) ApiDcimLocationsListRequest {
	r.circuitTerminationsIsnull = &circuitTerminationsIsnull
	return r
}

func (r ApiDcimLocationsListRequest) CircuitTerminationsN(circuitTerminationsN []string) ApiDcimLocationsListRequest {
	r.circuitTerminationsN = &circuitTerminationsN
	return r
}

func (r ApiDcimLocationsListRequest) Clusters(clusters []string) ApiDcimLocationsListRequest {
	r.clusters = &clusters
	return r
}

func (r ApiDcimLocationsListRequest) ClustersIsnull(clustersIsnull bool) ApiDcimLocationsListRequest {
	r.clustersIsnull = &clustersIsnull
	return r
}

func (r ApiDcimLocationsListRequest) ClustersN(clustersN []string) ApiDcimLocationsListRequest {
	r.clustersN = &clustersN
	return r
}

func (r ApiDcimLocationsListRequest) Comments(comments []string) ApiDcimLocationsListRequest {
	r.comments = &comments
	return r
}

func (r ApiDcimLocationsListRequest) CommentsIc(commentsIc []string) ApiDcimLocationsListRequest {
	r.commentsIc = &commentsIc
	return r
}

func (r ApiDcimLocationsListRequest) CommentsIe(commentsIe []string) ApiDcimLocationsListRequest {
	r.commentsIe = &commentsIe
	return r
}

func (r ApiDcimLocationsListRequest) CommentsIew(commentsIew []string) ApiDcimLocationsListRequest {
	r.commentsIew = &commentsIew
	return r
}

func (r ApiDcimLocationsListRequest) CommentsIre(commentsIre []string) ApiDcimLocationsListRequest {
	r.commentsIre = &commentsIre
	return r
}

func (r ApiDcimLocationsListRequest) CommentsIsw(commentsIsw []string) ApiDcimLocationsListRequest {
	r.commentsIsw = &commentsIsw
	return r
}

func (r ApiDcimLocationsListRequest) CommentsN(commentsN []string) ApiDcimLocationsListRequest {
	r.commentsN = &commentsN
	return r
}

func (r ApiDcimLocationsListRequest) CommentsNic(commentsNic []string) ApiDcimLocationsListRequest {
	r.commentsNic = &commentsNic
	return r
}

func (r ApiDcimLocationsListRequest) CommentsNie(commentsNie []string) ApiDcimLocationsListRequest {
	r.commentsNie = &commentsNie
	return r
}

func (r ApiDcimLocationsListRequest) CommentsNiew(commentsNiew []string) ApiDcimLocationsListRequest {
	r.commentsNiew = &commentsNiew
	return r
}

func (r ApiDcimLocationsListRequest) CommentsNire(commentsNire []string) ApiDcimLocationsListRequest {
	r.commentsNire = &commentsNire
	return r
}

func (r ApiDcimLocationsListRequest) CommentsNisw(commentsNisw []string) ApiDcimLocationsListRequest {
	r.commentsNisw = &commentsNisw
	return r
}

func (r ApiDcimLocationsListRequest) CommentsNre(commentsNre []string) ApiDcimLocationsListRequest {
	r.commentsNre = &commentsNre
	return r
}

func (r ApiDcimLocationsListRequest) CommentsRe(commentsRe []string) ApiDcimLocationsListRequest {
	r.commentsRe = &commentsRe
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmail(contactEmail []string) ApiDcimLocationsListRequest {
	r.contactEmail = &contactEmail
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailIc(contactEmailIc []string) ApiDcimLocationsListRequest {
	r.contactEmailIc = &contactEmailIc
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailIe(contactEmailIe []string) ApiDcimLocationsListRequest {
	r.contactEmailIe = &contactEmailIe
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailIew(contactEmailIew []string) ApiDcimLocationsListRequest {
	r.contactEmailIew = &contactEmailIew
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailIre(contactEmailIre []string) ApiDcimLocationsListRequest {
	r.contactEmailIre = &contactEmailIre
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailIsw(contactEmailIsw []string) ApiDcimLocationsListRequest {
	r.contactEmailIsw = &contactEmailIsw
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailN(contactEmailN []string) ApiDcimLocationsListRequest {
	r.contactEmailN = &contactEmailN
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailNic(contactEmailNic []string) ApiDcimLocationsListRequest {
	r.contactEmailNic = &contactEmailNic
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailNie(contactEmailNie []string) ApiDcimLocationsListRequest {
	r.contactEmailNie = &contactEmailNie
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailNiew(contactEmailNiew []string) ApiDcimLocationsListRequest {
	r.contactEmailNiew = &contactEmailNiew
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailNire(contactEmailNire []string) ApiDcimLocationsListRequest {
	r.contactEmailNire = &contactEmailNire
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailNisw(contactEmailNisw []string) ApiDcimLocationsListRequest {
	r.contactEmailNisw = &contactEmailNisw
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailNre(contactEmailNre []string) ApiDcimLocationsListRequest {
	r.contactEmailNre = &contactEmailNre
	return r
}

func (r ApiDcimLocationsListRequest) ContactEmailRe(contactEmailRe []string) ApiDcimLocationsListRequest {
	r.contactEmailRe = &contactEmailRe
	return r
}

func (r ApiDcimLocationsListRequest) ContactName(contactName []string) ApiDcimLocationsListRequest {
	r.contactName = &contactName
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameIc(contactNameIc []string) ApiDcimLocationsListRequest {
	r.contactNameIc = &contactNameIc
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameIe(contactNameIe []string) ApiDcimLocationsListRequest {
	r.contactNameIe = &contactNameIe
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameIew(contactNameIew []string) ApiDcimLocationsListRequest {
	r.contactNameIew = &contactNameIew
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameIre(contactNameIre []string) ApiDcimLocationsListRequest {
	r.contactNameIre = &contactNameIre
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameIsw(contactNameIsw []string) ApiDcimLocationsListRequest {
	r.contactNameIsw = &contactNameIsw
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameN(contactNameN []string) ApiDcimLocationsListRequest {
	r.contactNameN = &contactNameN
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameNic(contactNameNic []string) ApiDcimLocationsListRequest {
	r.contactNameNic = &contactNameNic
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameNie(contactNameNie []string) ApiDcimLocationsListRequest {
	r.contactNameNie = &contactNameNie
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameNiew(contactNameNiew []string) ApiDcimLocationsListRequest {
	r.contactNameNiew = &contactNameNiew
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameNire(contactNameNire []string) ApiDcimLocationsListRequest {
	r.contactNameNire = &contactNameNire
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameNisw(contactNameNisw []string) ApiDcimLocationsListRequest {
	r.contactNameNisw = &contactNameNisw
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameNre(contactNameNre []string) ApiDcimLocationsListRequest {
	r.contactNameNre = &contactNameNre
	return r
}

func (r ApiDcimLocationsListRequest) ContactNameRe(contactNameRe []string) ApiDcimLocationsListRequest {
	r.contactNameRe = &contactNameRe
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhone(contactPhone []string) ApiDcimLocationsListRequest {
	r.contactPhone = &contactPhone
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneIc(contactPhoneIc []string) ApiDcimLocationsListRequest {
	r.contactPhoneIc = &contactPhoneIc
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneIe(contactPhoneIe []string) ApiDcimLocationsListRequest {
	r.contactPhoneIe = &contactPhoneIe
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneIew(contactPhoneIew []string) ApiDcimLocationsListRequest {
	r.contactPhoneIew = &contactPhoneIew
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneIre(contactPhoneIre []string) ApiDcimLocationsListRequest {
	r.contactPhoneIre = &contactPhoneIre
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneIsw(contactPhoneIsw []string) ApiDcimLocationsListRequest {
	r.contactPhoneIsw = &contactPhoneIsw
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneN(contactPhoneN []string) ApiDcimLocationsListRequest {
	r.contactPhoneN = &contactPhoneN
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneNic(contactPhoneNic []string) ApiDcimLocationsListRequest {
	r.contactPhoneNic = &contactPhoneNic
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneNie(contactPhoneNie []string) ApiDcimLocationsListRequest {
	r.contactPhoneNie = &contactPhoneNie
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneNiew(contactPhoneNiew []string) ApiDcimLocationsListRequest {
	r.contactPhoneNiew = &contactPhoneNiew
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneNire(contactPhoneNire []string) ApiDcimLocationsListRequest {
	r.contactPhoneNire = &contactPhoneNire
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneNisw(contactPhoneNisw []string) ApiDcimLocationsListRequest {
	r.contactPhoneNisw = &contactPhoneNisw
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneNre(contactPhoneNre []string) ApiDcimLocationsListRequest {
	r.contactPhoneNre = &contactPhoneNre
	return r
}

func (r ApiDcimLocationsListRequest) ContactPhoneRe(contactPhoneRe []string) ApiDcimLocationsListRequest {
	r.contactPhoneRe = &contactPhoneRe
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentType(contentType []int32) ApiDcimLocationsListRequest {
	r.contentType = &contentType
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeIc(contentTypeIc []int32) ApiDcimLocationsListRequest {
	r.contentTypeIc = &contentTypeIc
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeIe(contentTypeIe []int32) ApiDcimLocationsListRequest {
	r.contentTypeIe = &contentTypeIe
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeIew(contentTypeIew []int32) ApiDcimLocationsListRequest {
	r.contentTypeIew = &contentTypeIew
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeIre(contentTypeIre []int32) ApiDcimLocationsListRequest {
	r.contentTypeIre = &contentTypeIre
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeIsw(contentTypeIsw []int32) ApiDcimLocationsListRequest {
	r.contentTypeIsw = &contentTypeIsw
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeN(contentTypeN []int32) ApiDcimLocationsListRequest {
	r.contentTypeN = &contentTypeN
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeNic(contentTypeNic []int32) ApiDcimLocationsListRequest {
	r.contentTypeNic = &contentTypeNic
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeNie(contentTypeNie []int32) ApiDcimLocationsListRequest {
	r.contentTypeNie = &contentTypeNie
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeNiew(contentTypeNiew []int32) ApiDcimLocationsListRequest {
	r.contentTypeNiew = &contentTypeNiew
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeNire(contentTypeNire []int32) ApiDcimLocationsListRequest {
	r.contentTypeNire = &contentTypeNire
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeNisw(contentTypeNisw []int32) ApiDcimLocationsListRequest {
	r.contentTypeNisw = &contentTypeNisw
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeNre(contentTypeNre []int32) ApiDcimLocationsListRequest {
	r.contentTypeNre = &contentTypeNre
	return r
}

// Object types allowed to be associated with this Location Type
func (r ApiDcimLocationsListRequest) ContentTypeRe(contentTypeRe []int32) ApiDcimLocationsListRequest {
	r.contentTypeRe = &contentTypeRe
	return r
}

func (r ApiDcimLocationsListRequest) Created(created []time.Time) ApiDcimLocationsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimLocationsListRequest) CreatedGt(createdGt []time.Time) ApiDcimLocationsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimLocationsListRequest) CreatedGte(createdGte []time.Time) ApiDcimLocationsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimLocationsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimLocationsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimLocationsListRequest) CreatedLt(createdLt []time.Time) ApiDcimLocationsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimLocationsListRequest) CreatedLte(createdLte []time.Time) ApiDcimLocationsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimLocationsListRequest) CreatedN(createdN []time.Time) ApiDcimLocationsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimLocationsListRequest) Description(description []string) ApiDcimLocationsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIc(descriptionIc []string) ApiDcimLocationsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIe(descriptionIe []string) ApiDcimLocationsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIew(descriptionIew []string) ApiDcimLocationsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIre(descriptionIre []string) ApiDcimLocationsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimLocationsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionN(descriptionN []string) ApiDcimLocationsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNic(descriptionNic []string) ApiDcimLocationsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNie(descriptionNie []string) ApiDcimLocationsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimLocationsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNire(descriptionNire []string) ApiDcimLocationsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimLocationsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionNre(descriptionNre []string) ApiDcimLocationsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimLocationsListRequest) DescriptionRe(descriptionRe []string) ApiDcimLocationsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimLocationsListRequest) Devices(devices []string) ApiDcimLocationsListRequest {
	r.devices = &devices
	return r
}

func (r ApiDcimLocationsListRequest) DevicesIsnull(devicesIsnull bool) ApiDcimLocationsListRequest {
	r.devicesIsnull = &devicesIsnull
	return r
}

func (r ApiDcimLocationsListRequest) DevicesN(devicesN []string) ApiDcimLocationsListRequest {
	r.devicesN = &devicesN
	return r
}

func (r ApiDcimLocationsListRequest) Facility(facility []string) ApiDcimLocationsListRequest {
	r.facility = &facility
	return r
}

func (r ApiDcimLocationsListRequest) FacilityIc(facilityIc []string) ApiDcimLocationsListRequest {
	r.facilityIc = &facilityIc
	return r
}

func (r ApiDcimLocationsListRequest) FacilityIe(facilityIe []string) ApiDcimLocationsListRequest {
	r.facilityIe = &facilityIe
	return r
}

func (r ApiDcimLocationsListRequest) FacilityIew(facilityIew []string) ApiDcimLocationsListRequest {
	r.facilityIew = &facilityIew
	return r
}

func (r ApiDcimLocationsListRequest) FacilityIre(facilityIre []string) ApiDcimLocationsListRequest {
	r.facilityIre = &facilityIre
	return r
}

func (r ApiDcimLocationsListRequest) FacilityIsw(facilityIsw []string) ApiDcimLocationsListRequest {
	r.facilityIsw = &facilityIsw
	return r
}

func (r ApiDcimLocationsListRequest) FacilityN(facilityN []string) ApiDcimLocationsListRequest {
	r.facilityN = &facilityN
	return r
}

func (r ApiDcimLocationsListRequest) FacilityNic(facilityNic []string) ApiDcimLocationsListRequest {
	r.facilityNic = &facilityNic
	return r
}

func (r ApiDcimLocationsListRequest) FacilityNie(facilityNie []string) ApiDcimLocationsListRequest {
	r.facilityNie = &facilityNie
	return r
}

func (r ApiDcimLocationsListRequest) FacilityNiew(facilityNiew []string) ApiDcimLocationsListRequest {
	r.facilityNiew = &facilityNiew
	return r
}

func (r ApiDcimLocationsListRequest) FacilityNire(facilityNire []string) ApiDcimLocationsListRequest {
	r.facilityNire = &facilityNire
	return r
}

func (r ApiDcimLocationsListRequest) FacilityNisw(facilityNisw []string) ApiDcimLocationsListRequest {
	r.facilityNisw = &facilityNisw
	return r
}

func (r ApiDcimLocationsListRequest) FacilityNre(facilityNre []string) ApiDcimLocationsListRequest {
	r.facilityNre = &facilityNre
	return r
}

func (r ApiDcimLocationsListRequest) FacilityRe(facilityRe []string) ApiDcimLocationsListRequest {
	r.facilityRe = &facilityRe
	return r
}

func (r ApiDcimLocationsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsListRequest {
	r.format = &format
	return r
}

// Has circuit terminations
func (r ApiDcimLocationsListRequest) HasCircuitTerminations(hasCircuitTerminations bool) ApiDcimLocationsListRequest {
	r.hasCircuitTerminations = &hasCircuitTerminations
	return r
}

// Has clusters
func (r ApiDcimLocationsListRequest) HasClusters(hasClusters bool) ApiDcimLocationsListRequest {
	r.hasClusters = &hasClusters
	return r
}

// Has devices
func (r ApiDcimLocationsListRequest) HasDevices(hasDevices bool) ApiDcimLocationsListRequest {
	r.hasDevices = &hasDevices
	return r
}

// Has power panels
func (r ApiDcimLocationsListRequest) HasPowerPanels(hasPowerPanels bool) ApiDcimLocationsListRequest {
	r.hasPowerPanels = &hasPowerPanels
	return r
}

// Has prefixes
func (r ApiDcimLocationsListRequest) HasPrefixes(hasPrefixes bool) ApiDcimLocationsListRequest {
	r.hasPrefixes = &hasPrefixes
	return r
}

// Has rack groups
func (r ApiDcimLocationsListRequest) HasRackGroups(hasRackGroups bool) ApiDcimLocationsListRequest {
	r.hasRackGroups = &hasRackGroups
	return r
}

// Has racks
func (r ApiDcimLocationsListRequest) HasRacks(hasRacks bool) ApiDcimLocationsListRequest {
	r.hasRacks = &hasRacks
	return r
}

// Has VLAN groups
func (r ApiDcimLocationsListRequest) HasVlanGroups(hasVlanGroups bool) ApiDcimLocationsListRequest {
	r.hasVlanGroups = &hasVlanGroups
	return r
}

// Has VLANs
func (r ApiDcimLocationsListRequest) HasVlans(hasVlans bool) ApiDcimLocationsListRequest {
	r.hasVlans = &hasVlans
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimLocationsListRequest) Id(id []string) ApiDcimLocationsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimLocationsListRequest) IdIc(idIc []string) ApiDcimLocationsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimLocationsListRequest) IdIe(idIe []string) ApiDcimLocationsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimLocationsListRequest) IdIew(idIew []string) ApiDcimLocationsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimLocationsListRequest) IdIre(idIre []string) ApiDcimLocationsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimLocationsListRequest) IdIsw(idIsw []string) ApiDcimLocationsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimLocationsListRequest) IdN(idN []string) ApiDcimLocationsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimLocationsListRequest) IdNic(idNic []string) ApiDcimLocationsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimLocationsListRequest) IdNie(idNie []string) ApiDcimLocationsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimLocationsListRequest) IdNiew(idNiew []string) ApiDcimLocationsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimLocationsListRequest) IdNire(idNire []string) ApiDcimLocationsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimLocationsListRequest) IdNisw(idNisw []string) ApiDcimLocationsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimLocationsListRequest) IdNre(idNre []string) ApiDcimLocationsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimLocationsListRequest) IdRe(idRe []string) ApiDcimLocationsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimLocationsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimLocationsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimLocationsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimLocationsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimLocationsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimLocationsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimLocationsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimLocationsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

func (r ApiDcimLocationsListRequest) Latitude(latitude []float32) ApiDcimLocationsListRequest {
	r.latitude = &latitude
	return r
}

func (r ApiDcimLocationsListRequest) LatitudeGt(latitudeGt []float32) ApiDcimLocationsListRequest {
	r.latitudeGt = &latitudeGt
	return r
}

func (r ApiDcimLocationsListRequest) LatitudeGte(latitudeGte []float32) ApiDcimLocationsListRequest {
	r.latitudeGte = &latitudeGte
	return r
}

func (r ApiDcimLocationsListRequest) LatitudeIsnull(latitudeIsnull bool) ApiDcimLocationsListRequest {
	r.latitudeIsnull = &latitudeIsnull
	return r
}

func (r ApiDcimLocationsListRequest) LatitudeLt(latitudeLt []float32) ApiDcimLocationsListRequest {
	r.latitudeLt = &latitudeLt
	return r
}

func (r ApiDcimLocationsListRequest) LatitudeLte(latitudeLte []float32) ApiDcimLocationsListRequest {
	r.latitudeLte = &latitudeLte
	return r
}

func (r ApiDcimLocationsListRequest) LatitudeN(latitudeN []float32) ApiDcimLocationsListRequest {
	r.latitudeN = &latitudeN
	return r
}

// Number of results to return per page.
func (r ApiDcimLocationsListRequest) Limit(limit int32) ApiDcimLocationsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimLocationsListRequest) LocationType(locationType []string) ApiDcimLocationsListRequest {
	r.locationType = &locationType
	return r
}

func (r ApiDcimLocationsListRequest) LocationTypeN(locationTypeN []string) ApiDcimLocationsListRequest {
	r.locationTypeN = &locationTypeN
	return r
}

func (r ApiDcimLocationsListRequest) Longitude(longitude []float32) ApiDcimLocationsListRequest {
	r.longitude = &longitude
	return r
}

func (r ApiDcimLocationsListRequest) LongitudeGt(longitudeGt []float32) ApiDcimLocationsListRequest {
	r.longitudeGt = &longitudeGt
	return r
}

func (r ApiDcimLocationsListRequest) LongitudeGte(longitudeGte []float32) ApiDcimLocationsListRequest {
	r.longitudeGte = &longitudeGte
	return r
}

func (r ApiDcimLocationsListRequest) LongitudeIsnull(longitudeIsnull bool) ApiDcimLocationsListRequest {
	r.longitudeIsnull = &longitudeIsnull
	return r
}

func (r ApiDcimLocationsListRequest) LongitudeLt(longitudeLt []float32) ApiDcimLocationsListRequest {
	r.longitudeLt = &longitudeLt
	return r
}

func (r ApiDcimLocationsListRequest) LongitudeLte(longitudeLte []float32) ApiDcimLocationsListRequest {
	r.longitudeLte = &longitudeLte
	return r
}

func (r ApiDcimLocationsListRequest) LongitudeN(longitudeN []float32) ApiDcimLocationsListRequest {
	r.longitudeN = &longitudeN
	return r
}

func (r ApiDcimLocationsListRequest) Name(name []string) ApiDcimLocationsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimLocationsListRequest) NameIc(nameIc []string) ApiDcimLocationsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimLocationsListRequest) NameIe(nameIe []string) ApiDcimLocationsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimLocationsListRequest) NameIew(nameIew []string) ApiDcimLocationsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimLocationsListRequest) NameIre(nameIre []string) ApiDcimLocationsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimLocationsListRequest) NameIsw(nameIsw []string) ApiDcimLocationsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimLocationsListRequest) NameN(nameN []string) ApiDcimLocationsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimLocationsListRequest) NameNic(nameNic []string) ApiDcimLocationsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimLocationsListRequest) NameNie(nameNie []string) ApiDcimLocationsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimLocationsListRequest) NameNiew(nameNiew []string) ApiDcimLocationsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimLocationsListRequest) NameNire(nameNire []string) ApiDcimLocationsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimLocationsListRequest) NameNisw(nameNisw []string) ApiDcimLocationsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimLocationsListRequest) NameNre(nameNre []string) ApiDcimLocationsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimLocationsListRequest) NameRe(nameRe []string) ApiDcimLocationsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimLocationsListRequest) Offset(offset int32) ApiDcimLocationsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimLocationsListRequest) Parent(parent []string) ApiDcimLocationsListRequest {
	r.parent = &parent
	return r
}

func (r ApiDcimLocationsListRequest) ParentIsnull(parentIsnull bool) ApiDcimLocationsListRequest {
	r.parentIsnull = &parentIsnull
	return r
}

func (r ApiDcimLocationsListRequest) ParentN(parentN []string) ApiDcimLocationsListRequest {
	r.parentN = &parentN
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddress(physicalAddress []string) ApiDcimLocationsListRequest {
	r.physicalAddress = &physicalAddress
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressIc(physicalAddressIc []string) ApiDcimLocationsListRequest {
	r.physicalAddressIc = &physicalAddressIc
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressIe(physicalAddressIe []string) ApiDcimLocationsListRequest {
	r.physicalAddressIe = &physicalAddressIe
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressIew(physicalAddressIew []string) ApiDcimLocationsListRequest {
	r.physicalAddressIew = &physicalAddressIew
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressIre(physicalAddressIre []string) ApiDcimLocationsListRequest {
	r.physicalAddressIre = &physicalAddressIre
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressIsw(physicalAddressIsw []string) ApiDcimLocationsListRequest {
	r.physicalAddressIsw = &physicalAddressIsw
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressN(physicalAddressN []string) ApiDcimLocationsListRequest {
	r.physicalAddressN = &physicalAddressN
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressNic(physicalAddressNic []string) ApiDcimLocationsListRequest {
	r.physicalAddressNic = &physicalAddressNic
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressNie(physicalAddressNie []string) ApiDcimLocationsListRequest {
	r.physicalAddressNie = &physicalAddressNie
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressNiew(physicalAddressNiew []string) ApiDcimLocationsListRequest {
	r.physicalAddressNiew = &physicalAddressNiew
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressNire(physicalAddressNire []string) ApiDcimLocationsListRequest {
	r.physicalAddressNire = &physicalAddressNire
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressNisw(physicalAddressNisw []string) ApiDcimLocationsListRequest {
	r.physicalAddressNisw = &physicalAddressNisw
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressNre(physicalAddressNre []string) ApiDcimLocationsListRequest {
	r.physicalAddressNre = &physicalAddressNre
	return r
}

func (r ApiDcimLocationsListRequest) PhysicalAddressRe(physicalAddressRe []string) ApiDcimLocationsListRequest {
	r.physicalAddressRe = &physicalAddressRe
	return r
}

func (r ApiDcimLocationsListRequest) PowerPanels(powerPanels []string) ApiDcimLocationsListRequest {
	r.powerPanels = &powerPanels
	return r
}

func (r ApiDcimLocationsListRequest) PowerPanelsIsnull(powerPanelsIsnull bool) ApiDcimLocationsListRequest {
	r.powerPanelsIsnull = &powerPanelsIsnull
	return r
}

func (r ApiDcimLocationsListRequest) PowerPanelsN(powerPanelsN []string) ApiDcimLocationsListRequest {
	r.powerPanelsN = &powerPanelsN
	return r
}

func (r ApiDcimLocationsListRequest) Prefixes(prefixes []string) ApiDcimLocationsListRequest {
	r.prefixes = &prefixes
	return r
}

func (r ApiDcimLocationsListRequest) PrefixesIsnull(prefixesIsnull bool) ApiDcimLocationsListRequest {
	r.prefixesIsnull = &prefixesIsnull
	return r
}

func (r ApiDcimLocationsListRequest) PrefixesN(prefixesN []string) ApiDcimLocationsListRequest {
	r.prefixesN = &prefixesN
	return r
}

// Search
func (r ApiDcimLocationsListRequest) Q(q string) ApiDcimLocationsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimLocationsListRequest) RackGroups(rackGroups []string) ApiDcimLocationsListRequest {
	r.rackGroups = &rackGroups
	return r
}

func (r ApiDcimLocationsListRequest) RackGroupsIsnull(rackGroupsIsnull bool) ApiDcimLocationsListRequest {
	r.rackGroupsIsnull = &rackGroupsIsnull
	return r
}

func (r ApiDcimLocationsListRequest) RackGroupsN(rackGroupsN []string) ApiDcimLocationsListRequest {
	r.rackGroupsN = &rackGroupsN
	return r
}

func (r ApiDcimLocationsListRequest) Racks(racks []string) ApiDcimLocationsListRequest {
	r.racks = &racks
	return r
}

func (r ApiDcimLocationsListRequest) RacksIsnull(racksIsnull bool) ApiDcimLocationsListRequest {
	r.racksIsnull = &racksIsnull
	return r
}

func (r ApiDcimLocationsListRequest) RacksN(racksN []string) ApiDcimLocationsListRequest {
	r.racksN = &racksN
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddress(shippingAddress []string) ApiDcimLocationsListRequest {
	r.shippingAddress = &shippingAddress
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressIc(shippingAddressIc []string) ApiDcimLocationsListRequest {
	r.shippingAddressIc = &shippingAddressIc
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressIe(shippingAddressIe []string) ApiDcimLocationsListRequest {
	r.shippingAddressIe = &shippingAddressIe
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressIew(shippingAddressIew []string) ApiDcimLocationsListRequest {
	r.shippingAddressIew = &shippingAddressIew
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressIre(shippingAddressIre []string) ApiDcimLocationsListRequest {
	r.shippingAddressIre = &shippingAddressIre
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressIsw(shippingAddressIsw []string) ApiDcimLocationsListRequest {
	r.shippingAddressIsw = &shippingAddressIsw
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressN(shippingAddressN []string) ApiDcimLocationsListRequest {
	r.shippingAddressN = &shippingAddressN
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressNic(shippingAddressNic []string) ApiDcimLocationsListRequest {
	r.shippingAddressNic = &shippingAddressNic
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressNie(shippingAddressNie []string) ApiDcimLocationsListRequest {
	r.shippingAddressNie = &shippingAddressNie
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressNiew(shippingAddressNiew []string) ApiDcimLocationsListRequest {
	r.shippingAddressNiew = &shippingAddressNiew
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressNire(shippingAddressNire []string) ApiDcimLocationsListRequest {
	r.shippingAddressNire = &shippingAddressNire
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressNisw(shippingAddressNisw []string) ApiDcimLocationsListRequest {
	r.shippingAddressNisw = &shippingAddressNisw
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressNre(shippingAddressNre []string) ApiDcimLocationsListRequest {
	r.shippingAddressNre = &shippingAddressNre
	return r
}

func (r ApiDcimLocationsListRequest) ShippingAddressRe(shippingAddressRe []string) ApiDcimLocationsListRequest {
	r.shippingAddressRe = &shippingAddressRe
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimLocationsListRequest) Sort(sort string) ApiDcimLocationsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimLocationsListRequest) Status(status []string) ApiDcimLocationsListRequest {
	r.status = &status
	return r
}

func (r ApiDcimLocationsListRequest) StatusN(statusN []string) ApiDcimLocationsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimLocationsListRequest) Subtree(subtree []string) ApiDcimLocationsListRequest {
	r.subtree = &subtree
	return r
}

func (r ApiDcimLocationsListRequest) Tags(tags []string) ApiDcimLocationsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimLocationsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimLocationsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimLocationsListRequest) TagsN(tagsN []string) ApiDcimLocationsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimLocationsListRequest) Tenant(tenant []string) ApiDcimLocationsListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimLocationsListRequest) TenantIsnull(tenantIsnull bool) ApiDcimLocationsListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiDcimLocationsListRequest) TenantN(tenantN []string) ApiDcimLocationsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimLocationsListRequest) TenantGroup(tenantGroup []string) ApiDcimLocationsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimLocationsListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiDcimLocationsListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiDcimLocationsListRequest) TenantGroupN(tenantGroupN []string) ApiDcimLocationsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimLocationsListRequest) TenantId(tenantId []*string) ApiDcimLocationsListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimLocationsListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiDcimLocationsListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimLocationsListRequest) TenantIdN(tenantIdN []*string) ApiDcimLocationsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZone(timeZone []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZone = &timeZone
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneIc(timeZoneIc []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneIc = &timeZoneIc
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneIe(timeZoneIe []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneIe = &timeZoneIe
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneIew(timeZoneIew []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneIew = &timeZoneIew
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneIre(timeZoneIre []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneIre = &timeZoneIre
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneIsw(timeZoneIsw []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneIsw = &timeZoneIsw
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneN(timeZoneN []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneN = &timeZoneN
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneNic(timeZoneNic []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneNic = &timeZoneNic
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneNie(timeZoneNie []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneNie = &timeZoneNie
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneNiew(timeZoneNiew []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneNiew = &timeZoneNiew
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneNire(timeZoneNire []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneNire = &timeZoneNire
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneNisw(timeZoneNisw []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneNisw = &timeZoneNisw
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneNre(timeZoneNre []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneNre = &timeZoneNre
	return r
}

// Time zone  
func (r ApiDcimLocationsListRequest) TimeZoneRe(timeZoneRe []DcimLocationsListTimeZoneParameterInner) ApiDcimLocationsListRequest {
	r.timeZoneRe = &timeZoneRe
	return r
}

func (r ApiDcimLocationsListRequest) VlanGroups(vlanGroups []string) ApiDcimLocationsListRequest {
	r.vlanGroups = &vlanGroups
	return r
}

func (r ApiDcimLocationsListRequest) VlanGroupsIsnull(vlanGroupsIsnull bool) ApiDcimLocationsListRequest {
	r.vlanGroupsIsnull = &vlanGroupsIsnull
	return r
}

func (r ApiDcimLocationsListRequest) VlanGroupsN(vlanGroupsN []string) ApiDcimLocationsListRequest {
	r.vlanGroupsN = &vlanGroupsN
	return r
}

func (r ApiDcimLocationsListRequest) Vlans(vlans []string) ApiDcimLocationsListRequest {
	r.vlans = &vlans
	return r
}

func (r ApiDcimLocationsListRequest) VlansIsnull(vlansIsnull bool) ApiDcimLocationsListRequest {
	r.vlansIsnull = &vlansIsnull
	return r
}

func (r ApiDcimLocationsListRequest) VlansN(vlansN []string) ApiDcimLocationsListRequest {
	r.vlansN = &vlansN
	return r
}

// Serializer Depth
func (r ApiDcimLocationsListRequest) Depth(depth int32) ApiDcimLocationsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimLocationsListRequest) Execute() (*PaginatedLocationList, *http.Response, error) {
	return r.ApiService.DcimLocationsListExecute(r)
}

/*
DcimLocationsList Method for DcimLocationsList

Retrieve a list of location objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimLocationsListRequest
*/
func (a *DcimAPIService) DcimLocationsList(ctx context.Context) ApiDcimLocationsListRequest {
	return ApiDcimLocationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedLocationList
func (a *DcimAPIService) DcimLocationsListExecute(r ApiDcimLocationsListRequest) (*PaginatedLocationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedLocationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asn != nil {
		t := *r.asn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn", t, "multi")
		}
	}
	if r.asnGt != nil {
		t := *r.asnGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gt", t, "multi")
		}
	}
	if r.asnGte != nil {
		t := *r.asnGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gte", t, "multi")
		}
	}
	if r.asnIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asn__isnull", r.asnIsnull, "")
	}
	if r.asnLt != nil {
		t := *r.asnLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lt", t, "multi")
		}
	}
	if r.asnLte != nil {
		t := *r.asnLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lte", t, "multi")
		}
	}
	if r.asnN != nil {
		t := *r.asnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__n", t, "multi")
		}
	}
	if r.childLocationType != nil {
		t := *r.childLocationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "child_location_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "child_location_type", t, "multi")
		}
	}
	if r.circuitTerminations != nil {
		t := *r.circuitTerminations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "circuit_terminations", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "circuit_terminations", t, "multi")
		}
	}
	if r.circuitTerminationsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "circuit_terminations__isnull", r.circuitTerminationsIsnull, "")
	}
	if r.circuitTerminationsN != nil {
		t := *r.circuitTerminationsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "circuit_terminations__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "circuit_terminations__n", t, "multi")
		}
	}
	if r.clusters != nil {
		t := *r.clusters
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "clusters", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "clusters", t, "multi")
		}
	}
	if r.clustersIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusters__isnull", r.clustersIsnull, "")
	}
	if r.clustersN != nil {
		t := *r.clustersN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "clusters__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "clusters__n", t, "multi")
		}
	}
	if r.comments != nil {
		t := *r.comments
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments", t, "multi")
		}
	}
	if r.commentsIc != nil {
		t := *r.commentsIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ic", t, "multi")
		}
	}
	if r.commentsIe != nil {
		t := *r.commentsIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ie", t, "multi")
		}
	}
	if r.commentsIew != nil {
		t := *r.commentsIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__iew", t, "multi")
		}
	}
	if r.commentsIre != nil {
		t := *r.commentsIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ire", t, "multi")
		}
	}
	if r.commentsIsw != nil {
		t := *r.commentsIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__isw", t, "multi")
		}
	}
	if r.commentsN != nil {
		t := *r.commentsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__n", t, "multi")
		}
	}
	if r.commentsNic != nil {
		t := *r.commentsNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nic", t, "multi")
		}
	}
	if r.commentsNie != nil {
		t := *r.commentsNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nie", t, "multi")
		}
	}
	if r.commentsNiew != nil {
		t := *r.commentsNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__niew", t, "multi")
		}
	}
	if r.commentsNire != nil {
		t := *r.commentsNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nire", t, "multi")
		}
	}
	if r.commentsNisw != nil {
		t := *r.commentsNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nisw", t, "multi")
		}
	}
	if r.commentsNre != nil {
		t := *r.commentsNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nre", t, "multi")
		}
	}
	if r.commentsRe != nil {
		t := *r.commentsRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__re", t, "multi")
		}
	}
	if r.contactEmail != nil {
		t := *r.contactEmail
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email", t, "multi")
		}
	}
	if r.contactEmailIc != nil {
		t := *r.contactEmailIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__ic", t, "multi")
		}
	}
	if r.contactEmailIe != nil {
		t := *r.contactEmailIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__ie", t, "multi")
		}
	}
	if r.contactEmailIew != nil {
		t := *r.contactEmailIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__iew", t, "multi")
		}
	}
	if r.contactEmailIre != nil {
		t := *r.contactEmailIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__ire", t, "multi")
		}
	}
	if r.contactEmailIsw != nil {
		t := *r.contactEmailIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__isw", t, "multi")
		}
	}
	if r.contactEmailN != nil {
		t := *r.contactEmailN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__n", t, "multi")
		}
	}
	if r.contactEmailNic != nil {
		t := *r.contactEmailNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nic", t, "multi")
		}
	}
	if r.contactEmailNie != nil {
		t := *r.contactEmailNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nie", t, "multi")
		}
	}
	if r.contactEmailNiew != nil {
		t := *r.contactEmailNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__niew", t, "multi")
		}
	}
	if r.contactEmailNire != nil {
		t := *r.contactEmailNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nire", t, "multi")
		}
	}
	if r.contactEmailNisw != nil {
		t := *r.contactEmailNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nisw", t, "multi")
		}
	}
	if r.contactEmailNre != nil {
		t := *r.contactEmailNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__nre", t, "multi")
		}
	}
	if r.contactEmailRe != nil {
		t := *r.contactEmailRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_email__re", t, "multi")
		}
	}
	if r.contactName != nil {
		t := *r.contactName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name", t, "multi")
		}
	}
	if r.contactNameIc != nil {
		t := *r.contactNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__ic", t, "multi")
		}
	}
	if r.contactNameIe != nil {
		t := *r.contactNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__ie", t, "multi")
		}
	}
	if r.contactNameIew != nil {
		t := *r.contactNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__iew", t, "multi")
		}
	}
	if r.contactNameIre != nil {
		t := *r.contactNameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__ire", t, "multi")
		}
	}
	if r.contactNameIsw != nil {
		t := *r.contactNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__isw", t, "multi")
		}
	}
	if r.contactNameN != nil {
		t := *r.contactNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__n", t, "multi")
		}
	}
	if r.contactNameNic != nil {
		t := *r.contactNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nic", t, "multi")
		}
	}
	if r.contactNameNie != nil {
		t := *r.contactNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nie", t, "multi")
		}
	}
	if r.contactNameNiew != nil {
		t := *r.contactNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__niew", t, "multi")
		}
	}
	if r.contactNameNire != nil {
		t := *r.contactNameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nire", t, "multi")
		}
	}
	if r.contactNameNisw != nil {
		t := *r.contactNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nisw", t, "multi")
		}
	}
	if r.contactNameNre != nil {
		t := *r.contactNameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__nre", t, "multi")
		}
	}
	if r.contactNameRe != nil {
		t := *r.contactNameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_name__re", t, "multi")
		}
	}
	if r.contactPhone != nil {
		t := *r.contactPhone
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone", t, "multi")
		}
	}
	if r.contactPhoneIc != nil {
		t := *r.contactPhoneIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__ic", t, "multi")
		}
	}
	if r.contactPhoneIe != nil {
		t := *r.contactPhoneIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__ie", t, "multi")
		}
	}
	if r.contactPhoneIew != nil {
		t := *r.contactPhoneIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__iew", t, "multi")
		}
	}
	if r.contactPhoneIre != nil {
		t := *r.contactPhoneIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__ire", t, "multi")
		}
	}
	if r.contactPhoneIsw != nil {
		t := *r.contactPhoneIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__isw", t, "multi")
		}
	}
	if r.contactPhoneN != nil {
		t := *r.contactPhoneN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__n", t, "multi")
		}
	}
	if r.contactPhoneNic != nil {
		t := *r.contactPhoneNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nic", t, "multi")
		}
	}
	if r.contactPhoneNie != nil {
		t := *r.contactPhoneNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nie", t, "multi")
		}
	}
	if r.contactPhoneNiew != nil {
		t := *r.contactPhoneNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__niew", t, "multi")
		}
	}
	if r.contactPhoneNire != nil {
		t := *r.contactPhoneNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nire", t, "multi")
		}
	}
	if r.contactPhoneNisw != nil {
		t := *r.contactPhoneNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nisw", t, "multi")
		}
	}
	if r.contactPhoneNre != nil {
		t := *r.contactPhoneNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__nre", t, "multi")
		}
	}
	if r.contactPhoneRe != nil {
		t := *r.contactPhoneRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_phone__re", t, "multi")
		}
	}
	if r.contentType != nil {
		t := *r.contentType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type", t, "multi")
		}
	}
	if r.contentTypeIc != nil {
		t := *r.contentTypeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__ic", t, "multi")
		}
	}
	if r.contentTypeIe != nil {
		t := *r.contentTypeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__ie", t, "multi")
		}
	}
	if r.contentTypeIew != nil {
		t := *r.contentTypeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__iew", t, "multi")
		}
	}
	if r.contentTypeIre != nil {
		t := *r.contentTypeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__ire", t, "multi")
		}
	}
	if r.contentTypeIsw != nil {
		t := *r.contentTypeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__isw", t, "multi")
		}
	}
	if r.contentTypeN != nil {
		t := *r.contentTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__n", t, "multi")
		}
	}
	if r.contentTypeNic != nil {
		t := *r.contentTypeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nic", t, "multi")
		}
	}
	if r.contentTypeNie != nil {
		t := *r.contentTypeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nie", t, "multi")
		}
	}
	if r.contentTypeNiew != nil {
		t := *r.contentTypeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__niew", t, "multi")
		}
	}
	if r.contentTypeNire != nil {
		t := *r.contentTypeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nire", t, "multi")
		}
	}
	if r.contentTypeNisw != nil {
		t := *r.contentTypeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nisw", t, "multi")
		}
	}
	if r.contentTypeNre != nil {
		t := *r.contentTypeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__nre", t, "multi")
		}
	}
	if r.contentTypeRe != nil {
		t := *r.contentTypeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "content_type__re", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices", t, "multi")
		}
	}
	if r.devicesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices__isnull", r.devicesIsnull, "")
	}
	if r.devicesN != nil {
		t := *r.devicesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", t, "multi")
		}
	}
	if r.facility != nil {
		t := *r.facility
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility", t, "multi")
		}
	}
	if r.facilityIc != nil {
		t := *r.facilityIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__ic", t, "multi")
		}
	}
	if r.facilityIe != nil {
		t := *r.facilityIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__ie", t, "multi")
		}
	}
	if r.facilityIew != nil {
		t := *r.facilityIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__iew", t, "multi")
		}
	}
	if r.facilityIre != nil {
		t := *r.facilityIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__ire", t, "multi")
		}
	}
	if r.facilityIsw != nil {
		t := *r.facilityIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__isw", t, "multi")
		}
	}
	if r.facilityN != nil {
		t := *r.facilityN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__n", t, "multi")
		}
	}
	if r.facilityNic != nil {
		t := *r.facilityNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nic", t, "multi")
		}
	}
	if r.facilityNie != nil {
		t := *r.facilityNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nie", t, "multi")
		}
	}
	if r.facilityNiew != nil {
		t := *r.facilityNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__niew", t, "multi")
		}
	}
	if r.facilityNire != nil {
		t := *r.facilityNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nire", t, "multi")
		}
	}
	if r.facilityNisw != nil {
		t := *r.facilityNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nisw", t, "multi")
		}
	}
	if r.facilityNre != nil {
		t := *r.facilityNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__nre", t, "multi")
		}
	}
	if r.facilityRe != nil {
		t := *r.facilityRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasCircuitTerminations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_circuit_terminations", r.hasCircuitTerminations, "")
	}
	if r.hasClusters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_clusters", r.hasClusters, "")
	}
	if r.hasDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_devices", r.hasDevices, "")
	}
	if r.hasPowerPanels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_panels", r.hasPowerPanels, "")
	}
	if r.hasPrefixes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_prefixes", r.hasPrefixes, "")
	}
	if r.hasRackGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_rack_groups", r.hasRackGroups, "")
	}
	if r.hasRacks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_racks", r.hasRacks, "")
	}
	if r.hasVlanGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_vlan_groups", r.hasVlanGroups, "")
	}
	if r.hasVlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_vlans", r.hasVlans, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.latitude != nil {
		t := *r.latitude
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", t, "multi")
		}
	}
	if r.latitudeGt != nil {
		t := *r.latitudeGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__gt", t, "multi")
		}
	}
	if r.latitudeGte != nil {
		t := *r.latitudeGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__gte", t, "multi")
		}
	}
	if r.latitudeIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__isnull", r.latitudeIsnull, "")
	}
	if r.latitudeLt != nil {
		t := *r.latitudeLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__lt", t, "multi")
		}
	}
	if r.latitudeLte != nil {
		t := *r.latitudeLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__lte", t, "multi")
		}
	}
	if r.latitudeN != nil {
		t := *r.latitudeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "latitude__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.locationType != nil {
		t := *r.locationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location_type", t, "multi")
		}
	}
	if r.locationTypeN != nil {
		t := *r.locationTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location_type__n", t, "multi")
		}
	}
	if r.longitude != nil {
		t := *r.longitude
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", t, "multi")
		}
	}
	if r.longitudeGt != nil {
		t := *r.longitudeGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__gt", t, "multi")
		}
	}
	if r.longitudeGte != nil {
		t := *r.longitudeGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__gte", t, "multi")
		}
	}
	if r.longitudeIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__isnull", r.longitudeIsnull, "")
	}
	if r.longitudeLt != nil {
		t := *r.longitudeLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__lt", t, "multi")
		}
	}
	if r.longitudeLte != nil {
		t := *r.longitudeLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__lte", t, "multi")
		}
	}
	if r.longitudeN != nil {
		t := *r.longitudeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "longitude__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "multi")
		}
	}
	if r.parentIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent__isnull", r.parentIsnull, "")
	}
	if r.parentN != nil {
		t := *r.parentN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", t, "multi")
		}
	}
	if r.physicalAddress != nil {
		t := *r.physicalAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address", t, "multi")
		}
	}
	if r.physicalAddressIc != nil {
		t := *r.physicalAddressIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__ic", t, "multi")
		}
	}
	if r.physicalAddressIe != nil {
		t := *r.physicalAddressIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__ie", t, "multi")
		}
	}
	if r.physicalAddressIew != nil {
		t := *r.physicalAddressIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__iew", t, "multi")
		}
	}
	if r.physicalAddressIre != nil {
		t := *r.physicalAddressIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__ire", t, "multi")
		}
	}
	if r.physicalAddressIsw != nil {
		t := *r.physicalAddressIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__isw", t, "multi")
		}
	}
	if r.physicalAddressN != nil {
		t := *r.physicalAddressN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__n", t, "multi")
		}
	}
	if r.physicalAddressNic != nil {
		t := *r.physicalAddressNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nic", t, "multi")
		}
	}
	if r.physicalAddressNie != nil {
		t := *r.physicalAddressNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nie", t, "multi")
		}
	}
	if r.physicalAddressNiew != nil {
		t := *r.physicalAddressNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__niew", t, "multi")
		}
	}
	if r.physicalAddressNire != nil {
		t := *r.physicalAddressNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nire", t, "multi")
		}
	}
	if r.physicalAddressNisw != nil {
		t := *r.physicalAddressNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nisw", t, "multi")
		}
	}
	if r.physicalAddressNre != nil {
		t := *r.physicalAddressNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__nre", t, "multi")
		}
	}
	if r.physicalAddressRe != nil {
		t := *r.physicalAddressRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "physical_address__re", t, "multi")
		}
	}
	if r.powerPanels != nil {
		t := *r.powerPanels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels", t, "multi")
		}
	}
	if r.powerPanelsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels__isnull", r.powerPanelsIsnull, "")
	}
	if r.powerPanelsN != nil {
		t := *r.powerPanelsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels__n", t, "multi")
		}
	}
	if r.prefixes != nil {
		t := *r.prefixes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefixes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefixes", t, "multi")
		}
	}
	if r.prefixesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefixes__isnull", r.prefixesIsnull, "")
	}
	if r.prefixesN != nil {
		t := *r.prefixesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefixes__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefixes__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rackGroups != nil {
		t := *r.rackGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_groups", t, "multi")
		}
	}
	if r.rackGroupsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack_groups__isnull", r.rackGroupsIsnull, "")
	}
	if r.rackGroupsN != nil {
		t := *r.rackGroupsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_groups__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_groups__n", t, "multi")
		}
	}
	if r.racks != nil {
		t := *r.racks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "racks", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "racks", t, "multi")
		}
	}
	if r.racksIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "racks__isnull", r.racksIsnull, "")
	}
	if r.racksN != nil {
		t := *r.racksN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "racks__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "racks__n", t, "multi")
		}
	}
	if r.shippingAddress != nil {
		t := *r.shippingAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address", t, "multi")
		}
	}
	if r.shippingAddressIc != nil {
		t := *r.shippingAddressIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__ic", t, "multi")
		}
	}
	if r.shippingAddressIe != nil {
		t := *r.shippingAddressIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__ie", t, "multi")
		}
	}
	if r.shippingAddressIew != nil {
		t := *r.shippingAddressIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__iew", t, "multi")
		}
	}
	if r.shippingAddressIre != nil {
		t := *r.shippingAddressIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__ire", t, "multi")
		}
	}
	if r.shippingAddressIsw != nil {
		t := *r.shippingAddressIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__isw", t, "multi")
		}
	}
	if r.shippingAddressN != nil {
		t := *r.shippingAddressN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__n", t, "multi")
		}
	}
	if r.shippingAddressNic != nil {
		t := *r.shippingAddressNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nic", t, "multi")
		}
	}
	if r.shippingAddressNie != nil {
		t := *r.shippingAddressNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nie", t, "multi")
		}
	}
	if r.shippingAddressNiew != nil {
		t := *r.shippingAddressNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__niew", t, "multi")
		}
	}
	if r.shippingAddressNire != nil {
		t := *r.shippingAddressNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nire", t, "multi")
		}
	}
	if r.shippingAddressNisw != nil {
		t := *r.shippingAddressNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nisw", t, "multi")
		}
	}
	if r.shippingAddressNre != nil {
		t := *r.shippingAddressNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__nre", t, "multi")
		}
	}
	if r.shippingAddressRe != nil {
		t := *r.shippingAddressRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_address__re", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.subtree != nil {
		t := *r.subtree
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subtree", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subtree", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.timeZone != nil {
		t := *r.timeZone
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone", t, "multi")
		}
	}
	if r.timeZoneIc != nil {
		t := *r.timeZoneIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__ic", t, "multi")
		}
	}
	if r.timeZoneIe != nil {
		t := *r.timeZoneIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__ie", t, "multi")
		}
	}
	if r.timeZoneIew != nil {
		t := *r.timeZoneIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__iew", t, "multi")
		}
	}
	if r.timeZoneIre != nil {
		t := *r.timeZoneIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__ire", t, "multi")
		}
	}
	if r.timeZoneIsw != nil {
		t := *r.timeZoneIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__isw", t, "multi")
		}
	}
	if r.timeZoneN != nil {
		t := *r.timeZoneN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__n", t, "multi")
		}
	}
	if r.timeZoneNic != nil {
		t := *r.timeZoneNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nic", t, "multi")
		}
	}
	if r.timeZoneNie != nil {
		t := *r.timeZoneNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nie", t, "multi")
		}
	}
	if r.timeZoneNiew != nil {
		t := *r.timeZoneNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__niew", t, "multi")
		}
	}
	if r.timeZoneNire != nil {
		t := *r.timeZoneNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nire", t, "multi")
		}
	}
	if r.timeZoneNisw != nil {
		t := *r.timeZoneNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nisw", t, "multi")
		}
	}
	if r.timeZoneNre != nil {
		t := *r.timeZoneNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__nre", t, "multi")
		}
	}
	if r.timeZoneRe != nil {
		t := *r.timeZoneRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "time_zone__re", t, "multi")
		}
	}
	if r.vlanGroups != nil {
		t := *r.vlanGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_groups", t, "multi")
		}
	}
	if r.vlanGroupsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_groups__isnull", r.vlanGroupsIsnull, "")
	}
	if r.vlanGroupsN != nil {
		t := *r.vlanGroupsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_groups__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_groups__n", t, "multi")
		}
	}
	if r.vlans != nil {
		t := *r.vlans
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlans", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlans", t, "multi")
		}
	}
	if r.vlansIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlans__isnull", r.vlansIsnull, "")
	}
	if r.vlansN != nil {
		t := *r.vlansN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlans__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlans__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimLocationsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimLocationsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimLocationsNotesCreateExecute(r)
}

/*
DcimLocationsNotesCreate Method for DcimLocationsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location.
 @return ApiDcimLocationsNotesCreateRequest
*/
func (a *DcimAPIService) DcimLocationsNotesCreate(ctx context.Context, id string) ApiDcimLocationsNotesCreateRequest {
	return ApiDcimLocationsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimLocationsNotesCreateExecute(r ApiDcimLocationsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimLocationsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimLocationsNotesListRequest) Limit(limit int32) ApiDcimLocationsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimLocationsNotesListRequest) Offset(offset int32) ApiDcimLocationsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimLocationsNotesListRequest) Depth(depth int32) ApiDcimLocationsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimLocationsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimLocationsNotesListExecute(r)
}

/*
DcimLocationsNotesList Method for DcimLocationsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location.
 @return ApiDcimLocationsNotesListRequest
*/
func (a *DcimAPIService) DcimLocationsNotesList(ctx context.Context, id string) ApiDcimLocationsNotesListRequest {
	return ApiDcimLocationsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimLocationsNotesListExecute(r ApiDcimLocationsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedLocationRequest *PatchedLocationRequest
}

func (r ApiDcimLocationsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationsPartialUpdateRequest) PatchedLocationRequest(patchedLocationRequest PatchedLocationRequest) ApiDcimLocationsPartialUpdateRequest {
	r.patchedLocationRequest = &patchedLocationRequest
	return r
}

func (r ApiDcimLocationsPartialUpdateRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsPartialUpdateExecute(r)
}

/*
DcimLocationsPartialUpdate Method for DcimLocationsPartialUpdate

Partial update a location object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location.
 @return ApiDcimLocationsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimLocationsPartialUpdate(ctx context.Context, id string) ApiDcimLocationsPartialUpdateRequest {
	return ApiDcimLocationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimAPIService) DcimLocationsPartialUpdateExecute(r ApiDcimLocationsPartialUpdateRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedLocationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimLocationsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimLocationsRetrieveRequest) Depth(depth int32) ApiDcimLocationsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimLocationsRetrieveRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsRetrieveExecute(r)
}

/*
DcimLocationsRetrieve Method for DcimLocationsRetrieve

Retrieve a location object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location.
 @return ApiDcimLocationsRetrieveRequest
*/
func (a *DcimAPIService) DcimLocationsRetrieve(ctx context.Context, id string) ApiDcimLocationsRetrieveRequest {
	return ApiDcimLocationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimAPIService) DcimLocationsRetrieveExecute(r ApiDcimLocationsRetrieveRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimLocationsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	locationRequest *LocationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimLocationsUpdateRequest) LocationRequest(locationRequest LocationRequest) ApiDcimLocationsUpdateRequest {
	r.locationRequest = &locationRequest
	return r
}

func (r ApiDcimLocationsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimLocationsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimLocationsUpdateRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DcimLocationsUpdateExecute(r)
}

/*
DcimLocationsUpdate Method for DcimLocationsUpdate

Update a location object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this location.
 @return ApiDcimLocationsUpdateRequest
*/
func (a *DcimAPIService) DcimLocationsUpdate(ctx context.Context, id string) ApiDcimLocationsUpdateRequest {
	return ApiDcimLocationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Location
func (a *DcimAPIService) DcimLocationsUpdateExecute(r ApiDcimLocationsUpdateRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimLocationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.locationRequest == nil {
		return localVarReturnValue, nil, reportError("locationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.locationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimManufacturersBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimManufacturersBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimManufacturersBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimManufacturersBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimManufacturersBulkDestroyExecute(r)
}

/*
DcimManufacturersBulkDestroy Method for DcimManufacturersBulkDestroy

Destroy a list of manufacturer objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersBulkDestroyRequest
*/
func (a *DcimAPIService) DcimManufacturersBulkDestroy(ctx context.Context) ApiDcimManufacturersBulkDestroyRequest {
	return ApiDcimManufacturersBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimManufacturersBulkDestroyExecute(r ApiDcimManufacturersBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimManufacturersBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableManufacturerRequest *[]PatchedBulkWritableManufacturerRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimManufacturersBulkPartialUpdateRequest) PatchedBulkWritableManufacturerRequest(patchedBulkWritableManufacturerRequest []PatchedBulkWritableManufacturerRequest) ApiDcimManufacturersBulkPartialUpdateRequest {
	r.patchedBulkWritableManufacturerRequest = &patchedBulkWritableManufacturerRequest
	return r
}

func (r ApiDcimManufacturersBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimManufacturersBulkPartialUpdateRequest) Execute() ([]Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersBulkPartialUpdateExecute(r)
}

/*
DcimManufacturersBulkPartialUpdate Method for DcimManufacturersBulkPartialUpdate

Partial update a list of manufacturer objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimManufacturersBulkPartialUpdate(ctx context.Context) ApiDcimManufacturersBulkPartialUpdateRequest {
	return ApiDcimManufacturersBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Manufacturer
func (a *DcimAPIService) DcimManufacturersBulkPartialUpdateExecute(r ApiDcimManufacturersBulkPartialUpdateRequest) ([]Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableManufacturerRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableManufacturerRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableManufacturerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableManufacturerRequest *[]BulkWritableManufacturerRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimManufacturersBulkUpdateRequest) BulkWritableManufacturerRequest(bulkWritableManufacturerRequest []BulkWritableManufacturerRequest) ApiDcimManufacturersBulkUpdateRequest {
	r.bulkWritableManufacturerRequest = &bulkWritableManufacturerRequest
	return r
}

func (r ApiDcimManufacturersBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimManufacturersBulkUpdateRequest) Execute() ([]Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersBulkUpdateExecute(r)
}

/*
DcimManufacturersBulkUpdate Method for DcimManufacturersBulkUpdate

Update a list of manufacturer objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersBulkUpdateRequest
*/
func (a *DcimAPIService) DcimManufacturersBulkUpdate(ctx context.Context) ApiDcimManufacturersBulkUpdateRequest {
	return ApiDcimManufacturersBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Manufacturer
func (a *DcimAPIService) DcimManufacturersBulkUpdateExecute(r ApiDcimManufacturersBulkUpdateRequest) ([]Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableManufacturerRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableManufacturerRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableManufacturerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	manufacturerRequest *ManufacturerRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimManufacturersCreateRequest) ManufacturerRequest(manufacturerRequest ManufacturerRequest) ApiDcimManufacturersCreateRequest {
	r.manufacturerRequest = &manufacturerRequest
	return r
}

func (r ApiDcimManufacturersCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimManufacturersCreateRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersCreateExecute(r)
}

/*
DcimManufacturersCreate Method for DcimManufacturersCreate

Create one or more manufacturer objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersCreateRequest
*/
func (a *DcimAPIService) DcimManufacturersCreate(ctx context.Context) ApiDcimManufacturersCreateRequest {
	return ApiDcimManufacturersCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimAPIService) DcimManufacturersCreateExecute(r ApiDcimManufacturersCreateRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.manufacturerRequest == nil {
		return localVarReturnValue, nil, reportError("manufacturerRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.manufacturerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimManufacturersDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimManufacturersDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimManufacturersDestroyExecute(r)
}

/*
DcimManufacturersDestroy Method for DcimManufacturersDestroy

Destroy a manufacturer object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this manufacturer.
 @return ApiDcimManufacturersDestroyRequest
*/
func (a *DcimAPIService) DcimManufacturersDestroy(ctx context.Context, id string) ApiDcimManufacturersDestroyRequest {
	return ApiDcimManufacturersDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimManufacturersDestroyExecute(r ApiDcimManufacturersDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimManufacturersListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceTypes *[]string
	deviceTypesIsnull *bool
	deviceTypesN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasDeviceTypes *bool
	hasInventoryItems *bool
	hasPlatforms *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	inventoryItems *[]string
	inventoryItemsIsnull *bool
	inventoryItemsN *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	platforms *[]string
	platformsIsnull *bool
	platformsN *[]string
	q *string
	sort *string
	depth *int32
}

func (r ApiDcimManufacturersListRequest) Created(created []time.Time) ApiDcimManufacturersListRequest {
	r.created = &created
	return r
}

func (r ApiDcimManufacturersListRequest) CreatedGt(createdGt []time.Time) ApiDcimManufacturersListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimManufacturersListRequest) CreatedGte(createdGte []time.Time) ApiDcimManufacturersListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimManufacturersListRequest) CreatedIsnull(createdIsnull bool) ApiDcimManufacturersListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimManufacturersListRequest) CreatedLt(createdLt []time.Time) ApiDcimManufacturersListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimManufacturersListRequest) CreatedLte(createdLte []time.Time) ApiDcimManufacturersListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimManufacturersListRequest) CreatedN(createdN []time.Time) ApiDcimManufacturersListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimManufacturersListRequest) Description(description []string) ApiDcimManufacturersListRequest {
	r.description = &description
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIc(descriptionIc []string) ApiDcimManufacturersListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIe(descriptionIe []string) ApiDcimManufacturersListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIew(descriptionIew []string) ApiDcimManufacturersListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIre(descriptionIre []string) ApiDcimManufacturersListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimManufacturersListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionN(descriptionN []string) ApiDcimManufacturersListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNic(descriptionNic []string) ApiDcimManufacturersListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNie(descriptionNie []string) ApiDcimManufacturersListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimManufacturersListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNire(descriptionNire []string) ApiDcimManufacturersListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimManufacturersListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionNre(descriptionNre []string) ApiDcimManufacturersListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimManufacturersListRequest) DescriptionRe(descriptionRe []string) ApiDcimManufacturersListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimManufacturersListRequest) DeviceTypes(deviceTypes []string) ApiDcimManufacturersListRequest {
	r.deviceTypes = &deviceTypes
	return r
}

func (r ApiDcimManufacturersListRequest) DeviceTypesIsnull(deviceTypesIsnull bool) ApiDcimManufacturersListRequest {
	r.deviceTypesIsnull = &deviceTypesIsnull
	return r
}

func (r ApiDcimManufacturersListRequest) DeviceTypesN(deviceTypesN []string) ApiDcimManufacturersListRequest {
	r.deviceTypesN = &deviceTypesN
	return r
}

func (r ApiDcimManufacturersListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersListRequest {
	r.format = &format
	return r
}

// Has device types
func (r ApiDcimManufacturersListRequest) HasDeviceTypes(hasDeviceTypes bool) ApiDcimManufacturersListRequest {
	r.hasDeviceTypes = &hasDeviceTypes
	return r
}

// Has inventory items
func (r ApiDcimManufacturersListRequest) HasInventoryItems(hasInventoryItems bool) ApiDcimManufacturersListRequest {
	r.hasInventoryItems = &hasInventoryItems
	return r
}

// Has platforms
func (r ApiDcimManufacturersListRequest) HasPlatforms(hasPlatforms bool) ApiDcimManufacturersListRequest {
	r.hasPlatforms = &hasPlatforms
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimManufacturersListRequest) Id(id []string) ApiDcimManufacturersListRequest {
	r.id = &id
	return r
}

func (r ApiDcimManufacturersListRequest) IdIc(idIc []string) ApiDcimManufacturersListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimManufacturersListRequest) IdIe(idIe []string) ApiDcimManufacturersListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimManufacturersListRequest) IdIew(idIew []string) ApiDcimManufacturersListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimManufacturersListRequest) IdIre(idIre []string) ApiDcimManufacturersListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimManufacturersListRequest) IdIsw(idIsw []string) ApiDcimManufacturersListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimManufacturersListRequest) IdN(idN []string) ApiDcimManufacturersListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimManufacturersListRequest) IdNic(idNic []string) ApiDcimManufacturersListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimManufacturersListRequest) IdNie(idNie []string) ApiDcimManufacturersListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimManufacturersListRequest) IdNiew(idNiew []string) ApiDcimManufacturersListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimManufacturersListRequest) IdNire(idNire []string) ApiDcimManufacturersListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimManufacturersListRequest) IdNisw(idNisw []string) ApiDcimManufacturersListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimManufacturersListRequest) IdNre(idNre []string) ApiDcimManufacturersListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimManufacturersListRequest) IdRe(idRe []string) ApiDcimManufacturersListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimManufacturersListRequest) InventoryItems(inventoryItems []string) ApiDcimManufacturersListRequest {
	r.inventoryItems = &inventoryItems
	return r
}

func (r ApiDcimManufacturersListRequest) InventoryItemsIsnull(inventoryItemsIsnull bool) ApiDcimManufacturersListRequest {
	r.inventoryItemsIsnull = &inventoryItemsIsnull
	return r
}

func (r ApiDcimManufacturersListRequest) InventoryItemsN(inventoryItemsN []string) ApiDcimManufacturersListRequest {
	r.inventoryItemsN = &inventoryItemsN
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimManufacturersListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimManufacturersListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimManufacturersListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimManufacturersListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimManufacturersListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimManufacturersListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimManufacturersListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimManufacturersListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimManufacturersListRequest) Limit(limit int32) ApiDcimManufacturersListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimManufacturersListRequest) Name(name []string) ApiDcimManufacturersListRequest {
	r.name = &name
	return r
}

func (r ApiDcimManufacturersListRequest) NameIc(nameIc []string) ApiDcimManufacturersListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimManufacturersListRequest) NameIe(nameIe []string) ApiDcimManufacturersListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimManufacturersListRequest) NameIew(nameIew []string) ApiDcimManufacturersListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimManufacturersListRequest) NameIre(nameIre []string) ApiDcimManufacturersListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimManufacturersListRequest) NameIsw(nameIsw []string) ApiDcimManufacturersListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimManufacturersListRequest) NameN(nameN []string) ApiDcimManufacturersListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimManufacturersListRequest) NameNic(nameNic []string) ApiDcimManufacturersListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimManufacturersListRequest) NameNie(nameNie []string) ApiDcimManufacturersListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimManufacturersListRequest) NameNiew(nameNiew []string) ApiDcimManufacturersListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimManufacturersListRequest) NameNire(nameNire []string) ApiDcimManufacturersListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimManufacturersListRequest) NameNisw(nameNisw []string) ApiDcimManufacturersListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimManufacturersListRequest) NameNre(nameNre []string) ApiDcimManufacturersListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimManufacturersListRequest) NameRe(nameRe []string) ApiDcimManufacturersListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimManufacturersListRequest) Offset(offset int32) ApiDcimManufacturersListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimManufacturersListRequest) Platforms(platforms []string) ApiDcimManufacturersListRequest {
	r.platforms = &platforms
	return r
}

func (r ApiDcimManufacturersListRequest) PlatformsIsnull(platformsIsnull bool) ApiDcimManufacturersListRequest {
	r.platformsIsnull = &platformsIsnull
	return r
}

func (r ApiDcimManufacturersListRequest) PlatformsN(platformsN []string) ApiDcimManufacturersListRequest {
	r.platformsN = &platformsN
	return r
}

// Search
func (r ApiDcimManufacturersListRequest) Q(q string) ApiDcimManufacturersListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimManufacturersListRequest) Sort(sort string) ApiDcimManufacturersListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimManufacturersListRequest) Depth(depth int32) ApiDcimManufacturersListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimManufacturersListRequest) Execute() (*PaginatedManufacturerList, *http.Response, error) {
	return r.ApiService.DcimManufacturersListExecute(r)
}

/*
DcimManufacturersList Method for DcimManufacturersList

Retrieve a list of manufacturer objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimManufacturersListRequest
*/
func (a *DcimAPIService) DcimManufacturersList(ctx context.Context) ApiDcimManufacturersListRequest {
	return ApiDcimManufacturersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedManufacturerList
func (a *DcimAPIService) DcimManufacturersListExecute(r ApiDcimManufacturersListRequest) (*PaginatedManufacturerList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedManufacturerList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_types", t, "multi")
		}
	}
	if r.deviceTypesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__isnull", r.deviceTypesIsnull, "")
	}
	if r.deviceTypesN != nil {
		t := *r.deviceTypesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasDeviceTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_device_types", r.hasDeviceTypes, "")
	}
	if r.hasInventoryItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_inventory_items", r.hasInventoryItems, "")
	}
	if r.hasPlatforms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_platforms", r.hasPlatforms, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.inventoryItems != nil {
		t := *r.inventoryItems
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items", t, "multi")
		}
	}
	if r.inventoryItemsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items__isnull", r.inventoryItemsIsnull, "")
	}
	if r.inventoryItemsN != nil {
		t := *r.inventoryItemsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.platforms != nil {
		t := *r.platforms
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "platforms", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "platforms", t, "multi")
		}
	}
	if r.platformsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platforms__isnull", r.platformsIsnull, "")
	}
	if r.platformsN != nil {
		t := *r.platformsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "platforms__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "platforms__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimManufacturersNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimManufacturersNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimManufacturersNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimManufacturersNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimManufacturersNotesCreateExecute(r)
}

/*
DcimManufacturersNotesCreate Method for DcimManufacturersNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this manufacturer.
 @return ApiDcimManufacturersNotesCreateRequest
*/
func (a *DcimAPIService) DcimManufacturersNotesCreate(ctx context.Context, id string) ApiDcimManufacturersNotesCreateRequest {
	return ApiDcimManufacturersNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimManufacturersNotesCreateExecute(r ApiDcimManufacturersNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimManufacturersNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimManufacturersNotesListRequest) Limit(limit int32) ApiDcimManufacturersNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimManufacturersNotesListRequest) Offset(offset int32) ApiDcimManufacturersNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimManufacturersNotesListRequest) Depth(depth int32) ApiDcimManufacturersNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimManufacturersNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimManufacturersNotesListExecute(r)
}

/*
DcimManufacturersNotesList Method for DcimManufacturersNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this manufacturer.
 @return ApiDcimManufacturersNotesListRequest
*/
func (a *DcimAPIService) DcimManufacturersNotesList(ctx context.Context, id string) ApiDcimManufacturersNotesListRequest {
	return ApiDcimManufacturersNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimManufacturersNotesListExecute(r ApiDcimManufacturersNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedManufacturerRequest *PatchedManufacturerRequest
}

func (r ApiDcimManufacturersPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimManufacturersPartialUpdateRequest) PatchedManufacturerRequest(patchedManufacturerRequest PatchedManufacturerRequest) ApiDcimManufacturersPartialUpdateRequest {
	r.patchedManufacturerRequest = &patchedManufacturerRequest
	return r
}

func (r ApiDcimManufacturersPartialUpdateRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersPartialUpdateExecute(r)
}

/*
DcimManufacturersPartialUpdate Method for DcimManufacturersPartialUpdate

Partial update a manufacturer object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this manufacturer.
 @return ApiDcimManufacturersPartialUpdateRequest
*/
func (a *DcimAPIService) DcimManufacturersPartialUpdate(ctx context.Context, id string) ApiDcimManufacturersPartialUpdateRequest {
	return ApiDcimManufacturersPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimAPIService) DcimManufacturersPartialUpdateExecute(r ApiDcimManufacturersPartialUpdateRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedManufacturerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimManufacturersRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimManufacturersRetrieveRequest) Depth(depth int32) ApiDcimManufacturersRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimManufacturersRetrieveRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersRetrieveExecute(r)
}

/*
DcimManufacturersRetrieve Method for DcimManufacturersRetrieve

Retrieve a manufacturer object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this manufacturer.
 @return ApiDcimManufacturersRetrieveRequest
*/
func (a *DcimAPIService) DcimManufacturersRetrieve(ctx context.Context, id string) ApiDcimManufacturersRetrieveRequest {
	return ApiDcimManufacturersRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimAPIService) DcimManufacturersRetrieveExecute(r ApiDcimManufacturersRetrieveRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimManufacturersUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	manufacturerRequest *ManufacturerRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimManufacturersUpdateRequest) ManufacturerRequest(manufacturerRequest ManufacturerRequest) ApiDcimManufacturersUpdateRequest {
	r.manufacturerRequest = &manufacturerRequest
	return r
}

func (r ApiDcimManufacturersUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimManufacturersUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimManufacturersUpdateRequest) Execute() (*Manufacturer, *http.Response, error) {
	return r.ApiService.DcimManufacturersUpdateExecute(r)
}

/*
DcimManufacturersUpdate Method for DcimManufacturersUpdate

Update a manufacturer object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this manufacturer.
 @return ApiDcimManufacturersUpdateRequest
*/
func (a *DcimAPIService) DcimManufacturersUpdate(ctx context.Context, id string) ApiDcimManufacturersUpdateRequest {
	return ApiDcimManufacturersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DcimAPIService) DcimManufacturersUpdateExecute(r ApiDcimManufacturersUpdateRequest) (*Manufacturer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimManufacturersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.manufacturerRequest == nil {
		return localVarReturnValue, nil, reportError("manufacturerRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.manufacturerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPlatformsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimPlatformsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimPlatformsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPlatformsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPlatformsBulkDestroyExecute(r)
}

/*
DcimPlatformsBulkDestroy Method for DcimPlatformsBulkDestroy

Destroy a list of platform objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimPlatformsBulkDestroy(ctx context.Context) ApiDcimPlatformsBulkDestroyRequest {
	return ApiDcimPlatformsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPlatformsBulkDestroyExecute(r ApiDcimPlatformsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPlatformsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritablePlatformRequest *[]PatchedBulkWritablePlatformRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPlatformsBulkPartialUpdateRequest) PatchedBulkWritablePlatformRequest(patchedBulkWritablePlatformRequest []PatchedBulkWritablePlatformRequest) ApiDcimPlatformsBulkPartialUpdateRequest {
	r.patchedBulkWritablePlatformRequest = &patchedBulkWritablePlatformRequest
	return r
}

func (r ApiDcimPlatformsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPlatformsBulkPartialUpdateRequest) Execute() ([]Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsBulkPartialUpdateExecute(r)
}

/*
DcimPlatformsBulkPartialUpdate Method for DcimPlatformsBulkPartialUpdate

Partial update a list of platform objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPlatformsBulkPartialUpdate(ctx context.Context) ApiDcimPlatformsBulkPartialUpdateRequest {
	return ApiDcimPlatformsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Platform
func (a *DcimAPIService) DcimPlatformsBulkPartialUpdateExecute(r ApiDcimPlatformsBulkPartialUpdateRequest) ([]Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePlatformRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePlatformRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePlatformRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritablePlatformRequest *[]BulkWritablePlatformRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPlatformsBulkUpdateRequest) BulkWritablePlatformRequest(bulkWritablePlatformRequest []BulkWritablePlatformRequest) ApiDcimPlatformsBulkUpdateRequest {
	r.bulkWritablePlatformRequest = &bulkWritablePlatformRequest
	return r
}

func (r ApiDcimPlatformsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPlatformsBulkUpdateRequest) Execute() ([]Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsBulkUpdateExecute(r)
}

/*
DcimPlatformsBulkUpdate Method for DcimPlatformsBulkUpdate

Update a list of platform objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimPlatformsBulkUpdate(ctx context.Context) ApiDcimPlatformsBulkUpdateRequest {
	return ApiDcimPlatformsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Platform
func (a *DcimAPIService) DcimPlatformsBulkUpdateExecute(r ApiDcimPlatformsBulkUpdateRequest) ([]Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePlatformRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePlatformRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePlatformRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	platformRequest *PlatformRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPlatformsCreateRequest) PlatformRequest(platformRequest PlatformRequest) ApiDcimPlatformsCreateRequest {
	r.platformRequest = &platformRequest
	return r
}

func (r ApiDcimPlatformsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPlatformsCreateRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsCreateExecute(r)
}

/*
DcimPlatformsCreate Method for DcimPlatformsCreate

Create one or more platform objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsCreateRequest
*/
func (a *DcimAPIService) DcimPlatformsCreate(ctx context.Context) ApiDcimPlatformsCreateRequest {
	return ApiDcimPlatformsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimAPIService) DcimPlatformsCreateExecute(r ApiDcimPlatformsCreateRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.platformRequest == nil {
		return localVarReturnValue, nil, reportError("platformRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.platformRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPlatformsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPlatformsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPlatformsDestroyExecute(r)
}

/*
DcimPlatformsDestroy Method for DcimPlatformsDestroy

Destroy a platform object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this platform.
 @return ApiDcimPlatformsDestroyRequest
*/
func (a *DcimAPIService) DcimPlatformsDestroy(ctx context.Context, id string) ApiDcimPlatformsDestroyRequest {
	return ApiDcimPlatformsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPlatformsDestroyExecute(r ApiDcimPlatformsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPlatformsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	devices *[]string
	devicesIsnull *bool
	devicesN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasDevices *bool
	hasVirtualMachines *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	manufacturer *[]string
	manufacturerIsnull *bool
	manufacturerN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	napalmArgs *[]string
	napalmDriver *[]string
	napalmDriverIc *[]string
	napalmDriverIe *[]string
	napalmDriverIew *[]string
	napalmDriverIre *[]string
	napalmDriverIsw *[]string
	napalmDriverN *[]string
	napalmDriverNic *[]string
	napalmDriverNie *[]string
	napalmDriverNiew *[]string
	napalmDriverNire *[]string
	napalmDriverNisw *[]string
	napalmDriverNre *[]string
	napalmDriverRe *[]string
	networkDriver *[]string
	networkDriverIc *[]string
	networkDriverIe *[]string
	networkDriverIew *[]string
	networkDriverIre *[]string
	networkDriverIsw *[]string
	networkDriverN *[]string
	networkDriverNic *[]string
	networkDriverNie *[]string
	networkDriverNiew *[]string
	networkDriverNire *[]string
	networkDriverNisw *[]string
	networkDriverNre *[]string
	networkDriverRe *[]string
	offset *int32
	q *string
	sort *string
	virtualMachines *[]string
	virtualMachinesIsnull *bool
	virtualMachinesN *[]string
	depth *int32
}

func (r ApiDcimPlatformsListRequest) Created(created []time.Time) ApiDcimPlatformsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPlatformsListRequest) CreatedGt(createdGt []time.Time) ApiDcimPlatformsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimPlatformsListRequest) CreatedGte(createdGte []time.Time) ApiDcimPlatformsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPlatformsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimPlatformsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimPlatformsListRequest) CreatedLt(createdLt []time.Time) ApiDcimPlatformsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimPlatformsListRequest) CreatedLte(createdLte []time.Time) ApiDcimPlatformsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPlatformsListRequest) CreatedN(createdN []time.Time) ApiDcimPlatformsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimPlatformsListRequest) Description(description []string) ApiDcimPlatformsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIc(descriptionIc []string) ApiDcimPlatformsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIe(descriptionIe []string) ApiDcimPlatformsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIew(descriptionIew []string) ApiDcimPlatformsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIre(descriptionIre []string) ApiDcimPlatformsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimPlatformsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionN(descriptionN []string) ApiDcimPlatformsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNic(descriptionNic []string) ApiDcimPlatformsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNie(descriptionNie []string) ApiDcimPlatformsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimPlatformsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNire(descriptionNire []string) ApiDcimPlatformsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimPlatformsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionNre(descriptionNre []string) ApiDcimPlatformsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimPlatformsListRequest) DescriptionRe(descriptionRe []string) ApiDcimPlatformsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimPlatformsListRequest) Devices(devices []string) ApiDcimPlatformsListRequest {
	r.devices = &devices
	return r
}

func (r ApiDcimPlatformsListRequest) DevicesIsnull(devicesIsnull bool) ApiDcimPlatformsListRequest {
	r.devicesIsnull = &devicesIsnull
	return r
}

func (r ApiDcimPlatformsListRequest) DevicesN(devicesN []string) ApiDcimPlatformsListRequest {
	r.devicesN = &devicesN
	return r
}

func (r ApiDcimPlatformsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsListRequest {
	r.format = &format
	return r
}

// Has devices
func (r ApiDcimPlatformsListRequest) HasDevices(hasDevices bool) ApiDcimPlatformsListRequest {
	r.hasDevices = &hasDevices
	return r
}

// Has virtual machines
func (r ApiDcimPlatformsListRequest) HasVirtualMachines(hasVirtualMachines bool) ApiDcimPlatformsListRequest {
	r.hasVirtualMachines = &hasVirtualMachines
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimPlatformsListRequest) Id(id []string) ApiDcimPlatformsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPlatformsListRequest) IdIc(idIc []string) ApiDcimPlatformsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimPlatformsListRequest) IdIe(idIe []string) ApiDcimPlatformsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimPlatformsListRequest) IdIew(idIew []string) ApiDcimPlatformsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimPlatformsListRequest) IdIre(idIre []string) ApiDcimPlatformsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimPlatformsListRequest) IdIsw(idIsw []string) ApiDcimPlatformsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimPlatformsListRequest) IdN(idN []string) ApiDcimPlatformsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPlatformsListRequest) IdNic(idNic []string) ApiDcimPlatformsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimPlatformsListRequest) IdNie(idNie []string) ApiDcimPlatformsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimPlatformsListRequest) IdNiew(idNiew []string) ApiDcimPlatformsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimPlatformsListRequest) IdNire(idNire []string) ApiDcimPlatformsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimPlatformsListRequest) IdNisw(idNisw []string) ApiDcimPlatformsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimPlatformsListRequest) IdNre(idNre []string) ApiDcimPlatformsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimPlatformsListRequest) IdRe(idRe []string) ApiDcimPlatformsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimPlatformsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimPlatformsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimPlatformsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimPlatformsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimPlatformsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimPlatformsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPlatformsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimPlatformsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimPlatformsListRequest) Limit(limit int32) ApiDcimPlatformsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimPlatformsListRequest) Manufacturer(manufacturer []string) ApiDcimPlatformsListRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiDcimPlatformsListRequest) ManufacturerIsnull(manufacturerIsnull bool) ApiDcimPlatformsListRequest {
	r.manufacturerIsnull = &manufacturerIsnull
	return r
}

func (r ApiDcimPlatformsListRequest) ManufacturerN(manufacturerN []string) ApiDcimPlatformsListRequest {
	r.manufacturerN = &manufacturerN
	return r
}

func (r ApiDcimPlatformsListRequest) Name(name []string) ApiDcimPlatformsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPlatformsListRequest) NameIc(nameIc []string) ApiDcimPlatformsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPlatformsListRequest) NameIe(nameIe []string) ApiDcimPlatformsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPlatformsListRequest) NameIew(nameIew []string) ApiDcimPlatformsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPlatformsListRequest) NameIre(nameIre []string) ApiDcimPlatformsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimPlatformsListRequest) NameIsw(nameIsw []string) ApiDcimPlatformsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPlatformsListRequest) NameN(nameN []string) ApiDcimPlatformsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPlatformsListRequest) NameNic(nameNic []string) ApiDcimPlatformsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPlatformsListRequest) NameNie(nameNie []string) ApiDcimPlatformsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPlatformsListRequest) NameNiew(nameNiew []string) ApiDcimPlatformsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPlatformsListRequest) NameNire(nameNire []string) ApiDcimPlatformsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimPlatformsListRequest) NameNisw(nameNisw []string) ApiDcimPlatformsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPlatformsListRequest) NameNre(nameNre []string) ApiDcimPlatformsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimPlatformsListRequest) NameRe(nameRe []string) ApiDcimPlatformsListRequest {
	r.nameRe = &nameRe
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmArgs(napalmArgs []string) ApiDcimPlatformsListRequest {
	r.napalmArgs = &napalmArgs
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriver(napalmDriver []string) ApiDcimPlatformsListRequest {
	r.napalmDriver = &napalmDriver
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIc(napalmDriverIc []string) ApiDcimPlatformsListRequest {
	r.napalmDriverIc = &napalmDriverIc
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIe(napalmDriverIe []string) ApiDcimPlatformsListRequest {
	r.napalmDriverIe = &napalmDriverIe
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIew(napalmDriverIew []string) ApiDcimPlatformsListRequest {
	r.napalmDriverIew = &napalmDriverIew
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIre(napalmDriverIre []string) ApiDcimPlatformsListRequest {
	r.napalmDriverIre = &napalmDriverIre
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverIsw(napalmDriverIsw []string) ApiDcimPlatformsListRequest {
	r.napalmDriverIsw = &napalmDriverIsw
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverN(napalmDriverN []string) ApiDcimPlatformsListRequest {
	r.napalmDriverN = &napalmDriverN
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNic(napalmDriverNic []string) ApiDcimPlatformsListRequest {
	r.napalmDriverNic = &napalmDriverNic
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNie(napalmDriverNie []string) ApiDcimPlatformsListRequest {
	r.napalmDriverNie = &napalmDriverNie
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNiew(napalmDriverNiew []string) ApiDcimPlatformsListRequest {
	r.napalmDriverNiew = &napalmDriverNiew
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNire(napalmDriverNire []string) ApiDcimPlatformsListRequest {
	r.napalmDriverNire = &napalmDriverNire
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNisw(napalmDriverNisw []string) ApiDcimPlatformsListRequest {
	r.napalmDriverNisw = &napalmDriverNisw
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverNre(napalmDriverNre []string) ApiDcimPlatformsListRequest {
	r.napalmDriverNre = &napalmDriverNre
	return r
}

func (r ApiDcimPlatformsListRequest) NapalmDriverRe(napalmDriverRe []string) ApiDcimPlatformsListRequest {
	r.napalmDriverRe = &napalmDriverRe
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriver(networkDriver []string) ApiDcimPlatformsListRequest {
	r.networkDriver = &networkDriver
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverIc(networkDriverIc []string) ApiDcimPlatformsListRequest {
	r.networkDriverIc = &networkDriverIc
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverIe(networkDriverIe []string) ApiDcimPlatformsListRequest {
	r.networkDriverIe = &networkDriverIe
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverIew(networkDriverIew []string) ApiDcimPlatformsListRequest {
	r.networkDriverIew = &networkDriverIew
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverIre(networkDriverIre []string) ApiDcimPlatformsListRequest {
	r.networkDriverIre = &networkDriverIre
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverIsw(networkDriverIsw []string) ApiDcimPlatformsListRequest {
	r.networkDriverIsw = &networkDriverIsw
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverN(networkDriverN []string) ApiDcimPlatformsListRequest {
	r.networkDriverN = &networkDriverN
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverNic(networkDriverNic []string) ApiDcimPlatformsListRequest {
	r.networkDriverNic = &networkDriverNic
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverNie(networkDriverNie []string) ApiDcimPlatformsListRequest {
	r.networkDriverNie = &networkDriverNie
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverNiew(networkDriverNiew []string) ApiDcimPlatformsListRequest {
	r.networkDriverNiew = &networkDriverNiew
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverNire(networkDriverNire []string) ApiDcimPlatformsListRequest {
	r.networkDriverNire = &networkDriverNire
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverNisw(networkDriverNisw []string) ApiDcimPlatformsListRequest {
	r.networkDriverNisw = &networkDriverNisw
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverNre(networkDriverNre []string) ApiDcimPlatformsListRequest {
	r.networkDriverNre = &networkDriverNre
	return r
}

func (r ApiDcimPlatformsListRequest) NetworkDriverRe(networkDriverRe []string) ApiDcimPlatformsListRequest {
	r.networkDriverRe = &networkDriverRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPlatformsListRequest) Offset(offset int32) ApiDcimPlatformsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimPlatformsListRequest) Q(q string) ApiDcimPlatformsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimPlatformsListRequest) Sort(sort string) ApiDcimPlatformsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimPlatformsListRequest) VirtualMachines(virtualMachines []string) ApiDcimPlatformsListRequest {
	r.virtualMachines = &virtualMachines
	return r
}

func (r ApiDcimPlatformsListRequest) VirtualMachinesIsnull(virtualMachinesIsnull bool) ApiDcimPlatformsListRequest {
	r.virtualMachinesIsnull = &virtualMachinesIsnull
	return r
}

func (r ApiDcimPlatformsListRequest) VirtualMachinesN(virtualMachinesN []string) ApiDcimPlatformsListRequest {
	r.virtualMachinesN = &virtualMachinesN
	return r
}

// Serializer Depth
func (r ApiDcimPlatformsListRequest) Depth(depth int32) ApiDcimPlatformsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPlatformsListRequest) Execute() (*PaginatedPlatformList, *http.Response, error) {
	return r.ApiService.DcimPlatformsListExecute(r)
}

/*
DcimPlatformsList Method for DcimPlatformsList

Retrieve a list of platform objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPlatformsListRequest
*/
func (a *DcimAPIService) DcimPlatformsList(ctx context.Context) ApiDcimPlatformsListRequest {
	return ApiDcimPlatformsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPlatformList
func (a *DcimAPIService) DcimPlatformsListExecute(r ApiDcimPlatformsListRequest) (*PaginatedPlatformList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPlatformList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices", t, "multi")
		}
	}
	if r.devicesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices__isnull", r.devicesIsnull, "")
	}
	if r.devicesN != nil {
		t := *r.devicesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_devices", r.hasDevices, "")
	}
	if r.hasVirtualMachines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_virtual_machines", r.hasVirtualMachines, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.manufacturer != nil {
		t := *r.manufacturer
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", t, "multi")
		}
	}
	if r.manufacturerIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__isnull", r.manufacturerIsnull, "")
	}
	if r.manufacturerN != nil {
		t := *r.manufacturerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.napalmArgs != nil {
		t := *r.napalmArgs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_args", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_args", t, "multi")
		}
	}
	if r.napalmDriver != nil {
		t := *r.napalmDriver
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver", t, "multi")
		}
	}
	if r.napalmDriverIc != nil {
		t := *r.napalmDriverIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__ic", t, "multi")
		}
	}
	if r.napalmDriverIe != nil {
		t := *r.napalmDriverIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__ie", t, "multi")
		}
	}
	if r.napalmDriverIew != nil {
		t := *r.napalmDriverIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__iew", t, "multi")
		}
	}
	if r.napalmDriverIre != nil {
		t := *r.napalmDriverIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__ire", t, "multi")
		}
	}
	if r.napalmDriverIsw != nil {
		t := *r.napalmDriverIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__isw", t, "multi")
		}
	}
	if r.napalmDriverN != nil {
		t := *r.napalmDriverN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__n", t, "multi")
		}
	}
	if r.napalmDriverNic != nil {
		t := *r.napalmDriverNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nic", t, "multi")
		}
	}
	if r.napalmDriverNie != nil {
		t := *r.napalmDriverNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nie", t, "multi")
		}
	}
	if r.napalmDriverNiew != nil {
		t := *r.napalmDriverNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__niew", t, "multi")
		}
	}
	if r.napalmDriverNire != nil {
		t := *r.napalmDriverNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nire", t, "multi")
		}
	}
	if r.napalmDriverNisw != nil {
		t := *r.napalmDriverNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nisw", t, "multi")
		}
	}
	if r.napalmDriverNre != nil {
		t := *r.napalmDriverNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__nre", t, "multi")
		}
	}
	if r.napalmDriverRe != nil {
		t := *r.napalmDriverRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "napalm_driver__re", t, "multi")
		}
	}
	if r.networkDriver != nil {
		t := *r.networkDriver
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver", t, "multi")
		}
	}
	if r.networkDriverIc != nil {
		t := *r.networkDriverIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__ic", t, "multi")
		}
	}
	if r.networkDriverIe != nil {
		t := *r.networkDriverIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__ie", t, "multi")
		}
	}
	if r.networkDriverIew != nil {
		t := *r.networkDriverIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__iew", t, "multi")
		}
	}
	if r.networkDriverIre != nil {
		t := *r.networkDriverIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__ire", t, "multi")
		}
	}
	if r.networkDriverIsw != nil {
		t := *r.networkDriverIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__isw", t, "multi")
		}
	}
	if r.networkDriverN != nil {
		t := *r.networkDriverN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__n", t, "multi")
		}
	}
	if r.networkDriverNic != nil {
		t := *r.networkDriverNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nic", t, "multi")
		}
	}
	if r.networkDriverNie != nil {
		t := *r.networkDriverNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nie", t, "multi")
		}
	}
	if r.networkDriverNiew != nil {
		t := *r.networkDriverNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__niew", t, "multi")
		}
	}
	if r.networkDriverNire != nil {
		t := *r.networkDriverNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nire", t, "multi")
		}
	}
	if r.networkDriverNisw != nil {
		t := *r.networkDriverNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nisw", t, "multi")
		}
	}
	if r.networkDriverNre != nil {
		t := *r.networkDriverNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__nre", t, "multi")
		}
	}
	if r.networkDriverRe != nil {
		t := *r.networkDriverRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "network_driver__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.virtualMachines != nil {
		t := *r.virtualMachines
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines", t, "multi")
		}
	}
	if r.virtualMachinesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines__isnull", r.virtualMachinesIsnull, "")
	}
	if r.virtualMachinesN != nil {
		t := *r.virtualMachinesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPlatformsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimPlatformsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimPlatformsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPlatformsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimPlatformsNotesCreateExecute(r)
}

/*
DcimPlatformsNotesCreate Method for DcimPlatformsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this platform.
 @return ApiDcimPlatformsNotesCreateRequest
*/
func (a *DcimAPIService) DcimPlatformsNotesCreate(ctx context.Context, id string) ApiDcimPlatformsNotesCreateRequest {
	return ApiDcimPlatformsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimPlatformsNotesCreateExecute(r ApiDcimPlatformsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimPlatformsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimPlatformsNotesListRequest) Limit(limit int32) ApiDcimPlatformsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPlatformsNotesListRequest) Offset(offset int32) ApiDcimPlatformsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimPlatformsNotesListRequest) Depth(depth int32) ApiDcimPlatformsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPlatformsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimPlatformsNotesListExecute(r)
}

/*
DcimPlatformsNotesList Method for DcimPlatformsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this platform.
 @return ApiDcimPlatformsNotesListRequest
*/
func (a *DcimAPIService) DcimPlatformsNotesList(ctx context.Context, id string) ApiDcimPlatformsNotesListRequest {
	return ApiDcimPlatformsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimPlatformsNotesListExecute(r ApiDcimPlatformsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedPlatformRequest *PatchedPlatformRequest
}

func (r ApiDcimPlatformsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPlatformsPartialUpdateRequest) PatchedPlatformRequest(patchedPlatformRequest PatchedPlatformRequest) ApiDcimPlatformsPartialUpdateRequest {
	r.patchedPlatformRequest = &patchedPlatformRequest
	return r
}

func (r ApiDcimPlatformsPartialUpdateRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsPartialUpdateExecute(r)
}

/*
DcimPlatformsPartialUpdate Method for DcimPlatformsPartialUpdate

Partial update a platform object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this platform.
 @return ApiDcimPlatformsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPlatformsPartialUpdate(ctx context.Context, id string) ApiDcimPlatformsPartialUpdateRequest {
	return ApiDcimPlatformsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimAPIService) DcimPlatformsPartialUpdateExecute(r ApiDcimPlatformsPartialUpdateRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPlatformRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPlatformsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPlatformsRetrieveRequest) Depth(depth int32) ApiDcimPlatformsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPlatformsRetrieveRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsRetrieveExecute(r)
}

/*
DcimPlatformsRetrieve Method for DcimPlatformsRetrieve

Retrieve a platform object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this platform.
 @return ApiDcimPlatformsRetrieveRequest
*/
func (a *DcimAPIService) DcimPlatformsRetrieve(ctx context.Context, id string) ApiDcimPlatformsRetrieveRequest {
	return ApiDcimPlatformsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimAPIService) DcimPlatformsRetrieveExecute(r ApiDcimPlatformsRetrieveRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPlatformsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	platformRequest *PlatformRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPlatformsUpdateRequest) PlatformRequest(platformRequest PlatformRequest) ApiDcimPlatformsUpdateRequest {
	r.platformRequest = &platformRequest
	return r
}

func (r ApiDcimPlatformsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPlatformsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPlatformsUpdateRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.DcimPlatformsUpdateExecute(r)
}

/*
DcimPlatformsUpdate Method for DcimPlatformsUpdate

Update a platform object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this platform.
 @return ApiDcimPlatformsUpdateRequest
*/
func (a *DcimAPIService) DcimPlatformsUpdate(ctx context.Context, id string) ApiDcimPlatformsUpdateRequest {
	return ApiDcimPlatformsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Platform
func (a *DcimAPIService) DcimPlatformsUpdateExecute(r ApiDcimPlatformsUpdateRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPlatformsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.platformRequest == nil {
		return localVarReturnValue, nil, reportError("platformRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.platformRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerConnectionsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	device *[]string
	deviceId *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	limit *int32
	location *string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	sort *string
	depth *int32
}

// Device (name)
func (r ApiDcimPowerConnectionsListRequest) Device(device []string) ApiDcimPowerConnectionsListRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiDcimPowerConnectionsListRequest) DeviceId(deviceId []string) ApiDcimPowerConnectionsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiDcimPowerConnectionsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerConnectionsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimPowerConnectionsListRequest) Id(id []string) ApiDcimPowerConnectionsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdIc(idIc []string) ApiDcimPowerConnectionsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdIe(idIe []string) ApiDcimPowerConnectionsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdIew(idIew []string) ApiDcimPowerConnectionsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdIre(idIre []string) ApiDcimPowerConnectionsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdIsw(idIsw []string) ApiDcimPowerConnectionsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdN(idN []string) ApiDcimPowerConnectionsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdNic(idNic []string) ApiDcimPowerConnectionsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdNie(idNie []string) ApiDcimPowerConnectionsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdNiew(idNiew []string) ApiDcimPowerConnectionsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdNire(idNire []string) ApiDcimPowerConnectionsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdNisw(idNisw []string) ApiDcimPowerConnectionsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdNre(idNre []string) ApiDcimPowerConnectionsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimPowerConnectionsListRequest) IdRe(idRe []string) ApiDcimPowerConnectionsListRequest {
	r.idRe = &idRe
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerConnectionsListRequest) Limit(limit int32) ApiDcimPowerConnectionsListRequest {
	r.limit = &limit
	return r
}

// Location (name)
func (r ApiDcimPowerConnectionsListRequest) Location(location string) ApiDcimPowerConnectionsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimPowerConnectionsListRequest) Name(name []string) ApiDcimPowerConnectionsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIc(nameIc []string) ApiDcimPowerConnectionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIe(nameIe []string) ApiDcimPowerConnectionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIew(nameIew []string) ApiDcimPowerConnectionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIre(nameIre []string) ApiDcimPowerConnectionsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameIsw(nameIsw []string) ApiDcimPowerConnectionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameN(nameN []string) ApiDcimPowerConnectionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNic(nameNic []string) ApiDcimPowerConnectionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNie(nameNie []string) ApiDcimPowerConnectionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNiew(nameNiew []string) ApiDcimPowerConnectionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNire(nameNire []string) ApiDcimPowerConnectionsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNisw(nameNisw []string) ApiDcimPowerConnectionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameNre(nameNre []string) ApiDcimPowerConnectionsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimPowerConnectionsListRequest) NameRe(nameRe []string) ApiDcimPowerConnectionsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerConnectionsListRequest) Offset(offset int32) ApiDcimPowerConnectionsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimPowerConnectionsListRequest) Sort(sort string) ApiDcimPowerConnectionsListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimPowerConnectionsListRequest) Depth(depth int32) ApiDcimPowerConnectionsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerConnectionsListRequest) Execute() (*PaginatedPowerPortList, *http.Response, error) {
	return r.ApiService.DcimPowerConnectionsListExecute(r)
}

/*
DcimPowerConnectionsList Method for DcimPowerConnectionsList

Retrieve a list of power port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerConnectionsListRequest
*/
func (a *DcimAPIService) DcimPowerConnectionsList(ctx context.Context) ApiDcimPowerConnectionsListRequest {
	return ApiDcimPowerConnectionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPowerPortList
func (a *DcimAPIService) DcimPowerConnectionsListExecute(r ApiDcimPowerConnectionsListRequest) (*PaginatedPowerPortList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPowerPortList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerConnectionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerFeedsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimPowerFeedsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimPowerFeedsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerFeedsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerFeedsBulkDestroyExecute(r)
}

/*
DcimPowerFeedsBulkDestroy Method for DcimPowerFeedsBulkDestroy

Destroy a list of power feed objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimPowerFeedsBulkDestroy(ctx context.Context) ApiDcimPowerFeedsBulkDestroyRequest {
	return ApiDcimPowerFeedsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerFeedsBulkDestroyExecute(r ApiDcimPowerFeedsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritablePowerFeedRequest *[]PatchedBulkWritablePowerFeedRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerFeedsBulkPartialUpdateRequest) PatchedBulkWritablePowerFeedRequest(patchedBulkWritablePowerFeedRequest []PatchedBulkWritablePowerFeedRequest) ApiDcimPowerFeedsBulkPartialUpdateRequest {
	r.patchedBulkWritablePowerFeedRequest = &patchedBulkWritablePowerFeedRequest
	return r
}

func (r ApiDcimPowerFeedsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerFeedsBulkPartialUpdateRequest) Execute() ([]PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsBulkPartialUpdateExecute(r)
}

/*
DcimPowerFeedsBulkPartialUpdate Method for DcimPowerFeedsBulkPartialUpdate

Partial update a list of power feed objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerFeedsBulkPartialUpdate(ctx context.Context) ApiDcimPowerFeedsBulkPartialUpdateRequest {
	return ApiDcimPowerFeedsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerFeed
func (a *DcimAPIService) DcimPowerFeedsBulkPartialUpdateExecute(r ApiDcimPowerFeedsBulkPartialUpdateRequest) ([]PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePowerFeedRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePowerFeedRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePowerFeedRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritablePowerFeedRequest *[]BulkWritablePowerFeedRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerFeedsBulkUpdateRequest) BulkWritablePowerFeedRequest(bulkWritablePowerFeedRequest []BulkWritablePowerFeedRequest) ApiDcimPowerFeedsBulkUpdateRequest {
	r.bulkWritablePowerFeedRequest = &bulkWritablePowerFeedRequest
	return r
}

func (r ApiDcimPowerFeedsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerFeedsBulkUpdateRequest) Execute() ([]PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsBulkUpdateExecute(r)
}

/*
DcimPowerFeedsBulkUpdate Method for DcimPowerFeedsBulkUpdate

Update a list of power feed objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimPowerFeedsBulkUpdate(ctx context.Context) ApiDcimPowerFeedsBulkUpdateRequest {
	return ApiDcimPowerFeedsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerFeed
func (a *DcimAPIService) DcimPowerFeedsBulkUpdateExecute(r ApiDcimPowerFeedsBulkUpdateRequest) ([]PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePowerFeedRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePowerFeedRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePowerFeedRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writablePowerFeedRequest *WritablePowerFeedRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerFeedsCreateRequest) WritablePowerFeedRequest(writablePowerFeedRequest WritablePowerFeedRequest) ApiDcimPowerFeedsCreateRequest {
	r.writablePowerFeedRequest = &writablePowerFeedRequest
	return r
}

func (r ApiDcimPowerFeedsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerFeedsCreateRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsCreateExecute(r)
}

/*
DcimPowerFeedsCreate Method for DcimPowerFeedsCreate

Create one or more power feed objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsCreateRequest
*/
func (a *DcimAPIService) DcimPowerFeedsCreate(ctx context.Context) ApiDcimPowerFeedsCreateRequest {
	return ApiDcimPowerFeedsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimAPIService) DcimPowerFeedsCreateExecute(r ApiDcimPowerFeedsCreateRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerFeedRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerFeedRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerFeedRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerFeedsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerFeedsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerFeedsDestroyExecute(r)
}

/*
DcimPowerFeedsDestroy Method for DcimPowerFeedsDestroy

Destroy a power feed object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power feed.
 @return ApiDcimPowerFeedsDestroyRequest
*/
func (a *DcimAPIService) DcimPowerFeedsDestroy(ctx context.Context, id string) ApiDcimPowerFeedsDestroyRequest {
	return ApiDcimPowerFeedsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerFeedsDestroyExecute(r ApiDcimPowerFeedsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	amperage *[]int32
	amperageGt *[]int32
	amperageGte *[]int32
	amperageLt *[]int32
	amperageLte *[]int32
	amperageN *[]int32
	availablePower *[]int32
	availablePowerGt *[]int32
	availablePowerGte *[]int32
	availablePowerLt *[]int32
	availablePowerLte *[]int32
	availablePowerN *[]int32
	cable *[]string
	cableIsnull *bool
	cableN *[]string
	comments *[]string
	commentsIc *[]string
	commentsIe *[]string
	commentsIew *[]string
	commentsIre *[]string
	commentsIsw *[]string
	commentsN *[]string
	commentsNic *[]string
	commentsNie *[]string
	commentsNiew *[]string
	commentsNire *[]string
	commentsNisw *[]string
	commentsNre *[]string
	commentsRe *[]string
	connected *bool
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	format *CircuitsCircuitTerminationsListFormatParameter
	hasCable *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	maxUtilization *[]int32
	maxUtilizationGt *[]int32
	maxUtilizationGte *[]int32
	maxUtilizationLt *[]int32
	maxUtilizationLte *[]int32
	maxUtilizationN *[]int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	phase *[]string
	phaseIc *[]string
	phaseIe *[]string
	phaseIew *[]string
	phaseIre *[]string
	phaseIsw *[]string
	phaseN *[]string
	phaseNic *[]string
	phaseNie *[]string
	phaseNiew *[]string
	phaseNire *[]string
	phaseNisw *[]string
	phaseNre *[]string
	phaseRe *[]string
	powerPanel *[]string
	powerPanelN *[]string
	q *string
	rack *[]string
	rackIsnull *bool
	rackN *[]string
	sort *string
	status *[]string
	statusN *[]string
	supply *[]string
	supplyIc *[]string
	supplyIe *[]string
	supplyIew *[]string
	supplyIre *[]string
	supplyIsw *[]string
	supplyN *[]string
	supplyNic *[]string
	supplyNie *[]string
	supplyNiew *[]string
	supplyNire *[]string
	supplyNisw *[]string
	supplyNre *[]string
	supplyRe *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	voltage *[]int32
	voltageGt *[]int32
	voltageGte *[]int32
	voltageLt *[]int32
	voltageLte *[]int32
	voltageN *[]int32
	depth *int32
}

func (r ApiDcimPowerFeedsListRequest) Amperage(amperage []int32) ApiDcimPowerFeedsListRequest {
	r.amperage = &amperage
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageGt(amperageGt []int32) ApiDcimPowerFeedsListRequest {
	r.amperageGt = &amperageGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageGte(amperageGte []int32) ApiDcimPowerFeedsListRequest {
	r.amperageGte = &amperageGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageLt(amperageLt []int32) ApiDcimPowerFeedsListRequest {
	r.amperageLt = &amperageLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageLte(amperageLte []int32) ApiDcimPowerFeedsListRequest {
	r.amperageLte = &amperageLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) AmperageN(amperageN []int32) ApiDcimPowerFeedsListRequest {
	r.amperageN = &amperageN
	return r
}

func (r ApiDcimPowerFeedsListRequest) AvailablePower(availablePower []int32) ApiDcimPowerFeedsListRequest {
	r.availablePower = &availablePower
	return r
}

func (r ApiDcimPowerFeedsListRequest) AvailablePowerGt(availablePowerGt []int32) ApiDcimPowerFeedsListRequest {
	r.availablePowerGt = &availablePowerGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) AvailablePowerGte(availablePowerGte []int32) ApiDcimPowerFeedsListRequest {
	r.availablePowerGte = &availablePowerGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) AvailablePowerLt(availablePowerLt []int32) ApiDcimPowerFeedsListRequest {
	r.availablePowerLt = &availablePowerLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) AvailablePowerLte(availablePowerLte []int32) ApiDcimPowerFeedsListRequest {
	r.availablePowerLte = &availablePowerLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) AvailablePowerN(availablePowerN []int32) ApiDcimPowerFeedsListRequest {
	r.availablePowerN = &availablePowerN
	return r
}

// Cable
func (r ApiDcimPowerFeedsListRequest) Cable(cable []string) ApiDcimPowerFeedsListRequest {
	r.cable = &cable
	return r
}

func (r ApiDcimPowerFeedsListRequest) CableIsnull(cableIsnull bool) ApiDcimPowerFeedsListRequest {
	r.cableIsnull = &cableIsnull
	return r
}

// Cable
func (r ApiDcimPowerFeedsListRequest) CableN(cableN []string) ApiDcimPowerFeedsListRequest {
	r.cableN = &cableN
	return r
}

func (r ApiDcimPowerFeedsListRequest) Comments(comments []string) ApiDcimPowerFeedsListRequest {
	r.comments = &comments
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsIc(commentsIc []string) ApiDcimPowerFeedsListRequest {
	r.commentsIc = &commentsIc
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsIe(commentsIe []string) ApiDcimPowerFeedsListRequest {
	r.commentsIe = &commentsIe
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsIew(commentsIew []string) ApiDcimPowerFeedsListRequest {
	r.commentsIew = &commentsIew
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsIre(commentsIre []string) ApiDcimPowerFeedsListRequest {
	r.commentsIre = &commentsIre
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsIsw(commentsIsw []string) ApiDcimPowerFeedsListRequest {
	r.commentsIsw = &commentsIsw
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsN(commentsN []string) ApiDcimPowerFeedsListRequest {
	r.commentsN = &commentsN
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsNic(commentsNic []string) ApiDcimPowerFeedsListRequest {
	r.commentsNic = &commentsNic
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsNie(commentsNie []string) ApiDcimPowerFeedsListRequest {
	r.commentsNie = &commentsNie
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsNiew(commentsNiew []string) ApiDcimPowerFeedsListRequest {
	r.commentsNiew = &commentsNiew
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsNire(commentsNire []string) ApiDcimPowerFeedsListRequest {
	r.commentsNire = &commentsNire
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsNisw(commentsNisw []string) ApiDcimPowerFeedsListRequest {
	r.commentsNisw = &commentsNisw
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsNre(commentsNre []string) ApiDcimPowerFeedsListRequest {
	r.commentsNre = &commentsNre
	return r
}

func (r ApiDcimPowerFeedsListRequest) CommentsRe(commentsRe []string) ApiDcimPowerFeedsListRequest {
	r.commentsRe = &commentsRe
	return r
}

// Connected status (bool)
func (r ApiDcimPowerFeedsListRequest) Connected(connected bool) ApiDcimPowerFeedsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimPowerFeedsListRequest) Created(created []time.Time) ApiDcimPowerFeedsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPowerFeedsListRequest) CreatedGt(createdGt []time.Time) ApiDcimPowerFeedsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) CreatedGte(createdGte []time.Time) ApiDcimPowerFeedsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimPowerFeedsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimPowerFeedsListRequest) CreatedLt(createdLt []time.Time) ApiDcimPowerFeedsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) CreatedLte(createdLte []time.Time) ApiDcimPowerFeedsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) CreatedN(createdN []time.Time) ApiDcimPowerFeedsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimPowerFeedsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsListRequest {
	r.format = &format
	return r
}

// Has cable
func (r ApiDcimPowerFeedsListRequest) HasCable(hasCable bool) ApiDcimPowerFeedsListRequest {
	r.hasCable = &hasCable
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimPowerFeedsListRequest) Id(id []string) ApiDcimPowerFeedsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdIc(idIc []string) ApiDcimPowerFeedsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdIe(idIe []string) ApiDcimPowerFeedsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdIew(idIew []string) ApiDcimPowerFeedsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdIre(idIre []string) ApiDcimPowerFeedsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdIsw(idIsw []string) ApiDcimPowerFeedsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdN(idN []string) ApiDcimPowerFeedsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdNic(idNic []string) ApiDcimPowerFeedsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdNie(idNie []string) ApiDcimPowerFeedsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdNiew(idNiew []string) ApiDcimPowerFeedsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdNire(idNire []string) ApiDcimPowerFeedsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdNisw(idNisw []string) ApiDcimPowerFeedsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdNre(idNre []string) ApiDcimPowerFeedsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimPowerFeedsListRequest) IdRe(idRe []string) ApiDcimPowerFeedsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimPowerFeedsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimPowerFeedsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimPowerFeedsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimPowerFeedsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimPowerFeedsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimPowerFeedsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimPowerFeedsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerFeedsListRequest) Limit(limit int32) ApiDcimPowerFeedsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimPowerFeedsListRequest) Location(location []string) ApiDcimPowerFeedsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimPowerFeedsListRequest) LocationN(locationN []string) ApiDcimPowerFeedsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilization(maxUtilization []int32) ApiDcimPowerFeedsListRequest {
	r.maxUtilization = &maxUtilization
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationGt(maxUtilizationGt []int32) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationGt = &maxUtilizationGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationGte(maxUtilizationGte []int32) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationGte = &maxUtilizationGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationLt(maxUtilizationLt []int32) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationLt = &maxUtilizationLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationLte(maxUtilizationLte []int32) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationLte = &maxUtilizationLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) MaxUtilizationN(maxUtilizationN []int32) ApiDcimPowerFeedsListRequest {
	r.maxUtilizationN = &maxUtilizationN
	return r
}

func (r ApiDcimPowerFeedsListRequest) Name(name []string) ApiDcimPowerFeedsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIc(nameIc []string) ApiDcimPowerFeedsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIe(nameIe []string) ApiDcimPowerFeedsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIew(nameIew []string) ApiDcimPowerFeedsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIre(nameIre []string) ApiDcimPowerFeedsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameIsw(nameIsw []string) ApiDcimPowerFeedsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameN(nameN []string) ApiDcimPowerFeedsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNic(nameNic []string) ApiDcimPowerFeedsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNie(nameNie []string) ApiDcimPowerFeedsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNiew(nameNiew []string) ApiDcimPowerFeedsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNire(nameNire []string) ApiDcimPowerFeedsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNisw(nameNisw []string) ApiDcimPowerFeedsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameNre(nameNre []string) ApiDcimPowerFeedsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimPowerFeedsListRequest) NameRe(nameRe []string) ApiDcimPowerFeedsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerFeedsListRequest) Offset(offset int32) ApiDcimPowerFeedsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerFeedsListRequest) Phase(phase []string) ApiDcimPowerFeedsListRequest {
	r.phase = &phase
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseIc(phaseIc []string) ApiDcimPowerFeedsListRequest {
	r.phaseIc = &phaseIc
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseIe(phaseIe []string) ApiDcimPowerFeedsListRequest {
	r.phaseIe = &phaseIe
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseIew(phaseIew []string) ApiDcimPowerFeedsListRequest {
	r.phaseIew = &phaseIew
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseIre(phaseIre []string) ApiDcimPowerFeedsListRequest {
	r.phaseIre = &phaseIre
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseIsw(phaseIsw []string) ApiDcimPowerFeedsListRequest {
	r.phaseIsw = &phaseIsw
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseN(phaseN []string) ApiDcimPowerFeedsListRequest {
	r.phaseN = &phaseN
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseNic(phaseNic []string) ApiDcimPowerFeedsListRequest {
	r.phaseNic = &phaseNic
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseNie(phaseNie []string) ApiDcimPowerFeedsListRequest {
	r.phaseNie = &phaseNie
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseNiew(phaseNiew []string) ApiDcimPowerFeedsListRequest {
	r.phaseNiew = &phaseNiew
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseNire(phaseNire []string) ApiDcimPowerFeedsListRequest {
	r.phaseNire = &phaseNire
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseNisw(phaseNisw []string) ApiDcimPowerFeedsListRequest {
	r.phaseNisw = &phaseNisw
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseNre(phaseNre []string) ApiDcimPowerFeedsListRequest {
	r.phaseNre = &phaseNre
	return r
}

func (r ApiDcimPowerFeedsListRequest) PhaseRe(phaseRe []string) ApiDcimPowerFeedsListRequest {
	r.phaseRe = &phaseRe
	return r
}

func (r ApiDcimPowerFeedsListRequest) PowerPanel(powerPanel []string) ApiDcimPowerFeedsListRequest {
	r.powerPanel = &powerPanel
	return r
}

func (r ApiDcimPowerFeedsListRequest) PowerPanelN(powerPanelN []string) ApiDcimPowerFeedsListRequest {
	r.powerPanelN = &powerPanelN
	return r
}

// Search
func (r ApiDcimPowerFeedsListRequest) Q(q string) ApiDcimPowerFeedsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimPowerFeedsListRequest) Rack(rack []string) ApiDcimPowerFeedsListRequest {
	r.rack = &rack
	return r
}

func (r ApiDcimPowerFeedsListRequest) RackIsnull(rackIsnull bool) ApiDcimPowerFeedsListRequest {
	r.rackIsnull = &rackIsnull
	return r
}

func (r ApiDcimPowerFeedsListRequest) RackN(rackN []string) ApiDcimPowerFeedsListRequest {
	r.rackN = &rackN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimPowerFeedsListRequest) Sort(sort string) ApiDcimPowerFeedsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimPowerFeedsListRequest) Status(status []string) ApiDcimPowerFeedsListRequest {
	r.status = &status
	return r
}

func (r ApiDcimPowerFeedsListRequest) StatusN(statusN []string) ApiDcimPowerFeedsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimPowerFeedsListRequest) Supply(supply []string) ApiDcimPowerFeedsListRequest {
	r.supply = &supply
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyIc(supplyIc []string) ApiDcimPowerFeedsListRequest {
	r.supplyIc = &supplyIc
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyIe(supplyIe []string) ApiDcimPowerFeedsListRequest {
	r.supplyIe = &supplyIe
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyIew(supplyIew []string) ApiDcimPowerFeedsListRequest {
	r.supplyIew = &supplyIew
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyIre(supplyIre []string) ApiDcimPowerFeedsListRequest {
	r.supplyIre = &supplyIre
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyIsw(supplyIsw []string) ApiDcimPowerFeedsListRequest {
	r.supplyIsw = &supplyIsw
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyN(supplyN []string) ApiDcimPowerFeedsListRequest {
	r.supplyN = &supplyN
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyNic(supplyNic []string) ApiDcimPowerFeedsListRequest {
	r.supplyNic = &supplyNic
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyNie(supplyNie []string) ApiDcimPowerFeedsListRequest {
	r.supplyNie = &supplyNie
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyNiew(supplyNiew []string) ApiDcimPowerFeedsListRequest {
	r.supplyNiew = &supplyNiew
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyNire(supplyNire []string) ApiDcimPowerFeedsListRequest {
	r.supplyNire = &supplyNire
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyNisw(supplyNisw []string) ApiDcimPowerFeedsListRequest {
	r.supplyNisw = &supplyNisw
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyNre(supplyNre []string) ApiDcimPowerFeedsListRequest {
	r.supplyNre = &supplyNre
	return r
}

func (r ApiDcimPowerFeedsListRequest) SupplyRe(supplyRe []string) ApiDcimPowerFeedsListRequest {
	r.supplyRe = &supplyRe
	return r
}

func (r ApiDcimPowerFeedsListRequest) Tags(tags []string) ApiDcimPowerFeedsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimPowerFeedsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimPowerFeedsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimPowerFeedsListRequest) TagsN(tagsN []string) ApiDcimPowerFeedsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimPowerFeedsListRequest) Type_(type_ []string) ApiDcimPowerFeedsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeIc(typeIc []string) ApiDcimPowerFeedsListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeIe(typeIe []string) ApiDcimPowerFeedsListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeIew(typeIew []string) ApiDcimPowerFeedsListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeIre(typeIre []string) ApiDcimPowerFeedsListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeIsw(typeIsw []string) ApiDcimPowerFeedsListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeN(typeN []string) ApiDcimPowerFeedsListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeNic(typeNic []string) ApiDcimPowerFeedsListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeNie(typeNie []string) ApiDcimPowerFeedsListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeNiew(typeNiew []string) ApiDcimPowerFeedsListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeNire(typeNire []string) ApiDcimPowerFeedsListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeNisw(typeNisw []string) ApiDcimPowerFeedsListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeNre(typeNre []string) ApiDcimPowerFeedsListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimPowerFeedsListRequest) TypeRe(typeRe []string) ApiDcimPowerFeedsListRequest {
	r.typeRe = &typeRe
	return r
}

func (r ApiDcimPowerFeedsListRequest) Voltage(voltage []int32) ApiDcimPowerFeedsListRequest {
	r.voltage = &voltage
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageGt(voltageGt []int32) ApiDcimPowerFeedsListRequest {
	r.voltageGt = &voltageGt
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageGte(voltageGte []int32) ApiDcimPowerFeedsListRequest {
	r.voltageGte = &voltageGte
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageLt(voltageLt []int32) ApiDcimPowerFeedsListRequest {
	r.voltageLt = &voltageLt
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageLte(voltageLte []int32) ApiDcimPowerFeedsListRequest {
	r.voltageLte = &voltageLte
	return r
}

func (r ApiDcimPowerFeedsListRequest) VoltageN(voltageN []int32) ApiDcimPowerFeedsListRequest {
	r.voltageN = &voltageN
	return r
}

// Serializer Depth
func (r ApiDcimPowerFeedsListRequest) Depth(depth int32) ApiDcimPowerFeedsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerFeedsListRequest) Execute() (*PaginatedPowerFeedList, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsListExecute(r)
}

/*
DcimPowerFeedsList Method for DcimPowerFeedsList

Retrieve a list of power feed objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerFeedsListRequest
*/
func (a *DcimAPIService) DcimPowerFeedsList(ctx context.Context) ApiDcimPowerFeedsListRequest {
	return ApiDcimPowerFeedsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPowerFeedList
func (a *DcimAPIService) DcimPowerFeedsListExecute(r ApiDcimPowerFeedsListRequest) (*PaginatedPowerFeedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPowerFeedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.amperage != nil {
		t := *r.amperage
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amperage", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amperage", t, "multi")
		}
	}
	if r.amperageGt != nil {
		t := *r.amperageGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__gt", t, "multi")
		}
	}
	if r.amperageGte != nil {
		t := *r.amperageGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__gte", t, "multi")
		}
	}
	if r.amperageLt != nil {
		t := *r.amperageLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__lt", t, "multi")
		}
	}
	if r.amperageLte != nil {
		t := *r.amperageLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__lte", t, "multi")
		}
	}
	if r.amperageN != nil {
		t := *r.amperageN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amperage__n", t, "multi")
		}
	}
	if r.availablePower != nil {
		t := *r.availablePower
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "available_power", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "available_power", t, "multi")
		}
	}
	if r.availablePowerGt != nil {
		t := *r.availablePowerGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__gt", t, "multi")
		}
	}
	if r.availablePowerGte != nil {
		t := *r.availablePowerGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__gte", t, "multi")
		}
	}
	if r.availablePowerLt != nil {
		t := *r.availablePowerLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__lt", t, "multi")
		}
	}
	if r.availablePowerLte != nil {
		t := *r.availablePowerLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__lte", t, "multi")
		}
	}
	if r.availablePowerN != nil {
		t := *r.availablePowerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "available_power__n", t, "multi")
		}
	}
	if r.cable != nil {
		t := *r.cable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable", t, "multi")
		}
	}
	if r.cableIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cable__isnull", r.cableIsnull, "")
	}
	if r.cableN != nil {
		t := *r.cableN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", t, "multi")
		}
	}
	if r.comments != nil {
		t := *r.comments
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments", t, "multi")
		}
	}
	if r.commentsIc != nil {
		t := *r.commentsIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ic", t, "multi")
		}
	}
	if r.commentsIe != nil {
		t := *r.commentsIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ie", t, "multi")
		}
	}
	if r.commentsIew != nil {
		t := *r.commentsIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__iew", t, "multi")
		}
	}
	if r.commentsIre != nil {
		t := *r.commentsIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ire", t, "multi")
		}
	}
	if r.commentsIsw != nil {
		t := *r.commentsIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__isw", t, "multi")
		}
	}
	if r.commentsN != nil {
		t := *r.commentsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__n", t, "multi")
		}
	}
	if r.commentsNic != nil {
		t := *r.commentsNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nic", t, "multi")
		}
	}
	if r.commentsNie != nil {
		t := *r.commentsNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nie", t, "multi")
		}
	}
	if r.commentsNiew != nil {
		t := *r.commentsNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__niew", t, "multi")
		}
	}
	if r.commentsNire != nil {
		t := *r.commentsNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nire", t, "multi")
		}
	}
	if r.commentsNisw != nil {
		t := *r.commentsNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nisw", t, "multi")
		}
	}
	if r.commentsNre != nil {
		t := *r.commentsNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nre", t, "multi")
		}
	}
	if r.commentsRe != nil {
		t := *r.commentsRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__re", t, "multi")
		}
	}
	if r.connected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connected", r.connected, "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasCable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_cable", r.hasCable, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.maxUtilization != nil {
		t := *r.maxUtilization
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization", t, "multi")
		}
	}
	if r.maxUtilizationGt != nil {
		t := *r.maxUtilizationGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__gt", t, "multi")
		}
	}
	if r.maxUtilizationGte != nil {
		t := *r.maxUtilizationGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__gte", t, "multi")
		}
	}
	if r.maxUtilizationLt != nil {
		t := *r.maxUtilizationLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__lt", t, "multi")
		}
	}
	if r.maxUtilizationLte != nil {
		t := *r.maxUtilizationLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__lte", t, "multi")
		}
	}
	if r.maxUtilizationN != nil {
		t := *r.maxUtilizationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_utilization__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.phase != nil {
		t := *r.phase
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase", t, "multi")
		}
	}
	if r.phaseIc != nil {
		t := *r.phaseIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__ic", t, "multi")
		}
	}
	if r.phaseIe != nil {
		t := *r.phaseIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__ie", t, "multi")
		}
	}
	if r.phaseIew != nil {
		t := *r.phaseIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__iew", t, "multi")
		}
	}
	if r.phaseIre != nil {
		t := *r.phaseIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__ire", t, "multi")
		}
	}
	if r.phaseIsw != nil {
		t := *r.phaseIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__isw", t, "multi")
		}
	}
	if r.phaseN != nil {
		t := *r.phaseN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__n", t, "multi")
		}
	}
	if r.phaseNic != nil {
		t := *r.phaseNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nic", t, "multi")
		}
	}
	if r.phaseNie != nil {
		t := *r.phaseNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nie", t, "multi")
		}
	}
	if r.phaseNiew != nil {
		t := *r.phaseNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__niew", t, "multi")
		}
	}
	if r.phaseNire != nil {
		t := *r.phaseNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nire", t, "multi")
		}
	}
	if r.phaseNisw != nil {
		t := *r.phaseNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nisw", t, "multi")
		}
	}
	if r.phaseNre != nil {
		t := *r.phaseNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__nre", t, "multi")
		}
	}
	if r.phaseRe != nil {
		t := *r.phaseRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "phase__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "phase__re", t, "multi")
		}
	}
	if r.powerPanel != nil {
		t := *r.powerPanel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_panel", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_panel", t, "multi")
		}
	}
	if r.powerPanelN != nil {
		t := *r.powerPanelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_panel__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_panel__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rack != nil {
		t := *r.rack
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack", t, "multi")
		}
	}
	if r.rackIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack__isnull", r.rackIsnull, "")
	}
	if r.rackN != nil {
		t := *r.rackN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.supply != nil {
		t := *r.supply
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply", t, "multi")
		}
	}
	if r.supplyIc != nil {
		t := *r.supplyIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__ic", t, "multi")
		}
	}
	if r.supplyIe != nil {
		t := *r.supplyIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__ie", t, "multi")
		}
	}
	if r.supplyIew != nil {
		t := *r.supplyIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__iew", t, "multi")
		}
	}
	if r.supplyIre != nil {
		t := *r.supplyIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__ire", t, "multi")
		}
	}
	if r.supplyIsw != nil {
		t := *r.supplyIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__isw", t, "multi")
		}
	}
	if r.supplyN != nil {
		t := *r.supplyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__n", t, "multi")
		}
	}
	if r.supplyNic != nil {
		t := *r.supplyNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nic", t, "multi")
		}
	}
	if r.supplyNie != nil {
		t := *r.supplyNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nie", t, "multi")
		}
	}
	if r.supplyNiew != nil {
		t := *r.supplyNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__niew", t, "multi")
		}
	}
	if r.supplyNire != nil {
		t := *r.supplyNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nire", t, "multi")
		}
	}
	if r.supplyNisw != nil {
		t := *r.supplyNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nisw", t, "multi")
		}
	}
	if r.supplyNre != nil {
		t := *r.supplyNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__nre", t, "multi")
		}
	}
	if r.supplyRe != nil {
		t := *r.supplyRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supply__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supply__re", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.voltage != nil {
		t := *r.voltage
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "voltage", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "voltage", t, "multi")
		}
	}
	if r.voltageGt != nil {
		t := *r.voltageGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__gt", t, "multi")
		}
	}
	if r.voltageGte != nil {
		t := *r.voltageGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__gte", t, "multi")
		}
	}
	if r.voltageLt != nil {
		t := *r.voltageLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__lt", t, "multi")
		}
	}
	if r.voltageLte != nil {
		t := *r.voltageLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__lte", t, "multi")
		}
	}
	if r.voltageN != nil {
		t := *r.voltageN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "voltage__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerFeedsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimPowerFeedsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimPowerFeedsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerFeedsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsNotesCreateExecute(r)
}

/*
DcimPowerFeedsNotesCreate Method for DcimPowerFeedsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power feed.
 @return ApiDcimPowerFeedsNotesCreateRequest
*/
func (a *DcimAPIService) DcimPowerFeedsNotesCreate(ctx context.Context, id string) ApiDcimPowerFeedsNotesCreateRequest {
	return ApiDcimPowerFeedsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimPowerFeedsNotesCreateExecute(r ApiDcimPowerFeedsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimPowerFeedsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerFeedsNotesListRequest) Limit(limit int32) ApiDcimPowerFeedsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerFeedsNotesListRequest) Offset(offset int32) ApiDcimPowerFeedsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimPowerFeedsNotesListRequest) Depth(depth int32) ApiDcimPowerFeedsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerFeedsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsNotesListExecute(r)
}

/*
DcimPowerFeedsNotesList Method for DcimPowerFeedsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power feed.
 @return ApiDcimPowerFeedsNotesListRequest
*/
func (a *DcimAPIService) DcimPowerFeedsNotesList(ctx context.Context, id string) ApiDcimPowerFeedsNotesListRequest {
	return ApiDcimPowerFeedsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimPowerFeedsNotesListExecute(r ApiDcimPowerFeedsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritablePowerFeedRequest *PatchedWritablePowerFeedRequest
}

func (r ApiDcimPowerFeedsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerFeedsPartialUpdateRequest) PatchedWritablePowerFeedRequest(patchedWritablePowerFeedRequest PatchedWritablePowerFeedRequest) ApiDcimPowerFeedsPartialUpdateRequest {
	r.patchedWritablePowerFeedRequest = &patchedWritablePowerFeedRequest
	return r
}

func (r ApiDcimPowerFeedsPartialUpdateRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsPartialUpdateExecute(r)
}

/*
DcimPowerFeedsPartialUpdate Method for DcimPowerFeedsPartialUpdate

Partial update a power feed object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power feed.
 @return ApiDcimPowerFeedsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerFeedsPartialUpdate(ctx context.Context, id string) ApiDcimPowerFeedsPartialUpdateRequest {
	return ApiDcimPowerFeedsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimAPIService) DcimPowerFeedsPartialUpdateExecute(r ApiDcimPowerFeedsPartialUpdateRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePowerFeedRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerFeedsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerFeedsRetrieveRequest) Depth(depth int32) ApiDcimPowerFeedsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerFeedsRetrieveRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsRetrieveExecute(r)
}

/*
DcimPowerFeedsRetrieve Method for DcimPowerFeedsRetrieve

Retrieve a power feed object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power feed.
 @return ApiDcimPowerFeedsRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerFeedsRetrieve(ctx context.Context, id string) ApiDcimPowerFeedsRetrieveRequest {
	return ApiDcimPowerFeedsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimAPIService) DcimPowerFeedsRetrieveExecute(r ApiDcimPowerFeedsRetrieveRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsTraceRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerFeedsTraceRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsTraceRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerFeedsTraceRetrieveRequest) Depth(depth int32) ApiDcimPowerFeedsTraceRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerFeedsTraceRetrieveRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsTraceRetrieveExecute(r)
}

/*
DcimPowerFeedsTraceRetrieve Method for DcimPowerFeedsTraceRetrieve

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power feed.
 @return ApiDcimPowerFeedsTraceRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerFeedsTraceRetrieve(ctx context.Context, id string) ApiDcimPowerFeedsTraceRetrieveRequest {
	return ApiDcimPowerFeedsTraceRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimAPIService) DcimPowerFeedsTraceRetrieveExecute(r ApiDcimPowerFeedsTraceRetrieveRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsTraceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerFeedsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writablePowerFeedRequest *WritablePowerFeedRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerFeedsUpdateRequest) WritablePowerFeedRequest(writablePowerFeedRequest WritablePowerFeedRequest) ApiDcimPowerFeedsUpdateRequest {
	r.writablePowerFeedRequest = &writablePowerFeedRequest
	return r
}

func (r ApiDcimPowerFeedsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerFeedsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerFeedsUpdateRequest) Execute() (*PowerFeed, *http.Response, error) {
	return r.ApiService.DcimPowerFeedsUpdateExecute(r)
}

/*
DcimPowerFeedsUpdate Method for DcimPowerFeedsUpdate

Update a power feed object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power feed.
 @return ApiDcimPowerFeedsUpdateRequest
*/
func (a *DcimAPIService) DcimPowerFeedsUpdate(ctx context.Context, id string) ApiDcimPowerFeedsUpdateRequest {
	return ApiDcimPowerFeedsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerFeed
func (a *DcimAPIService) DcimPowerFeedsUpdateExecute(r ApiDcimPowerFeedsUpdateRequest) (*PowerFeed, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerFeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerFeedsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerFeedRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerFeedRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerFeedRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletTemplatesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimPowerOutletTemplatesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimPowerOutletTemplatesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesBulkDestroyExecute(r)
}

/*
DcimPowerOutletTemplatesBulkDestroy Method for DcimPowerOutletTemplatesBulkDestroy

Destroy a list of power outlet template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesBulkDestroy(ctx context.Context) ApiDcimPowerOutletTemplatesBulkDestroyRequest {
	return ApiDcimPowerOutletTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerOutletTemplatesBulkDestroyExecute(r ApiDcimPowerOutletTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritablePowerOutletTemplateRequest *[]PatchedBulkWritablePowerOutletTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest) PatchedBulkWritablePowerOutletTemplateRequest(patchedBulkWritablePowerOutletTemplateRequest []PatchedBulkWritablePowerOutletTemplateRequest) ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest {
	r.patchedBulkWritablePowerOutletTemplateRequest = &patchedBulkWritablePowerOutletTemplateRequest
	return r
}

func (r ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest) Execute() ([]PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimPowerOutletTemplatesBulkPartialUpdate Method for DcimPowerOutletTemplatesBulkPartialUpdate

Partial update a list of power outlet template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest {
	return ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerOutletTemplate
func (a *DcimAPIService) DcimPowerOutletTemplatesBulkPartialUpdateExecute(r ApiDcimPowerOutletTemplatesBulkPartialUpdateRequest) ([]PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePowerOutletTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePowerOutletTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePowerOutletTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritablePowerOutletTemplateRequest *[]BulkWritablePowerOutletTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletTemplatesBulkUpdateRequest) BulkWritablePowerOutletTemplateRequest(bulkWritablePowerOutletTemplateRequest []BulkWritablePowerOutletTemplateRequest) ApiDcimPowerOutletTemplatesBulkUpdateRequest {
	r.bulkWritablePowerOutletTemplateRequest = &bulkWritablePowerOutletTemplateRequest
	return r
}

func (r ApiDcimPowerOutletTemplatesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletTemplatesBulkUpdateRequest) Execute() ([]PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesBulkUpdateExecute(r)
}

/*
DcimPowerOutletTemplatesBulkUpdate Method for DcimPowerOutletTemplatesBulkUpdate

Update a list of power outlet template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesBulkUpdate(ctx context.Context) ApiDcimPowerOutletTemplatesBulkUpdateRequest {
	return ApiDcimPowerOutletTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerOutletTemplate
func (a *DcimAPIService) DcimPowerOutletTemplatesBulkUpdateExecute(r ApiDcimPowerOutletTemplatesBulkUpdateRequest) ([]PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePowerOutletTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePowerOutletTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePowerOutletTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writablePowerOutletTemplateRequest *WritablePowerOutletTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletTemplatesCreateRequest) WritablePowerOutletTemplateRequest(writablePowerOutletTemplateRequest WritablePowerOutletTemplateRequest) ApiDcimPowerOutletTemplatesCreateRequest {
	r.writablePowerOutletTemplateRequest = &writablePowerOutletTemplateRequest
	return r
}

func (r ApiDcimPowerOutletTemplatesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletTemplatesCreateRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesCreateExecute(r)
}

/*
DcimPowerOutletTemplatesCreate Method for DcimPowerOutletTemplatesCreate

Create one or more power outlet template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesCreateRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesCreate(ctx context.Context) ApiDcimPowerOutletTemplatesCreateRequest {
	return ApiDcimPowerOutletTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimAPIService) DcimPowerOutletTemplatesCreateExecute(r ApiDcimPowerOutletTemplatesCreateRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerOutletTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerOutletTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerOutletTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletTemplatesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesDestroyExecute(r)
}

/*
DcimPowerOutletTemplatesDestroy Method for DcimPowerOutletTemplatesDestroy

Destroy a power outlet template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesDestroyRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesDestroy(ctx context.Context, id string) ApiDcimPowerOutletTemplatesDestroyRequest {
	return ApiDcimPowerOutletTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerOutletTemplatesDestroyExecute(r ApiDcimPowerOutletTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceType *[]string
	deviceTypeN *[]string
	feedLeg *[]string
	feedLegIc *[]string
	feedLegIe *[]string
	feedLegIew *[]string
	feedLegIre *[]string
	feedLegIsw *[]string
	feedLegN *[]string
	feedLegNic *[]string
	feedLegNie *[]string
	feedLegNiew *[]string
	feedLegNire *[]string
	feedLegNisw *[]string
	feedLegNre *[]string
	feedLegRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	powerPortTemplate *[]string
	powerPortTemplateIsnull *bool
	powerPortTemplateN *[]string
	q *string
	sort *string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) Description(description []string) ApiDcimPowerOutletTemplatesListRequest {
	r.description = &description
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionIre(descriptionIre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionN(descriptionN []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionNire(descriptionNire []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionNre(descriptionNre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

// Description
func (r ApiDcimPowerOutletTemplatesListRequest) DescriptionRe(descriptionRe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) DeviceType(deviceType []string) ApiDcimPowerOutletTemplatesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimPowerOutletTemplatesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

// Phase (for three-phase feeds)
func (r ApiDcimPowerOutletTemplatesListRequest) FeedLeg(feedLeg []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLeg = &feedLeg
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegIc(feedLegIc []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegIc = &feedLegIc
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegIe(feedLegIe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegIe = &feedLegIe
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegIew(feedLegIew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegIew = &feedLegIew
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegIre(feedLegIre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegIre = &feedLegIre
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegIsw(feedLegIsw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegIsw = &feedLegIsw
	return r
}

// Phase (for three-phase feeds)
func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegN(feedLegN []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegN = &feedLegN
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegNic(feedLegNic []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegNic = &feedLegNic
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegNie(feedLegNie []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegNie = &feedLegNie
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegNiew(feedLegNiew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegNiew = &feedLegNiew
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegNire(feedLegNire []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegNire = &feedLegNire
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegNisw(feedLegNisw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegNisw = &feedLegNisw
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegNre(feedLegNre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegNre = &feedLegNre
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) FeedLegRe(feedLegRe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.feedLegRe = &feedLegRe
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesListRequest {
	r.format = &format
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) Id(id []string) ApiDcimPowerOutletTemplatesListRequest {
	r.id = &id
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdIc(idIc []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idIc = &idIc
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdIe(idIe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idIe = &idIe
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdIew(idIew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idIew = &idIew
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdIre(idIre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idIre = &idIre
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdIsw(idIsw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idIsw = &idIsw
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdN(idN []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idN = &idN
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdNic(idNic []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idNic = &idNic
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdNie(idNie []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idNie = &idNie
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdNiew(idNiew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idNiew = &idNiew
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdNire(idNire []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idNire = &idNire
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdNisw(idNisw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idNisw = &idNisw
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdNre(idNre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idNre = &idNre
	return r
}

// ID
func (r ApiDcimPowerOutletTemplatesListRequest) IdRe(idRe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.idRe = &idRe
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) Label(label []string) ApiDcimPowerOutletTemplatesListRequest {
	r.label = &label
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelIc(labelIc []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelIc = &labelIc
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelIe(labelIe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelIe = &labelIe
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelIew(labelIew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelIew = &labelIew
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelIre(labelIre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelIre = &labelIre
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelIsw(labelIsw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelIsw = &labelIsw
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelN(labelN []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelN = &labelN
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelNic(labelNic []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelNic = &labelNic
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelNie(labelNie []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelNie = &labelNie
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelNiew(labelNiew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelNiew = &labelNiew
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelNire(labelNire []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelNire = &labelNire
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelNisw(labelNisw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelNisw = &labelNisw
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelNre(labelNre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelNre = &labelNre
	return r
}

// Label
func (r ApiDcimPowerOutletTemplatesListRequest) LabelRe(labelRe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerOutletTemplatesListRequest) Limit(limit int32) ApiDcimPowerOutletTemplatesListRequest {
	r.limit = &limit
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) Name(name []string) ApiDcimPowerOutletTemplatesListRequest {
	r.name = &name
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameIc(nameIc []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameIe(nameIe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameIew(nameIew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameIre(nameIre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIre = &nameIre
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameIsw(nameIsw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameN(nameN []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameN = &nameN
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameNic(nameNic []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameNie(nameNie []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameNiew(nameNiew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameNire(nameNire []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNire = &nameNire
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameNisw(nameNisw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameNre(nameNre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameNre = &nameNre
	return r
}

// Name
func (r ApiDcimPowerOutletTemplatesListRequest) NameRe(nameRe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerOutletTemplatesListRequest) Offset(offset int32) ApiDcimPowerOutletTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) PowerPortTemplate(powerPortTemplate []string) ApiDcimPowerOutletTemplatesListRequest {
	r.powerPortTemplate = &powerPortTemplate
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) PowerPortTemplateIsnull(powerPortTemplateIsnull bool) ApiDcimPowerOutletTemplatesListRequest {
	r.powerPortTemplateIsnull = &powerPortTemplateIsnull
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) PowerPortTemplateN(powerPortTemplateN []string) ApiDcimPowerOutletTemplatesListRequest {
	r.powerPortTemplateN = &powerPortTemplateN
	return r
}

// Search
func (r ApiDcimPowerOutletTemplatesListRequest) Q(q string) ApiDcimPowerOutletTemplatesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimPowerOutletTemplatesListRequest) Sort(sort string) ApiDcimPowerOutletTemplatesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) Type_(type_ []string) ApiDcimPowerOutletTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeIc(typeIc []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeIe(typeIe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeIew(typeIew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeIre(typeIre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeIsw(typeIsw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeN(typeN []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeNic(typeNic []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeNie(typeNie []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeNiew(typeNiew []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeNire(typeNire []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeNisw(typeNisw []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeNre(typeNre []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) TypeRe(typeRe []string) ApiDcimPowerOutletTemplatesListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimPowerOutletTemplatesListRequest) Depth(depth int32) ApiDcimPowerOutletTemplatesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerOutletTemplatesListRequest) Execute() (*PaginatedPowerOutletTemplateList, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesListExecute(r)
}

/*
DcimPowerOutletTemplatesList Method for DcimPowerOutletTemplatesList

Retrieve a list of power outlet template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletTemplatesListRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesList(ctx context.Context) ApiDcimPowerOutletTemplatesListRequest {
	return ApiDcimPowerOutletTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPowerOutletTemplateList
func (a *DcimAPIService) DcimPowerOutletTemplatesListExecute(r ApiDcimPowerOutletTemplatesListRequest) (*PaginatedPowerOutletTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPowerOutletTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.feedLeg != nil {
		t := *r.feedLeg
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg", t, "multi")
		}
	}
	if r.feedLegIc != nil {
		t := *r.feedLegIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ic", t, "multi")
		}
	}
	if r.feedLegIe != nil {
		t := *r.feedLegIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ie", t, "multi")
		}
	}
	if r.feedLegIew != nil {
		t := *r.feedLegIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__iew", t, "multi")
		}
	}
	if r.feedLegIre != nil {
		t := *r.feedLegIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ire", t, "multi")
		}
	}
	if r.feedLegIsw != nil {
		t := *r.feedLegIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__isw", t, "multi")
		}
	}
	if r.feedLegN != nil {
		t := *r.feedLegN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__n", t, "multi")
		}
	}
	if r.feedLegNic != nil {
		t := *r.feedLegNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nic", t, "multi")
		}
	}
	if r.feedLegNie != nil {
		t := *r.feedLegNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nie", t, "multi")
		}
	}
	if r.feedLegNiew != nil {
		t := *r.feedLegNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__niew", t, "multi")
		}
	}
	if r.feedLegNire != nil {
		t := *r.feedLegNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nire", t, "multi")
		}
	}
	if r.feedLegNisw != nil {
		t := *r.feedLegNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nisw", t, "multi")
		}
	}
	if r.feedLegNre != nil {
		t := *r.feedLegNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nre", t, "multi")
		}
	}
	if r.feedLegRe != nil {
		t := *r.feedLegRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.powerPortTemplate != nil {
		t := *r.powerPortTemplate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_template", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_template", t, "multi")
		}
	}
	if r.powerPortTemplateIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_template__isnull", r.powerPortTemplateIsnull, "")
	}
	if r.powerPortTemplateN != nil {
		t := *r.powerPortTemplateN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_template__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_port_template__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletTemplatesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimPowerOutletTemplatesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimPowerOutletTemplatesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletTemplatesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesNotesCreateExecute(r)
}

/*
DcimPowerOutletTemplatesNotesCreate Method for DcimPowerOutletTemplatesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesNotesCreateRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesNotesCreate(ctx context.Context, id string) ApiDcimPowerOutletTemplatesNotesCreateRequest {
	return ApiDcimPowerOutletTemplatesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimPowerOutletTemplatesNotesCreateExecute(r ApiDcimPowerOutletTemplatesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimPowerOutletTemplatesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerOutletTemplatesNotesListRequest) Limit(limit int32) ApiDcimPowerOutletTemplatesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerOutletTemplatesNotesListRequest) Offset(offset int32) ApiDcimPowerOutletTemplatesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimPowerOutletTemplatesNotesListRequest) Depth(depth int32) ApiDcimPowerOutletTemplatesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerOutletTemplatesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesNotesListExecute(r)
}

/*
DcimPowerOutletTemplatesNotesList Method for DcimPowerOutletTemplatesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesNotesListRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesNotesList(ctx context.Context, id string) ApiDcimPowerOutletTemplatesNotesListRequest {
	return ApiDcimPowerOutletTemplatesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimPowerOutletTemplatesNotesListExecute(r ApiDcimPowerOutletTemplatesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritablePowerOutletTemplateRequest *PatchedWritablePowerOutletTemplateRequest
}

func (r ApiDcimPowerOutletTemplatesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletTemplatesPartialUpdateRequest) PatchedWritablePowerOutletTemplateRequest(patchedWritablePowerOutletTemplateRequest PatchedWritablePowerOutletTemplateRequest) ApiDcimPowerOutletTemplatesPartialUpdateRequest {
	r.patchedWritablePowerOutletTemplateRequest = &patchedWritablePowerOutletTemplateRequest
	return r
}

func (r ApiDcimPowerOutletTemplatesPartialUpdateRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesPartialUpdateExecute(r)
}

/*
DcimPowerOutletTemplatesPartialUpdate Method for DcimPowerOutletTemplatesPartialUpdate

Partial update a power outlet template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesPartialUpdate(ctx context.Context, id string) ApiDcimPowerOutletTemplatesPartialUpdateRequest {
	return ApiDcimPowerOutletTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimAPIService) DcimPowerOutletTemplatesPartialUpdateExecute(r ApiDcimPowerOutletTemplatesPartialUpdateRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePowerOutletTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerOutletTemplatesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerOutletTemplatesRetrieveRequest) Depth(depth int32) ApiDcimPowerOutletTemplatesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerOutletTemplatesRetrieveRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesRetrieveExecute(r)
}

/*
DcimPowerOutletTemplatesRetrieve Method for DcimPowerOutletTemplatesRetrieve

Retrieve a power outlet template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesRetrieve(ctx context.Context, id string) ApiDcimPowerOutletTemplatesRetrieveRequest {
	return ApiDcimPowerOutletTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimAPIService) DcimPowerOutletTemplatesRetrieveExecute(r ApiDcimPowerOutletTemplatesRetrieveRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writablePowerOutletTemplateRequest *WritablePowerOutletTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletTemplatesUpdateRequest) WritablePowerOutletTemplateRequest(writablePowerOutletTemplateRequest WritablePowerOutletTemplateRequest) ApiDcimPowerOutletTemplatesUpdateRequest {
	r.writablePowerOutletTemplateRequest = &writablePowerOutletTemplateRequest
	return r
}

func (r ApiDcimPowerOutletTemplatesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletTemplatesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletTemplatesUpdateRequest) Execute() (*PowerOutletTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerOutletTemplatesUpdateExecute(r)
}

/*
DcimPowerOutletTemplatesUpdate Method for DcimPowerOutletTemplatesUpdate

Update a power outlet template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet template.
 @return ApiDcimPowerOutletTemplatesUpdateRequest
*/
func (a *DcimAPIService) DcimPowerOutletTemplatesUpdate(ctx context.Context, id string) ApiDcimPowerOutletTemplatesUpdateRequest {
	return ApiDcimPowerOutletTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutletTemplate
func (a *DcimAPIService) DcimPowerOutletTemplatesUpdateExecute(r ApiDcimPowerOutletTemplatesUpdateRequest) (*PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutletTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerOutletTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerOutletTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerOutletTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimPowerOutletsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimPowerOutletsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerOutletsBulkDestroyExecute(r)
}

/*
DcimPowerOutletsBulkDestroy Method for DcimPowerOutletsBulkDestroy

Destroy a list of power outlet objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimPowerOutletsBulkDestroy(ctx context.Context) ApiDcimPowerOutletsBulkDestroyRequest {
	return ApiDcimPowerOutletsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerOutletsBulkDestroyExecute(r ApiDcimPowerOutletsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritablePowerOutletRequest *[]PatchedBulkWritablePowerOutletRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletsBulkPartialUpdateRequest) PatchedBulkWritablePowerOutletRequest(patchedBulkWritablePowerOutletRequest []PatchedBulkWritablePowerOutletRequest) ApiDcimPowerOutletsBulkPartialUpdateRequest {
	r.patchedBulkWritablePowerOutletRequest = &patchedBulkWritablePowerOutletRequest
	return r
}

func (r ApiDcimPowerOutletsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletsBulkPartialUpdateRequest) Execute() ([]PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsBulkPartialUpdateExecute(r)
}

/*
DcimPowerOutletsBulkPartialUpdate Method for DcimPowerOutletsBulkPartialUpdate

Partial update a list of power outlet objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerOutletsBulkPartialUpdate(ctx context.Context) ApiDcimPowerOutletsBulkPartialUpdateRequest {
	return ApiDcimPowerOutletsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerOutlet
func (a *DcimAPIService) DcimPowerOutletsBulkPartialUpdateExecute(r ApiDcimPowerOutletsBulkPartialUpdateRequest) ([]PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePowerOutletRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePowerOutletRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePowerOutletRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritablePowerOutletRequest *[]BulkWritablePowerOutletRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletsBulkUpdateRequest) BulkWritablePowerOutletRequest(bulkWritablePowerOutletRequest []BulkWritablePowerOutletRequest) ApiDcimPowerOutletsBulkUpdateRequest {
	r.bulkWritablePowerOutletRequest = &bulkWritablePowerOutletRequest
	return r
}

func (r ApiDcimPowerOutletsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletsBulkUpdateRequest) Execute() ([]PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsBulkUpdateExecute(r)
}

/*
DcimPowerOutletsBulkUpdate Method for DcimPowerOutletsBulkUpdate

Update a list of power outlet objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimPowerOutletsBulkUpdate(ctx context.Context) ApiDcimPowerOutletsBulkUpdateRequest {
	return ApiDcimPowerOutletsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerOutlet
func (a *DcimAPIService) DcimPowerOutletsBulkUpdateExecute(r ApiDcimPowerOutletsBulkUpdateRequest) ([]PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePowerOutletRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePowerOutletRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePowerOutletRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writablePowerOutletRequest *WritablePowerOutletRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletsCreateRequest) WritablePowerOutletRequest(writablePowerOutletRequest WritablePowerOutletRequest) ApiDcimPowerOutletsCreateRequest {
	r.writablePowerOutletRequest = &writablePowerOutletRequest
	return r
}

func (r ApiDcimPowerOutletsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletsCreateRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsCreateExecute(r)
}

/*
DcimPowerOutletsCreate Method for DcimPowerOutletsCreate

Create one or more power outlet objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsCreateRequest
*/
func (a *DcimAPIService) DcimPowerOutletsCreate(ctx context.Context) ApiDcimPowerOutletsCreateRequest {
	return ApiDcimPowerOutletsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimAPIService) DcimPowerOutletsCreateExecute(r ApiDcimPowerOutletsCreateRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerOutletRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerOutletRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerOutletRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerOutletsDestroyExecute(r)
}

/*
DcimPowerOutletsDestroy Method for DcimPowerOutletsDestroy

Destroy a power outlet object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet.
 @return ApiDcimPowerOutletsDestroyRequest
*/
func (a *DcimAPIService) DcimPowerOutletsDestroy(ctx context.Context, id string) ApiDcimPowerOutletsDestroyRequest {
	return ApiDcimPowerOutletsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerOutletsDestroyExecute(r ApiDcimPowerOutletsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	cable *[]string
	cableIsnull *bool
	cableN *[]string
	connected *bool
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceN *[]string
	feedLeg *[]string
	feedLegIc *[]string
	feedLegIe *[]string
	feedLegIew *[]string
	feedLegIre *[]string
	feedLegIsw *[]string
	feedLegN *[]string
	feedLegNic *[]string
	feedLegNie *[]string
	feedLegNiew *[]string
	feedLegNire *[]string
	feedLegNisw *[]string
	feedLegNre *[]string
	feedLegRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasCable *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	powerPort *[]string
	powerPortIsnull *bool
	powerPortN *[]string
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Cable
func (r ApiDcimPowerOutletsListRequest) Cable(cable []string) ApiDcimPowerOutletsListRequest {
	r.cable = &cable
	return r
}

func (r ApiDcimPowerOutletsListRequest) CableIsnull(cableIsnull bool) ApiDcimPowerOutletsListRequest {
	r.cableIsnull = &cableIsnull
	return r
}

// Cable
func (r ApiDcimPowerOutletsListRequest) CableN(cableN []string) ApiDcimPowerOutletsListRequest {
	r.cableN = &cableN
	return r
}

// Connected status (bool)
func (r ApiDcimPowerOutletsListRequest) Connected(connected bool) ApiDcimPowerOutletsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimPowerOutletsListRequest) Description(description []string) ApiDcimPowerOutletsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIc(descriptionIc []string) ApiDcimPowerOutletsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIe(descriptionIe []string) ApiDcimPowerOutletsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIew(descriptionIew []string) ApiDcimPowerOutletsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIre(descriptionIre []string) ApiDcimPowerOutletsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimPowerOutletsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionN(descriptionN []string) ApiDcimPowerOutletsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNic(descriptionNic []string) ApiDcimPowerOutletsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNie(descriptionNie []string) ApiDcimPowerOutletsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimPowerOutletsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNire(descriptionNire []string) ApiDcimPowerOutletsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimPowerOutletsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionNre(descriptionNre []string) ApiDcimPowerOutletsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimPowerOutletsListRequest) DescriptionRe(descriptionRe []string) ApiDcimPowerOutletsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimPowerOutletsListRequest) Device(device []string) ApiDcimPowerOutletsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimPowerOutletsListRequest) DeviceN(deviceN []string) ApiDcimPowerOutletsListRequest {
	r.deviceN = &deviceN
	return r
}

// Phase (for three-phase feeds)
func (r ApiDcimPowerOutletsListRequest) FeedLeg(feedLeg []string) ApiDcimPowerOutletsListRequest {
	r.feedLeg = &feedLeg
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegIc(feedLegIc []string) ApiDcimPowerOutletsListRequest {
	r.feedLegIc = &feedLegIc
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegIe(feedLegIe []string) ApiDcimPowerOutletsListRequest {
	r.feedLegIe = &feedLegIe
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegIew(feedLegIew []string) ApiDcimPowerOutletsListRequest {
	r.feedLegIew = &feedLegIew
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegIre(feedLegIre []string) ApiDcimPowerOutletsListRequest {
	r.feedLegIre = &feedLegIre
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegIsw(feedLegIsw []string) ApiDcimPowerOutletsListRequest {
	r.feedLegIsw = &feedLegIsw
	return r
}

// Phase (for three-phase feeds)
func (r ApiDcimPowerOutletsListRequest) FeedLegN(feedLegN []string) ApiDcimPowerOutletsListRequest {
	r.feedLegN = &feedLegN
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegNic(feedLegNic []string) ApiDcimPowerOutletsListRequest {
	r.feedLegNic = &feedLegNic
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegNie(feedLegNie []string) ApiDcimPowerOutletsListRequest {
	r.feedLegNie = &feedLegNie
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegNiew(feedLegNiew []string) ApiDcimPowerOutletsListRequest {
	r.feedLegNiew = &feedLegNiew
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegNire(feedLegNire []string) ApiDcimPowerOutletsListRequest {
	r.feedLegNire = &feedLegNire
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegNisw(feedLegNisw []string) ApiDcimPowerOutletsListRequest {
	r.feedLegNisw = &feedLegNisw
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegNre(feedLegNre []string) ApiDcimPowerOutletsListRequest {
	r.feedLegNre = &feedLegNre
	return r
}

func (r ApiDcimPowerOutletsListRequest) FeedLegRe(feedLegRe []string) ApiDcimPowerOutletsListRequest {
	r.feedLegRe = &feedLegRe
	return r
}

func (r ApiDcimPowerOutletsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsListRequest {
	r.format = &format
	return r
}

// Has cable
func (r ApiDcimPowerOutletsListRequest) HasCable(hasCable bool) ApiDcimPowerOutletsListRequest {
	r.hasCable = &hasCable
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimPowerOutletsListRequest) Id(id []string) ApiDcimPowerOutletsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdIc(idIc []string) ApiDcimPowerOutletsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdIe(idIe []string) ApiDcimPowerOutletsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdIew(idIew []string) ApiDcimPowerOutletsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdIre(idIre []string) ApiDcimPowerOutletsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdIsw(idIsw []string) ApiDcimPowerOutletsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdN(idN []string) ApiDcimPowerOutletsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdNic(idNic []string) ApiDcimPowerOutletsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdNie(idNie []string) ApiDcimPowerOutletsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdNiew(idNiew []string) ApiDcimPowerOutletsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdNire(idNire []string) ApiDcimPowerOutletsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdNisw(idNisw []string) ApiDcimPowerOutletsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdNre(idNre []string) ApiDcimPowerOutletsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimPowerOutletsListRequest) IdRe(idRe []string) ApiDcimPowerOutletsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimPowerOutletsListRequest) Label(label []string) ApiDcimPowerOutletsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIc(labelIc []string) ApiDcimPowerOutletsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIe(labelIe []string) ApiDcimPowerOutletsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIew(labelIew []string) ApiDcimPowerOutletsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIre(labelIre []string) ApiDcimPowerOutletsListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelIsw(labelIsw []string) ApiDcimPowerOutletsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelN(labelN []string) ApiDcimPowerOutletsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNic(labelNic []string) ApiDcimPowerOutletsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNie(labelNie []string) ApiDcimPowerOutletsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNiew(labelNiew []string) ApiDcimPowerOutletsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNire(labelNire []string) ApiDcimPowerOutletsListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNisw(labelNisw []string) ApiDcimPowerOutletsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelNre(labelNre []string) ApiDcimPowerOutletsListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimPowerOutletsListRequest) LabelRe(labelRe []string) ApiDcimPowerOutletsListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerOutletsListRequest) Limit(limit int32) ApiDcimPowerOutletsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimPowerOutletsListRequest) Location(location []string) ApiDcimPowerOutletsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimPowerOutletsListRequest) LocationN(locationN []string) ApiDcimPowerOutletsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimPowerOutletsListRequest) Name(name []string) ApiDcimPowerOutletsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIc(nameIc []string) ApiDcimPowerOutletsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIe(nameIe []string) ApiDcimPowerOutletsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIew(nameIew []string) ApiDcimPowerOutletsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIre(nameIre []string) ApiDcimPowerOutletsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameIsw(nameIsw []string) ApiDcimPowerOutletsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameN(nameN []string) ApiDcimPowerOutletsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNic(nameNic []string) ApiDcimPowerOutletsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNie(nameNie []string) ApiDcimPowerOutletsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNiew(nameNiew []string) ApiDcimPowerOutletsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNire(nameNire []string) ApiDcimPowerOutletsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNisw(nameNisw []string) ApiDcimPowerOutletsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameNre(nameNre []string) ApiDcimPowerOutletsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimPowerOutletsListRequest) NameRe(nameRe []string) ApiDcimPowerOutletsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerOutletsListRequest) Offset(offset int32) ApiDcimPowerOutletsListRequest {
	r.offset = &offset
	return r
}

// Power port
func (r ApiDcimPowerOutletsListRequest) PowerPort(powerPort []string) ApiDcimPowerOutletsListRequest {
	r.powerPort = &powerPort
	return r
}

func (r ApiDcimPowerOutletsListRequest) PowerPortIsnull(powerPortIsnull bool) ApiDcimPowerOutletsListRequest {
	r.powerPortIsnull = &powerPortIsnull
	return r
}

// Power port
func (r ApiDcimPowerOutletsListRequest) PowerPortN(powerPortN []string) ApiDcimPowerOutletsListRequest {
	r.powerPortN = &powerPortN
	return r
}

// Search
func (r ApiDcimPowerOutletsListRequest) Q(q string) ApiDcimPowerOutletsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimPowerOutletsListRequest) Sort(sort string) ApiDcimPowerOutletsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimPowerOutletsListRequest) Tags(tags []string) ApiDcimPowerOutletsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimPowerOutletsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimPowerOutletsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimPowerOutletsListRequest) TagsN(tagsN []string) ApiDcimPowerOutletsListRequest {
	r.tagsN = &tagsN
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) Type_(type_ []string) ApiDcimPowerOutletsListRequest {
	r.type_ = &type_
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeIc(typeIc []string) ApiDcimPowerOutletsListRequest {
	r.typeIc = &typeIc
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeIe(typeIe []string) ApiDcimPowerOutletsListRequest {
	r.typeIe = &typeIe
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeIew(typeIew []string) ApiDcimPowerOutletsListRequest {
	r.typeIew = &typeIew
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeIre(typeIre []string) ApiDcimPowerOutletsListRequest {
	r.typeIre = &typeIre
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeIsw(typeIsw []string) ApiDcimPowerOutletsListRequest {
	r.typeIsw = &typeIsw
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeN(typeN []string) ApiDcimPowerOutletsListRequest {
	r.typeN = &typeN
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeNic(typeNic []string) ApiDcimPowerOutletsListRequest {
	r.typeNic = &typeNic
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeNie(typeNie []string) ApiDcimPowerOutletsListRequest {
	r.typeNie = &typeNie
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeNiew(typeNiew []string) ApiDcimPowerOutletsListRequest {
	r.typeNiew = &typeNiew
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeNire(typeNire []string) ApiDcimPowerOutletsListRequest {
	r.typeNire = &typeNire
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeNisw(typeNisw []string) ApiDcimPowerOutletsListRequest {
	r.typeNisw = &typeNisw
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeNre(typeNre []string) ApiDcimPowerOutletsListRequest {
	r.typeNre = &typeNre
	return r
}

// Physical port type
func (r ApiDcimPowerOutletsListRequest) TypeRe(typeRe []string) ApiDcimPowerOutletsListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimPowerOutletsListRequest) Depth(depth int32) ApiDcimPowerOutletsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerOutletsListRequest) Execute() (*PaginatedPowerOutletList, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsListExecute(r)
}

/*
DcimPowerOutletsList Method for DcimPowerOutletsList

Retrieve a list of power outlet objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerOutletsListRequest
*/
func (a *DcimAPIService) DcimPowerOutletsList(ctx context.Context) ApiDcimPowerOutletsListRequest {
	return ApiDcimPowerOutletsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPowerOutletList
func (a *DcimAPIService) DcimPowerOutletsListExecute(r ApiDcimPowerOutletsListRequest) (*PaginatedPowerOutletList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPowerOutletList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cable != nil {
		t := *r.cable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable", t, "multi")
		}
	}
	if r.cableIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cable__isnull", r.cableIsnull, "")
	}
	if r.cableN != nil {
		t := *r.cableN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", t, "multi")
		}
	}
	if r.connected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connected", r.connected, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.feedLeg != nil {
		t := *r.feedLeg
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg", t, "multi")
		}
	}
	if r.feedLegIc != nil {
		t := *r.feedLegIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ic", t, "multi")
		}
	}
	if r.feedLegIe != nil {
		t := *r.feedLegIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ie", t, "multi")
		}
	}
	if r.feedLegIew != nil {
		t := *r.feedLegIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__iew", t, "multi")
		}
	}
	if r.feedLegIre != nil {
		t := *r.feedLegIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__ire", t, "multi")
		}
	}
	if r.feedLegIsw != nil {
		t := *r.feedLegIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__isw", t, "multi")
		}
	}
	if r.feedLegN != nil {
		t := *r.feedLegN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__n", t, "multi")
		}
	}
	if r.feedLegNic != nil {
		t := *r.feedLegNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nic", t, "multi")
		}
	}
	if r.feedLegNie != nil {
		t := *r.feedLegNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nie", t, "multi")
		}
	}
	if r.feedLegNiew != nil {
		t := *r.feedLegNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__niew", t, "multi")
		}
	}
	if r.feedLegNire != nil {
		t := *r.feedLegNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nire", t, "multi")
		}
	}
	if r.feedLegNisw != nil {
		t := *r.feedLegNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nisw", t, "multi")
		}
	}
	if r.feedLegNre != nil {
		t := *r.feedLegNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__nre", t, "multi")
		}
	}
	if r.feedLegRe != nil {
		t := *r.feedLegRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feed_leg__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasCable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_cable", r.hasCable, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.powerPort != nil {
		t := *r.powerPort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_port", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_port", t, "multi")
		}
	}
	if r.powerPortIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_port__isnull", r.powerPortIsnull, "")
	}
	if r.powerPortN != nil {
		t := *r.powerPortN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_port__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_port__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimPowerOutletsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimPowerOutletsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsNotesCreateExecute(r)
}

/*
DcimPowerOutletsNotesCreate Method for DcimPowerOutletsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet.
 @return ApiDcimPowerOutletsNotesCreateRequest
*/
func (a *DcimAPIService) DcimPowerOutletsNotesCreate(ctx context.Context, id string) ApiDcimPowerOutletsNotesCreateRequest {
	return ApiDcimPowerOutletsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimPowerOutletsNotesCreateExecute(r ApiDcimPowerOutletsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimPowerOutletsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerOutletsNotesListRequest) Limit(limit int32) ApiDcimPowerOutletsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerOutletsNotesListRequest) Offset(offset int32) ApiDcimPowerOutletsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimPowerOutletsNotesListRequest) Depth(depth int32) ApiDcimPowerOutletsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerOutletsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsNotesListExecute(r)
}

/*
DcimPowerOutletsNotesList Method for DcimPowerOutletsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet.
 @return ApiDcimPowerOutletsNotesListRequest
*/
func (a *DcimAPIService) DcimPowerOutletsNotesList(ctx context.Context, id string) ApiDcimPowerOutletsNotesListRequest {
	return ApiDcimPowerOutletsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimPowerOutletsNotesListExecute(r ApiDcimPowerOutletsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritablePowerOutletRequest *PatchedWritablePowerOutletRequest
}

func (r ApiDcimPowerOutletsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletsPartialUpdateRequest) PatchedWritablePowerOutletRequest(patchedWritablePowerOutletRequest PatchedWritablePowerOutletRequest) ApiDcimPowerOutletsPartialUpdateRequest {
	r.patchedWritablePowerOutletRequest = &patchedWritablePowerOutletRequest
	return r
}

func (r ApiDcimPowerOutletsPartialUpdateRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsPartialUpdateExecute(r)
}

/*
DcimPowerOutletsPartialUpdate Method for DcimPowerOutletsPartialUpdate

Partial update a power outlet object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet.
 @return ApiDcimPowerOutletsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerOutletsPartialUpdate(ctx context.Context, id string) ApiDcimPowerOutletsPartialUpdateRequest {
	return ApiDcimPowerOutletsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimAPIService) DcimPowerOutletsPartialUpdateExecute(r ApiDcimPowerOutletsPartialUpdateRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePowerOutletRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerOutletsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerOutletsRetrieveRequest) Depth(depth int32) ApiDcimPowerOutletsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerOutletsRetrieveRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsRetrieveExecute(r)
}

/*
DcimPowerOutletsRetrieve Method for DcimPowerOutletsRetrieve

Retrieve a power outlet object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet.
 @return ApiDcimPowerOutletsRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerOutletsRetrieve(ctx context.Context, id string) ApiDcimPowerOutletsRetrieveRequest {
	return ApiDcimPowerOutletsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimAPIService) DcimPowerOutletsRetrieveExecute(r ApiDcimPowerOutletsRetrieveRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsTraceRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerOutletsTraceRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsTraceRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerOutletsTraceRetrieveRequest) Depth(depth int32) ApiDcimPowerOutletsTraceRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerOutletsTraceRetrieveRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsTraceRetrieveExecute(r)
}

/*
DcimPowerOutletsTraceRetrieve Method for DcimPowerOutletsTraceRetrieve

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet.
 @return ApiDcimPowerOutletsTraceRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerOutletsTraceRetrieve(ctx context.Context, id string) ApiDcimPowerOutletsTraceRetrieveRequest {
	return ApiDcimPowerOutletsTraceRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimAPIService) DcimPowerOutletsTraceRetrieveExecute(r ApiDcimPowerOutletsTraceRetrieveRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsTraceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerOutletsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writablePowerOutletRequest *WritablePowerOutletRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerOutletsUpdateRequest) WritablePowerOutletRequest(writablePowerOutletRequest WritablePowerOutletRequest) ApiDcimPowerOutletsUpdateRequest {
	r.writablePowerOutletRequest = &writablePowerOutletRequest
	return r
}

func (r ApiDcimPowerOutletsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerOutletsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerOutletsUpdateRequest) Execute() (*PowerOutlet, *http.Response, error) {
	return r.ApiService.DcimPowerOutletsUpdateExecute(r)
}

/*
DcimPowerOutletsUpdate Method for DcimPowerOutletsUpdate

Update a power outlet object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power outlet.
 @return ApiDcimPowerOutletsUpdateRequest
*/
func (a *DcimAPIService) DcimPowerOutletsUpdate(ctx context.Context, id string) ApiDcimPowerOutletsUpdateRequest {
	return ApiDcimPowerOutletsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerOutlet
func (a *DcimAPIService) DcimPowerOutletsUpdateExecute(r ApiDcimPowerOutletsUpdateRequest) (*PowerOutlet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerOutlet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerOutletsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerOutletRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerOutletRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerOutletRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPanelsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimPowerPanelsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimPowerPanelsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPanelsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPanelsBulkDestroyExecute(r)
}

/*
DcimPowerPanelsBulkDestroy Method for DcimPowerPanelsBulkDestroy

Destroy a list of power panel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimPowerPanelsBulkDestroy(ctx context.Context) ApiDcimPowerPanelsBulkDestroyRequest {
	return ApiDcimPowerPanelsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerPanelsBulkDestroyExecute(r ApiDcimPowerPanelsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritablePowerPanelRequest *[]PatchedBulkWritablePowerPanelRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPanelsBulkPartialUpdateRequest) PatchedBulkWritablePowerPanelRequest(patchedBulkWritablePowerPanelRequest []PatchedBulkWritablePowerPanelRequest) ApiDcimPowerPanelsBulkPartialUpdateRequest {
	r.patchedBulkWritablePowerPanelRequest = &patchedBulkWritablePowerPanelRequest
	return r
}

func (r ApiDcimPowerPanelsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPanelsBulkPartialUpdateRequest) Execute() ([]PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsBulkPartialUpdateExecute(r)
}

/*
DcimPowerPanelsBulkPartialUpdate Method for DcimPowerPanelsBulkPartialUpdate

Partial update a list of power panel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPanelsBulkPartialUpdate(ctx context.Context) ApiDcimPowerPanelsBulkPartialUpdateRequest {
	return ApiDcimPowerPanelsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerPanel
func (a *DcimAPIService) DcimPowerPanelsBulkPartialUpdateExecute(r ApiDcimPowerPanelsBulkPartialUpdateRequest) ([]PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePowerPanelRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePowerPanelRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePowerPanelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritablePowerPanelRequest *[]BulkWritablePowerPanelRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPanelsBulkUpdateRequest) BulkWritablePowerPanelRequest(bulkWritablePowerPanelRequest []BulkWritablePowerPanelRequest) ApiDcimPowerPanelsBulkUpdateRequest {
	r.bulkWritablePowerPanelRequest = &bulkWritablePowerPanelRequest
	return r
}

func (r ApiDcimPowerPanelsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPanelsBulkUpdateRequest) Execute() ([]PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsBulkUpdateExecute(r)
}

/*
DcimPowerPanelsBulkUpdate Method for DcimPowerPanelsBulkUpdate

Update a list of power panel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPanelsBulkUpdate(ctx context.Context) ApiDcimPowerPanelsBulkUpdateRequest {
	return ApiDcimPowerPanelsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerPanel
func (a *DcimAPIService) DcimPowerPanelsBulkUpdateExecute(r ApiDcimPowerPanelsBulkUpdateRequest) ([]PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePowerPanelRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePowerPanelRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePowerPanelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	powerPanelRequest *PowerPanelRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPanelsCreateRequest) PowerPanelRequest(powerPanelRequest PowerPanelRequest) ApiDcimPowerPanelsCreateRequest {
	r.powerPanelRequest = &powerPanelRequest
	return r
}

func (r ApiDcimPowerPanelsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPanelsCreateRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsCreateExecute(r)
}

/*
DcimPowerPanelsCreate Method for DcimPowerPanelsCreate

Create one or more power panel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsCreateRequest
*/
func (a *DcimAPIService) DcimPowerPanelsCreate(ctx context.Context) ApiDcimPowerPanelsCreateRequest {
	return ApiDcimPowerPanelsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimAPIService) DcimPowerPanelsCreateExecute(r ApiDcimPowerPanelsCreateRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.powerPanelRequest == nil {
		return localVarReturnValue, nil, reportError("powerPanelRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.powerPanelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPanelsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPanelsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPanelsDestroyExecute(r)
}

/*
DcimPowerPanelsDestroy Method for DcimPowerPanelsDestroy

Destroy a power panel object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power panel.
 @return ApiDcimPowerPanelsDestroyRequest
*/
func (a *DcimAPIService) DcimPowerPanelsDestroy(ctx context.Context, id string) ApiDcimPowerPanelsDestroyRequest {
	return ApiDcimPowerPanelsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerPanelsDestroyExecute(r ApiDcimPowerPanelsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	format *CircuitsCircuitTerminationsListFormatParameter
	hasPowerFeeds *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	powerFeeds *[]string
	powerFeedsIsnull *bool
	powerFeedsN *[]string
	q *string
	rackGroup *[]string
	rackGroupIsnull *bool
	rackGroupN *[]string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	depth *int32
}

func (r ApiDcimPowerPanelsListRequest) Created(created []time.Time) ApiDcimPowerPanelsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimPowerPanelsListRequest) CreatedGt(createdGt []time.Time) ApiDcimPowerPanelsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimPowerPanelsListRequest) CreatedGte(createdGte []time.Time) ApiDcimPowerPanelsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimPowerPanelsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimPowerPanelsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimPowerPanelsListRequest) CreatedLt(createdLt []time.Time) ApiDcimPowerPanelsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimPowerPanelsListRequest) CreatedLte(createdLte []time.Time) ApiDcimPowerPanelsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimPowerPanelsListRequest) CreatedN(createdN []time.Time) ApiDcimPowerPanelsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimPowerPanelsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsListRequest {
	r.format = &format
	return r
}

// Has power feeds
func (r ApiDcimPowerPanelsListRequest) HasPowerFeeds(hasPowerFeeds bool) ApiDcimPowerPanelsListRequest {
	r.hasPowerFeeds = &hasPowerFeeds
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimPowerPanelsListRequest) Id(id []string) ApiDcimPowerPanelsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdIc(idIc []string) ApiDcimPowerPanelsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdIe(idIe []string) ApiDcimPowerPanelsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdIew(idIew []string) ApiDcimPowerPanelsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdIre(idIre []string) ApiDcimPowerPanelsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdIsw(idIsw []string) ApiDcimPowerPanelsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdN(idN []string) ApiDcimPowerPanelsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdNic(idNic []string) ApiDcimPowerPanelsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdNie(idNie []string) ApiDcimPowerPanelsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdNiew(idNiew []string) ApiDcimPowerPanelsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdNire(idNire []string) ApiDcimPowerPanelsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdNisw(idNisw []string) ApiDcimPowerPanelsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdNre(idNre []string) ApiDcimPowerPanelsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimPowerPanelsListRequest) IdRe(idRe []string) ApiDcimPowerPanelsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimPowerPanelsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimPowerPanelsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimPowerPanelsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimPowerPanelsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimPowerPanelsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimPowerPanelsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimPowerPanelsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimPowerPanelsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPanelsListRequest) Limit(limit int32) ApiDcimPowerPanelsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimPowerPanelsListRequest) Location(location []string) ApiDcimPowerPanelsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimPowerPanelsListRequest) LocationN(locationN []string) ApiDcimPowerPanelsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimPowerPanelsListRequest) Name(name []string) ApiDcimPowerPanelsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIc(nameIc []string) ApiDcimPowerPanelsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIe(nameIe []string) ApiDcimPowerPanelsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIew(nameIew []string) ApiDcimPowerPanelsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIre(nameIre []string) ApiDcimPowerPanelsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameIsw(nameIsw []string) ApiDcimPowerPanelsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameN(nameN []string) ApiDcimPowerPanelsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNic(nameNic []string) ApiDcimPowerPanelsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNie(nameNie []string) ApiDcimPowerPanelsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNiew(nameNiew []string) ApiDcimPowerPanelsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNire(nameNire []string) ApiDcimPowerPanelsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNisw(nameNisw []string) ApiDcimPowerPanelsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameNre(nameNre []string) ApiDcimPowerPanelsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimPowerPanelsListRequest) NameRe(nameRe []string) ApiDcimPowerPanelsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPanelsListRequest) Offset(offset int32) ApiDcimPowerPanelsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerPanelsListRequest) PowerFeeds(powerFeeds []string) ApiDcimPowerPanelsListRequest {
	r.powerFeeds = &powerFeeds
	return r
}

func (r ApiDcimPowerPanelsListRequest) PowerFeedsIsnull(powerFeedsIsnull bool) ApiDcimPowerPanelsListRequest {
	r.powerFeedsIsnull = &powerFeedsIsnull
	return r
}

func (r ApiDcimPowerPanelsListRequest) PowerFeedsN(powerFeedsN []string) ApiDcimPowerPanelsListRequest {
	r.powerFeedsN = &powerFeedsN
	return r
}

// Search
func (r ApiDcimPowerPanelsListRequest) Q(q string) ApiDcimPowerPanelsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimPowerPanelsListRequest) RackGroup(rackGroup []string) ApiDcimPowerPanelsListRequest {
	r.rackGroup = &rackGroup
	return r
}

func (r ApiDcimPowerPanelsListRequest) RackGroupIsnull(rackGroupIsnull bool) ApiDcimPowerPanelsListRequest {
	r.rackGroupIsnull = &rackGroupIsnull
	return r
}

func (r ApiDcimPowerPanelsListRequest) RackGroupN(rackGroupN []string) ApiDcimPowerPanelsListRequest {
	r.rackGroupN = &rackGroupN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimPowerPanelsListRequest) Sort(sort string) ApiDcimPowerPanelsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimPowerPanelsListRequest) Tags(tags []string) ApiDcimPowerPanelsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimPowerPanelsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimPowerPanelsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimPowerPanelsListRequest) TagsN(tagsN []string) ApiDcimPowerPanelsListRequest {
	r.tagsN = &tagsN
	return r
}

// Serializer Depth
func (r ApiDcimPowerPanelsListRequest) Depth(depth int32) ApiDcimPowerPanelsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPanelsListRequest) Execute() (*PaginatedPowerPanelList, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsListExecute(r)
}

/*
DcimPowerPanelsList Method for DcimPowerPanelsList

Retrieve a list of power panel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPanelsListRequest
*/
func (a *DcimAPIService) DcimPowerPanelsList(ctx context.Context) ApiDcimPowerPanelsListRequest {
	return ApiDcimPowerPanelsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPowerPanelList
func (a *DcimAPIService) DcimPowerPanelsListExecute(r ApiDcimPowerPanelsListRequest) (*PaginatedPowerPanelList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPowerPanelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasPowerFeeds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_feeds", r.hasPowerFeeds, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.powerFeeds != nil {
		t := *r.powerFeeds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds", t, "multi")
		}
	}
	if r.powerFeedsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds__isnull", r.powerFeedsIsnull, "")
	}
	if r.powerFeedsN != nil {
		t := *r.powerFeedsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rackGroup != nil {
		t := *r.rackGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group", t, "multi")
		}
	}
	if r.rackGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__isnull", r.rackGroupIsnull, "")
	}
	if r.rackGroupN != nil {
		t := *r.rackGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPanelsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimPowerPanelsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimPowerPanelsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPanelsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsNotesCreateExecute(r)
}

/*
DcimPowerPanelsNotesCreate Method for DcimPowerPanelsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power panel.
 @return ApiDcimPowerPanelsNotesCreateRequest
*/
func (a *DcimAPIService) DcimPowerPanelsNotesCreate(ctx context.Context, id string) ApiDcimPowerPanelsNotesCreateRequest {
	return ApiDcimPowerPanelsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimPowerPanelsNotesCreateExecute(r ApiDcimPowerPanelsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimPowerPanelsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPanelsNotesListRequest) Limit(limit int32) ApiDcimPowerPanelsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPanelsNotesListRequest) Offset(offset int32) ApiDcimPowerPanelsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimPowerPanelsNotesListRequest) Depth(depth int32) ApiDcimPowerPanelsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPanelsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsNotesListExecute(r)
}

/*
DcimPowerPanelsNotesList Method for DcimPowerPanelsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power panel.
 @return ApiDcimPowerPanelsNotesListRequest
*/
func (a *DcimAPIService) DcimPowerPanelsNotesList(ctx context.Context, id string) ApiDcimPowerPanelsNotesListRequest {
	return ApiDcimPowerPanelsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimPowerPanelsNotesListExecute(r ApiDcimPowerPanelsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedPowerPanelRequest *PatchedPowerPanelRequest
}

func (r ApiDcimPowerPanelsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPanelsPartialUpdateRequest) PatchedPowerPanelRequest(patchedPowerPanelRequest PatchedPowerPanelRequest) ApiDcimPowerPanelsPartialUpdateRequest {
	r.patchedPowerPanelRequest = &patchedPowerPanelRequest
	return r
}

func (r ApiDcimPowerPanelsPartialUpdateRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsPartialUpdateExecute(r)
}

/*
DcimPowerPanelsPartialUpdate Method for DcimPowerPanelsPartialUpdate

Partial update a power panel object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power panel.
 @return ApiDcimPowerPanelsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPanelsPartialUpdate(ctx context.Context, id string) ApiDcimPowerPanelsPartialUpdateRequest {
	return ApiDcimPowerPanelsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimAPIService) DcimPowerPanelsPartialUpdateExecute(r ApiDcimPowerPanelsPartialUpdateRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPowerPanelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerPanelsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerPanelsRetrieveRequest) Depth(depth int32) ApiDcimPowerPanelsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPanelsRetrieveRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsRetrieveExecute(r)
}

/*
DcimPowerPanelsRetrieve Method for DcimPowerPanelsRetrieve

Retrieve a power panel object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power panel.
 @return ApiDcimPowerPanelsRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerPanelsRetrieve(ctx context.Context, id string) ApiDcimPowerPanelsRetrieveRequest {
	return ApiDcimPowerPanelsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimAPIService) DcimPowerPanelsRetrieveExecute(r ApiDcimPowerPanelsRetrieveRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPanelsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	powerPanelRequest *PowerPanelRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPanelsUpdateRequest) PowerPanelRequest(powerPanelRequest PowerPanelRequest) ApiDcimPowerPanelsUpdateRequest {
	r.powerPanelRequest = &powerPanelRequest
	return r
}

func (r ApiDcimPowerPanelsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPanelsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPanelsUpdateRequest) Execute() (*PowerPanel, *http.Response, error) {
	return r.ApiService.DcimPowerPanelsUpdateExecute(r)
}

/*
DcimPowerPanelsUpdate Method for DcimPowerPanelsUpdate

Update a power panel object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power panel.
 @return ApiDcimPowerPanelsUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPanelsUpdate(ctx context.Context, id string) ApiDcimPowerPanelsUpdateRequest {
	return ApiDcimPowerPanelsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPanel
func (a *DcimAPIService) DcimPowerPanelsUpdateExecute(r ApiDcimPowerPanelsUpdateRequest) (*PowerPanel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPanel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPanelsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.powerPanelRequest == nil {
		return localVarReturnValue, nil, reportError("powerPanelRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.powerPanelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortTemplatesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimPowerPortTemplatesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimPowerPortTemplatesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesBulkDestroyExecute(r)
}

/*
DcimPowerPortTemplatesBulkDestroy Method for DcimPowerPortTemplatesBulkDestroy

Destroy a list of power port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesBulkDestroy(ctx context.Context) ApiDcimPowerPortTemplatesBulkDestroyRequest {
	return ApiDcimPowerPortTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerPortTemplatesBulkDestroyExecute(r ApiDcimPowerPortTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritablePowerPortTemplateRequest *[]PatchedBulkWritablePowerPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortTemplatesBulkPartialUpdateRequest) PatchedBulkWritablePowerPortTemplateRequest(patchedBulkWritablePowerPortTemplateRequest []PatchedBulkWritablePowerPortTemplateRequest) ApiDcimPowerPortTemplatesBulkPartialUpdateRequest {
	r.patchedBulkWritablePowerPortTemplateRequest = &patchedBulkWritablePowerPortTemplateRequest
	return r
}

func (r ApiDcimPowerPortTemplatesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortTemplatesBulkPartialUpdateRequest) Execute() ([]PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimPowerPortTemplatesBulkPartialUpdate Method for DcimPowerPortTemplatesBulkPartialUpdate

Partial update a list of power port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimPowerPortTemplatesBulkPartialUpdateRequest {
	return ApiDcimPowerPortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerPortTemplate
func (a *DcimAPIService) DcimPowerPortTemplatesBulkPartialUpdateExecute(r ApiDcimPowerPortTemplatesBulkPartialUpdateRequest) ([]PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePowerPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePowerPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePowerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritablePowerPortTemplateRequest *[]BulkWritablePowerPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortTemplatesBulkUpdateRequest) BulkWritablePowerPortTemplateRequest(bulkWritablePowerPortTemplateRequest []BulkWritablePowerPortTemplateRequest) ApiDcimPowerPortTemplatesBulkUpdateRequest {
	r.bulkWritablePowerPortTemplateRequest = &bulkWritablePowerPortTemplateRequest
	return r
}

func (r ApiDcimPowerPortTemplatesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortTemplatesBulkUpdateRequest) Execute() ([]PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesBulkUpdateExecute(r)
}

/*
DcimPowerPortTemplatesBulkUpdate Method for DcimPowerPortTemplatesBulkUpdate

Update a list of power port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesBulkUpdate(ctx context.Context) ApiDcimPowerPortTemplatesBulkUpdateRequest {
	return ApiDcimPowerPortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerPortTemplate
func (a *DcimAPIService) DcimPowerPortTemplatesBulkUpdateExecute(r ApiDcimPowerPortTemplatesBulkUpdateRequest) ([]PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePowerPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePowerPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePowerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writablePowerPortTemplateRequest *WritablePowerPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortTemplatesCreateRequest) WritablePowerPortTemplateRequest(writablePowerPortTemplateRequest WritablePowerPortTemplateRequest) ApiDcimPowerPortTemplatesCreateRequest {
	r.writablePowerPortTemplateRequest = &writablePowerPortTemplateRequest
	return r
}

func (r ApiDcimPowerPortTemplatesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortTemplatesCreateRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesCreateExecute(r)
}

/*
DcimPowerPortTemplatesCreate Method for DcimPowerPortTemplatesCreate

Create one or more power port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesCreateRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesCreate(ctx context.Context) ApiDcimPowerPortTemplatesCreateRequest {
	return ApiDcimPowerPortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimAPIService) DcimPowerPortTemplatesCreateExecute(r ApiDcimPowerPortTemplatesCreateRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortTemplatesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesDestroyExecute(r)
}

/*
DcimPowerPortTemplatesDestroy Method for DcimPowerPortTemplatesDestroy

Destroy a power port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port template.
 @return ApiDcimPowerPortTemplatesDestroyRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesDestroy(ctx context.Context, id string) ApiDcimPowerPortTemplatesDestroyRequest {
	return ApiDcimPowerPortTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerPortTemplatesDestroyExecute(r ApiDcimPowerPortTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	allocatedDraw *[]int32
	allocatedDrawGt *[]int32
	allocatedDrawGte *[]int32
	allocatedDrawIsnull *bool
	allocatedDrawLt *[]int32
	allocatedDrawLte *[]int32
	allocatedDrawN *[]int32
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceType *[]string
	deviceTypeN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasPowerOutletTemplates *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	maximumDraw *[]int32
	maximumDrawGt *[]int32
	maximumDrawGte *[]int32
	maximumDrawIsnull *bool
	maximumDrawLt *[]int32
	maximumDrawLte *[]int32
	maximumDrawN *[]int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	powerOutletTemplates *[]string
	powerOutletTemplatesIsnull *bool
	powerOutletTemplatesN *[]string
	q *string
	sort *string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDraw(allocatedDraw []int32) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDraw = &allocatedDraw
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawGt(allocatedDrawGt []int32) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawGt = &allocatedDrawGt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawGte(allocatedDrawGte []int32) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawGte = &allocatedDrawGte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawIsnull(allocatedDrawIsnull bool) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawIsnull = &allocatedDrawIsnull
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawLt(allocatedDrawLt []int32) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawLt = &allocatedDrawLt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawLte(allocatedDrawLte []int32) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawLte = &allocatedDrawLte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) AllocatedDrawN(allocatedDrawN []int32) ApiDcimPowerPortTemplatesListRequest {
	r.allocatedDrawN = &allocatedDrawN
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) Description(description []string) ApiDcimPowerPortTemplatesListRequest {
	r.description = &description
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionIre(descriptionIre []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionN(descriptionN []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionNire(descriptionNire []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionNre(descriptionNre []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

// Description
func (r ApiDcimPowerPortTemplatesListRequest) DescriptionRe(descriptionRe []string) ApiDcimPowerPortTemplatesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) DeviceType(deviceType []string) ApiDcimPowerPortTemplatesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimPowerPortTemplatesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesListRequest {
	r.format = &format
	return r
}

// Has power outlet templates
func (r ApiDcimPowerPortTemplatesListRequest) HasPowerOutletTemplates(hasPowerOutletTemplates bool) ApiDcimPowerPortTemplatesListRequest {
	r.hasPowerOutletTemplates = &hasPowerOutletTemplates
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) Id(id []string) ApiDcimPowerPortTemplatesListRequest {
	r.id = &id
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdIc(idIc []string) ApiDcimPowerPortTemplatesListRequest {
	r.idIc = &idIc
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdIe(idIe []string) ApiDcimPowerPortTemplatesListRequest {
	r.idIe = &idIe
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdIew(idIew []string) ApiDcimPowerPortTemplatesListRequest {
	r.idIew = &idIew
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdIre(idIre []string) ApiDcimPowerPortTemplatesListRequest {
	r.idIre = &idIre
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdIsw(idIsw []string) ApiDcimPowerPortTemplatesListRequest {
	r.idIsw = &idIsw
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdN(idN []string) ApiDcimPowerPortTemplatesListRequest {
	r.idN = &idN
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdNic(idNic []string) ApiDcimPowerPortTemplatesListRequest {
	r.idNic = &idNic
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdNie(idNie []string) ApiDcimPowerPortTemplatesListRequest {
	r.idNie = &idNie
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdNiew(idNiew []string) ApiDcimPowerPortTemplatesListRequest {
	r.idNiew = &idNiew
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdNire(idNire []string) ApiDcimPowerPortTemplatesListRequest {
	r.idNire = &idNire
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdNisw(idNisw []string) ApiDcimPowerPortTemplatesListRequest {
	r.idNisw = &idNisw
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdNre(idNre []string) ApiDcimPowerPortTemplatesListRequest {
	r.idNre = &idNre
	return r
}

// ID
func (r ApiDcimPowerPortTemplatesListRequest) IdRe(idRe []string) ApiDcimPowerPortTemplatesListRequest {
	r.idRe = &idRe
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) Label(label []string) ApiDcimPowerPortTemplatesListRequest {
	r.label = &label
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelIc(labelIc []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelIc = &labelIc
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelIe(labelIe []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelIe = &labelIe
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelIew(labelIew []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelIew = &labelIew
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelIre(labelIre []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelIre = &labelIre
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelIsw(labelIsw []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelIsw = &labelIsw
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelN(labelN []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelN = &labelN
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelNic(labelNic []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelNic = &labelNic
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelNie(labelNie []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelNie = &labelNie
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelNiew(labelNiew []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelNiew = &labelNiew
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelNire(labelNire []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelNire = &labelNire
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelNisw(labelNisw []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelNisw = &labelNisw
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelNre(labelNre []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelNre = &labelNre
	return r
}

// Label
func (r ApiDcimPowerPortTemplatesListRequest) LabelRe(labelRe []string) ApiDcimPowerPortTemplatesListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPortTemplatesListRequest) Limit(limit int32) ApiDcimPowerPortTemplatesListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDraw(maximumDraw []int32) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDraw = &maximumDraw
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawGt(maximumDrawGt []int32) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawGt = &maximumDrawGt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawGte(maximumDrawGte []int32) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawGte = &maximumDrawGte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawIsnull(maximumDrawIsnull bool) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawIsnull = &maximumDrawIsnull
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawLt(maximumDrawLt []int32) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawLt = &maximumDrawLt
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawLte(maximumDrawLte []int32) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawLte = &maximumDrawLte
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) MaximumDrawN(maximumDrawN []int32) ApiDcimPowerPortTemplatesListRequest {
	r.maximumDrawN = &maximumDrawN
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) Name(name []string) ApiDcimPowerPortTemplatesListRequest {
	r.name = &name
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameIc(nameIc []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameIe(nameIe []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameIew(nameIew []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameIre(nameIre []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIre = &nameIre
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameIsw(nameIsw []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameN(nameN []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameNic(nameNic []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameNie(nameNie []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameNiew(nameNiew []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameNire(nameNire []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNire = &nameNire
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameNisw(nameNisw []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameNre(nameNre []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameNre = &nameNre
	return r
}

// Name
func (r ApiDcimPowerPortTemplatesListRequest) NameRe(nameRe []string) ApiDcimPowerPortTemplatesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPortTemplatesListRequest) Offset(offset int32) ApiDcimPowerPortTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) PowerOutletTemplates(powerOutletTemplates []string) ApiDcimPowerPortTemplatesListRequest {
	r.powerOutletTemplates = &powerOutletTemplates
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) PowerOutletTemplatesIsnull(powerOutletTemplatesIsnull bool) ApiDcimPowerPortTemplatesListRequest {
	r.powerOutletTemplatesIsnull = &powerOutletTemplatesIsnull
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) PowerOutletTemplatesN(powerOutletTemplatesN []string) ApiDcimPowerPortTemplatesListRequest {
	r.powerOutletTemplatesN = &powerOutletTemplatesN
	return r
}

// Search
func (r ApiDcimPowerPortTemplatesListRequest) Q(q string) ApiDcimPowerPortTemplatesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimPowerPortTemplatesListRequest) Sort(sort string) ApiDcimPowerPortTemplatesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) Type_(type_ []string) ApiDcimPowerPortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeIc(typeIc []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeIe(typeIe []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeIew(typeIew []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeIre(typeIre []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeIsw(typeIsw []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeN(typeN []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeNic(typeNic []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeNie(typeNie []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeNiew(typeNiew []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeNire(typeNire []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeNisw(typeNisw []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeNre(typeNre []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) TypeRe(typeRe []string) ApiDcimPowerPortTemplatesListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimPowerPortTemplatesListRequest) Depth(depth int32) ApiDcimPowerPortTemplatesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPortTemplatesListRequest) Execute() (*PaginatedPowerPortTemplateList, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesListExecute(r)
}

/*
DcimPowerPortTemplatesList Method for DcimPowerPortTemplatesList

Retrieve a list of power port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortTemplatesListRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesList(ctx context.Context) ApiDcimPowerPortTemplatesListRequest {
	return ApiDcimPowerPortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPowerPortTemplateList
func (a *DcimAPIService) DcimPowerPortTemplatesListExecute(r ApiDcimPowerPortTemplatesListRequest) (*PaginatedPowerPortTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPowerPortTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allocatedDraw != nil {
		t := *r.allocatedDraw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw", t, "multi")
		}
	}
	if r.allocatedDrawGt != nil {
		t := *r.allocatedDrawGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__gt", t, "multi")
		}
	}
	if r.allocatedDrawGte != nil {
		t := *r.allocatedDrawGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__gte", t, "multi")
		}
	}
	if r.allocatedDrawIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__isnull", r.allocatedDrawIsnull, "")
	}
	if r.allocatedDrawLt != nil {
		t := *r.allocatedDrawLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__lt", t, "multi")
		}
	}
	if r.allocatedDrawLte != nil {
		t := *r.allocatedDrawLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__lte", t, "multi")
		}
	}
	if r.allocatedDrawN != nil {
		t := *r.allocatedDrawN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasPowerOutletTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_outlet_templates", r.hasPowerOutletTemplates, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.maximumDraw != nil {
		t := *r.maximumDraw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw", t, "multi")
		}
	}
	if r.maximumDrawGt != nil {
		t := *r.maximumDrawGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__gt", t, "multi")
		}
	}
	if r.maximumDrawGte != nil {
		t := *r.maximumDrawGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__gte", t, "multi")
		}
	}
	if r.maximumDrawIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__isnull", r.maximumDrawIsnull, "")
	}
	if r.maximumDrawLt != nil {
		t := *r.maximumDrawLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__lt", t, "multi")
		}
	}
	if r.maximumDrawLte != nil {
		t := *r.maximumDrawLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__lte", t, "multi")
		}
	}
	if r.maximumDrawN != nil {
		t := *r.maximumDrawN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.powerOutletTemplates != nil {
		t := *r.powerOutletTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates", t, "multi")
		}
	}
	if r.powerOutletTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates__isnull", r.powerOutletTemplatesIsnull, "")
	}
	if r.powerOutletTemplatesN != nil {
		t := *r.powerOutletTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlet_templates__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortTemplatesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimPowerPortTemplatesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimPowerPortTemplatesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortTemplatesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesNotesCreateExecute(r)
}

/*
DcimPowerPortTemplatesNotesCreate Method for DcimPowerPortTemplatesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port template.
 @return ApiDcimPowerPortTemplatesNotesCreateRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesNotesCreate(ctx context.Context, id string) ApiDcimPowerPortTemplatesNotesCreateRequest {
	return ApiDcimPowerPortTemplatesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimPowerPortTemplatesNotesCreateExecute(r ApiDcimPowerPortTemplatesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimPowerPortTemplatesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPortTemplatesNotesListRequest) Limit(limit int32) ApiDcimPowerPortTemplatesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPortTemplatesNotesListRequest) Offset(offset int32) ApiDcimPowerPortTemplatesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimPowerPortTemplatesNotesListRequest) Depth(depth int32) ApiDcimPowerPortTemplatesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPortTemplatesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesNotesListExecute(r)
}

/*
DcimPowerPortTemplatesNotesList Method for DcimPowerPortTemplatesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port template.
 @return ApiDcimPowerPortTemplatesNotesListRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesNotesList(ctx context.Context, id string) ApiDcimPowerPortTemplatesNotesListRequest {
	return ApiDcimPowerPortTemplatesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimPowerPortTemplatesNotesListExecute(r ApiDcimPowerPortTemplatesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritablePowerPortTemplateRequest *PatchedWritablePowerPortTemplateRequest
}

func (r ApiDcimPowerPortTemplatesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortTemplatesPartialUpdateRequest) PatchedWritablePowerPortTemplateRequest(patchedWritablePowerPortTemplateRequest PatchedWritablePowerPortTemplateRequest) ApiDcimPowerPortTemplatesPartialUpdateRequest {
	r.patchedWritablePowerPortTemplateRequest = &patchedWritablePowerPortTemplateRequest
	return r
}

func (r ApiDcimPowerPortTemplatesPartialUpdateRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesPartialUpdateExecute(r)
}

/*
DcimPowerPortTemplatesPartialUpdate Method for DcimPowerPortTemplatesPartialUpdate

Partial update a power port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port template.
 @return ApiDcimPowerPortTemplatesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesPartialUpdate(ctx context.Context, id string) ApiDcimPowerPortTemplatesPartialUpdateRequest {
	return ApiDcimPowerPortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimAPIService) DcimPowerPortTemplatesPartialUpdateExecute(r ApiDcimPowerPortTemplatesPartialUpdateRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePowerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerPortTemplatesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerPortTemplatesRetrieveRequest) Depth(depth int32) ApiDcimPowerPortTemplatesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPortTemplatesRetrieveRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesRetrieveExecute(r)
}

/*
DcimPowerPortTemplatesRetrieve Method for DcimPowerPortTemplatesRetrieve

Retrieve a power port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port template.
 @return ApiDcimPowerPortTemplatesRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesRetrieve(ctx context.Context, id string) ApiDcimPowerPortTemplatesRetrieveRequest {
	return ApiDcimPowerPortTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimAPIService) DcimPowerPortTemplatesRetrieveExecute(r ApiDcimPowerPortTemplatesRetrieveRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writablePowerPortTemplateRequest *WritablePowerPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortTemplatesUpdateRequest) WritablePowerPortTemplateRequest(writablePowerPortTemplateRequest WritablePowerPortTemplateRequest) ApiDcimPowerPortTemplatesUpdateRequest {
	r.writablePowerPortTemplateRequest = &writablePowerPortTemplateRequest
	return r
}

func (r ApiDcimPowerPortTemplatesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortTemplatesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortTemplatesUpdateRequest) Execute() (*PowerPortTemplate, *http.Response, error) {
	return r.ApiService.DcimPowerPortTemplatesUpdateExecute(r)
}

/*
DcimPowerPortTemplatesUpdate Method for DcimPowerPortTemplatesUpdate

Update a power port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port template.
 @return ApiDcimPowerPortTemplatesUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPortTemplatesUpdate(ctx context.Context, id string) ApiDcimPowerPortTemplatesUpdateRequest {
	return ApiDcimPowerPortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPortTemplate
func (a *DcimAPIService) DcimPowerPortTemplatesUpdateExecute(r ApiDcimPowerPortTemplatesUpdateRequest) (*PowerPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimPowerPortsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimPowerPortsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPortsBulkDestroyExecute(r)
}

/*
DcimPowerPortsBulkDestroy Method for DcimPowerPortsBulkDestroy

Destroy a list of power port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimPowerPortsBulkDestroy(ctx context.Context) ApiDcimPowerPortsBulkDestroyRequest {
	return ApiDcimPowerPortsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerPortsBulkDestroyExecute(r ApiDcimPowerPortsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritablePowerPortRequest *[]PatchedBulkWritablePowerPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortsBulkPartialUpdateRequest) PatchedBulkWritablePowerPortRequest(patchedBulkWritablePowerPortRequest []PatchedBulkWritablePowerPortRequest) ApiDcimPowerPortsBulkPartialUpdateRequest {
	r.patchedBulkWritablePowerPortRequest = &patchedBulkWritablePowerPortRequest
	return r
}

func (r ApiDcimPowerPortsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortsBulkPartialUpdateRequest) Execute() ([]PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsBulkPartialUpdateExecute(r)
}

/*
DcimPowerPortsBulkPartialUpdate Method for DcimPowerPortsBulkPartialUpdate

Partial update a list of power port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPortsBulkPartialUpdate(ctx context.Context) ApiDcimPowerPortsBulkPartialUpdateRequest {
	return ApiDcimPowerPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerPort
func (a *DcimAPIService) DcimPowerPortsBulkPartialUpdateExecute(r ApiDcimPowerPortsBulkPartialUpdateRequest) ([]PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePowerPortRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePowerPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePowerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritablePowerPortRequest *[]BulkWritablePowerPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortsBulkUpdateRequest) BulkWritablePowerPortRequest(bulkWritablePowerPortRequest []BulkWritablePowerPortRequest) ApiDcimPowerPortsBulkUpdateRequest {
	r.bulkWritablePowerPortRequest = &bulkWritablePowerPortRequest
	return r
}

func (r ApiDcimPowerPortsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortsBulkUpdateRequest) Execute() ([]PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsBulkUpdateExecute(r)
}

/*
DcimPowerPortsBulkUpdate Method for DcimPowerPortsBulkUpdate

Update a list of power port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPortsBulkUpdate(ctx context.Context) ApiDcimPowerPortsBulkUpdateRequest {
	return ApiDcimPowerPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PowerPort
func (a *DcimAPIService) DcimPowerPortsBulkUpdateExecute(r ApiDcimPowerPortsBulkUpdateRequest) ([]PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePowerPortRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePowerPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePowerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writablePowerPortRequest *WritablePowerPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortsCreateRequest) WritablePowerPortRequest(writablePowerPortRequest WritablePowerPortRequest) ApiDcimPowerPortsCreateRequest {
	r.writablePowerPortRequest = &writablePowerPortRequest
	return r
}

func (r ApiDcimPowerPortsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortsCreateRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsCreateExecute(r)
}

/*
DcimPowerPortsCreate Method for DcimPowerPortsCreate

Create one or more power port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsCreateRequest
*/
func (a *DcimAPIService) DcimPowerPortsCreate(ctx context.Context) ApiDcimPowerPortsCreateRequest {
	return ApiDcimPowerPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimAPIService) DcimPowerPortsCreateExecute(r ApiDcimPowerPortsCreateRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerPortRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimPowerPortsDestroyExecute(r)
}

/*
DcimPowerPortsDestroy Method for DcimPowerPortsDestroy

Destroy a power port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port.
 @return ApiDcimPowerPortsDestroyRequest
*/
func (a *DcimAPIService) DcimPowerPortsDestroy(ctx context.Context, id string) ApiDcimPowerPortsDestroyRequest {
	return ApiDcimPowerPortsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimPowerPortsDestroyExecute(r ApiDcimPowerPortsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimPowerPortsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	allocatedDraw *[]int32
	allocatedDrawGt *[]int32
	allocatedDrawGte *[]int32
	allocatedDrawIsnull *bool
	allocatedDrawLt *[]int32
	allocatedDrawLte *[]int32
	allocatedDrawN *[]int32
	cable *[]string
	cableIsnull *bool
	cableN *[]string
	connected *bool
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasCable *bool
	hasPowerOutlets *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	location *[]string
	locationN *[]string
	maximumDraw *[]int32
	maximumDrawGt *[]int32
	maximumDrawGte *[]int32
	maximumDrawIsnull *bool
	maximumDrawLt *[]int32
	maximumDrawLte *[]int32
	maximumDrawN *[]int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	powerOutlets *[]string
	powerOutletsIsnull *bool
	powerOutletsN *[]string
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

func (r ApiDcimPowerPortsListRequest) AllocatedDraw(allocatedDraw []int32) ApiDcimPowerPortsListRequest {
	r.allocatedDraw = &allocatedDraw
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawGt(allocatedDrawGt []int32) ApiDcimPowerPortsListRequest {
	r.allocatedDrawGt = &allocatedDrawGt
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawGte(allocatedDrawGte []int32) ApiDcimPowerPortsListRequest {
	r.allocatedDrawGte = &allocatedDrawGte
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawIsnull(allocatedDrawIsnull bool) ApiDcimPowerPortsListRequest {
	r.allocatedDrawIsnull = &allocatedDrawIsnull
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawLt(allocatedDrawLt []int32) ApiDcimPowerPortsListRequest {
	r.allocatedDrawLt = &allocatedDrawLt
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawLte(allocatedDrawLte []int32) ApiDcimPowerPortsListRequest {
	r.allocatedDrawLte = &allocatedDrawLte
	return r
}

func (r ApiDcimPowerPortsListRequest) AllocatedDrawN(allocatedDrawN []int32) ApiDcimPowerPortsListRequest {
	r.allocatedDrawN = &allocatedDrawN
	return r
}

// Cable
func (r ApiDcimPowerPortsListRequest) Cable(cable []string) ApiDcimPowerPortsListRequest {
	r.cable = &cable
	return r
}

func (r ApiDcimPowerPortsListRequest) CableIsnull(cableIsnull bool) ApiDcimPowerPortsListRequest {
	r.cableIsnull = &cableIsnull
	return r
}

// Cable
func (r ApiDcimPowerPortsListRequest) CableN(cableN []string) ApiDcimPowerPortsListRequest {
	r.cableN = &cableN
	return r
}

// Connected status (bool)
func (r ApiDcimPowerPortsListRequest) Connected(connected bool) ApiDcimPowerPortsListRequest {
	r.connected = &connected
	return r
}

func (r ApiDcimPowerPortsListRequest) Description(description []string) ApiDcimPowerPortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIc(descriptionIc []string) ApiDcimPowerPortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIe(descriptionIe []string) ApiDcimPowerPortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIew(descriptionIew []string) ApiDcimPowerPortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIre(descriptionIre []string) ApiDcimPowerPortsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimPowerPortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionN(descriptionN []string) ApiDcimPowerPortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNic(descriptionNic []string) ApiDcimPowerPortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNie(descriptionNie []string) ApiDcimPowerPortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimPowerPortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNire(descriptionNire []string) ApiDcimPowerPortsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimPowerPortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionNre(descriptionNre []string) ApiDcimPowerPortsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimPowerPortsListRequest) DescriptionRe(descriptionRe []string) ApiDcimPowerPortsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimPowerPortsListRequest) Device(device []string) ApiDcimPowerPortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimPowerPortsListRequest) DeviceN(deviceN []string) ApiDcimPowerPortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimPowerPortsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsListRequest {
	r.format = &format
	return r
}

// Has cable
func (r ApiDcimPowerPortsListRequest) HasCable(hasCable bool) ApiDcimPowerPortsListRequest {
	r.hasCable = &hasCable
	return r
}

// Has power outlets
func (r ApiDcimPowerPortsListRequest) HasPowerOutlets(hasPowerOutlets bool) ApiDcimPowerPortsListRequest {
	r.hasPowerOutlets = &hasPowerOutlets
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimPowerPortsListRequest) Id(id []string) ApiDcimPowerPortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimPowerPortsListRequest) IdIc(idIc []string) ApiDcimPowerPortsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimPowerPortsListRequest) IdIe(idIe []string) ApiDcimPowerPortsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimPowerPortsListRequest) IdIew(idIew []string) ApiDcimPowerPortsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimPowerPortsListRequest) IdIre(idIre []string) ApiDcimPowerPortsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimPowerPortsListRequest) IdIsw(idIsw []string) ApiDcimPowerPortsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimPowerPortsListRequest) IdN(idN []string) ApiDcimPowerPortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimPowerPortsListRequest) IdNic(idNic []string) ApiDcimPowerPortsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimPowerPortsListRequest) IdNie(idNie []string) ApiDcimPowerPortsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimPowerPortsListRequest) IdNiew(idNiew []string) ApiDcimPowerPortsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimPowerPortsListRequest) IdNire(idNire []string) ApiDcimPowerPortsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimPowerPortsListRequest) IdNisw(idNisw []string) ApiDcimPowerPortsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimPowerPortsListRequest) IdNre(idNre []string) ApiDcimPowerPortsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimPowerPortsListRequest) IdRe(idRe []string) ApiDcimPowerPortsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimPowerPortsListRequest) Label(label []string) ApiDcimPowerPortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIc(labelIc []string) ApiDcimPowerPortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIe(labelIe []string) ApiDcimPowerPortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIew(labelIew []string) ApiDcimPowerPortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIre(labelIre []string) ApiDcimPowerPortsListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelIsw(labelIsw []string) ApiDcimPowerPortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelN(labelN []string) ApiDcimPowerPortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNic(labelNic []string) ApiDcimPowerPortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNie(labelNie []string) ApiDcimPowerPortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNiew(labelNiew []string) ApiDcimPowerPortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNire(labelNire []string) ApiDcimPowerPortsListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNisw(labelNisw []string) ApiDcimPowerPortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelNre(labelNre []string) ApiDcimPowerPortsListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimPowerPortsListRequest) LabelRe(labelRe []string) ApiDcimPowerPortsListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPortsListRequest) Limit(limit int32) ApiDcimPowerPortsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimPowerPortsListRequest) Location(location []string) ApiDcimPowerPortsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimPowerPortsListRequest) LocationN(locationN []string) ApiDcimPowerPortsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDraw(maximumDraw []int32) ApiDcimPowerPortsListRequest {
	r.maximumDraw = &maximumDraw
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawGt(maximumDrawGt []int32) ApiDcimPowerPortsListRequest {
	r.maximumDrawGt = &maximumDrawGt
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawGte(maximumDrawGte []int32) ApiDcimPowerPortsListRequest {
	r.maximumDrawGte = &maximumDrawGte
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawIsnull(maximumDrawIsnull bool) ApiDcimPowerPortsListRequest {
	r.maximumDrawIsnull = &maximumDrawIsnull
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawLt(maximumDrawLt []int32) ApiDcimPowerPortsListRequest {
	r.maximumDrawLt = &maximumDrawLt
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawLte(maximumDrawLte []int32) ApiDcimPowerPortsListRequest {
	r.maximumDrawLte = &maximumDrawLte
	return r
}

func (r ApiDcimPowerPortsListRequest) MaximumDrawN(maximumDrawN []int32) ApiDcimPowerPortsListRequest {
	r.maximumDrawN = &maximumDrawN
	return r
}

func (r ApiDcimPowerPortsListRequest) Name(name []string) ApiDcimPowerPortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIc(nameIc []string) ApiDcimPowerPortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIe(nameIe []string) ApiDcimPowerPortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIew(nameIew []string) ApiDcimPowerPortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIre(nameIre []string) ApiDcimPowerPortsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimPowerPortsListRequest) NameIsw(nameIsw []string) ApiDcimPowerPortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimPowerPortsListRequest) NameN(nameN []string) ApiDcimPowerPortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNic(nameNic []string) ApiDcimPowerPortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNie(nameNie []string) ApiDcimPowerPortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNiew(nameNiew []string) ApiDcimPowerPortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNire(nameNire []string) ApiDcimPowerPortsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNisw(nameNisw []string) ApiDcimPowerPortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimPowerPortsListRequest) NameNre(nameNre []string) ApiDcimPowerPortsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimPowerPortsListRequest) NameRe(nameRe []string) ApiDcimPowerPortsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPortsListRequest) Offset(offset int32) ApiDcimPowerPortsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimPowerPortsListRequest) PowerOutlets(powerOutlets []string) ApiDcimPowerPortsListRequest {
	r.powerOutlets = &powerOutlets
	return r
}

func (r ApiDcimPowerPortsListRequest) PowerOutletsIsnull(powerOutletsIsnull bool) ApiDcimPowerPortsListRequest {
	r.powerOutletsIsnull = &powerOutletsIsnull
	return r
}

func (r ApiDcimPowerPortsListRequest) PowerOutletsN(powerOutletsN []string) ApiDcimPowerPortsListRequest {
	r.powerOutletsN = &powerOutletsN
	return r
}

// Search
func (r ApiDcimPowerPortsListRequest) Q(q string) ApiDcimPowerPortsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimPowerPortsListRequest) Sort(sort string) ApiDcimPowerPortsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimPowerPortsListRequest) Tags(tags []string) ApiDcimPowerPortsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimPowerPortsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimPowerPortsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimPowerPortsListRequest) TagsN(tagsN []string) ApiDcimPowerPortsListRequest {
	r.tagsN = &tagsN
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) Type_(type_ []string) ApiDcimPowerPortsListRequest {
	r.type_ = &type_
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeIc(typeIc []string) ApiDcimPowerPortsListRequest {
	r.typeIc = &typeIc
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeIe(typeIe []string) ApiDcimPowerPortsListRequest {
	r.typeIe = &typeIe
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeIew(typeIew []string) ApiDcimPowerPortsListRequest {
	r.typeIew = &typeIew
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeIre(typeIre []string) ApiDcimPowerPortsListRequest {
	r.typeIre = &typeIre
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeIsw(typeIsw []string) ApiDcimPowerPortsListRequest {
	r.typeIsw = &typeIsw
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeN(typeN []string) ApiDcimPowerPortsListRequest {
	r.typeN = &typeN
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeNic(typeNic []string) ApiDcimPowerPortsListRequest {
	r.typeNic = &typeNic
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeNie(typeNie []string) ApiDcimPowerPortsListRequest {
	r.typeNie = &typeNie
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeNiew(typeNiew []string) ApiDcimPowerPortsListRequest {
	r.typeNiew = &typeNiew
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeNire(typeNire []string) ApiDcimPowerPortsListRequest {
	r.typeNire = &typeNire
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeNisw(typeNisw []string) ApiDcimPowerPortsListRequest {
	r.typeNisw = &typeNisw
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeNre(typeNre []string) ApiDcimPowerPortsListRequest {
	r.typeNre = &typeNre
	return r
}

// Physical port type
func (r ApiDcimPowerPortsListRequest) TypeRe(typeRe []string) ApiDcimPowerPortsListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimPowerPortsListRequest) Depth(depth int32) ApiDcimPowerPortsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPortsListRequest) Execute() (*PaginatedPowerPortList, *http.Response, error) {
	return r.ApiService.DcimPowerPortsListExecute(r)
}

/*
DcimPowerPortsList Method for DcimPowerPortsList

Retrieve a list of power port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimPowerPortsListRequest
*/
func (a *DcimAPIService) DcimPowerPortsList(ctx context.Context) ApiDcimPowerPortsListRequest {
	return ApiDcimPowerPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPowerPortList
func (a *DcimAPIService) DcimPowerPortsListExecute(r ApiDcimPowerPortsListRequest) (*PaginatedPowerPortList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPowerPortList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allocatedDraw != nil {
		t := *r.allocatedDraw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw", t, "multi")
		}
	}
	if r.allocatedDrawGt != nil {
		t := *r.allocatedDrawGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__gt", t, "multi")
		}
	}
	if r.allocatedDrawGte != nil {
		t := *r.allocatedDrawGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__gte", t, "multi")
		}
	}
	if r.allocatedDrawIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__isnull", r.allocatedDrawIsnull, "")
	}
	if r.allocatedDrawLt != nil {
		t := *r.allocatedDrawLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__lt", t, "multi")
		}
	}
	if r.allocatedDrawLte != nil {
		t := *r.allocatedDrawLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__lte", t, "multi")
		}
	}
	if r.allocatedDrawN != nil {
		t := *r.allocatedDrawN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allocated_draw__n", t, "multi")
		}
	}
	if r.cable != nil {
		t := *r.cable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable", t, "multi")
		}
	}
	if r.cableIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cable__isnull", r.cableIsnull, "")
	}
	if r.cableN != nil {
		t := *r.cableN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", t, "multi")
		}
	}
	if r.connected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connected", r.connected, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasCable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_cable", r.hasCable, "")
	}
	if r.hasPowerOutlets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_outlets", r.hasPowerOutlets, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.maximumDraw != nil {
		t := *r.maximumDraw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw", t, "multi")
		}
	}
	if r.maximumDrawGt != nil {
		t := *r.maximumDrawGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__gt", t, "multi")
		}
	}
	if r.maximumDrawGte != nil {
		t := *r.maximumDrawGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__gte", t, "multi")
		}
	}
	if r.maximumDrawIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__isnull", r.maximumDrawIsnull, "")
	}
	if r.maximumDrawLt != nil {
		t := *r.maximumDrawLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__lt", t, "multi")
		}
	}
	if r.maximumDrawLte != nil {
		t := *r.maximumDrawLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__lte", t, "multi")
		}
	}
	if r.maximumDrawN != nil {
		t := *r.maximumDrawN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maximum_draw__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.powerOutlets != nil {
		t := *r.powerOutlets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets", t, "multi")
		}
	}
	if r.powerOutletsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets__isnull", r.powerOutletsIsnull, "")
	}
	if r.powerOutletsN != nil {
		t := *r.powerOutletsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_outlets__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimPowerPortsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimPowerPortsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimPowerPortsNotesCreateExecute(r)
}

/*
DcimPowerPortsNotesCreate Method for DcimPowerPortsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port.
 @return ApiDcimPowerPortsNotesCreateRequest
*/
func (a *DcimAPIService) DcimPowerPortsNotesCreate(ctx context.Context, id string) ApiDcimPowerPortsNotesCreateRequest {
	return ApiDcimPowerPortsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimPowerPortsNotesCreateExecute(r ApiDcimPowerPortsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimPowerPortsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimPowerPortsNotesListRequest) Limit(limit int32) ApiDcimPowerPortsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimPowerPortsNotesListRequest) Offset(offset int32) ApiDcimPowerPortsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimPowerPortsNotesListRequest) Depth(depth int32) ApiDcimPowerPortsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPortsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimPowerPortsNotesListExecute(r)
}

/*
DcimPowerPortsNotesList Method for DcimPowerPortsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port.
 @return ApiDcimPowerPortsNotesListRequest
*/
func (a *DcimAPIService) DcimPowerPortsNotesList(ctx context.Context, id string) ApiDcimPowerPortsNotesListRequest {
	return ApiDcimPowerPortsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimPowerPortsNotesListExecute(r ApiDcimPowerPortsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritablePowerPortRequest *PatchedWritablePowerPortRequest
}

func (r ApiDcimPowerPortsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortsPartialUpdateRequest) PatchedWritablePowerPortRequest(patchedWritablePowerPortRequest PatchedWritablePowerPortRequest) ApiDcimPowerPortsPartialUpdateRequest {
	r.patchedWritablePowerPortRequest = &patchedWritablePowerPortRequest
	return r
}

func (r ApiDcimPowerPortsPartialUpdateRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsPartialUpdateExecute(r)
}

/*
DcimPowerPortsPartialUpdate Method for DcimPowerPortsPartialUpdate

Partial update a power port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port.
 @return ApiDcimPowerPortsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPortsPartialUpdate(ctx context.Context, id string) ApiDcimPowerPortsPartialUpdateRequest {
	return ApiDcimPowerPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimAPIService) DcimPowerPortsPartialUpdateExecute(r ApiDcimPowerPortsPartialUpdateRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePowerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerPortsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerPortsRetrieveRequest) Depth(depth int32) ApiDcimPowerPortsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPortsRetrieveRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsRetrieveExecute(r)
}

/*
DcimPowerPortsRetrieve Method for DcimPowerPortsRetrieve

Retrieve a power port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port.
 @return ApiDcimPowerPortsRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerPortsRetrieve(ctx context.Context, id string) ApiDcimPowerPortsRetrieveRequest {
	return ApiDcimPowerPortsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimAPIService) DcimPowerPortsRetrieveExecute(r ApiDcimPowerPortsRetrieveRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsTraceRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimPowerPortsTraceRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsTraceRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimPowerPortsTraceRetrieveRequest) Depth(depth int32) ApiDcimPowerPortsTraceRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimPowerPortsTraceRetrieveRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsTraceRetrieveExecute(r)
}

/*
DcimPowerPortsTraceRetrieve Method for DcimPowerPortsTraceRetrieve

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port.
 @return ApiDcimPowerPortsTraceRetrieveRequest
*/
func (a *DcimAPIService) DcimPowerPortsTraceRetrieve(ctx context.Context, id string) ApiDcimPowerPortsTraceRetrieveRequest {
	return ApiDcimPowerPortsTraceRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimAPIService) DcimPowerPortsTraceRetrieveExecute(r ApiDcimPowerPortsTraceRetrieveRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsTraceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimPowerPortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writablePowerPortRequest *WritablePowerPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimPowerPortsUpdateRequest) WritablePowerPortRequest(writablePowerPortRequest WritablePowerPortRequest) ApiDcimPowerPortsUpdateRequest {
	r.writablePowerPortRequest = &writablePowerPortRequest
	return r
}

func (r ApiDcimPowerPortsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimPowerPortsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimPowerPortsUpdateRequest) Execute() (*PowerPort, *http.Response, error) {
	return r.ApiService.DcimPowerPortsUpdateExecute(r)
}

/*
DcimPowerPortsUpdate Method for DcimPowerPortsUpdate

Update a power port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this power port.
 @return ApiDcimPowerPortsUpdateRequest
*/
func (a *DcimAPIService) DcimPowerPortsUpdate(ctx context.Context, id string) ApiDcimPowerPortsUpdateRequest {
	return ApiDcimPowerPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PowerPort
func (a *DcimAPIService) DcimPowerPortsUpdateExecute(r ApiDcimPowerPortsUpdateRequest) (*PowerPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimPowerPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePowerPortRequest == nil {
		return localVarReturnValue, nil, reportError("writablePowerPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePowerPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackGroupsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimRackGroupsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimRackGroupsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRackGroupsBulkDestroyExecute(r)
}

/*
DcimRackGroupsBulkDestroy Method for DcimRackGroupsBulkDestroy

Destroy a list of rack group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackGroupsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimRackGroupsBulkDestroy(ctx context.Context) ApiDcimRackGroupsBulkDestroyRequest {
	return ApiDcimRackGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRackGroupsBulkDestroyExecute(r ApiDcimRackGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRackGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableRackGroupRequest *[]PatchedBulkWritableRackGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackGroupsBulkPartialUpdateRequest) PatchedBulkWritableRackGroupRequest(patchedBulkWritableRackGroupRequest []PatchedBulkWritableRackGroupRequest) ApiDcimRackGroupsBulkPartialUpdateRequest {
	r.patchedBulkWritableRackGroupRequest = &patchedBulkWritableRackGroupRequest
	return r
}

func (r ApiDcimRackGroupsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackGroupsBulkPartialUpdateRequest) Execute() ([]RackGroup, *http.Response, error) {
	return r.ApiService.DcimRackGroupsBulkPartialUpdateExecute(r)
}

/*
DcimRackGroupsBulkPartialUpdate Method for DcimRackGroupsBulkPartialUpdate

Partial update a list of rack group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackGroupsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRackGroupsBulkPartialUpdate(ctx context.Context) ApiDcimRackGroupsBulkPartialUpdateRequest {
	return ApiDcimRackGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RackGroup
func (a *DcimAPIService) DcimRackGroupsBulkPartialUpdateExecute(r ApiDcimRackGroupsBulkPartialUpdateRequest) ([]RackGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RackGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableRackGroupRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableRackGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableRackGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableRackGroupRequest *[]BulkWritableRackGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackGroupsBulkUpdateRequest) BulkWritableRackGroupRequest(bulkWritableRackGroupRequest []BulkWritableRackGroupRequest) ApiDcimRackGroupsBulkUpdateRequest {
	r.bulkWritableRackGroupRequest = &bulkWritableRackGroupRequest
	return r
}

func (r ApiDcimRackGroupsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackGroupsBulkUpdateRequest) Execute() ([]RackGroup, *http.Response, error) {
	return r.ApiService.DcimRackGroupsBulkUpdateExecute(r)
}

/*
DcimRackGroupsBulkUpdate Method for DcimRackGroupsBulkUpdate

Update a list of rack group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackGroupsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimRackGroupsBulkUpdate(ctx context.Context) ApiDcimRackGroupsBulkUpdateRequest {
	return ApiDcimRackGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RackGroup
func (a *DcimAPIService) DcimRackGroupsBulkUpdateExecute(r ApiDcimRackGroupsBulkUpdateRequest) ([]RackGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RackGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableRackGroupRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableRackGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableRackGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	rackGroupRequest *RackGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackGroupsCreateRequest) RackGroupRequest(rackGroupRequest RackGroupRequest) ApiDcimRackGroupsCreateRequest {
	r.rackGroupRequest = &rackGroupRequest
	return r
}

func (r ApiDcimRackGroupsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackGroupsCreateRequest) Execute() (*RackGroup, *http.Response, error) {
	return r.ApiService.DcimRackGroupsCreateExecute(r)
}

/*
DcimRackGroupsCreate Method for DcimRackGroupsCreate

Create one or more rack group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackGroupsCreateRequest
*/
func (a *DcimAPIService) DcimRackGroupsCreate(ctx context.Context) ApiDcimRackGroupsCreateRequest {
	return ApiDcimRackGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RackGroup
func (a *DcimAPIService) DcimRackGroupsCreateExecute(r ApiDcimRackGroupsCreateRequest) (*RackGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rackGroupRequest == nil {
		return localVarReturnValue, nil, reportError("rackGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rackGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackGroupsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRackGroupsDestroyExecute(r)
}

/*
DcimRackGroupsDestroy Method for DcimRackGroupsDestroy

Destroy a rack group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack group.
 @return ApiDcimRackGroupsDestroyRequest
*/
func (a *DcimAPIService) DcimRackGroupsDestroy(ctx context.Context, id string) ApiDcimRackGroupsDestroyRequest {
	return ApiDcimRackGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRackGroupsDestroyExecute(r ApiDcimRackGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRackGroupsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	children *[]string
	childrenIsnull *bool
	childrenN *[]string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasChildren *bool
	hasPowerPanels *bool
	hasRacks *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	parent *[]string
	parentIsnull *bool
	parentN *[]string
	powerPanels *[]string
	powerPanelsIsnull *bool
	powerPanelsN *[]string
	q *string
	racks *[]string
	racksIsnull *bool
	racksN *[]string
	sort *string
	depth *int32
}

func (r ApiDcimRackGroupsListRequest) Children(children []string) ApiDcimRackGroupsListRequest {
	r.children = &children
	return r
}

func (r ApiDcimRackGroupsListRequest) ChildrenIsnull(childrenIsnull bool) ApiDcimRackGroupsListRequest {
	r.childrenIsnull = &childrenIsnull
	return r
}

func (r ApiDcimRackGroupsListRequest) ChildrenN(childrenN []string) ApiDcimRackGroupsListRequest {
	r.childrenN = &childrenN
	return r
}

func (r ApiDcimRackGroupsListRequest) Created(created []time.Time) ApiDcimRackGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRackGroupsListRequest) CreatedGt(createdGt []time.Time) ApiDcimRackGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimRackGroupsListRequest) CreatedGte(createdGte []time.Time) ApiDcimRackGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRackGroupsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimRackGroupsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimRackGroupsListRequest) CreatedLt(createdLt []time.Time) ApiDcimRackGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimRackGroupsListRequest) CreatedLte(createdLte []time.Time) ApiDcimRackGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRackGroupsListRequest) CreatedN(createdN []time.Time) ApiDcimRackGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimRackGroupsListRequest) Description(description []string) ApiDcimRackGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionIc(descriptionIc []string) ApiDcimRackGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionIe(descriptionIe []string) ApiDcimRackGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionIew(descriptionIew []string) ApiDcimRackGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionIre(descriptionIre []string) ApiDcimRackGroupsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimRackGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionN(descriptionN []string) ApiDcimRackGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionNic(descriptionNic []string) ApiDcimRackGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionNie(descriptionNie []string) ApiDcimRackGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimRackGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionNire(descriptionNire []string) ApiDcimRackGroupsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimRackGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionNre(descriptionNre []string) ApiDcimRackGroupsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimRackGroupsListRequest) DescriptionRe(descriptionRe []string) ApiDcimRackGroupsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimRackGroupsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsListRequest {
	r.format = &format
	return r
}

// Has children
func (r ApiDcimRackGroupsListRequest) HasChildren(hasChildren bool) ApiDcimRackGroupsListRequest {
	r.hasChildren = &hasChildren
	return r
}

// Has power panels
func (r ApiDcimRackGroupsListRequest) HasPowerPanels(hasPowerPanels bool) ApiDcimRackGroupsListRequest {
	r.hasPowerPanels = &hasPowerPanels
	return r
}

// Has racks
func (r ApiDcimRackGroupsListRequest) HasRacks(hasRacks bool) ApiDcimRackGroupsListRequest {
	r.hasRacks = &hasRacks
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimRackGroupsListRequest) Id(id []string) ApiDcimRackGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRackGroupsListRequest) IdIc(idIc []string) ApiDcimRackGroupsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimRackGroupsListRequest) IdIe(idIe []string) ApiDcimRackGroupsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimRackGroupsListRequest) IdIew(idIew []string) ApiDcimRackGroupsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimRackGroupsListRequest) IdIre(idIre []string) ApiDcimRackGroupsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimRackGroupsListRequest) IdIsw(idIsw []string) ApiDcimRackGroupsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimRackGroupsListRequest) IdN(idN []string) ApiDcimRackGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRackGroupsListRequest) IdNic(idNic []string) ApiDcimRackGroupsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimRackGroupsListRequest) IdNie(idNie []string) ApiDcimRackGroupsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimRackGroupsListRequest) IdNiew(idNiew []string) ApiDcimRackGroupsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimRackGroupsListRequest) IdNire(idNire []string) ApiDcimRackGroupsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimRackGroupsListRequest) IdNisw(idNisw []string) ApiDcimRackGroupsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimRackGroupsListRequest) IdNre(idNre []string) ApiDcimRackGroupsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimRackGroupsListRequest) IdRe(idRe []string) ApiDcimRackGroupsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimRackGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimRackGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRackGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimRackGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimRackGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimRackGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRackGroupsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimRackGroupsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimRackGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimRackGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimRackGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimRackGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRackGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimRackGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimRackGroupsListRequest) Limit(limit int32) ApiDcimRackGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimRackGroupsListRequest) Location(location []string) ApiDcimRackGroupsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimRackGroupsListRequest) LocationN(locationN []string) ApiDcimRackGroupsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimRackGroupsListRequest) Name(name []string) ApiDcimRackGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimRackGroupsListRequest) NameIc(nameIc []string) ApiDcimRackGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimRackGroupsListRequest) NameIe(nameIe []string) ApiDcimRackGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimRackGroupsListRequest) NameIew(nameIew []string) ApiDcimRackGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimRackGroupsListRequest) NameIre(nameIre []string) ApiDcimRackGroupsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimRackGroupsListRequest) NameIsw(nameIsw []string) ApiDcimRackGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimRackGroupsListRequest) NameN(nameN []string) ApiDcimRackGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimRackGroupsListRequest) NameNic(nameNic []string) ApiDcimRackGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimRackGroupsListRequest) NameNie(nameNie []string) ApiDcimRackGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimRackGroupsListRequest) NameNiew(nameNiew []string) ApiDcimRackGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimRackGroupsListRequest) NameNire(nameNire []string) ApiDcimRackGroupsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimRackGroupsListRequest) NameNisw(nameNisw []string) ApiDcimRackGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimRackGroupsListRequest) NameNre(nameNre []string) ApiDcimRackGroupsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimRackGroupsListRequest) NameRe(nameRe []string) ApiDcimRackGroupsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRackGroupsListRequest) Offset(offset int32) ApiDcimRackGroupsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRackGroupsListRequest) Parent(parent []string) ApiDcimRackGroupsListRequest {
	r.parent = &parent
	return r
}

func (r ApiDcimRackGroupsListRequest) ParentIsnull(parentIsnull bool) ApiDcimRackGroupsListRequest {
	r.parentIsnull = &parentIsnull
	return r
}

func (r ApiDcimRackGroupsListRequest) ParentN(parentN []string) ApiDcimRackGroupsListRequest {
	r.parentN = &parentN
	return r
}

func (r ApiDcimRackGroupsListRequest) PowerPanels(powerPanels []string) ApiDcimRackGroupsListRequest {
	r.powerPanels = &powerPanels
	return r
}

func (r ApiDcimRackGroupsListRequest) PowerPanelsIsnull(powerPanelsIsnull bool) ApiDcimRackGroupsListRequest {
	r.powerPanelsIsnull = &powerPanelsIsnull
	return r
}

func (r ApiDcimRackGroupsListRequest) PowerPanelsN(powerPanelsN []string) ApiDcimRackGroupsListRequest {
	r.powerPanelsN = &powerPanelsN
	return r
}

// Search
func (r ApiDcimRackGroupsListRequest) Q(q string) ApiDcimRackGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRackGroupsListRequest) Racks(racks []string) ApiDcimRackGroupsListRequest {
	r.racks = &racks
	return r
}

func (r ApiDcimRackGroupsListRequest) RacksIsnull(racksIsnull bool) ApiDcimRackGroupsListRequest {
	r.racksIsnull = &racksIsnull
	return r
}

func (r ApiDcimRackGroupsListRequest) RacksN(racksN []string) ApiDcimRackGroupsListRequest {
	r.racksN = &racksN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimRackGroupsListRequest) Sort(sort string) ApiDcimRackGroupsListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiDcimRackGroupsListRequest) Depth(depth int32) ApiDcimRackGroupsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRackGroupsListRequest) Execute() (*PaginatedRackGroupList, *http.Response, error) {
	return r.ApiService.DcimRackGroupsListExecute(r)
}

/*
DcimRackGroupsList Method for DcimRackGroupsList

Retrieve a list of rack group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackGroupsListRequest
*/
func (a *DcimAPIService) DcimRackGroupsList(ctx context.Context) ApiDcimRackGroupsListRequest {
	return ApiDcimRackGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRackGroupList
func (a *DcimAPIService) DcimRackGroupsListExecute(r ApiDcimRackGroupsListRequest) (*PaginatedRackGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRackGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.children != nil {
		t := *r.children
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children", t, "multi")
		}
	}
	if r.childrenIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children__isnull", r.childrenIsnull, "")
	}
	if r.childrenN != nil {
		t := *r.childrenN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__n", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_children", r.hasChildren, "")
	}
	if r.hasPowerPanels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_panels", r.hasPowerPanels, "")
	}
	if r.hasRacks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_racks", r.hasRacks, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "multi")
		}
	}
	if r.parentIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent__isnull", r.parentIsnull, "")
	}
	if r.parentN != nil {
		t := *r.parentN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", t, "multi")
		}
	}
	if r.powerPanels != nil {
		t := *r.powerPanels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels", t, "multi")
		}
	}
	if r.powerPanelsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels__isnull", r.powerPanelsIsnull, "")
	}
	if r.powerPanelsN != nil {
		t := *r.powerPanelsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_panels__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.racks != nil {
		t := *r.racks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "racks", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "racks", t, "multi")
		}
	}
	if r.racksIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "racks__isnull", r.racksIsnull, "")
	}
	if r.racksN != nil {
		t := *r.racksN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "racks__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "racks__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackGroupsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimRackGroupsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimRackGroupsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackGroupsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimRackGroupsNotesCreateExecute(r)
}

/*
DcimRackGroupsNotesCreate Method for DcimRackGroupsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack group.
 @return ApiDcimRackGroupsNotesCreateRequest
*/
func (a *DcimAPIService) DcimRackGroupsNotesCreate(ctx context.Context, id string) ApiDcimRackGroupsNotesCreateRequest {
	return ApiDcimRackGroupsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimRackGroupsNotesCreateExecute(r ApiDcimRackGroupsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimRackGroupsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimRackGroupsNotesListRequest) Limit(limit int32) ApiDcimRackGroupsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRackGroupsNotesListRequest) Offset(offset int32) ApiDcimRackGroupsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimRackGroupsNotesListRequest) Depth(depth int32) ApiDcimRackGroupsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRackGroupsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimRackGroupsNotesListExecute(r)
}

/*
DcimRackGroupsNotesList Method for DcimRackGroupsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack group.
 @return ApiDcimRackGroupsNotesListRequest
*/
func (a *DcimAPIService) DcimRackGroupsNotesList(ctx context.Context, id string) ApiDcimRackGroupsNotesListRequest {
	return ApiDcimRackGroupsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimRackGroupsNotesListExecute(r ApiDcimRackGroupsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedRackGroupRequest *PatchedRackGroupRequest
}

func (r ApiDcimRackGroupsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackGroupsPartialUpdateRequest) PatchedRackGroupRequest(patchedRackGroupRequest PatchedRackGroupRequest) ApiDcimRackGroupsPartialUpdateRequest {
	r.patchedRackGroupRequest = &patchedRackGroupRequest
	return r
}

func (r ApiDcimRackGroupsPartialUpdateRequest) Execute() (*RackGroup, *http.Response, error) {
	return r.ApiService.DcimRackGroupsPartialUpdateExecute(r)
}

/*
DcimRackGroupsPartialUpdate Method for DcimRackGroupsPartialUpdate

Partial update a rack group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack group.
 @return ApiDcimRackGroupsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRackGroupsPartialUpdate(ctx context.Context, id string) ApiDcimRackGroupsPartialUpdateRequest {
	return ApiDcimRackGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackGroup
func (a *DcimAPIService) DcimRackGroupsPartialUpdateExecute(r ApiDcimRackGroupsPartialUpdateRequest) (*RackGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRackGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimRackGroupsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimRackGroupsRetrieveRequest) Depth(depth int32) ApiDcimRackGroupsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRackGroupsRetrieveRequest) Execute() (*RackGroup, *http.Response, error) {
	return r.ApiService.DcimRackGroupsRetrieveExecute(r)
}

/*
DcimRackGroupsRetrieve Method for DcimRackGroupsRetrieve

Retrieve a rack group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack group.
 @return ApiDcimRackGroupsRetrieveRequest
*/
func (a *DcimAPIService) DcimRackGroupsRetrieve(ctx context.Context, id string) ApiDcimRackGroupsRetrieveRequest {
	return ApiDcimRackGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackGroup
func (a *DcimAPIService) DcimRackGroupsRetrieveExecute(r ApiDcimRackGroupsRetrieveRequest) (*RackGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	rackGroupRequest *RackGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackGroupsUpdateRequest) RackGroupRequest(rackGroupRequest RackGroupRequest) ApiDcimRackGroupsUpdateRequest {
	r.rackGroupRequest = &rackGroupRequest
	return r
}

func (r ApiDcimRackGroupsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackGroupsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackGroupsUpdateRequest) Execute() (*RackGroup, *http.Response, error) {
	return r.ApiService.DcimRackGroupsUpdateExecute(r)
}

/*
DcimRackGroupsUpdate Method for DcimRackGroupsUpdate

Update a rack group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack group.
 @return ApiDcimRackGroupsUpdateRequest
*/
func (a *DcimAPIService) DcimRackGroupsUpdate(ctx context.Context, id string) ApiDcimRackGroupsUpdateRequest {
	return ApiDcimRackGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackGroup
func (a *DcimAPIService) DcimRackGroupsUpdateExecute(r ApiDcimRackGroupsUpdateRequest) (*RackGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rackGroupRequest == nil {
		return localVarReturnValue, nil, reportError("rackGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rackGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackReservationsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimRackReservationsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimRackReservationsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackReservationsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRackReservationsBulkDestroyExecute(r)
}

/*
DcimRackReservationsBulkDestroy Method for DcimRackReservationsBulkDestroy

Destroy a list of rack reservation objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimRackReservationsBulkDestroy(ctx context.Context) ApiDcimRackReservationsBulkDestroyRequest {
	return ApiDcimRackReservationsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRackReservationsBulkDestroyExecute(r ApiDcimRackReservationsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRackReservationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableRackReservationRequest *[]PatchedBulkWritableRackReservationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackReservationsBulkPartialUpdateRequest) PatchedBulkWritableRackReservationRequest(patchedBulkWritableRackReservationRequest []PatchedBulkWritableRackReservationRequest) ApiDcimRackReservationsBulkPartialUpdateRequest {
	r.patchedBulkWritableRackReservationRequest = &patchedBulkWritableRackReservationRequest
	return r
}

func (r ApiDcimRackReservationsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackReservationsBulkPartialUpdateRequest) Execute() ([]RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsBulkPartialUpdateExecute(r)
}

/*
DcimRackReservationsBulkPartialUpdate Method for DcimRackReservationsBulkPartialUpdate

Partial update a list of rack reservation objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRackReservationsBulkPartialUpdate(ctx context.Context) ApiDcimRackReservationsBulkPartialUpdateRequest {
	return ApiDcimRackReservationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RackReservation
func (a *DcimAPIService) DcimRackReservationsBulkPartialUpdateExecute(r ApiDcimRackReservationsBulkPartialUpdateRequest) ([]RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableRackReservationRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableRackReservationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableRackReservationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableRackReservationRequest *[]BulkWritableRackReservationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackReservationsBulkUpdateRequest) BulkWritableRackReservationRequest(bulkWritableRackReservationRequest []BulkWritableRackReservationRequest) ApiDcimRackReservationsBulkUpdateRequest {
	r.bulkWritableRackReservationRequest = &bulkWritableRackReservationRequest
	return r
}

func (r ApiDcimRackReservationsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackReservationsBulkUpdateRequest) Execute() ([]RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsBulkUpdateExecute(r)
}

/*
DcimRackReservationsBulkUpdate Method for DcimRackReservationsBulkUpdate

Update a list of rack reservation objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimRackReservationsBulkUpdate(ctx context.Context) ApiDcimRackReservationsBulkUpdateRequest {
	return ApiDcimRackReservationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RackReservation
func (a *DcimAPIService) DcimRackReservationsBulkUpdateExecute(r ApiDcimRackReservationsBulkUpdateRequest) ([]RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableRackReservationRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableRackReservationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableRackReservationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	rackReservationRequest *RackReservationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackReservationsCreateRequest) RackReservationRequest(rackReservationRequest RackReservationRequest) ApiDcimRackReservationsCreateRequest {
	r.rackReservationRequest = &rackReservationRequest
	return r
}

func (r ApiDcimRackReservationsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackReservationsCreateRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsCreateExecute(r)
}

/*
DcimRackReservationsCreate Method for DcimRackReservationsCreate

Create one or more rack reservation objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsCreateRequest
*/
func (a *DcimAPIService) DcimRackReservationsCreate(ctx context.Context) ApiDcimRackReservationsCreateRequest {
	return ApiDcimRackReservationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimAPIService) DcimRackReservationsCreateExecute(r ApiDcimRackReservationsCreateRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rackReservationRequest == nil {
		return localVarReturnValue, nil, reportError("rackReservationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rackReservationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackReservationsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackReservationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRackReservationsDestroyExecute(r)
}

/*
DcimRackReservationsDestroy Method for DcimRackReservationsDestroy

Destroy a rack reservation object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack reservation.
 @return ApiDcimRackReservationsDestroyRequest
*/
func (a *DcimAPIService) DcimRackReservationsDestroy(ctx context.Context, id string) ApiDcimRackReservationsDestroyRequest {
	return ApiDcimRackReservationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRackReservationsDestroyExecute(r ApiDcimRackReservationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRackReservationsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	offset *int32
	q *string
	rack *[]string
	rackN *[]string
	rackGroup *[]string
	rackGroupIsnull *bool
	rackGroupN *[]string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	user *[]string
	userN *[]string
	depth *int32
}

func (r ApiDcimRackReservationsListRequest) Created(created []time.Time) ApiDcimRackReservationsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRackReservationsListRequest) CreatedGt(createdGt []time.Time) ApiDcimRackReservationsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimRackReservationsListRequest) CreatedGte(createdGte []time.Time) ApiDcimRackReservationsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRackReservationsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimRackReservationsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimRackReservationsListRequest) CreatedLt(createdLt []time.Time) ApiDcimRackReservationsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimRackReservationsListRequest) CreatedLte(createdLte []time.Time) ApiDcimRackReservationsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRackReservationsListRequest) CreatedN(createdN []time.Time) ApiDcimRackReservationsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimRackReservationsListRequest) Description(description []string) ApiDcimRackReservationsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionIc(descriptionIc []string) ApiDcimRackReservationsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionIe(descriptionIe []string) ApiDcimRackReservationsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionIew(descriptionIew []string) ApiDcimRackReservationsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionIre(descriptionIre []string) ApiDcimRackReservationsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimRackReservationsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionN(descriptionN []string) ApiDcimRackReservationsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionNic(descriptionNic []string) ApiDcimRackReservationsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionNie(descriptionNie []string) ApiDcimRackReservationsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimRackReservationsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionNire(descriptionNire []string) ApiDcimRackReservationsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimRackReservationsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionNre(descriptionNre []string) ApiDcimRackReservationsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimRackReservationsListRequest) DescriptionRe(descriptionRe []string) ApiDcimRackReservationsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimRackReservationsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimRackReservationsListRequest) Id(id []string) ApiDcimRackReservationsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRackReservationsListRequest) IdIc(idIc []string) ApiDcimRackReservationsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimRackReservationsListRequest) IdIe(idIe []string) ApiDcimRackReservationsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimRackReservationsListRequest) IdIew(idIew []string) ApiDcimRackReservationsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimRackReservationsListRequest) IdIre(idIre []string) ApiDcimRackReservationsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimRackReservationsListRequest) IdIsw(idIsw []string) ApiDcimRackReservationsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimRackReservationsListRequest) IdN(idN []string) ApiDcimRackReservationsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRackReservationsListRequest) IdNic(idNic []string) ApiDcimRackReservationsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimRackReservationsListRequest) IdNie(idNie []string) ApiDcimRackReservationsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimRackReservationsListRequest) IdNiew(idNiew []string) ApiDcimRackReservationsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimRackReservationsListRequest) IdNire(idNire []string) ApiDcimRackReservationsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimRackReservationsListRequest) IdNisw(idNisw []string) ApiDcimRackReservationsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimRackReservationsListRequest) IdNre(idNre []string) ApiDcimRackReservationsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimRackReservationsListRequest) IdRe(idRe []string) ApiDcimRackReservationsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimRackReservationsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimRackReservationsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimRackReservationsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimRackReservationsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimRackReservationsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimRackReservationsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRackReservationsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimRackReservationsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimRackReservationsListRequest) Limit(limit int32) ApiDcimRackReservationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRackReservationsListRequest) Offset(offset int32) ApiDcimRackReservationsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimRackReservationsListRequest) Q(q string) ApiDcimRackReservationsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRackReservationsListRequest) Rack(rack []string) ApiDcimRackReservationsListRequest {
	r.rack = &rack
	return r
}

func (r ApiDcimRackReservationsListRequest) RackN(rackN []string) ApiDcimRackReservationsListRequest {
	r.rackN = &rackN
	return r
}

func (r ApiDcimRackReservationsListRequest) RackGroup(rackGroup []string) ApiDcimRackReservationsListRequest {
	r.rackGroup = &rackGroup
	return r
}

func (r ApiDcimRackReservationsListRequest) RackGroupIsnull(rackGroupIsnull bool) ApiDcimRackReservationsListRequest {
	r.rackGroupIsnull = &rackGroupIsnull
	return r
}

func (r ApiDcimRackReservationsListRequest) RackGroupN(rackGroupN []string) ApiDcimRackReservationsListRequest {
	r.rackGroupN = &rackGroupN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimRackReservationsListRequest) Sort(sort string) ApiDcimRackReservationsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimRackReservationsListRequest) Tags(tags []string) ApiDcimRackReservationsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimRackReservationsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimRackReservationsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimRackReservationsListRequest) TagsN(tagsN []string) ApiDcimRackReservationsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimRackReservationsListRequest) Tenant(tenant []string) ApiDcimRackReservationsListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantIsnull(tenantIsnull bool) ApiDcimRackReservationsListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantN(tenantN []string) ApiDcimRackReservationsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantGroup(tenantGroup []string) ApiDcimRackReservationsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiDcimRackReservationsListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantGroupN(tenantGroupN []string) ApiDcimRackReservationsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimRackReservationsListRequest) TenantId(tenantId []*string) ApiDcimRackReservationsListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimRackReservationsListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiDcimRackReservationsListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimRackReservationsListRequest) TenantIdN(tenantIdN []*string) ApiDcimRackReservationsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiDcimRackReservationsListRequest) User(user []string) ApiDcimRackReservationsListRequest {
	r.user = &user
	return r
}

func (r ApiDcimRackReservationsListRequest) UserN(userN []string) ApiDcimRackReservationsListRequest {
	r.userN = &userN
	return r
}

// Serializer Depth
func (r ApiDcimRackReservationsListRequest) Depth(depth int32) ApiDcimRackReservationsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRackReservationsListRequest) Execute() (*PaginatedRackReservationList, *http.Response, error) {
	return r.ApiService.DcimRackReservationsListExecute(r)
}

/*
DcimRackReservationsList Method for DcimRackReservationsList

Retrieve a list of rack reservation objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRackReservationsListRequest
*/
func (a *DcimAPIService) DcimRackReservationsList(ctx context.Context) ApiDcimRackReservationsListRequest {
	return ApiDcimRackReservationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRackReservationList
func (a *DcimAPIService) DcimRackReservationsListExecute(r ApiDcimRackReservationsListRequest) (*PaginatedRackReservationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRackReservationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rack != nil {
		t := *r.rack
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack", t, "multi")
		}
	}
	if r.rackN != nil {
		t := *r.rackN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack__n", t, "multi")
		}
	}
	if r.rackGroup != nil {
		t := *r.rackGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group", t, "multi")
		}
	}
	if r.rackGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__isnull", r.rackGroupIsnull, "")
	}
	if r.rackGroupN != nil {
		t := *r.rackGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.userN != nil {
		t := *r.userN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackReservationsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimRackReservationsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimRackReservationsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackReservationsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimRackReservationsNotesCreateExecute(r)
}

/*
DcimRackReservationsNotesCreate Method for DcimRackReservationsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack reservation.
 @return ApiDcimRackReservationsNotesCreateRequest
*/
func (a *DcimAPIService) DcimRackReservationsNotesCreate(ctx context.Context, id string) ApiDcimRackReservationsNotesCreateRequest {
	return ApiDcimRackReservationsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimRackReservationsNotesCreateExecute(r ApiDcimRackReservationsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimRackReservationsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimRackReservationsNotesListRequest) Limit(limit int32) ApiDcimRackReservationsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRackReservationsNotesListRequest) Offset(offset int32) ApiDcimRackReservationsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimRackReservationsNotesListRequest) Depth(depth int32) ApiDcimRackReservationsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRackReservationsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimRackReservationsNotesListExecute(r)
}

/*
DcimRackReservationsNotesList Method for DcimRackReservationsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack reservation.
 @return ApiDcimRackReservationsNotesListRequest
*/
func (a *DcimAPIService) DcimRackReservationsNotesList(ctx context.Context, id string) ApiDcimRackReservationsNotesListRequest {
	return ApiDcimRackReservationsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimRackReservationsNotesListExecute(r ApiDcimRackReservationsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedRackReservationRequest *PatchedRackReservationRequest
}

func (r ApiDcimRackReservationsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackReservationsPartialUpdateRequest) PatchedRackReservationRequest(patchedRackReservationRequest PatchedRackReservationRequest) ApiDcimRackReservationsPartialUpdateRequest {
	r.patchedRackReservationRequest = &patchedRackReservationRequest
	return r
}

func (r ApiDcimRackReservationsPartialUpdateRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsPartialUpdateExecute(r)
}

/*
DcimRackReservationsPartialUpdate Method for DcimRackReservationsPartialUpdate

Partial update a rack reservation object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack reservation.
 @return ApiDcimRackReservationsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRackReservationsPartialUpdate(ctx context.Context, id string) ApiDcimRackReservationsPartialUpdateRequest {
	return ApiDcimRackReservationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimAPIService) DcimRackReservationsPartialUpdateExecute(r ApiDcimRackReservationsPartialUpdateRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRackReservationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimRackReservationsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimRackReservationsRetrieveRequest) Depth(depth int32) ApiDcimRackReservationsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRackReservationsRetrieveRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsRetrieveExecute(r)
}

/*
DcimRackReservationsRetrieve Method for DcimRackReservationsRetrieve

Retrieve a rack reservation object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack reservation.
 @return ApiDcimRackReservationsRetrieveRequest
*/
func (a *DcimAPIService) DcimRackReservationsRetrieve(ctx context.Context, id string) ApiDcimRackReservationsRetrieveRequest {
	return ApiDcimRackReservationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimAPIService) DcimRackReservationsRetrieveExecute(r ApiDcimRackReservationsRetrieveRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRackReservationsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	rackReservationRequest *RackReservationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRackReservationsUpdateRequest) RackReservationRequest(rackReservationRequest RackReservationRequest) ApiDcimRackReservationsUpdateRequest {
	r.rackReservationRequest = &rackReservationRequest
	return r
}

func (r ApiDcimRackReservationsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRackReservationsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRackReservationsUpdateRequest) Execute() (*RackReservation, *http.Response, error) {
	return r.ApiService.DcimRackReservationsUpdateExecute(r)
}

/*
DcimRackReservationsUpdate Method for DcimRackReservationsUpdate

Update a rack reservation object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack reservation.
 @return ApiDcimRackReservationsUpdateRequest
*/
func (a *DcimAPIService) DcimRackReservationsUpdate(ctx context.Context, id string) ApiDcimRackReservationsUpdateRequest {
	return ApiDcimRackReservationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RackReservation
func (a *DcimAPIService) DcimRackReservationsUpdateExecute(r ApiDcimRackReservationsUpdateRequest) (*RackReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RackReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRackReservationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rackReservationRequest == nil {
		return localVarReturnValue, nil, reportError("rackReservationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rackReservationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRacksBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimRacksBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimRacksBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRacksBulkDestroyExecute(r)
}

/*
DcimRacksBulkDestroy Method for DcimRacksBulkDestroy

Destroy a list of rack objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksBulkDestroyRequest
*/
func (a *DcimAPIService) DcimRacksBulkDestroy(ctx context.Context) ApiDcimRacksBulkDestroyRequest {
	return ApiDcimRacksBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRacksBulkDestroyExecute(r ApiDcimRacksBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRacksBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableRackRequest *[]PatchedBulkWritableRackRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRacksBulkPartialUpdateRequest) PatchedBulkWritableRackRequest(patchedBulkWritableRackRequest []PatchedBulkWritableRackRequest) ApiDcimRacksBulkPartialUpdateRequest {
	r.patchedBulkWritableRackRequest = &patchedBulkWritableRackRequest
	return r
}

func (r ApiDcimRacksBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksBulkPartialUpdateRequest) Execute() ([]Rack, *http.Response, error) {
	return r.ApiService.DcimRacksBulkPartialUpdateExecute(r)
}

/*
DcimRacksBulkPartialUpdate Method for DcimRacksBulkPartialUpdate

Partial update a list of rack objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRacksBulkPartialUpdate(ctx context.Context) ApiDcimRacksBulkPartialUpdateRequest {
	return ApiDcimRacksBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Rack
func (a *DcimAPIService) DcimRacksBulkPartialUpdateExecute(r ApiDcimRacksBulkPartialUpdateRequest) ([]Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableRackRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableRackRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableRackRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableRackRequest *[]BulkWritableRackRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRacksBulkUpdateRequest) BulkWritableRackRequest(bulkWritableRackRequest []BulkWritableRackRequest) ApiDcimRacksBulkUpdateRequest {
	r.bulkWritableRackRequest = &bulkWritableRackRequest
	return r
}

func (r ApiDcimRacksBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksBulkUpdateRequest) Execute() ([]Rack, *http.Response, error) {
	return r.ApiService.DcimRacksBulkUpdateExecute(r)
}

/*
DcimRacksBulkUpdate Method for DcimRacksBulkUpdate

Update a list of rack objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksBulkUpdateRequest
*/
func (a *DcimAPIService) DcimRacksBulkUpdate(ctx context.Context) ApiDcimRacksBulkUpdateRequest {
	return ApiDcimRacksBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Rack
func (a *DcimAPIService) DcimRacksBulkUpdateExecute(r ApiDcimRacksBulkUpdateRequest) ([]Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableRackRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableRackRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableRackRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableRackRequest *WritableRackRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRacksCreateRequest) WritableRackRequest(writableRackRequest WritableRackRequest) ApiDcimRacksCreateRequest {
	r.writableRackRequest = &writableRackRequest
	return r
}

func (r ApiDcimRacksCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksCreateRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksCreateExecute(r)
}

/*
DcimRacksCreate Method for DcimRacksCreate

Create one or more rack objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksCreateRequest
*/
func (a *DcimAPIService) DcimRacksCreate(ctx context.Context) ApiDcimRacksCreateRequest {
	return ApiDcimRacksCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimAPIService) DcimRacksCreateExecute(r ApiDcimRacksCreateRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRackRequest == nil {
		return localVarReturnValue, nil, reportError("writableRackRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRackRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRacksDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRacksDestroyExecute(r)
}

/*
DcimRacksDestroy Method for DcimRacksDestroy

Destroy a rack object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack.
 @return ApiDcimRacksDestroyRequest
*/
func (a *DcimAPIService) DcimRacksDestroy(ctx context.Context, id string) ApiDcimRacksDestroyRequest {
	return ApiDcimRacksDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRacksDestroyExecute(r ApiDcimRacksDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRacksElevationListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	displayFullname *bool
	exclude *string
	expandDevices *bool
	face *DcimRacksElevationListFaceParameter
	format *CircuitsCircuitTerminationsListFormatParameter
	includeImages *bool
	legendWidth *int32
	limit *int32
	offset *int32
	q *string
	render *DcimRacksElevationListRenderParameter
	unitHeight *int32
	unitWidth *int32
	depth *int32
}

func (r ApiDcimRacksElevationListRequest) DisplayFullname(displayFullname bool) ApiDcimRacksElevationListRequest {
	r.displayFullname = &displayFullname
	return r
}

func (r ApiDcimRacksElevationListRequest) Exclude(exclude string) ApiDcimRacksElevationListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiDcimRacksElevationListRequest) ExpandDevices(expandDevices bool) ApiDcimRacksElevationListRequest {
	r.expandDevices = &expandDevices
	return r
}

func (r ApiDcimRacksElevationListRequest) Face(face DcimRacksElevationListFaceParameter) ApiDcimRacksElevationListRequest {
	r.face = &face
	return r
}

func (r ApiDcimRacksElevationListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksElevationListRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksElevationListRequest) IncludeImages(includeImages bool) ApiDcimRacksElevationListRequest {
	r.includeImages = &includeImages
	return r
}

func (r ApiDcimRacksElevationListRequest) LegendWidth(legendWidth int32) ApiDcimRacksElevationListRequest {
	r.legendWidth = &legendWidth
	return r
}

// Number of results to return per page.
func (r ApiDcimRacksElevationListRequest) Limit(limit int32) ApiDcimRacksElevationListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRacksElevationListRequest) Offset(offset int32) ApiDcimRacksElevationListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRacksElevationListRequest) Q(q string) ApiDcimRacksElevationListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRacksElevationListRequest) Render(render DcimRacksElevationListRenderParameter) ApiDcimRacksElevationListRequest {
	r.render = &render
	return r
}

func (r ApiDcimRacksElevationListRequest) UnitHeight(unitHeight int32) ApiDcimRacksElevationListRequest {
	r.unitHeight = &unitHeight
	return r
}

func (r ApiDcimRacksElevationListRequest) UnitWidth(unitWidth int32) ApiDcimRacksElevationListRequest {
	r.unitWidth = &unitWidth
	return r
}

// Serializer Depth
func (r ApiDcimRacksElevationListRequest) Depth(depth int32) ApiDcimRacksElevationListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRacksElevationListRequest) Execute() (*PaginatedRackUnitList, *http.Response, error) {
	return r.ApiService.DcimRacksElevationListExecute(r)
}

/*
DcimRacksElevationList Method for DcimRacksElevationList

Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack.
 @return ApiDcimRacksElevationListRequest
*/
func (a *DcimAPIService) DcimRacksElevationList(ctx context.Context, id string) ApiDcimRacksElevationListRequest {
	return ApiDcimRacksElevationListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedRackUnitList
func (a *DcimAPIService) DcimRacksElevationListExecute(r ApiDcimRacksElevationListRequest) (*PaginatedRackUnitList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRackUnitList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksElevationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/elevation/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.displayFullname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display_fullname", r.displayFullname, "")
	} else {
		var defaultValue bool = true
		r.displayFullname = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "")
	}
	if r.expandDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_devices", r.expandDevices, "")
	} else {
		var defaultValue bool = true
		r.expandDevices = &defaultValue
	}
	if r.face != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "face", r.face, "")
	} else {
		var defaultValue DcimRacksElevationListFaceParameter = "front"
		r.face = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.includeImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_images", r.includeImages, "")
	} else {
		var defaultValue bool = true
		r.includeImages = &defaultValue
	}
	if r.legendWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "legend_width", r.legendWidth, "")
	} else {
		var defaultValue int32 = 30
		r.legendWidth = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.render != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "render", r.render, "")
	} else {
		var defaultValue DcimRacksElevationListRenderParameter = "json"
		r.render = &defaultValue
	}
	if r.unitHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unit_height", r.unitHeight, "")
	}
	if r.unitWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unit_width", r.unitWidth, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	assetTag *[]string
	assetTagIc *[]string
	assetTagIe *[]string
	assetTagIew *[]string
	assetTagIre *[]string
	assetTagIsnull *bool
	assetTagIsw *[]string
	assetTagN *[]string
	assetTagNic *[]string
	assetTagNie *[]string
	assetTagNiew *[]string
	assetTagNire *[]string
	assetTagNisw *[]string
	assetTagNre *[]string
	assetTagRe *[]string
	comments *[]string
	commentsIc *[]string
	commentsIe *[]string
	commentsIew *[]string
	commentsIre *[]string
	commentsIsw *[]string
	commentsN *[]string
	commentsNic *[]string
	commentsNie *[]string
	commentsNiew *[]string
	commentsNire *[]string
	commentsNisw *[]string
	commentsNre *[]string
	commentsRe *[]string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	descUnits *bool
	devices *[]string
	devicesIsnull *bool
	devicesN *[]string
	facilityId *[]string
	facilityIdIc *[]string
	facilityIdIe *[]string
	facilityIdIew *[]string
	facilityIdIre *[]string
	facilityIdIsnull *bool
	facilityIdIsw *[]string
	facilityIdN *[]string
	facilityIdNic *[]string
	facilityIdNie *[]string
	facilityIdNiew *[]string
	facilityIdNire *[]string
	facilityIdNisw *[]string
	facilityIdNre *[]string
	facilityIdRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasDevices *bool
	hasPowerFeeds *bool
	hasRackReservations *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	outerDepth *[]int32
	outerDepthGt *[]int32
	outerDepthGte *[]int32
	outerDepthIsnull *bool
	outerDepthLt *[]int32
	outerDepthLte *[]int32
	outerDepthN *[]int32
	outerUnit *[]string
	outerUnitIc *[]string
	outerUnitIe *[]string
	outerUnitIew *[]string
	outerUnitIre *[]string
	outerUnitIsw *[]string
	outerUnitN *[]string
	outerUnitNic *[]string
	outerUnitNie *[]string
	outerUnitNiew *[]string
	outerUnitNire *[]string
	outerUnitNisw *[]string
	outerUnitNre *[]string
	outerUnitRe *[]string
	outerWidth *[]int32
	outerWidthGt *[]int32
	outerWidthGte *[]int32
	outerWidthIsnull *bool
	outerWidthLt *[]int32
	outerWidthLte *[]int32
	outerWidthN *[]int32
	powerFeeds *[]string
	powerFeedsIsnull *bool
	powerFeedsN *[]string
	q *string
	rackGroup *[]string
	rackGroupIsnull *bool
	rackGroupN *[]string
	rackReservations *[]string
	rackReservationsIsnull *bool
	rackReservationsN *[]string
	role *[]string
	roleIsnull *bool
	roleN *[]string
	serial *[]string
	sort *string
	status *[]string
	statusN *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	uHeight *[]int32
	uHeightGt *[]int32
	uHeightGte *[]int32
	uHeightLt *[]int32
	uHeightLte *[]int32
	uHeightN *[]int32
	width *[]int32
	widthIc *[]int32
	widthIe *[]int32
	widthIew *[]int32
	widthIre *[]int32
	widthIsw *[]int32
	widthN *[]int32
	widthNic *[]int32
	widthNie *[]int32
	widthNiew *[]int32
	widthNire *[]int32
	widthNisw *[]int32
	widthNre *[]int32
	widthRe *[]int32
	depth *int32
}

func (r ApiDcimRacksListRequest) AssetTag(assetTag []string) ApiDcimRacksListRequest {
	r.assetTag = &assetTag
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIc(assetTagIc []string) ApiDcimRacksListRequest {
	r.assetTagIc = &assetTagIc
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIe(assetTagIe []string) ApiDcimRacksListRequest {
	r.assetTagIe = &assetTagIe
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIew(assetTagIew []string) ApiDcimRacksListRequest {
	r.assetTagIew = &assetTagIew
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIre(assetTagIre []string) ApiDcimRacksListRequest {
	r.assetTagIre = &assetTagIre
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIsnull(assetTagIsnull bool) ApiDcimRacksListRequest {
	r.assetTagIsnull = &assetTagIsnull
	return r
}

func (r ApiDcimRacksListRequest) AssetTagIsw(assetTagIsw []string) ApiDcimRacksListRequest {
	r.assetTagIsw = &assetTagIsw
	return r
}

func (r ApiDcimRacksListRequest) AssetTagN(assetTagN []string) ApiDcimRacksListRequest {
	r.assetTagN = &assetTagN
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNic(assetTagNic []string) ApiDcimRacksListRequest {
	r.assetTagNic = &assetTagNic
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNie(assetTagNie []string) ApiDcimRacksListRequest {
	r.assetTagNie = &assetTagNie
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNiew(assetTagNiew []string) ApiDcimRacksListRequest {
	r.assetTagNiew = &assetTagNiew
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNire(assetTagNire []string) ApiDcimRacksListRequest {
	r.assetTagNire = &assetTagNire
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNisw(assetTagNisw []string) ApiDcimRacksListRequest {
	r.assetTagNisw = &assetTagNisw
	return r
}

func (r ApiDcimRacksListRequest) AssetTagNre(assetTagNre []string) ApiDcimRacksListRequest {
	r.assetTagNre = &assetTagNre
	return r
}

func (r ApiDcimRacksListRequest) AssetTagRe(assetTagRe []string) ApiDcimRacksListRequest {
	r.assetTagRe = &assetTagRe
	return r
}

func (r ApiDcimRacksListRequest) Comments(comments []string) ApiDcimRacksListRequest {
	r.comments = &comments
	return r
}

func (r ApiDcimRacksListRequest) CommentsIc(commentsIc []string) ApiDcimRacksListRequest {
	r.commentsIc = &commentsIc
	return r
}

func (r ApiDcimRacksListRequest) CommentsIe(commentsIe []string) ApiDcimRacksListRequest {
	r.commentsIe = &commentsIe
	return r
}

func (r ApiDcimRacksListRequest) CommentsIew(commentsIew []string) ApiDcimRacksListRequest {
	r.commentsIew = &commentsIew
	return r
}

func (r ApiDcimRacksListRequest) CommentsIre(commentsIre []string) ApiDcimRacksListRequest {
	r.commentsIre = &commentsIre
	return r
}

func (r ApiDcimRacksListRequest) CommentsIsw(commentsIsw []string) ApiDcimRacksListRequest {
	r.commentsIsw = &commentsIsw
	return r
}

func (r ApiDcimRacksListRequest) CommentsN(commentsN []string) ApiDcimRacksListRequest {
	r.commentsN = &commentsN
	return r
}

func (r ApiDcimRacksListRequest) CommentsNic(commentsNic []string) ApiDcimRacksListRequest {
	r.commentsNic = &commentsNic
	return r
}

func (r ApiDcimRacksListRequest) CommentsNie(commentsNie []string) ApiDcimRacksListRequest {
	r.commentsNie = &commentsNie
	return r
}

func (r ApiDcimRacksListRequest) CommentsNiew(commentsNiew []string) ApiDcimRacksListRequest {
	r.commentsNiew = &commentsNiew
	return r
}

func (r ApiDcimRacksListRequest) CommentsNire(commentsNire []string) ApiDcimRacksListRequest {
	r.commentsNire = &commentsNire
	return r
}

func (r ApiDcimRacksListRequest) CommentsNisw(commentsNisw []string) ApiDcimRacksListRequest {
	r.commentsNisw = &commentsNisw
	return r
}

func (r ApiDcimRacksListRequest) CommentsNre(commentsNre []string) ApiDcimRacksListRequest {
	r.commentsNre = &commentsNre
	return r
}

func (r ApiDcimRacksListRequest) CommentsRe(commentsRe []string) ApiDcimRacksListRequest {
	r.commentsRe = &commentsRe
	return r
}

func (r ApiDcimRacksListRequest) Created(created []time.Time) ApiDcimRacksListRequest {
	r.created = &created
	return r
}

func (r ApiDcimRacksListRequest) CreatedGt(createdGt []time.Time) ApiDcimRacksListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimRacksListRequest) CreatedGte(createdGte []time.Time) ApiDcimRacksListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimRacksListRequest) CreatedIsnull(createdIsnull bool) ApiDcimRacksListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimRacksListRequest) CreatedLt(createdLt []time.Time) ApiDcimRacksListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimRacksListRequest) CreatedLte(createdLte []time.Time) ApiDcimRacksListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimRacksListRequest) CreatedN(createdN []time.Time) ApiDcimRacksListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimRacksListRequest) DescUnits(descUnits bool) ApiDcimRacksListRequest {
	r.descUnits = &descUnits
	return r
}

func (r ApiDcimRacksListRequest) Devices(devices []string) ApiDcimRacksListRequest {
	r.devices = &devices
	return r
}

func (r ApiDcimRacksListRequest) DevicesIsnull(devicesIsnull bool) ApiDcimRacksListRequest {
	r.devicesIsnull = &devicesIsnull
	return r
}

func (r ApiDcimRacksListRequest) DevicesN(devicesN []string) ApiDcimRacksListRequest {
	r.devicesN = &devicesN
	return r
}

func (r ApiDcimRacksListRequest) FacilityId(facilityId []string) ApiDcimRacksListRequest {
	r.facilityId = &facilityId
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIc(facilityIdIc []string) ApiDcimRacksListRequest {
	r.facilityIdIc = &facilityIdIc
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIe(facilityIdIe []string) ApiDcimRacksListRequest {
	r.facilityIdIe = &facilityIdIe
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIew(facilityIdIew []string) ApiDcimRacksListRequest {
	r.facilityIdIew = &facilityIdIew
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIre(facilityIdIre []string) ApiDcimRacksListRequest {
	r.facilityIdIre = &facilityIdIre
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIsnull(facilityIdIsnull bool) ApiDcimRacksListRequest {
	r.facilityIdIsnull = &facilityIdIsnull
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdIsw(facilityIdIsw []string) ApiDcimRacksListRequest {
	r.facilityIdIsw = &facilityIdIsw
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdN(facilityIdN []string) ApiDcimRacksListRequest {
	r.facilityIdN = &facilityIdN
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNic(facilityIdNic []string) ApiDcimRacksListRequest {
	r.facilityIdNic = &facilityIdNic
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNie(facilityIdNie []string) ApiDcimRacksListRequest {
	r.facilityIdNie = &facilityIdNie
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNiew(facilityIdNiew []string) ApiDcimRacksListRequest {
	r.facilityIdNiew = &facilityIdNiew
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNire(facilityIdNire []string) ApiDcimRacksListRequest {
	r.facilityIdNire = &facilityIdNire
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNisw(facilityIdNisw []string) ApiDcimRacksListRequest {
	r.facilityIdNisw = &facilityIdNisw
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdNre(facilityIdNre []string) ApiDcimRacksListRequest {
	r.facilityIdNre = &facilityIdNre
	return r
}

func (r ApiDcimRacksListRequest) FacilityIdRe(facilityIdRe []string) ApiDcimRacksListRequest {
	r.facilityIdRe = &facilityIdRe
	return r
}

func (r ApiDcimRacksListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksListRequest {
	r.format = &format
	return r
}

// Has devices
func (r ApiDcimRacksListRequest) HasDevices(hasDevices bool) ApiDcimRacksListRequest {
	r.hasDevices = &hasDevices
	return r
}

// Has power feeds
func (r ApiDcimRacksListRequest) HasPowerFeeds(hasPowerFeeds bool) ApiDcimRacksListRequest {
	r.hasPowerFeeds = &hasPowerFeeds
	return r
}

// Has rack reservations
func (r ApiDcimRacksListRequest) HasRackReservations(hasRackReservations bool) ApiDcimRacksListRequest {
	r.hasRackReservations = &hasRackReservations
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimRacksListRequest) Id(id []string) ApiDcimRacksListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRacksListRequest) IdIc(idIc []string) ApiDcimRacksListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimRacksListRequest) IdIe(idIe []string) ApiDcimRacksListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimRacksListRequest) IdIew(idIew []string) ApiDcimRacksListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimRacksListRequest) IdIre(idIre []string) ApiDcimRacksListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimRacksListRequest) IdIsw(idIsw []string) ApiDcimRacksListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimRacksListRequest) IdN(idN []string) ApiDcimRacksListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRacksListRequest) IdNic(idNic []string) ApiDcimRacksListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimRacksListRequest) IdNie(idNie []string) ApiDcimRacksListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimRacksListRequest) IdNiew(idNiew []string) ApiDcimRacksListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimRacksListRequest) IdNire(idNire []string) ApiDcimRacksListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimRacksListRequest) IdNisw(idNisw []string) ApiDcimRacksListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimRacksListRequest) IdNre(idNre []string) ApiDcimRacksListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimRacksListRequest) IdRe(idRe []string) ApiDcimRacksListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimRacksListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimRacksListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimRacksListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimRacksListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimRacksListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimRacksListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimRacksListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimRacksListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimRacksListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimRacksListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimRacksListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimRacksListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimRacksListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimRacksListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimRacksListRequest) Limit(limit int32) ApiDcimRacksListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimRacksListRequest) Location(location []string) ApiDcimRacksListRequest {
	r.location = &location
	return r
}

func (r ApiDcimRacksListRequest) LocationN(locationN []string) ApiDcimRacksListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimRacksListRequest) Name(name []string) ApiDcimRacksListRequest {
	r.name = &name
	return r
}

func (r ApiDcimRacksListRequest) NameIc(nameIc []string) ApiDcimRacksListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimRacksListRequest) NameIe(nameIe []string) ApiDcimRacksListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimRacksListRequest) NameIew(nameIew []string) ApiDcimRacksListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimRacksListRequest) NameIre(nameIre []string) ApiDcimRacksListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimRacksListRequest) NameIsw(nameIsw []string) ApiDcimRacksListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimRacksListRequest) NameN(nameN []string) ApiDcimRacksListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimRacksListRequest) NameNic(nameNic []string) ApiDcimRacksListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimRacksListRequest) NameNie(nameNie []string) ApiDcimRacksListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimRacksListRequest) NameNiew(nameNiew []string) ApiDcimRacksListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimRacksListRequest) NameNire(nameNire []string) ApiDcimRacksListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimRacksListRequest) NameNisw(nameNisw []string) ApiDcimRacksListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimRacksListRequest) NameNre(nameNre []string) ApiDcimRacksListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimRacksListRequest) NameRe(nameRe []string) ApiDcimRacksListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRacksListRequest) Offset(offset int32) ApiDcimRacksListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRacksListRequest) OuterDepth(outerDepth []int32) ApiDcimRacksListRequest {
	r.outerDepth = &outerDepth
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthGt(outerDepthGt []int32) ApiDcimRacksListRequest {
	r.outerDepthGt = &outerDepthGt
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthGte(outerDepthGte []int32) ApiDcimRacksListRequest {
	r.outerDepthGte = &outerDepthGte
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthIsnull(outerDepthIsnull bool) ApiDcimRacksListRequest {
	r.outerDepthIsnull = &outerDepthIsnull
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthLt(outerDepthLt []int32) ApiDcimRacksListRequest {
	r.outerDepthLt = &outerDepthLt
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthLte(outerDepthLte []int32) ApiDcimRacksListRequest {
	r.outerDepthLte = &outerDepthLte
	return r
}

func (r ApiDcimRacksListRequest) OuterDepthN(outerDepthN []int32) ApiDcimRacksListRequest {
	r.outerDepthN = &outerDepthN
	return r
}

func (r ApiDcimRacksListRequest) OuterUnit(outerUnit []string) ApiDcimRacksListRequest {
	r.outerUnit = &outerUnit
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitIc(outerUnitIc []string) ApiDcimRacksListRequest {
	r.outerUnitIc = &outerUnitIc
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitIe(outerUnitIe []string) ApiDcimRacksListRequest {
	r.outerUnitIe = &outerUnitIe
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitIew(outerUnitIew []string) ApiDcimRacksListRequest {
	r.outerUnitIew = &outerUnitIew
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitIre(outerUnitIre []string) ApiDcimRacksListRequest {
	r.outerUnitIre = &outerUnitIre
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitIsw(outerUnitIsw []string) ApiDcimRacksListRequest {
	r.outerUnitIsw = &outerUnitIsw
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitN(outerUnitN []string) ApiDcimRacksListRequest {
	r.outerUnitN = &outerUnitN
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitNic(outerUnitNic []string) ApiDcimRacksListRequest {
	r.outerUnitNic = &outerUnitNic
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitNie(outerUnitNie []string) ApiDcimRacksListRequest {
	r.outerUnitNie = &outerUnitNie
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitNiew(outerUnitNiew []string) ApiDcimRacksListRequest {
	r.outerUnitNiew = &outerUnitNiew
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitNire(outerUnitNire []string) ApiDcimRacksListRequest {
	r.outerUnitNire = &outerUnitNire
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitNisw(outerUnitNisw []string) ApiDcimRacksListRequest {
	r.outerUnitNisw = &outerUnitNisw
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitNre(outerUnitNre []string) ApiDcimRacksListRequest {
	r.outerUnitNre = &outerUnitNre
	return r
}

func (r ApiDcimRacksListRequest) OuterUnitRe(outerUnitRe []string) ApiDcimRacksListRequest {
	r.outerUnitRe = &outerUnitRe
	return r
}

func (r ApiDcimRacksListRequest) OuterWidth(outerWidth []int32) ApiDcimRacksListRequest {
	r.outerWidth = &outerWidth
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthGt(outerWidthGt []int32) ApiDcimRacksListRequest {
	r.outerWidthGt = &outerWidthGt
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthGte(outerWidthGte []int32) ApiDcimRacksListRequest {
	r.outerWidthGte = &outerWidthGte
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthIsnull(outerWidthIsnull bool) ApiDcimRacksListRequest {
	r.outerWidthIsnull = &outerWidthIsnull
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthLt(outerWidthLt []int32) ApiDcimRacksListRequest {
	r.outerWidthLt = &outerWidthLt
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthLte(outerWidthLte []int32) ApiDcimRacksListRequest {
	r.outerWidthLte = &outerWidthLte
	return r
}

func (r ApiDcimRacksListRequest) OuterWidthN(outerWidthN []int32) ApiDcimRacksListRequest {
	r.outerWidthN = &outerWidthN
	return r
}

func (r ApiDcimRacksListRequest) PowerFeeds(powerFeeds []string) ApiDcimRacksListRequest {
	r.powerFeeds = &powerFeeds
	return r
}

func (r ApiDcimRacksListRequest) PowerFeedsIsnull(powerFeedsIsnull bool) ApiDcimRacksListRequest {
	r.powerFeedsIsnull = &powerFeedsIsnull
	return r
}

func (r ApiDcimRacksListRequest) PowerFeedsN(powerFeedsN []string) ApiDcimRacksListRequest {
	r.powerFeedsN = &powerFeedsN
	return r
}

// Search
func (r ApiDcimRacksListRequest) Q(q string) ApiDcimRacksListRequest {
	r.q = &q
	return r
}

func (r ApiDcimRacksListRequest) RackGroup(rackGroup []string) ApiDcimRacksListRequest {
	r.rackGroup = &rackGroup
	return r
}

func (r ApiDcimRacksListRequest) RackGroupIsnull(rackGroupIsnull bool) ApiDcimRacksListRequest {
	r.rackGroupIsnull = &rackGroupIsnull
	return r
}

func (r ApiDcimRacksListRequest) RackGroupN(rackGroupN []string) ApiDcimRacksListRequest {
	r.rackGroupN = &rackGroupN
	return r
}

func (r ApiDcimRacksListRequest) RackReservations(rackReservations []string) ApiDcimRacksListRequest {
	r.rackReservations = &rackReservations
	return r
}

func (r ApiDcimRacksListRequest) RackReservationsIsnull(rackReservationsIsnull bool) ApiDcimRacksListRequest {
	r.rackReservationsIsnull = &rackReservationsIsnull
	return r
}

func (r ApiDcimRacksListRequest) RackReservationsN(rackReservationsN []string) ApiDcimRacksListRequest {
	r.rackReservationsN = &rackReservationsN
	return r
}

func (r ApiDcimRacksListRequest) Role(role []string) ApiDcimRacksListRequest {
	r.role = &role
	return r
}

func (r ApiDcimRacksListRequest) RoleIsnull(roleIsnull bool) ApiDcimRacksListRequest {
	r.roleIsnull = &roleIsnull
	return r
}

func (r ApiDcimRacksListRequest) RoleN(roleN []string) ApiDcimRacksListRequest {
	r.roleN = &roleN
	return r
}

// Serial Number
func (r ApiDcimRacksListRequest) Serial(serial []string) ApiDcimRacksListRequest {
	r.serial = &serial
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimRacksListRequest) Sort(sort string) ApiDcimRacksListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimRacksListRequest) Status(status []string) ApiDcimRacksListRequest {
	r.status = &status
	return r
}

func (r ApiDcimRacksListRequest) StatusN(statusN []string) ApiDcimRacksListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimRacksListRequest) Tags(tags []string) ApiDcimRacksListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimRacksListRequest) TagsIsnull(tagsIsnull bool) ApiDcimRacksListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimRacksListRequest) TagsN(tagsN []string) ApiDcimRacksListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimRacksListRequest) Tenant(tenant []string) ApiDcimRacksListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimRacksListRequest) TenantIsnull(tenantIsnull bool) ApiDcimRacksListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiDcimRacksListRequest) TenantN(tenantN []string) ApiDcimRacksListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiDcimRacksListRequest) TenantGroup(tenantGroup []string) ApiDcimRacksListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiDcimRacksListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiDcimRacksListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiDcimRacksListRequest) TenantGroupN(tenantGroupN []string) ApiDcimRacksListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimRacksListRequest) TenantId(tenantId []*string) ApiDcimRacksListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiDcimRacksListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiDcimRacksListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiDcimRacksListRequest) TenantIdN(tenantIdN []*string) ApiDcimRacksListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiDcimRacksListRequest) Type_(type_ []string) ApiDcimRacksListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimRacksListRequest) TypeIc(typeIc []string) ApiDcimRacksListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimRacksListRequest) TypeIe(typeIe []string) ApiDcimRacksListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimRacksListRequest) TypeIew(typeIew []string) ApiDcimRacksListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimRacksListRequest) TypeIre(typeIre []string) ApiDcimRacksListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimRacksListRequest) TypeIsw(typeIsw []string) ApiDcimRacksListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimRacksListRequest) TypeN(typeN []string) ApiDcimRacksListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimRacksListRequest) TypeNic(typeNic []string) ApiDcimRacksListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimRacksListRequest) TypeNie(typeNie []string) ApiDcimRacksListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimRacksListRequest) TypeNiew(typeNiew []string) ApiDcimRacksListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimRacksListRequest) TypeNire(typeNire []string) ApiDcimRacksListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimRacksListRequest) TypeNisw(typeNisw []string) ApiDcimRacksListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimRacksListRequest) TypeNre(typeNre []string) ApiDcimRacksListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimRacksListRequest) TypeRe(typeRe []string) ApiDcimRacksListRequest {
	r.typeRe = &typeRe
	return r
}

func (r ApiDcimRacksListRequest) UHeight(uHeight []int32) ApiDcimRacksListRequest {
	r.uHeight = &uHeight
	return r
}

func (r ApiDcimRacksListRequest) UHeightGt(uHeightGt []int32) ApiDcimRacksListRequest {
	r.uHeightGt = &uHeightGt
	return r
}

func (r ApiDcimRacksListRequest) UHeightGte(uHeightGte []int32) ApiDcimRacksListRequest {
	r.uHeightGte = &uHeightGte
	return r
}

func (r ApiDcimRacksListRequest) UHeightLt(uHeightLt []int32) ApiDcimRacksListRequest {
	r.uHeightLt = &uHeightLt
	return r
}

func (r ApiDcimRacksListRequest) UHeightLte(uHeightLte []int32) ApiDcimRacksListRequest {
	r.uHeightLte = &uHeightLte
	return r
}

func (r ApiDcimRacksListRequest) UHeightN(uHeightN []int32) ApiDcimRacksListRequest {
	r.uHeightN = &uHeightN
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) Width(width []int32) ApiDcimRacksListRequest {
	r.width = &width
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthIc(widthIc []int32) ApiDcimRacksListRequest {
	r.widthIc = &widthIc
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthIe(widthIe []int32) ApiDcimRacksListRequest {
	r.widthIe = &widthIe
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthIew(widthIew []int32) ApiDcimRacksListRequest {
	r.widthIew = &widthIew
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthIre(widthIre []int32) ApiDcimRacksListRequest {
	r.widthIre = &widthIre
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthIsw(widthIsw []int32) ApiDcimRacksListRequest {
	r.widthIsw = &widthIsw
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthN(widthN []int32) ApiDcimRacksListRequest {
	r.widthN = &widthN
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthNic(widthNic []int32) ApiDcimRacksListRequest {
	r.widthNic = &widthNic
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthNie(widthNie []int32) ApiDcimRacksListRequest {
	r.widthNie = &widthNie
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthNiew(widthNiew []int32) ApiDcimRacksListRequest {
	r.widthNiew = &widthNiew
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthNire(widthNire []int32) ApiDcimRacksListRequest {
	r.widthNire = &widthNire
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthNisw(widthNisw []int32) ApiDcimRacksListRequest {
	r.widthNisw = &widthNisw
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthNre(widthNre []int32) ApiDcimRacksListRequest {
	r.widthNre = &widthNre
	return r
}

// Rail-to-rail width
func (r ApiDcimRacksListRequest) WidthRe(widthRe []int32) ApiDcimRacksListRequest {
	r.widthRe = &widthRe
	return r
}

// Serializer Depth
func (r ApiDcimRacksListRequest) Depth(depth int32) ApiDcimRacksListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRacksListRequest) Execute() (*PaginatedRackList, *http.Response, error) {
	return r.ApiService.DcimRacksListExecute(r)
}

/*
DcimRacksList Method for DcimRacksList

Retrieve a list of rack objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRacksListRequest
*/
func (a *DcimAPIService) DcimRacksList(ctx context.Context) ApiDcimRacksListRequest {
	return ApiDcimRacksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRackList
func (a *DcimAPIService) DcimRacksListExecute(r ApiDcimRacksListRequest) (*PaginatedRackList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRackList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.assetTag != nil {
		t := *r.assetTag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag", t, "multi")
		}
	}
	if r.assetTagIc != nil {
		t := *r.assetTagIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ic", t, "multi")
		}
	}
	if r.assetTagIe != nil {
		t := *r.assetTagIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ie", t, "multi")
		}
	}
	if r.assetTagIew != nil {
		t := *r.assetTagIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__iew", t, "multi")
		}
	}
	if r.assetTagIre != nil {
		t := *r.assetTagIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__ire", t, "multi")
		}
	}
	if r.assetTagIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isnull", r.assetTagIsnull, "")
	}
	if r.assetTagIsw != nil {
		t := *r.assetTagIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__isw", t, "multi")
		}
	}
	if r.assetTagN != nil {
		t := *r.assetTagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__n", t, "multi")
		}
	}
	if r.assetTagNic != nil {
		t := *r.assetTagNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nic", t, "multi")
		}
	}
	if r.assetTagNie != nil {
		t := *r.assetTagNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nie", t, "multi")
		}
	}
	if r.assetTagNiew != nil {
		t := *r.assetTagNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__niew", t, "multi")
		}
	}
	if r.assetTagNire != nil {
		t := *r.assetTagNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nire", t, "multi")
		}
	}
	if r.assetTagNisw != nil {
		t := *r.assetTagNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nisw", t, "multi")
		}
	}
	if r.assetTagNre != nil {
		t := *r.assetTagNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__nre", t, "multi")
		}
	}
	if r.assetTagRe != nil {
		t := *r.assetTagRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asset_tag__re", t, "multi")
		}
	}
	if r.comments != nil {
		t := *r.comments
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments", t, "multi")
		}
	}
	if r.commentsIc != nil {
		t := *r.commentsIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ic", t, "multi")
		}
	}
	if r.commentsIe != nil {
		t := *r.commentsIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ie", t, "multi")
		}
	}
	if r.commentsIew != nil {
		t := *r.commentsIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__iew", t, "multi")
		}
	}
	if r.commentsIre != nil {
		t := *r.commentsIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__ire", t, "multi")
		}
	}
	if r.commentsIsw != nil {
		t := *r.commentsIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__isw", t, "multi")
		}
	}
	if r.commentsN != nil {
		t := *r.commentsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__n", t, "multi")
		}
	}
	if r.commentsNic != nil {
		t := *r.commentsNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nic", t, "multi")
		}
	}
	if r.commentsNie != nil {
		t := *r.commentsNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nie", t, "multi")
		}
	}
	if r.commentsNiew != nil {
		t := *r.commentsNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__niew", t, "multi")
		}
	}
	if r.commentsNire != nil {
		t := *r.commentsNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nire", t, "multi")
		}
	}
	if r.commentsNisw != nil {
		t := *r.commentsNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nisw", t, "multi")
		}
	}
	if r.commentsNre != nil {
		t := *r.commentsNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__nre", t, "multi")
		}
	}
	if r.commentsRe != nil {
		t := *r.commentsRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "comments__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "comments__re", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.descUnits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "desc_units", r.descUnits, "")
	}
	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices", t, "multi")
		}
	}
	if r.devicesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices__isnull", r.devicesIsnull, "")
	}
	if r.devicesN != nil {
		t := *r.devicesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", t, "multi")
		}
	}
	if r.facilityId != nil {
		t := *r.facilityId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id", t, "multi")
		}
	}
	if r.facilityIdIc != nil {
		t := *r.facilityIdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__ic", t, "multi")
		}
	}
	if r.facilityIdIe != nil {
		t := *r.facilityIdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__ie", t, "multi")
		}
	}
	if r.facilityIdIew != nil {
		t := *r.facilityIdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__iew", t, "multi")
		}
	}
	if r.facilityIdIre != nil {
		t := *r.facilityIdIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__ire", t, "multi")
		}
	}
	if r.facilityIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__isnull", r.facilityIdIsnull, "")
	}
	if r.facilityIdIsw != nil {
		t := *r.facilityIdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__isw", t, "multi")
		}
	}
	if r.facilityIdN != nil {
		t := *r.facilityIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__n", t, "multi")
		}
	}
	if r.facilityIdNic != nil {
		t := *r.facilityIdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nic", t, "multi")
		}
	}
	if r.facilityIdNie != nil {
		t := *r.facilityIdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nie", t, "multi")
		}
	}
	if r.facilityIdNiew != nil {
		t := *r.facilityIdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__niew", t, "multi")
		}
	}
	if r.facilityIdNire != nil {
		t := *r.facilityIdNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nire", t, "multi")
		}
	}
	if r.facilityIdNisw != nil {
		t := *r.facilityIdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nisw", t, "multi")
		}
	}
	if r.facilityIdNre != nil {
		t := *r.facilityIdNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__nre", t, "multi")
		}
	}
	if r.facilityIdRe != nil {
		t := *r.facilityIdRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facility_id__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_devices", r.hasDevices, "")
	}
	if r.hasPowerFeeds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_power_feeds", r.hasPowerFeeds, "")
	}
	if r.hasRackReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_rack_reservations", r.hasRackReservations, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.outerDepth != nil {
		t := *r.outerDepth
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth", t, "multi")
		}
	}
	if r.outerDepthGt != nil {
		t := *r.outerDepthGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__gt", t, "multi")
		}
	}
	if r.outerDepthGte != nil {
		t := *r.outerDepthGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__gte", t, "multi")
		}
	}
	if r.outerDepthIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__isnull", r.outerDepthIsnull, "")
	}
	if r.outerDepthLt != nil {
		t := *r.outerDepthLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__lt", t, "multi")
		}
	}
	if r.outerDepthLte != nil {
		t := *r.outerDepthLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__lte", t, "multi")
		}
	}
	if r.outerDepthN != nil {
		t := *r.outerDepthN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_depth__n", t, "multi")
		}
	}
	if r.outerUnit != nil {
		t := *r.outerUnit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit", t, "multi")
		}
	}
	if r.outerUnitIc != nil {
		t := *r.outerUnitIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__ic", t, "multi")
		}
	}
	if r.outerUnitIe != nil {
		t := *r.outerUnitIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__ie", t, "multi")
		}
	}
	if r.outerUnitIew != nil {
		t := *r.outerUnitIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__iew", t, "multi")
		}
	}
	if r.outerUnitIre != nil {
		t := *r.outerUnitIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__ire", t, "multi")
		}
	}
	if r.outerUnitIsw != nil {
		t := *r.outerUnitIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__isw", t, "multi")
		}
	}
	if r.outerUnitN != nil {
		t := *r.outerUnitN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__n", t, "multi")
		}
	}
	if r.outerUnitNic != nil {
		t := *r.outerUnitNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nic", t, "multi")
		}
	}
	if r.outerUnitNie != nil {
		t := *r.outerUnitNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nie", t, "multi")
		}
	}
	if r.outerUnitNiew != nil {
		t := *r.outerUnitNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__niew", t, "multi")
		}
	}
	if r.outerUnitNire != nil {
		t := *r.outerUnitNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nire", t, "multi")
		}
	}
	if r.outerUnitNisw != nil {
		t := *r.outerUnitNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nisw", t, "multi")
		}
	}
	if r.outerUnitNre != nil {
		t := *r.outerUnitNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__nre", t, "multi")
		}
	}
	if r.outerUnitRe != nil {
		t := *r.outerUnitRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_unit__re", t, "multi")
		}
	}
	if r.outerWidth != nil {
		t := *r.outerWidth
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width", t, "multi")
		}
	}
	if r.outerWidthGt != nil {
		t := *r.outerWidthGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__gt", t, "multi")
		}
	}
	if r.outerWidthGte != nil {
		t := *r.outerWidthGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__gte", t, "multi")
		}
	}
	if r.outerWidthIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__isnull", r.outerWidthIsnull, "")
	}
	if r.outerWidthLt != nil {
		t := *r.outerWidthLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__lt", t, "multi")
		}
	}
	if r.outerWidthLte != nil {
		t := *r.outerWidthLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__lte", t, "multi")
		}
	}
	if r.outerWidthN != nil {
		t := *r.outerWidthN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outer_width__n", t, "multi")
		}
	}
	if r.powerFeeds != nil {
		t := *r.powerFeeds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds", t, "multi")
		}
	}
	if r.powerFeedsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds__isnull", r.powerFeedsIsnull, "")
	}
	if r.powerFeedsN != nil {
		t := *r.powerFeedsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "power_feeds__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rackGroup != nil {
		t := *r.rackGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group", t, "multi")
		}
	}
	if r.rackGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__isnull", r.rackGroupIsnull, "")
	}
	if r.rackGroupN != nil {
		t := *r.rackGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_group__n", t, "multi")
		}
	}
	if r.rackReservations != nil {
		t := *r.rackReservations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_reservations", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_reservations", t, "multi")
		}
	}
	if r.rackReservationsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack_reservations__isnull", r.rackReservationsIsnull, "")
	}
	if r.rackReservationsN != nil {
		t := *r.rackReservationsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rack_reservations__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rack_reservations__n", t, "multi")
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "multi")
		}
	}
	if r.roleIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__isnull", r.roleIsnull, "")
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "multi")
		}
	}
	if r.serial != nil {
		t := *r.serial
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serial", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serial", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.uHeight != nil {
		t := *r.uHeight
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height", t, "multi")
		}
	}
	if r.uHeightGt != nil {
		t := *r.uHeightGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__gt", t, "multi")
		}
	}
	if r.uHeightGte != nil {
		t := *r.uHeightGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__gte", t, "multi")
		}
	}
	if r.uHeightLt != nil {
		t := *r.uHeightLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__lt", t, "multi")
		}
	}
	if r.uHeightLte != nil {
		t := *r.uHeightLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__lte", t, "multi")
		}
	}
	if r.uHeightN != nil {
		t := *r.uHeightN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "u_height__n", t, "multi")
		}
	}
	if r.width != nil {
		t := *r.width
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width", t, "multi")
		}
	}
	if r.widthIc != nil {
		t := *r.widthIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__ic", t, "multi")
		}
	}
	if r.widthIe != nil {
		t := *r.widthIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__ie", t, "multi")
		}
	}
	if r.widthIew != nil {
		t := *r.widthIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__iew", t, "multi")
		}
	}
	if r.widthIre != nil {
		t := *r.widthIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__ire", t, "multi")
		}
	}
	if r.widthIsw != nil {
		t := *r.widthIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__isw", t, "multi")
		}
	}
	if r.widthN != nil {
		t := *r.widthN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__n", t, "multi")
		}
	}
	if r.widthNic != nil {
		t := *r.widthNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__nic", t, "multi")
		}
	}
	if r.widthNie != nil {
		t := *r.widthNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__nie", t, "multi")
		}
	}
	if r.widthNiew != nil {
		t := *r.widthNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__niew", t, "multi")
		}
	}
	if r.widthNire != nil {
		t := *r.widthNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__nire", t, "multi")
		}
	}
	if r.widthNisw != nil {
		t := *r.widthNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__nisw", t, "multi")
		}
	}
	if r.widthNre != nil {
		t := *r.widthNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__nre", t, "multi")
		}
	}
	if r.widthRe != nil {
		t := *r.widthRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "width__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "width__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRacksNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimRacksNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimRacksNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimRacksNotesCreateExecute(r)
}

/*
DcimRacksNotesCreate Method for DcimRacksNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack.
 @return ApiDcimRacksNotesCreateRequest
*/
func (a *DcimAPIService) DcimRacksNotesCreate(ctx context.Context, id string) ApiDcimRacksNotesCreateRequest {
	return ApiDcimRacksNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimRacksNotesCreateExecute(r ApiDcimRacksNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimRacksNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimRacksNotesListRequest) Limit(limit int32) ApiDcimRacksNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRacksNotesListRequest) Offset(offset int32) ApiDcimRacksNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimRacksNotesListRequest) Depth(depth int32) ApiDcimRacksNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRacksNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimRacksNotesListExecute(r)
}

/*
DcimRacksNotesList Method for DcimRacksNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack.
 @return ApiDcimRacksNotesListRequest
*/
func (a *DcimAPIService) DcimRacksNotesList(ctx context.Context, id string) ApiDcimRacksNotesListRequest {
	return ApiDcimRacksNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimRacksNotesListExecute(r ApiDcimRacksNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableRackRequest *PatchedWritableRackRequest
}

func (r ApiDcimRacksPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksPartialUpdateRequest) PatchedWritableRackRequest(patchedWritableRackRequest PatchedWritableRackRequest) ApiDcimRacksPartialUpdateRequest {
	r.patchedWritableRackRequest = &patchedWritableRackRequest
	return r
}

func (r ApiDcimRacksPartialUpdateRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksPartialUpdateExecute(r)
}

/*
DcimRacksPartialUpdate Method for DcimRacksPartialUpdate

Partial update a rack object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack.
 @return ApiDcimRacksPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRacksPartialUpdate(ctx context.Context, id string) ApiDcimRacksPartialUpdateRequest {
	return ApiDcimRacksPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimAPIService) DcimRacksPartialUpdateExecute(r ApiDcimRacksPartialUpdateRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableRackRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimRacksRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimRacksRetrieveRequest) Depth(depth int32) ApiDcimRacksRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRacksRetrieveRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksRetrieveExecute(r)
}

/*
DcimRacksRetrieve Method for DcimRacksRetrieve

Retrieve a rack object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack.
 @return ApiDcimRacksRetrieveRequest
*/
func (a *DcimAPIService) DcimRacksRetrieve(ctx context.Context, id string) ApiDcimRacksRetrieveRequest {
	return ApiDcimRacksRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimAPIService) DcimRacksRetrieveExecute(r ApiDcimRacksRetrieveRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRacksUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableRackRequest *WritableRackRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRacksUpdateRequest) WritableRackRequest(writableRackRequest WritableRackRequest) ApiDcimRacksUpdateRequest {
	r.writableRackRequest = &writableRackRequest
	return r
}

func (r ApiDcimRacksUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRacksUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRacksUpdateRequest) Execute() (*Rack, *http.Response, error) {
	return r.ApiService.DcimRacksUpdateExecute(r)
}

/*
DcimRacksUpdate Method for DcimRacksUpdate

Update a rack object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rack.
 @return ApiDcimRacksUpdateRequest
*/
func (a *DcimAPIService) DcimRacksUpdate(ctx context.Context, id string) ApiDcimRacksUpdateRequest {
	return ApiDcimRacksUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Rack
func (a *DcimAPIService) DcimRacksUpdateExecute(r ApiDcimRacksUpdateRequest) (*Rack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRacksUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRackRequest == nil {
		return localVarReturnValue, nil, reportError("writableRackRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRackRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortTemplatesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimRearPortTemplatesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimRearPortTemplatesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesBulkDestroyExecute(r)
}

/*
DcimRearPortTemplatesBulkDestroy Method for DcimRearPortTemplatesBulkDestroy

Destroy a list of rear port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesBulkDestroy(ctx context.Context) ApiDcimRearPortTemplatesBulkDestroyRequest {
	return ApiDcimRearPortTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRearPortTemplatesBulkDestroyExecute(r ApiDcimRearPortTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableRearPortTemplateRequest *[]PatchedBulkWritableRearPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortTemplatesBulkPartialUpdateRequest) PatchedBulkWritableRearPortTemplateRequest(patchedBulkWritableRearPortTemplateRequest []PatchedBulkWritableRearPortTemplateRequest) ApiDcimRearPortTemplatesBulkPartialUpdateRequest {
	r.patchedBulkWritableRearPortTemplateRequest = &patchedBulkWritableRearPortTemplateRequest
	return r
}

func (r ApiDcimRearPortTemplatesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortTemplatesBulkPartialUpdateRequest) Execute() ([]RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesBulkPartialUpdateExecute(r)
}

/*
DcimRearPortTemplatesBulkPartialUpdate Method for DcimRearPortTemplatesBulkPartialUpdate

Partial update a list of rear port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesBulkPartialUpdate(ctx context.Context) ApiDcimRearPortTemplatesBulkPartialUpdateRequest {
	return ApiDcimRearPortTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RearPortTemplate
func (a *DcimAPIService) DcimRearPortTemplatesBulkPartialUpdateExecute(r ApiDcimRearPortTemplatesBulkPartialUpdateRequest) ([]RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableRearPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableRearPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableRearPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableRearPortTemplateRequest *[]BulkWritableRearPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortTemplatesBulkUpdateRequest) BulkWritableRearPortTemplateRequest(bulkWritableRearPortTemplateRequest []BulkWritableRearPortTemplateRequest) ApiDcimRearPortTemplatesBulkUpdateRequest {
	r.bulkWritableRearPortTemplateRequest = &bulkWritableRearPortTemplateRequest
	return r
}

func (r ApiDcimRearPortTemplatesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortTemplatesBulkUpdateRequest) Execute() ([]RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesBulkUpdateExecute(r)
}

/*
DcimRearPortTemplatesBulkUpdate Method for DcimRearPortTemplatesBulkUpdate

Update a list of rear port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesBulkUpdate(ctx context.Context) ApiDcimRearPortTemplatesBulkUpdateRequest {
	return ApiDcimRearPortTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RearPortTemplate
func (a *DcimAPIService) DcimRearPortTemplatesBulkUpdateExecute(r ApiDcimRearPortTemplatesBulkUpdateRequest) ([]RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableRearPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableRearPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableRearPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableRearPortTemplateRequest *WritableRearPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortTemplatesCreateRequest) WritableRearPortTemplateRequest(writableRearPortTemplateRequest WritableRearPortTemplateRequest) ApiDcimRearPortTemplatesCreateRequest {
	r.writableRearPortTemplateRequest = &writableRearPortTemplateRequest
	return r
}

func (r ApiDcimRearPortTemplatesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortTemplatesCreateRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesCreateExecute(r)
}

/*
DcimRearPortTemplatesCreate Method for DcimRearPortTemplatesCreate

Create one or more rear port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesCreateRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesCreate(ctx context.Context) ApiDcimRearPortTemplatesCreateRequest {
	return ApiDcimRearPortTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimAPIService) DcimRearPortTemplatesCreateExecute(r ApiDcimRearPortTemplatesCreateRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRearPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableRearPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRearPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortTemplatesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesDestroyExecute(r)
}

/*
DcimRearPortTemplatesDestroy Method for DcimRearPortTemplatesDestroy

Destroy a rear port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port template.
 @return ApiDcimRearPortTemplatesDestroyRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesDestroy(ctx context.Context, id string) ApiDcimRearPortTemplatesDestroyRequest {
	return ApiDcimRearPortTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRearPortTemplatesDestroyExecute(r ApiDcimRearPortTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	deviceType *[]string
	deviceTypeN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	frontPortTemplates *[]string
	frontPortTemplatesIsnull *bool
	frontPortTemplatesN *[]string
	hasFrontPortTemplates *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	positions *[]int32
	positionsGt *[]int32
	positionsGte *[]int32
	positionsLt *[]int32
	positionsLte *[]int32
	positionsN *[]int32
	q *string
	sort *string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) Description(description []string) ApiDcimRearPortTemplatesListRequest {
	r.description = &description
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionIre(descriptionIre []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionN(descriptionN []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionNire(descriptionNire []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionNre(descriptionNre []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

// Description
func (r ApiDcimRearPortTemplatesListRequest) DescriptionRe(descriptionRe []string) ApiDcimRearPortTemplatesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) DeviceType(deviceType []string) ApiDcimRearPortTemplatesListRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) DeviceTypeN(deviceTypeN []string) ApiDcimRearPortTemplatesListRequest {
	r.deviceTypeN = &deviceTypeN
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesListRequest {
	r.format = &format
	return r
}

// Front port templates
func (r ApiDcimRearPortTemplatesListRequest) FrontPortTemplates(frontPortTemplates []string) ApiDcimRearPortTemplatesListRequest {
	r.frontPortTemplates = &frontPortTemplates
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) FrontPortTemplatesIsnull(frontPortTemplatesIsnull bool) ApiDcimRearPortTemplatesListRequest {
	r.frontPortTemplatesIsnull = &frontPortTemplatesIsnull
	return r
}

// Front port templates
func (r ApiDcimRearPortTemplatesListRequest) FrontPortTemplatesN(frontPortTemplatesN []string) ApiDcimRearPortTemplatesListRequest {
	r.frontPortTemplatesN = &frontPortTemplatesN
	return r
}

// Has front port templates
func (r ApiDcimRearPortTemplatesListRequest) HasFrontPortTemplates(hasFrontPortTemplates bool) ApiDcimRearPortTemplatesListRequest {
	r.hasFrontPortTemplates = &hasFrontPortTemplates
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) Id(id []string) ApiDcimRearPortTemplatesListRequest {
	r.id = &id
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdIc(idIc []string) ApiDcimRearPortTemplatesListRequest {
	r.idIc = &idIc
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdIe(idIe []string) ApiDcimRearPortTemplatesListRequest {
	r.idIe = &idIe
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdIew(idIew []string) ApiDcimRearPortTemplatesListRequest {
	r.idIew = &idIew
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdIre(idIre []string) ApiDcimRearPortTemplatesListRequest {
	r.idIre = &idIre
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdIsw(idIsw []string) ApiDcimRearPortTemplatesListRequest {
	r.idIsw = &idIsw
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdN(idN []string) ApiDcimRearPortTemplatesListRequest {
	r.idN = &idN
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdNic(idNic []string) ApiDcimRearPortTemplatesListRequest {
	r.idNic = &idNic
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdNie(idNie []string) ApiDcimRearPortTemplatesListRequest {
	r.idNie = &idNie
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdNiew(idNiew []string) ApiDcimRearPortTemplatesListRequest {
	r.idNiew = &idNiew
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdNire(idNire []string) ApiDcimRearPortTemplatesListRequest {
	r.idNire = &idNire
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdNisw(idNisw []string) ApiDcimRearPortTemplatesListRequest {
	r.idNisw = &idNisw
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdNre(idNre []string) ApiDcimRearPortTemplatesListRequest {
	r.idNre = &idNre
	return r
}

// ID
func (r ApiDcimRearPortTemplatesListRequest) IdRe(idRe []string) ApiDcimRearPortTemplatesListRequest {
	r.idRe = &idRe
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) Label(label []string) ApiDcimRearPortTemplatesListRequest {
	r.label = &label
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelIc(labelIc []string) ApiDcimRearPortTemplatesListRequest {
	r.labelIc = &labelIc
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelIe(labelIe []string) ApiDcimRearPortTemplatesListRequest {
	r.labelIe = &labelIe
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelIew(labelIew []string) ApiDcimRearPortTemplatesListRequest {
	r.labelIew = &labelIew
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelIre(labelIre []string) ApiDcimRearPortTemplatesListRequest {
	r.labelIre = &labelIre
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelIsw(labelIsw []string) ApiDcimRearPortTemplatesListRequest {
	r.labelIsw = &labelIsw
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelN(labelN []string) ApiDcimRearPortTemplatesListRequest {
	r.labelN = &labelN
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelNic(labelNic []string) ApiDcimRearPortTemplatesListRequest {
	r.labelNic = &labelNic
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelNie(labelNie []string) ApiDcimRearPortTemplatesListRequest {
	r.labelNie = &labelNie
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelNiew(labelNiew []string) ApiDcimRearPortTemplatesListRequest {
	r.labelNiew = &labelNiew
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelNire(labelNire []string) ApiDcimRearPortTemplatesListRequest {
	r.labelNire = &labelNire
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelNisw(labelNisw []string) ApiDcimRearPortTemplatesListRequest {
	r.labelNisw = &labelNisw
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelNre(labelNre []string) ApiDcimRearPortTemplatesListRequest {
	r.labelNre = &labelNre
	return r
}

// Label
func (r ApiDcimRearPortTemplatesListRequest) LabelRe(labelRe []string) ApiDcimRearPortTemplatesListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimRearPortTemplatesListRequest) Limit(limit int32) ApiDcimRearPortTemplatesListRequest {
	r.limit = &limit
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) Name(name []string) ApiDcimRearPortTemplatesListRequest {
	r.name = &name
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameIc(nameIc []string) ApiDcimRearPortTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameIe(nameIe []string) ApiDcimRearPortTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameIew(nameIew []string) ApiDcimRearPortTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameIre(nameIre []string) ApiDcimRearPortTemplatesListRequest {
	r.nameIre = &nameIre
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameIsw(nameIsw []string) ApiDcimRearPortTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameN(nameN []string) ApiDcimRearPortTemplatesListRequest {
	r.nameN = &nameN
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameNic(nameNic []string) ApiDcimRearPortTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameNie(nameNie []string) ApiDcimRearPortTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameNiew(nameNiew []string) ApiDcimRearPortTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameNire(nameNire []string) ApiDcimRearPortTemplatesListRequest {
	r.nameNire = &nameNire
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameNisw(nameNisw []string) ApiDcimRearPortTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameNre(nameNre []string) ApiDcimRearPortTemplatesListRequest {
	r.nameNre = &nameNre
	return r
}

// Name
func (r ApiDcimRearPortTemplatesListRequest) NameRe(nameRe []string) ApiDcimRearPortTemplatesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRearPortTemplatesListRequest) Offset(offset int32) ApiDcimRearPortTemplatesListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Positions(positions []int32) ApiDcimRearPortTemplatesListRequest {
	r.positions = &positions
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsGt(positionsGt []int32) ApiDcimRearPortTemplatesListRequest {
	r.positionsGt = &positionsGt
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsGte(positionsGte []int32) ApiDcimRearPortTemplatesListRequest {
	r.positionsGte = &positionsGte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsLt(positionsLt []int32) ApiDcimRearPortTemplatesListRequest {
	r.positionsLt = &positionsLt
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsLte(positionsLte []int32) ApiDcimRearPortTemplatesListRequest {
	r.positionsLte = &positionsLte
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) PositionsN(positionsN []int32) ApiDcimRearPortTemplatesListRequest {
	r.positionsN = &positionsN
	return r
}

// Search
func (r ApiDcimRearPortTemplatesListRequest) Q(q string) ApiDcimRearPortTemplatesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimRearPortTemplatesListRequest) Sort(sort string) ApiDcimRearPortTemplatesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Type_(type_ []string) ApiDcimRearPortTemplatesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeIc(typeIc []string) ApiDcimRearPortTemplatesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeIe(typeIe []string) ApiDcimRearPortTemplatesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeIew(typeIew []string) ApiDcimRearPortTemplatesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeIre(typeIre []string) ApiDcimRearPortTemplatesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeIsw(typeIsw []string) ApiDcimRearPortTemplatesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeN(typeN []string) ApiDcimRearPortTemplatesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeNic(typeNic []string) ApiDcimRearPortTemplatesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeNie(typeNie []string) ApiDcimRearPortTemplatesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeNiew(typeNiew []string) ApiDcimRearPortTemplatesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeNire(typeNire []string) ApiDcimRearPortTemplatesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeNisw(typeNisw []string) ApiDcimRearPortTemplatesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeNre(typeNre []string) ApiDcimRearPortTemplatesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) TypeRe(typeRe []string) ApiDcimRearPortTemplatesListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimRearPortTemplatesListRequest) Depth(depth int32) ApiDcimRearPortTemplatesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRearPortTemplatesListRequest) Execute() (*PaginatedRearPortTemplateList, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesListExecute(r)
}

/*
DcimRearPortTemplatesList Method for DcimRearPortTemplatesList

Retrieve a list of rear port template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortTemplatesListRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesList(ctx context.Context) ApiDcimRearPortTemplatesListRequest {
	return ApiDcimRearPortTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRearPortTemplateList
func (a *DcimAPIService) DcimRearPortTemplatesListExecute(r ApiDcimRearPortTemplatesListRequest) (*PaginatedRearPortTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRearPortTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.deviceType != nil {
		t := *r.deviceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", t, "multi")
		}
	}
	if r.deviceTypeN != nil {
		t := *r.deviceTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.frontPortTemplates != nil {
		t := *r.frontPortTemplates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates", t, "multi")
		}
	}
	if r.frontPortTemplatesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates__isnull", r.frontPortTemplatesIsnull, "")
	}
	if r.frontPortTemplatesN != nil {
		t := *r.frontPortTemplatesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "front_port_templates__n", t, "multi")
		}
	}
	if r.hasFrontPortTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_front_port_templates", r.hasFrontPortTemplates, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.positions != nil {
		t := *r.positions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions", t, "multi")
		}
	}
	if r.positionsGt != nil {
		t := *r.positionsGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__gt", t, "multi")
		}
	}
	if r.positionsGte != nil {
		t := *r.positionsGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__gte", t, "multi")
		}
	}
	if r.positionsLt != nil {
		t := *r.positionsLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__lt", t, "multi")
		}
	}
	if r.positionsLte != nil {
		t := *r.positionsLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__lte", t, "multi")
		}
	}
	if r.positionsN != nil {
		t := *r.positionsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortTemplatesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimRearPortTemplatesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimRearPortTemplatesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortTemplatesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesNotesCreateExecute(r)
}

/*
DcimRearPortTemplatesNotesCreate Method for DcimRearPortTemplatesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port template.
 @return ApiDcimRearPortTemplatesNotesCreateRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesNotesCreate(ctx context.Context, id string) ApiDcimRearPortTemplatesNotesCreateRequest {
	return ApiDcimRearPortTemplatesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimRearPortTemplatesNotesCreateExecute(r ApiDcimRearPortTemplatesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimRearPortTemplatesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimRearPortTemplatesNotesListRequest) Limit(limit int32) ApiDcimRearPortTemplatesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRearPortTemplatesNotesListRequest) Offset(offset int32) ApiDcimRearPortTemplatesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimRearPortTemplatesNotesListRequest) Depth(depth int32) ApiDcimRearPortTemplatesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRearPortTemplatesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesNotesListExecute(r)
}

/*
DcimRearPortTemplatesNotesList Method for DcimRearPortTemplatesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port template.
 @return ApiDcimRearPortTemplatesNotesListRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesNotesList(ctx context.Context, id string) ApiDcimRearPortTemplatesNotesListRequest {
	return ApiDcimRearPortTemplatesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimRearPortTemplatesNotesListExecute(r ApiDcimRearPortTemplatesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableRearPortTemplateRequest *PatchedWritableRearPortTemplateRequest
}

func (r ApiDcimRearPortTemplatesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortTemplatesPartialUpdateRequest) PatchedWritableRearPortTemplateRequest(patchedWritableRearPortTemplateRequest PatchedWritableRearPortTemplateRequest) ApiDcimRearPortTemplatesPartialUpdateRequest {
	r.patchedWritableRearPortTemplateRequest = &patchedWritableRearPortTemplateRequest
	return r
}

func (r ApiDcimRearPortTemplatesPartialUpdateRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesPartialUpdateExecute(r)
}

/*
DcimRearPortTemplatesPartialUpdate Method for DcimRearPortTemplatesPartialUpdate

Partial update a rear port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port template.
 @return ApiDcimRearPortTemplatesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesPartialUpdate(ctx context.Context, id string) ApiDcimRearPortTemplatesPartialUpdateRequest {
	return ApiDcimRearPortTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimAPIService) DcimRearPortTemplatesPartialUpdateExecute(r ApiDcimRearPortTemplatesPartialUpdateRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableRearPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimRearPortTemplatesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimRearPortTemplatesRetrieveRequest) Depth(depth int32) ApiDcimRearPortTemplatesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRearPortTemplatesRetrieveRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesRetrieveExecute(r)
}

/*
DcimRearPortTemplatesRetrieve Method for DcimRearPortTemplatesRetrieve

Retrieve a rear port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port template.
 @return ApiDcimRearPortTemplatesRetrieveRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesRetrieve(ctx context.Context, id string) ApiDcimRearPortTemplatesRetrieveRequest {
	return ApiDcimRearPortTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimAPIService) DcimRearPortTemplatesRetrieveExecute(r ApiDcimRearPortTemplatesRetrieveRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableRearPortTemplateRequest *WritableRearPortTemplateRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortTemplatesUpdateRequest) WritableRearPortTemplateRequest(writableRearPortTemplateRequest WritableRearPortTemplateRequest) ApiDcimRearPortTemplatesUpdateRequest {
	r.writableRearPortTemplateRequest = &writableRearPortTemplateRequest
	return r
}

func (r ApiDcimRearPortTemplatesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortTemplatesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortTemplatesUpdateRequest) Execute() (*RearPortTemplate, *http.Response, error) {
	return r.ApiService.DcimRearPortTemplatesUpdateExecute(r)
}

/*
DcimRearPortTemplatesUpdate Method for DcimRearPortTemplatesUpdate

Update a rear port template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port template.
 @return ApiDcimRearPortTemplatesUpdateRequest
*/
func (a *DcimAPIService) DcimRearPortTemplatesUpdate(ctx context.Context, id string) ApiDcimRearPortTemplatesUpdateRequest {
	return ApiDcimRearPortTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPortTemplate
func (a *DcimAPIService) DcimRearPortTemplatesUpdateExecute(r ApiDcimRearPortTemplatesUpdateRequest) (*RearPortTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPortTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRearPortTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableRearPortTemplateRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRearPortTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimRearPortsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimRearPortsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRearPortsBulkDestroyExecute(r)
}

/*
DcimRearPortsBulkDestroy Method for DcimRearPortsBulkDestroy

Destroy a list of rear port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimRearPortsBulkDestroy(ctx context.Context) ApiDcimRearPortsBulkDestroyRequest {
	return ApiDcimRearPortsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRearPortsBulkDestroyExecute(r ApiDcimRearPortsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRearPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableRearPortRequest *[]PatchedBulkWritableRearPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortsBulkPartialUpdateRequest) PatchedBulkWritableRearPortRequest(patchedBulkWritableRearPortRequest []PatchedBulkWritableRearPortRequest) ApiDcimRearPortsBulkPartialUpdateRequest {
	r.patchedBulkWritableRearPortRequest = &patchedBulkWritableRearPortRequest
	return r
}

func (r ApiDcimRearPortsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsBulkPartialUpdateRequest) Execute() ([]RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsBulkPartialUpdateExecute(r)
}

/*
DcimRearPortsBulkPartialUpdate Method for DcimRearPortsBulkPartialUpdate

Partial update a list of rear port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRearPortsBulkPartialUpdate(ctx context.Context) ApiDcimRearPortsBulkPartialUpdateRequest {
	return ApiDcimRearPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RearPort
func (a *DcimAPIService) DcimRearPortsBulkPartialUpdateExecute(r ApiDcimRearPortsBulkPartialUpdateRequest) ([]RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableRearPortRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableRearPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableRearPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableRearPortRequest *[]BulkWritableRearPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortsBulkUpdateRequest) BulkWritableRearPortRequest(bulkWritableRearPortRequest []BulkWritableRearPortRequest) ApiDcimRearPortsBulkUpdateRequest {
	r.bulkWritableRearPortRequest = &bulkWritableRearPortRequest
	return r
}

func (r ApiDcimRearPortsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsBulkUpdateRequest) Execute() ([]RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsBulkUpdateExecute(r)
}

/*
DcimRearPortsBulkUpdate Method for DcimRearPortsBulkUpdate

Update a list of rear port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimRearPortsBulkUpdate(ctx context.Context) ApiDcimRearPortsBulkUpdateRequest {
	return ApiDcimRearPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RearPort
func (a *DcimAPIService) DcimRearPortsBulkUpdateExecute(r ApiDcimRearPortsBulkUpdateRequest) ([]RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableRearPortRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableRearPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableRearPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	writableRearPortRequest *WritableRearPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortsCreateRequest) WritableRearPortRequest(writableRearPortRequest WritableRearPortRequest) ApiDcimRearPortsCreateRequest {
	r.writableRearPortRequest = &writableRearPortRequest
	return r
}

func (r ApiDcimRearPortsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsCreateRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsCreateExecute(r)
}

/*
DcimRearPortsCreate Method for DcimRearPortsCreate

Create one or more rear port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsCreateRequest
*/
func (a *DcimAPIService) DcimRearPortsCreate(ctx context.Context) ApiDcimRearPortsCreateRequest {
	return ApiDcimRearPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimAPIService) DcimRearPortsCreateExecute(r ApiDcimRearPortsCreateRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRearPortRequest == nil {
		return localVarReturnValue, nil, reportError("writableRearPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRearPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimRearPortsDestroyExecute(r)
}

/*
DcimRearPortsDestroy Method for DcimRearPortsDestroy

Destroy a rear port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port.
 @return ApiDcimRearPortsDestroyRequest
*/
func (a *DcimAPIService) DcimRearPortsDestroy(ctx context.Context, id string) ApiDcimRearPortsDestroyRequest {
	return ApiDcimRearPortsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimRearPortsDestroyExecute(r ApiDcimRearPortsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimRearPortsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	cable *[]string
	cableIsnull *bool
	cableN *[]string
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	device *[]string
	deviceN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	frontPorts *[]string
	frontPortsIsnull *bool
	frontPortsN *[]string
	hasCable *bool
	hasFrontPorts *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	label *[]string
	labelIc *[]string
	labelIe *[]string
	labelIew *[]string
	labelIre *[]string
	labelIsw *[]string
	labelN *[]string
	labelNic *[]string
	labelNie *[]string
	labelNiew *[]string
	labelNire *[]string
	labelNisw *[]string
	labelNre *[]string
	labelRe *[]string
	limit *int32
	location *[]string
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	positions *[]int32
	positionsGt *[]int32
	positionsGte *[]int32
	positionsLt *[]int32
	positionsLte *[]int32
	positionsN *[]int32
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	depth *int32
}

// Cable
func (r ApiDcimRearPortsListRequest) Cable(cable []string) ApiDcimRearPortsListRequest {
	r.cable = &cable
	return r
}

func (r ApiDcimRearPortsListRequest) CableIsnull(cableIsnull bool) ApiDcimRearPortsListRequest {
	r.cableIsnull = &cableIsnull
	return r
}

// Cable
func (r ApiDcimRearPortsListRequest) CableN(cableN []string) ApiDcimRearPortsListRequest {
	r.cableN = &cableN
	return r
}

func (r ApiDcimRearPortsListRequest) Description(description []string) ApiDcimRearPortsListRequest {
	r.description = &description
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIc(descriptionIc []string) ApiDcimRearPortsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIe(descriptionIe []string) ApiDcimRearPortsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIew(descriptionIew []string) ApiDcimRearPortsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIre(descriptionIre []string) ApiDcimRearPortsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionIsw(descriptionIsw []string) ApiDcimRearPortsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionN(descriptionN []string) ApiDcimRearPortsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNic(descriptionNic []string) ApiDcimRearPortsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNie(descriptionNie []string) ApiDcimRearPortsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNiew(descriptionNiew []string) ApiDcimRearPortsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNire(descriptionNire []string) ApiDcimRearPortsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNisw(descriptionNisw []string) ApiDcimRearPortsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionNre(descriptionNre []string) ApiDcimRearPortsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiDcimRearPortsListRequest) DescriptionRe(descriptionRe []string) ApiDcimRearPortsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiDcimRearPortsListRequest) Device(device []string) ApiDcimRearPortsListRequest {
	r.device = &device
	return r
}

func (r ApiDcimRearPortsListRequest) DeviceN(deviceN []string) ApiDcimRearPortsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiDcimRearPortsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsListRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsListRequest) FrontPorts(frontPorts []string) ApiDcimRearPortsListRequest {
	r.frontPorts = &frontPorts
	return r
}

func (r ApiDcimRearPortsListRequest) FrontPortsIsnull(frontPortsIsnull bool) ApiDcimRearPortsListRequest {
	r.frontPortsIsnull = &frontPortsIsnull
	return r
}

func (r ApiDcimRearPortsListRequest) FrontPortsN(frontPortsN []string) ApiDcimRearPortsListRequest {
	r.frontPortsN = &frontPortsN
	return r
}

// Has cable
func (r ApiDcimRearPortsListRequest) HasCable(hasCable bool) ApiDcimRearPortsListRequest {
	r.hasCable = &hasCable
	return r
}

// Has front ports
func (r ApiDcimRearPortsListRequest) HasFrontPorts(hasFrontPorts bool) ApiDcimRearPortsListRequest {
	r.hasFrontPorts = &hasFrontPorts
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimRearPortsListRequest) Id(id []string) ApiDcimRearPortsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimRearPortsListRequest) IdIc(idIc []string) ApiDcimRearPortsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimRearPortsListRequest) IdIe(idIe []string) ApiDcimRearPortsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimRearPortsListRequest) IdIew(idIew []string) ApiDcimRearPortsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimRearPortsListRequest) IdIre(idIre []string) ApiDcimRearPortsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimRearPortsListRequest) IdIsw(idIsw []string) ApiDcimRearPortsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimRearPortsListRequest) IdN(idN []string) ApiDcimRearPortsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimRearPortsListRequest) IdNic(idNic []string) ApiDcimRearPortsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimRearPortsListRequest) IdNie(idNie []string) ApiDcimRearPortsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimRearPortsListRequest) IdNiew(idNiew []string) ApiDcimRearPortsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimRearPortsListRequest) IdNire(idNire []string) ApiDcimRearPortsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimRearPortsListRequest) IdNisw(idNisw []string) ApiDcimRearPortsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimRearPortsListRequest) IdNre(idNre []string) ApiDcimRearPortsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimRearPortsListRequest) IdRe(idRe []string) ApiDcimRearPortsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimRearPortsListRequest) Label(label []string) ApiDcimRearPortsListRequest {
	r.label = &label
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIc(labelIc []string) ApiDcimRearPortsListRequest {
	r.labelIc = &labelIc
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIe(labelIe []string) ApiDcimRearPortsListRequest {
	r.labelIe = &labelIe
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIew(labelIew []string) ApiDcimRearPortsListRequest {
	r.labelIew = &labelIew
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIre(labelIre []string) ApiDcimRearPortsListRequest {
	r.labelIre = &labelIre
	return r
}

func (r ApiDcimRearPortsListRequest) LabelIsw(labelIsw []string) ApiDcimRearPortsListRequest {
	r.labelIsw = &labelIsw
	return r
}

func (r ApiDcimRearPortsListRequest) LabelN(labelN []string) ApiDcimRearPortsListRequest {
	r.labelN = &labelN
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNic(labelNic []string) ApiDcimRearPortsListRequest {
	r.labelNic = &labelNic
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNie(labelNie []string) ApiDcimRearPortsListRequest {
	r.labelNie = &labelNie
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNiew(labelNiew []string) ApiDcimRearPortsListRequest {
	r.labelNiew = &labelNiew
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNire(labelNire []string) ApiDcimRearPortsListRequest {
	r.labelNire = &labelNire
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNisw(labelNisw []string) ApiDcimRearPortsListRequest {
	r.labelNisw = &labelNisw
	return r
}

func (r ApiDcimRearPortsListRequest) LabelNre(labelNre []string) ApiDcimRearPortsListRequest {
	r.labelNre = &labelNre
	return r
}

func (r ApiDcimRearPortsListRequest) LabelRe(labelRe []string) ApiDcimRearPortsListRequest {
	r.labelRe = &labelRe
	return r
}

// Number of results to return per page.
func (r ApiDcimRearPortsListRequest) Limit(limit int32) ApiDcimRearPortsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimRearPortsListRequest) Location(location []string) ApiDcimRearPortsListRequest {
	r.location = &location
	return r
}

func (r ApiDcimRearPortsListRequest) LocationN(locationN []string) ApiDcimRearPortsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimRearPortsListRequest) Name(name []string) ApiDcimRearPortsListRequest {
	r.name = &name
	return r
}

func (r ApiDcimRearPortsListRequest) NameIc(nameIc []string) ApiDcimRearPortsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimRearPortsListRequest) NameIe(nameIe []string) ApiDcimRearPortsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimRearPortsListRequest) NameIew(nameIew []string) ApiDcimRearPortsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimRearPortsListRequest) NameIre(nameIre []string) ApiDcimRearPortsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimRearPortsListRequest) NameIsw(nameIsw []string) ApiDcimRearPortsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimRearPortsListRequest) NameN(nameN []string) ApiDcimRearPortsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimRearPortsListRequest) NameNic(nameNic []string) ApiDcimRearPortsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimRearPortsListRequest) NameNie(nameNie []string) ApiDcimRearPortsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimRearPortsListRequest) NameNiew(nameNiew []string) ApiDcimRearPortsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimRearPortsListRequest) NameNire(nameNire []string) ApiDcimRearPortsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimRearPortsListRequest) NameNisw(nameNisw []string) ApiDcimRearPortsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimRearPortsListRequest) NameNre(nameNre []string) ApiDcimRearPortsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimRearPortsListRequest) NameRe(nameRe []string) ApiDcimRearPortsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRearPortsListRequest) Offset(offset int32) ApiDcimRearPortsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimRearPortsListRequest) Positions(positions []int32) ApiDcimRearPortsListRequest {
	r.positions = &positions
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsGt(positionsGt []int32) ApiDcimRearPortsListRequest {
	r.positionsGt = &positionsGt
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsGte(positionsGte []int32) ApiDcimRearPortsListRequest {
	r.positionsGte = &positionsGte
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsLt(positionsLt []int32) ApiDcimRearPortsListRequest {
	r.positionsLt = &positionsLt
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsLte(positionsLte []int32) ApiDcimRearPortsListRequest {
	r.positionsLte = &positionsLte
	return r
}

func (r ApiDcimRearPortsListRequest) PositionsN(positionsN []int32) ApiDcimRearPortsListRequest {
	r.positionsN = &positionsN
	return r
}

// Search
func (r ApiDcimRearPortsListRequest) Q(q string) ApiDcimRearPortsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimRearPortsListRequest) Sort(sort string) ApiDcimRearPortsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimRearPortsListRequest) Tags(tags []string) ApiDcimRearPortsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimRearPortsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimRearPortsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimRearPortsListRequest) TagsN(tagsN []string) ApiDcimRearPortsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimRearPortsListRequest) Type_(type_ []string) ApiDcimRearPortsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiDcimRearPortsListRequest) TypeIc(typeIc []string) ApiDcimRearPortsListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiDcimRearPortsListRequest) TypeIe(typeIe []string) ApiDcimRearPortsListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiDcimRearPortsListRequest) TypeIew(typeIew []string) ApiDcimRearPortsListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiDcimRearPortsListRequest) TypeIre(typeIre []string) ApiDcimRearPortsListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiDcimRearPortsListRequest) TypeIsw(typeIsw []string) ApiDcimRearPortsListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiDcimRearPortsListRequest) TypeN(typeN []string) ApiDcimRearPortsListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiDcimRearPortsListRequest) TypeNic(typeNic []string) ApiDcimRearPortsListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiDcimRearPortsListRequest) TypeNie(typeNie []string) ApiDcimRearPortsListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiDcimRearPortsListRequest) TypeNiew(typeNiew []string) ApiDcimRearPortsListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiDcimRearPortsListRequest) TypeNire(typeNire []string) ApiDcimRearPortsListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiDcimRearPortsListRequest) TypeNisw(typeNisw []string) ApiDcimRearPortsListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiDcimRearPortsListRequest) TypeNre(typeNre []string) ApiDcimRearPortsListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiDcimRearPortsListRequest) TypeRe(typeRe []string) ApiDcimRearPortsListRequest {
	r.typeRe = &typeRe
	return r
}

// Serializer Depth
func (r ApiDcimRearPortsListRequest) Depth(depth int32) ApiDcimRearPortsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRearPortsListRequest) Execute() (*PaginatedRearPortList, *http.Response, error) {
	return r.ApiService.DcimRearPortsListExecute(r)
}

/*
DcimRearPortsList Method for DcimRearPortsList

Retrieve a list of rear port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimRearPortsListRequest
*/
func (a *DcimAPIService) DcimRearPortsList(ctx context.Context) ApiDcimRearPortsListRequest {
	return ApiDcimRearPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRearPortList
func (a *DcimAPIService) DcimRearPortsListExecute(r ApiDcimRearPortsListRequest) (*PaginatedRearPortList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRearPortList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cable != nil {
		t := *r.cable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable", t, "multi")
		}
	}
	if r.cableIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cable__isnull", r.cableIsnull, "")
	}
	if r.cableN != nil {
		t := *r.cableN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cable__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.frontPorts != nil {
		t := *r.frontPorts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports", t, "multi")
		}
	}
	if r.frontPortsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports__isnull", r.frontPortsIsnull, "")
	}
	if r.frontPortsN != nil {
		t := *r.frontPortsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "front_ports__n", t, "multi")
		}
	}
	if r.hasCable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_cable", r.hasCable, "")
	}
	if r.hasFrontPorts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_front_ports", r.hasFrontPorts, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.label != nil {
		t := *r.label
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label", t, "multi")
		}
	}
	if r.labelIc != nil {
		t := *r.labelIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ic", t, "multi")
		}
	}
	if r.labelIe != nil {
		t := *r.labelIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ie", t, "multi")
		}
	}
	if r.labelIew != nil {
		t := *r.labelIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__iew", t, "multi")
		}
	}
	if r.labelIre != nil {
		t := *r.labelIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__ire", t, "multi")
		}
	}
	if r.labelIsw != nil {
		t := *r.labelIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__isw", t, "multi")
		}
	}
	if r.labelN != nil {
		t := *r.labelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__n", t, "multi")
		}
	}
	if r.labelNic != nil {
		t := *r.labelNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nic", t, "multi")
		}
	}
	if r.labelNie != nil {
		t := *r.labelNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nie", t, "multi")
		}
	}
	if r.labelNiew != nil {
		t := *r.labelNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__niew", t, "multi")
		}
	}
	if r.labelNire != nil {
		t := *r.labelNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nire", t, "multi")
		}
	}
	if r.labelNisw != nil {
		t := *r.labelNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nisw", t, "multi")
		}
	}
	if r.labelNre != nil {
		t := *r.labelNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__nre", t, "multi")
		}
	}
	if r.labelRe != nil {
		t := *r.labelRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label__re", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.positions != nil {
		t := *r.positions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions", t, "multi")
		}
	}
	if r.positionsGt != nil {
		t := *r.positionsGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__gt", t, "multi")
		}
	}
	if r.positionsGte != nil {
		t := *r.positionsGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__gte", t, "multi")
		}
	}
	if r.positionsLt != nil {
		t := *r.positionsLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__lt", t, "multi")
		}
	}
	if r.positionsLte != nil {
		t := *r.positionsLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__lte", t, "multi")
		}
	}
	if r.positionsN != nil {
		t := *r.positionsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "positions__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "positions__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimRearPortsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimRearPortsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimRearPortsNotesCreateExecute(r)
}

/*
DcimRearPortsNotesCreate Method for DcimRearPortsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port.
 @return ApiDcimRearPortsNotesCreateRequest
*/
func (a *DcimAPIService) DcimRearPortsNotesCreate(ctx context.Context, id string) ApiDcimRearPortsNotesCreateRequest {
	return ApiDcimRearPortsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimRearPortsNotesCreateExecute(r ApiDcimRearPortsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimRearPortsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimRearPortsNotesListRequest) Limit(limit int32) ApiDcimRearPortsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRearPortsNotesListRequest) Offset(offset int32) ApiDcimRearPortsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimRearPortsNotesListRequest) Depth(depth int32) ApiDcimRearPortsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRearPortsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimRearPortsNotesListExecute(r)
}

/*
DcimRearPortsNotesList Method for DcimRearPortsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port.
 @return ApiDcimRearPortsNotesListRequest
*/
func (a *DcimAPIService) DcimRearPortsNotesList(ctx context.Context, id string) ApiDcimRearPortsNotesListRequest {
	return ApiDcimRearPortsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimRearPortsNotesListExecute(r ApiDcimRearPortsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableRearPortRequest *PatchedWritableRearPortRequest
}

func (r ApiDcimRearPortsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsPartialUpdateRequest) PatchedWritableRearPortRequest(patchedWritableRearPortRequest PatchedWritableRearPortRequest) ApiDcimRearPortsPartialUpdateRequest {
	r.patchedWritableRearPortRequest = &patchedWritableRearPortRequest
	return r
}

func (r ApiDcimRearPortsPartialUpdateRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsPartialUpdateExecute(r)
}

/*
DcimRearPortsPartialUpdate Method for DcimRearPortsPartialUpdate

Partial update a rear port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port.
 @return ApiDcimRearPortsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimRearPortsPartialUpdate(ctx context.Context, id string) ApiDcimRearPortsPartialUpdateRequest {
	return ApiDcimRearPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimAPIService) DcimRearPortsPartialUpdateExecute(r ApiDcimRearPortsPartialUpdateRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableRearPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsPathsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimRearPortsPathsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsPathsListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimRearPortsPathsListRequest) Limit(limit int32) ApiDcimRearPortsPathsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimRearPortsPathsListRequest) Offset(offset int32) ApiDcimRearPortsPathsListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimRearPortsPathsListRequest) Depth(depth int32) ApiDcimRearPortsPathsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRearPortsPathsListRequest) Execute() (*PaginatedCablePathList, *http.Response, error) {
	return r.ApiService.DcimRearPortsPathsListExecute(r)
}

/*
DcimRearPortsPathsList Method for DcimRearPortsPathsList

Return all CablePaths which traverse a given pass-through port.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port.
 @return ApiDcimRearPortsPathsListRequest
*/
func (a *DcimAPIService) DcimRearPortsPathsList(ctx context.Context, id string) ApiDcimRearPortsPathsListRequest {
	return ApiDcimRearPortsPathsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedCablePathList
func (a *DcimAPIService) DcimRearPortsPathsListExecute(r ApiDcimRearPortsPathsListRequest) (*PaginatedCablePathList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedCablePathList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsPathsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/paths/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimRearPortsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimRearPortsRetrieveRequest) Depth(depth int32) ApiDcimRearPortsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimRearPortsRetrieveRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsRetrieveExecute(r)
}

/*
DcimRearPortsRetrieve Method for DcimRearPortsRetrieve

Retrieve a rear port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port.
 @return ApiDcimRearPortsRetrieveRequest
*/
func (a *DcimAPIService) DcimRearPortsRetrieve(ctx context.Context, id string) ApiDcimRearPortsRetrieveRequest {
	return ApiDcimRearPortsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimAPIService) DcimRearPortsRetrieveExecute(r ApiDcimRearPortsRetrieveRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimRearPortsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	writableRearPortRequest *WritableRearPortRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimRearPortsUpdateRequest) WritableRearPortRequest(writableRearPortRequest WritableRearPortRequest) ApiDcimRearPortsUpdateRequest {
	r.writableRearPortRequest = &writableRearPortRequest
	return r
}

func (r ApiDcimRearPortsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimRearPortsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimRearPortsUpdateRequest) Execute() (*RearPort, *http.Response, error) {
	return r.ApiService.DcimRearPortsUpdateExecute(r)
}

/*
DcimRearPortsUpdate Method for DcimRearPortsUpdate

Update a rear port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this rear port.
 @return ApiDcimRearPortsUpdateRequest
*/
func (a *DcimAPIService) DcimRearPortsUpdate(ctx context.Context, id string) ApiDcimRearPortsUpdateRequest {
	return ApiDcimRearPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RearPort
func (a *DcimAPIService) DcimRearPortsUpdateExecute(r ApiDcimRearPortsUpdateRequest) (*RearPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RearPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimRearPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRearPortRequest == nil {
		return localVarReturnValue, nil, reportError("writableRearPortRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRearPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareImageFilesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimSoftwareImageFilesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimSoftwareImageFilesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareImageFilesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesBulkDestroyExecute(r)
}

/*
DcimSoftwareImageFilesBulkDestroy Method for DcimSoftwareImageFilesBulkDestroy

Destroy a list of software image file objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareImageFilesBulkDestroyRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesBulkDestroy(ctx context.Context) ApiDcimSoftwareImageFilesBulkDestroyRequest {
	return ApiDcimSoftwareImageFilesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimSoftwareImageFilesBulkDestroyExecute(r ApiDcimSoftwareImageFilesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableSoftwareImageFileRequest *[]PatchedBulkWritableSoftwareImageFileRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareImageFilesBulkPartialUpdateRequest) PatchedBulkWritableSoftwareImageFileRequest(patchedBulkWritableSoftwareImageFileRequest []PatchedBulkWritableSoftwareImageFileRequest) ApiDcimSoftwareImageFilesBulkPartialUpdateRequest {
	r.patchedBulkWritableSoftwareImageFileRequest = &patchedBulkWritableSoftwareImageFileRequest
	return r
}

func (r ApiDcimSoftwareImageFilesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareImageFilesBulkPartialUpdateRequest) Execute() ([]SoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesBulkPartialUpdateExecute(r)
}

/*
DcimSoftwareImageFilesBulkPartialUpdate Method for DcimSoftwareImageFilesBulkPartialUpdate

Partial update a list of software image file objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareImageFilesBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesBulkPartialUpdate(ctx context.Context) ApiDcimSoftwareImageFilesBulkPartialUpdateRequest {
	return ApiDcimSoftwareImageFilesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SoftwareImageFile
func (a *DcimAPIService) DcimSoftwareImageFilesBulkPartialUpdateExecute(r ApiDcimSoftwareImageFilesBulkPartialUpdateRequest) ([]SoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableSoftwareImageFileRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableSoftwareImageFileRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableSoftwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableSoftwareImageFileRequest *[]BulkWritableSoftwareImageFileRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareImageFilesBulkUpdateRequest) BulkWritableSoftwareImageFileRequest(bulkWritableSoftwareImageFileRequest []BulkWritableSoftwareImageFileRequest) ApiDcimSoftwareImageFilesBulkUpdateRequest {
	r.bulkWritableSoftwareImageFileRequest = &bulkWritableSoftwareImageFileRequest
	return r
}

func (r ApiDcimSoftwareImageFilesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareImageFilesBulkUpdateRequest) Execute() ([]SoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesBulkUpdateExecute(r)
}

/*
DcimSoftwareImageFilesBulkUpdate Method for DcimSoftwareImageFilesBulkUpdate

Update a list of software image file objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareImageFilesBulkUpdateRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesBulkUpdate(ctx context.Context) ApiDcimSoftwareImageFilesBulkUpdateRequest {
	return ApiDcimSoftwareImageFilesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SoftwareImageFile
func (a *DcimAPIService) DcimSoftwareImageFilesBulkUpdateExecute(r ApiDcimSoftwareImageFilesBulkUpdateRequest) ([]SoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableSoftwareImageFileRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableSoftwareImageFileRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableSoftwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	softwareImageFileRequest *SoftwareImageFileRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareImageFilesCreateRequest) SoftwareImageFileRequest(softwareImageFileRequest SoftwareImageFileRequest) ApiDcimSoftwareImageFilesCreateRequest {
	r.softwareImageFileRequest = &softwareImageFileRequest
	return r
}

func (r ApiDcimSoftwareImageFilesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareImageFilesCreateRequest) Execute() (*SoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesCreateExecute(r)
}

/*
DcimSoftwareImageFilesCreate Method for DcimSoftwareImageFilesCreate

Create one or more software image file objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareImageFilesCreateRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesCreate(ctx context.Context) ApiDcimSoftwareImageFilesCreateRequest {
	return ApiDcimSoftwareImageFilesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SoftwareImageFile
func (a *DcimAPIService) DcimSoftwareImageFilesCreateExecute(r ApiDcimSoftwareImageFilesCreateRequest) (*SoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.softwareImageFileRequest == nil {
		return localVarReturnValue, nil, reportError("softwareImageFileRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareImageFilesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareImageFilesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesDestroyExecute(r)
}

/*
DcimSoftwareImageFilesDestroy Method for DcimSoftwareImageFilesDestroy

Destroy a software image file object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software image file.
 @return ApiDcimSoftwareImageFilesDestroyRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesDestroy(ctx context.Context, id string) ApiDcimSoftwareImageFilesDestroyRequest {
	return ApiDcimSoftwareImageFilesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimSoftwareImageFilesDestroyExecute(r ApiDcimSoftwareImageFilesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	defaultImage *bool
	deviceTypes *[]string
	deviceTypesIsnull *bool
	deviceTypesN *[]string
	devices *[]string
	devicesIsnull *bool
	devicesN *[]string
	downloadUrl *[]string
	downloadUrlIc *[]string
	downloadUrlIe *[]string
	downloadUrlIew *[]string
	downloadUrlIre *[]string
	downloadUrlIsw *[]string
	downloadUrlN *[]string
	downloadUrlNic *[]string
	downloadUrlNie *[]string
	downloadUrlNiew *[]string
	downloadUrlNire *[]string
	downloadUrlNisw *[]string
	downloadUrlNre *[]string
	downloadUrlRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasDeviceTypes *bool
	hasDevices *bool
	hashingAlgorithm *[]string
	hashingAlgorithmIc *[]string
	hashingAlgorithmIe *[]string
	hashingAlgorithmIew *[]string
	hashingAlgorithmIre *[]string
	hashingAlgorithmIsw *[]string
	hashingAlgorithmN *[]string
	hashingAlgorithmNic *[]string
	hashingAlgorithmNie *[]string
	hashingAlgorithmNiew *[]string
	hashingAlgorithmNire *[]string
	hashingAlgorithmNisw *[]string
	hashingAlgorithmNre *[]string
	hashingAlgorithmRe *[]string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	imageFileChecksum *[]string
	imageFileChecksumIc *[]string
	imageFileChecksumIe *[]string
	imageFileChecksumIew *[]string
	imageFileChecksumIre *[]string
	imageFileChecksumIsw *[]string
	imageFileChecksumN *[]string
	imageFileChecksumNic *[]string
	imageFileChecksumNie *[]string
	imageFileChecksumNiew *[]string
	imageFileChecksumNire *[]string
	imageFileChecksumNisw *[]string
	imageFileChecksumNre *[]string
	imageFileChecksumRe *[]string
	imageFileName *[]string
	imageFileNameIc *[]string
	imageFileNameIe *[]string
	imageFileNameIew *[]string
	imageFileNameIre *[]string
	imageFileNameIsw *[]string
	imageFileNameN *[]string
	imageFileNameNic *[]string
	imageFileNameNie *[]string
	imageFileNameNiew *[]string
	imageFileNameNire *[]string
	imageFileNameNisw *[]string
	imageFileNameNre *[]string
	imageFileNameRe *[]string
	imageFileSize *[]int32
	imageFileSizeGt *[]int32
	imageFileSizeGte *[]int32
	imageFileSizeIsnull *bool
	imageFileSizeLt *[]int32
	imageFileSizeLte *[]int32
	imageFileSizeN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	offset *int32
	q *string
	softwareVersion *[]string
	softwareVersionN *[]string
	sort *string
	status *[]string
	statusN *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	depth *int32
}

func (r ApiDcimSoftwareImageFilesListRequest) Created(created []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.created = &created
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) CreatedGt(createdGt []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) CreatedGte(createdGte []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) CreatedIsnull(createdIsnull bool) ApiDcimSoftwareImageFilesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) CreatedLt(createdLt []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) CreatedLte(createdLte []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) CreatedN(createdN []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.createdN = &createdN
	return r
}

// Is default image for associated software version
func (r ApiDcimSoftwareImageFilesListRequest) DefaultImage(defaultImage bool) ApiDcimSoftwareImageFilesListRequest {
	r.defaultImage = &defaultImage
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DeviceTypes(deviceTypes []string) ApiDcimSoftwareImageFilesListRequest {
	r.deviceTypes = &deviceTypes
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DeviceTypesIsnull(deviceTypesIsnull bool) ApiDcimSoftwareImageFilesListRequest {
	r.deviceTypesIsnull = &deviceTypesIsnull
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DeviceTypesN(deviceTypesN []string) ApiDcimSoftwareImageFilesListRequest {
	r.deviceTypesN = &deviceTypesN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) Devices(devices []string) ApiDcimSoftwareImageFilesListRequest {
	r.devices = &devices
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DevicesIsnull(devicesIsnull bool) ApiDcimSoftwareImageFilesListRequest {
	r.devicesIsnull = &devicesIsnull
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DevicesN(devicesN []string) ApiDcimSoftwareImageFilesListRequest {
	r.devicesN = &devicesN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrl(downloadUrl []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrl = &downloadUrl
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlIc(downloadUrlIc []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlIc = &downloadUrlIc
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlIe(downloadUrlIe []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlIe = &downloadUrlIe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlIew(downloadUrlIew []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlIew = &downloadUrlIew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlIre(downloadUrlIre []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlIre = &downloadUrlIre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlIsw(downloadUrlIsw []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlIsw = &downloadUrlIsw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlN(downloadUrlN []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlN = &downloadUrlN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlNic(downloadUrlNic []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlNic = &downloadUrlNic
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlNie(downloadUrlNie []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlNie = &downloadUrlNie
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlNiew(downloadUrlNiew []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlNiew = &downloadUrlNiew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlNire(downloadUrlNire []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlNire = &downloadUrlNire
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlNisw(downloadUrlNisw []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlNisw = &downloadUrlNisw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlNre(downloadUrlNre []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlNre = &downloadUrlNre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) DownloadUrlRe(downloadUrlRe []string) ApiDcimSoftwareImageFilesListRequest {
	r.downloadUrlRe = &downloadUrlRe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesListRequest {
	r.format = &format
	return r
}

// Has device types
func (r ApiDcimSoftwareImageFilesListRequest) HasDeviceTypes(hasDeviceTypes bool) ApiDcimSoftwareImageFilesListRequest {
	r.hasDeviceTypes = &hasDeviceTypes
	return r
}

// Has devices
func (r ApiDcimSoftwareImageFilesListRequest) HasDevices(hasDevices bool) ApiDcimSoftwareImageFilesListRequest {
	r.hasDevices = &hasDevices
	return r
}

// Hashing algorithm for image file checksum
func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithm(hashingAlgorithm []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithm = &hashingAlgorithm
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmIc(hashingAlgorithmIc []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmIc = &hashingAlgorithmIc
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmIe(hashingAlgorithmIe []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmIe = &hashingAlgorithmIe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmIew(hashingAlgorithmIew []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmIew = &hashingAlgorithmIew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmIre(hashingAlgorithmIre []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmIre = &hashingAlgorithmIre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmIsw(hashingAlgorithmIsw []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmIsw = &hashingAlgorithmIsw
	return r
}

// Hashing algorithm for image file checksum
func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmN(hashingAlgorithmN []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmN = &hashingAlgorithmN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmNic(hashingAlgorithmNic []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmNic = &hashingAlgorithmNic
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmNie(hashingAlgorithmNie []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmNie = &hashingAlgorithmNie
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmNiew(hashingAlgorithmNiew []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmNiew = &hashingAlgorithmNiew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmNire(hashingAlgorithmNire []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmNire = &hashingAlgorithmNire
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmNisw(hashingAlgorithmNisw []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmNisw = &hashingAlgorithmNisw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmNre(hashingAlgorithmNre []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmNre = &hashingAlgorithmNre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) HashingAlgorithmRe(hashingAlgorithmRe []string) ApiDcimSoftwareImageFilesListRequest {
	r.hashingAlgorithmRe = &hashingAlgorithmRe
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimSoftwareImageFilesListRequest) Id(id []string) ApiDcimSoftwareImageFilesListRequest {
	r.id = &id
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdIc(idIc []string) ApiDcimSoftwareImageFilesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdIe(idIe []string) ApiDcimSoftwareImageFilesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdIew(idIew []string) ApiDcimSoftwareImageFilesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdIre(idIre []string) ApiDcimSoftwareImageFilesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdIsw(idIsw []string) ApiDcimSoftwareImageFilesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdN(idN []string) ApiDcimSoftwareImageFilesListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdNic(idNic []string) ApiDcimSoftwareImageFilesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdNie(idNie []string) ApiDcimSoftwareImageFilesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdNiew(idNiew []string) ApiDcimSoftwareImageFilesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdNire(idNire []string) ApiDcimSoftwareImageFilesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdNisw(idNisw []string) ApiDcimSoftwareImageFilesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdNre(idNre []string) ApiDcimSoftwareImageFilesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) IdRe(idRe []string) ApiDcimSoftwareImageFilesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksum(imageFileChecksum []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksum = &imageFileChecksum
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumIc(imageFileChecksumIc []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumIc = &imageFileChecksumIc
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumIe(imageFileChecksumIe []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumIe = &imageFileChecksumIe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumIew(imageFileChecksumIew []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumIew = &imageFileChecksumIew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumIre(imageFileChecksumIre []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumIre = &imageFileChecksumIre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumIsw(imageFileChecksumIsw []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumIsw = &imageFileChecksumIsw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumN(imageFileChecksumN []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumN = &imageFileChecksumN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumNic(imageFileChecksumNic []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumNic = &imageFileChecksumNic
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumNie(imageFileChecksumNie []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumNie = &imageFileChecksumNie
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumNiew(imageFileChecksumNiew []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumNiew = &imageFileChecksumNiew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumNire(imageFileChecksumNire []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumNire = &imageFileChecksumNire
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumNisw(imageFileChecksumNisw []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumNisw = &imageFileChecksumNisw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumNre(imageFileChecksumNre []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumNre = &imageFileChecksumNre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileChecksumRe(imageFileChecksumRe []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileChecksumRe = &imageFileChecksumRe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileName(imageFileName []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileName = &imageFileName
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameIc(imageFileNameIc []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameIc = &imageFileNameIc
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameIe(imageFileNameIe []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameIe = &imageFileNameIe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameIew(imageFileNameIew []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameIew = &imageFileNameIew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameIre(imageFileNameIre []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameIre = &imageFileNameIre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameIsw(imageFileNameIsw []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameIsw = &imageFileNameIsw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameN(imageFileNameN []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameN = &imageFileNameN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameNic(imageFileNameNic []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameNic = &imageFileNameNic
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameNie(imageFileNameNie []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameNie = &imageFileNameNie
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameNiew(imageFileNameNiew []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameNiew = &imageFileNameNiew
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameNire(imageFileNameNire []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameNire = &imageFileNameNire
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameNisw(imageFileNameNisw []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameNisw = &imageFileNameNisw
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameNre(imageFileNameNre []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameNre = &imageFileNameNre
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileNameRe(imageFileNameRe []string) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileNameRe = &imageFileNameRe
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileSize(imageFileSize []int32) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileSize = &imageFileSize
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileSizeGt(imageFileSizeGt []int32) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileSizeGt = &imageFileSizeGt
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileSizeGte(imageFileSizeGte []int32) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileSizeGte = &imageFileSizeGte
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileSizeIsnull(imageFileSizeIsnull bool) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileSizeIsnull = &imageFileSizeIsnull
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileSizeLt(imageFileSizeLt []int32) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileSizeLt = &imageFileSizeLt
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileSizeLte(imageFileSizeLte []int32) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileSizeLte = &imageFileSizeLte
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) ImageFileSizeN(imageFileSizeN []int32) ApiDcimSoftwareImageFilesListRequest {
	r.imageFileSizeN = &imageFileSizeN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimSoftwareImageFilesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimSoftwareImageFilesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimSoftwareImageFilesListRequest) Limit(limit int32) ApiDcimSoftwareImageFilesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimSoftwareImageFilesListRequest) Offset(offset int32) ApiDcimSoftwareImageFilesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimSoftwareImageFilesListRequest) Q(q string) ApiDcimSoftwareImageFilesListRequest {
	r.q = &q
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) SoftwareVersion(softwareVersion []string) ApiDcimSoftwareImageFilesListRequest {
	r.softwareVersion = &softwareVersion
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) SoftwareVersionN(softwareVersionN []string) ApiDcimSoftwareImageFilesListRequest {
	r.softwareVersionN = &softwareVersionN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimSoftwareImageFilesListRequest) Sort(sort string) ApiDcimSoftwareImageFilesListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) Status(status []string) ApiDcimSoftwareImageFilesListRequest {
	r.status = &status
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) StatusN(statusN []string) ApiDcimSoftwareImageFilesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) Tags(tags []string) ApiDcimSoftwareImageFilesListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) TagsIsnull(tagsIsnull bool) ApiDcimSoftwareImageFilesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) TagsN(tagsN []string) ApiDcimSoftwareImageFilesListRequest {
	r.tagsN = &tagsN
	return r
}

// Serializer Depth
func (r ApiDcimSoftwareImageFilesListRequest) Depth(depth int32) ApiDcimSoftwareImageFilesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimSoftwareImageFilesListRequest) Execute() (*PaginatedSoftwareImageFileList, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesListExecute(r)
}

/*
DcimSoftwareImageFilesList Method for DcimSoftwareImageFilesList

Retrieve a list of software image file objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareImageFilesListRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesList(ctx context.Context) ApiDcimSoftwareImageFilesListRequest {
	return ApiDcimSoftwareImageFilesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedSoftwareImageFileList
func (a *DcimAPIService) DcimSoftwareImageFilesListExecute(r ApiDcimSoftwareImageFilesListRequest) (*PaginatedSoftwareImageFileList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSoftwareImageFileList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.defaultImage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_image", r.defaultImage, "")
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_types", t, "multi")
		}
	}
	if r.deviceTypesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__isnull", r.deviceTypesIsnull, "")
	}
	if r.deviceTypesN != nil {
		t := *r.deviceTypesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__n", t, "multi")
		}
	}
	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices", t, "multi")
		}
	}
	if r.devicesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices__isnull", r.devicesIsnull, "")
	}
	if r.devicesN != nil {
		t := *r.devicesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", t, "multi")
		}
	}
	if r.downloadUrl != nil {
		t := *r.downloadUrl
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url", t, "multi")
		}
	}
	if r.downloadUrlIc != nil {
		t := *r.downloadUrlIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__ic", t, "multi")
		}
	}
	if r.downloadUrlIe != nil {
		t := *r.downloadUrlIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__ie", t, "multi")
		}
	}
	if r.downloadUrlIew != nil {
		t := *r.downloadUrlIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__iew", t, "multi")
		}
	}
	if r.downloadUrlIre != nil {
		t := *r.downloadUrlIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__ire", t, "multi")
		}
	}
	if r.downloadUrlIsw != nil {
		t := *r.downloadUrlIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__isw", t, "multi")
		}
	}
	if r.downloadUrlN != nil {
		t := *r.downloadUrlN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__n", t, "multi")
		}
	}
	if r.downloadUrlNic != nil {
		t := *r.downloadUrlNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nic", t, "multi")
		}
	}
	if r.downloadUrlNie != nil {
		t := *r.downloadUrlNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nie", t, "multi")
		}
	}
	if r.downloadUrlNiew != nil {
		t := *r.downloadUrlNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__niew", t, "multi")
		}
	}
	if r.downloadUrlNire != nil {
		t := *r.downloadUrlNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nire", t, "multi")
		}
	}
	if r.downloadUrlNisw != nil {
		t := *r.downloadUrlNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nisw", t, "multi")
		}
	}
	if r.downloadUrlNre != nil {
		t := *r.downloadUrlNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__nre", t, "multi")
		}
	}
	if r.downloadUrlRe != nil {
		t := *r.downloadUrlRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "download_url__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasDeviceTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_device_types", r.hasDeviceTypes, "")
	}
	if r.hasDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_devices", r.hasDevices, "")
	}
	if r.hashingAlgorithm != nil {
		t := *r.hashingAlgorithm
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm", t, "multi")
		}
	}
	if r.hashingAlgorithmIc != nil {
		t := *r.hashingAlgorithmIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__ic", t, "multi")
		}
	}
	if r.hashingAlgorithmIe != nil {
		t := *r.hashingAlgorithmIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__ie", t, "multi")
		}
	}
	if r.hashingAlgorithmIew != nil {
		t := *r.hashingAlgorithmIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__iew", t, "multi")
		}
	}
	if r.hashingAlgorithmIre != nil {
		t := *r.hashingAlgorithmIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__ire", t, "multi")
		}
	}
	if r.hashingAlgorithmIsw != nil {
		t := *r.hashingAlgorithmIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__isw", t, "multi")
		}
	}
	if r.hashingAlgorithmN != nil {
		t := *r.hashingAlgorithmN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__n", t, "multi")
		}
	}
	if r.hashingAlgorithmNic != nil {
		t := *r.hashingAlgorithmNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nic", t, "multi")
		}
	}
	if r.hashingAlgorithmNie != nil {
		t := *r.hashingAlgorithmNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nie", t, "multi")
		}
	}
	if r.hashingAlgorithmNiew != nil {
		t := *r.hashingAlgorithmNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__niew", t, "multi")
		}
	}
	if r.hashingAlgorithmNire != nil {
		t := *r.hashingAlgorithmNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nire", t, "multi")
		}
	}
	if r.hashingAlgorithmNisw != nil {
		t := *r.hashingAlgorithmNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nisw", t, "multi")
		}
	}
	if r.hashingAlgorithmNre != nil {
		t := *r.hashingAlgorithmNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__nre", t, "multi")
		}
	}
	if r.hashingAlgorithmRe != nil {
		t := *r.hashingAlgorithmRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashing_algorithm__re", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.imageFileChecksum != nil {
		t := *r.imageFileChecksum
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum", t, "multi")
		}
	}
	if r.imageFileChecksumIc != nil {
		t := *r.imageFileChecksumIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__ic", t, "multi")
		}
	}
	if r.imageFileChecksumIe != nil {
		t := *r.imageFileChecksumIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__ie", t, "multi")
		}
	}
	if r.imageFileChecksumIew != nil {
		t := *r.imageFileChecksumIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__iew", t, "multi")
		}
	}
	if r.imageFileChecksumIre != nil {
		t := *r.imageFileChecksumIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__ire", t, "multi")
		}
	}
	if r.imageFileChecksumIsw != nil {
		t := *r.imageFileChecksumIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__isw", t, "multi")
		}
	}
	if r.imageFileChecksumN != nil {
		t := *r.imageFileChecksumN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__n", t, "multi")
		}
	}
	if r.imageFileChecksumNic != nil {
		t := *r.imageFileChecksumNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nic", t, "multi")
		}
	}
	if r.imageFileChecksumNie != nil {
		t := *r.imageFileChecksumNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nie", t, "multi")
		}
	}
	if r.imageFileChecksumNiew != nil {
		t := *r.imageFileChecksumNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__niew", t, "multi")
		}
	}
	if r.imageFileChecksumNire != nil {
		t := *r.imageFileChecksumNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nire", t, "multi")
		}
	}
	if r.imageFileChecksumNisw != nil {
		t := *r.imageFileChecksumNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nisw", t, "multi")
		}
	}
	if r.imageFileChecksumNre != nil {
		t := *r.imageFileChecksumNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__nre", t, "multi")
		}
	}
	if r.imageFileChecksumRe != nil {
		t := *r.imageFileChecksumRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_checksum__re", t, "multi")
		}
	}
	if r.imageFileName != nil {
		t := *r.imageFileName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name", t, "multi")
		}
	}
	if r.imageFileNameIc != nil {
		t := *r.imageFileNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__ic", t, "multi")
		}
	}
	if r.imageFileNameIe != nil {
		t := *r.imageFileNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__ie", t, "multi")
		}
	}
	if r.imageFileNameIew != nil {
		t := *r.imageFileNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__iew", t, "multi")
		}
	}
	if r.imageFileNameIre != nil {
		t := *r.imageFileNameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__ire", t, "multi")
		}
	}
	if r.imageFileNameIsw != nil {
		t := *r.imageFileNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__isw", t, "multi")
		}
	}
	if r.imageFileNameN != nil {
		t := *r.imageFileNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__n", t, "multi")
		}
	}
	if r.imageFileNameNic != nil {
		t := *r.imageFileNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nic", t, "multi")
		}
	}
	if r.imageFileNameNie != nil {
		t := *r.imageFileNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nie", t, "multi")
		}
	}
	if r.imageFileNameNiew != nil {
		t := *r.imageFileNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__niew", t, "multi")
		}
	}
	if r.imageFileNameNire != nil {
		t := *r.imageFileNameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nire", t, "multi")
		}
	}
	if r.imageFileNameNisw != nil {
		t := *r.imageFileNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nisw", t, "multi")
		}
	}
	if r.imageFileNameNre != nil {
		t := *r.imageFileNameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__nre", t, "multi")
		}
	}
	if r.imageFileNameRe != nil {
		t := *r.imageFileNameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_name__re", t, "multi")
		}
	}
	if r.imageFileSize != nil {
		t := *r.imageFileSize
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size", t, "multi")
		}
	}
	if r.imageFileSizeGt != nil {
		t := *r.imageFileSizeGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__gt", t, "multi")
		}
	}
	if r.imageFileSizeGte != nil {
		t := *r.imageFileSizeGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__gte", t, "multi")
		}
	}
	if r.imageFileSizeIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__isnull", r.imageFileSizeIsnull, "")
	}
	if r.imageFileSizeLt != nil {
		t := *r.imageFileSizeLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__lt", t, "multi")
		}
	}
	if r.imageFileSizeLte != nil {
		t := *r.imageFileSizeLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__lte", t, "multi")
		}
	}
	if r.imageFileSizeN != nil {
		t := *r.imageFileSizeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "image_file_size__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.softwareVersion != nil {
		t := *r.softwareVersion
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_version", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_version", t, "multi")
		}
	}
	if r.softwareVersionN != nil {
		t := *r.softwareVersionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_version__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_version__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareImageFilesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimSoftwareImageFilesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimSoftwareImageFilesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareImageFilesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesNotesCreateExecute(r)
}

/*
DcimSoftwareImageFilesNotesCreate Method for DcimSoftwareImageFilesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software image file.
 @return ApiDcimSoftwareImageFilesNotesCreateRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesNotesCreate(ctx context.Context, id string) ApiDcimSoftwareImageFilesNotesCreateRequest {
	return ApiDcimSoftwareImageFilesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimSoftwareImageFilesNotesCreateExecute(r ApiDcimSoftwareImageFilesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimSoftwareImageFilesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimSoftwareImageFilesNotesListRequest) Limit(limit int32) ApiDcimSoftwareImageFilesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimSoftwareImageFilesNotesListRequest) Offset(offset int32) ApiDcimSoftwareImageFilesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimSoftwareImageFilesNotesListRequest) Depth(depth int32) ApiDcimSoftwareImageFilesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimSoftwareImageFilesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesNotesListExecute(r)
}

/*
DcimSoftwareImageFilesNotesList Method for DcimSoftwareImageFilesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software image file.
 @return ApiDcimSoftwareImageFilesNotesListRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesNotesList(ctx context.Context, id string) ApiDcimSoftwareImageFilesNotesListRequest {
	return ApiDcimSoftwareImageFilesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimSoftwareImageFilesNotesListExecute(r ApiDcimSoftwareImageFilesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedSoftwareImageFileRequest *PatchedSoftwareImageFileRequest
}

func (r ApiDcimSoftwareImageFilesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareImageFilesPartialUpdateRequest) PatchedSoftwareImageFileRequest(patchedSoftwareImageFileRequest PatchedSoftwareImageFileRequest) ApiDcimSoftwareImageFilesPartialUpdateRequest {
	r.patchedSoftwareImageFileRequest = &patchedSoftwareImageFileRequest
	return r
}

func (r ApiDcimSoftwareImageFilesPartialUpdateRequest) Execute() (*SoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesPartialUpdateExecute(r)
}

/*
DcimSoftwareImageFilesPartialUpdate Method for DcimSoftwareImageFilesPartialUpdate

Partial update a software image file object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software image file.
 @return ApiDcimSoftwareImageFilesPartialUpdateRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesPartialUpdate(ctx context.Context, id string) ApiDcimSoftwareImageFilesPartialUpdateRequest {
	return ApiDcimSoftwareImageFilesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SoftwareImageFile
func (a *DcimAPIService) DcimSoftwareImageFilesPartialUpdateExecute(r ApiDcimSoftwareImageFilesPartialUpdateRequest) (*SoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSoftwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimSoftwareImageFilesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimSoftwareImageFilesRetrieveRequest) Depth(depth int32) ApiDcimSoftwareImageFilesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimSoftwareImageFilesRetrieveRequest) Execute() (*SoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesRetrieveExecute(r)
}

/*
DcimSoftwareImageFilesRetrieve Method for DcimSoftwareImageFilesRetrieve

Retrieve a software image file object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software image file.
 @return ApiDcimSoftwareImageFilesRetrieveRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesRetrieve(ctx context.Context, id string) ApiDcimSoftwareImageFilesRetrieveRequest {
	return ApiDcimSoftwareImageFilesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SoftwareImageFile
func (a *DcimAPIService) DcimSoftwareImageFilesRetrieveExecute(r ApiDcimSoftwareImageFilesRetrieveRequest) (*SoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareImageFilesUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	softwareImageFileRequest *SoftwareImageFileRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareImageFilesUpdateRequest) SoftwareImageFileRequest(softwareImageFileRequest SoftwareImageFileRequest) ApiDcimSoftwareImageFilesUpdateRequest {
	r.softwareImageFileRequest = &softwareImageFileRequest
	return r
}

func (r ApiDcimSoftwareImageFilesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareImageFilesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareImageFilesUpdateRequest) Execute() (*SoftwareImageFile, *http.Response, error) {
	return r.ApiService.DcimSoftwareImageFilesUpdateExecute(r)
}

/*
DcimSoftwareImageFilesUpdate Method for DcimSoftwareImageFilesUpdate

Update a software image file object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software image file.
 @return ApiDcimSoftwareImageFilesUpdateRequest
*/
func (a *DcimAPIService) DcimSoftwareImageFilesUpdate(ctx context.Context, id string) ApiDcimSoftwareImageFilesUpdateRequest {
	return ApiDcimSoftwareImageFilesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SoftwareImageFile
func (a *DcimAPIService) DcimSoftwareImageFilesUpdateExecute(r ApiDcimSoftwareImageFilesUpdateRequest) (*SoftwareImageFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareImageFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareImageFilesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.softwareImageFileRequest == nil {
		return localVarReturnValue, nil, reportError("softwareImageFileRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareImageFileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareVersionsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimSoftwareVersionsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimSoftwareVersionsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareVersionsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsBulkDestroyExecute(r)
}

/*
DcimSoftwareVersionsBulkDestroy Method for DcimSoftwareVersionsBulkDestroy

Destroy a list of software version objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareVersionsBulkDestroyRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsBulkDestroy(ctx context.Context) ApiDcimSoftwareVersionsBulkDestroyRequest {
	return ApiDcimSoftwareVersionsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimSoftwareVersionsBulkDestroyExecute(r ApiDcimSoftwareVersionsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableSoftwareVersionRequest *[]PatchedBulkWritableSoftwareVersionRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareVersionsBulkPartialUpdateRequest) PatchedBulkWritableSoftwareVersionRequest(patchedBulkWritableSoftwareVersionRequest []PatchedBulkWritableSoftwareVersionRequest) ApiDcimSoftwareVersionsBulkPartialUpdateRequest {
	r.patchedBulkWritableSoftwareVersionRequest = &patchedBulkWritableSoftwareVersionRequest
	return r
}

func (r ApiDcimSoftwareVersionsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareVersionsBulkPartialUpdateRequest) Execute() ([]SoftwareVersion, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsBulkPartialUpdateExecute(r)
}

/*
DcimSoftwareVersionsBulkPartialUpdate Method for DcimSoftwareVersionsBulkPartialUpdate

Partial update a list of software version objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareVersionsBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsBulkPartialUpdate(ctx context.Context) ApiDcimSoftwareVersionsBulkPartialUpdateRequest {
	return ApiDcimSoftwareVersionsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SoftwareVersion
func (a *DcimAPIService) DcimSoftwareVersionsBulkPartialUpdateExecute(r ApiDcimSoftwareVersionsBulkPartialUpdateRequest) ([]SoftwareVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SoftwareVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableSoftwareVersionRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableSoftwareVersionRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableSoftwareVersionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableSoftwareVersionRequest *[]BulkWritableSoftwareVersionRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareVersionsBulkUpdateRequest) BulkWritableSoftwareVersionRequest(bulkWritableSoftwareVersionRequest []BulkWritableSoftwareVersionRequest) ApiDcimSoftwareVersionsBulkUpdateRequest {
	r.bulkWritableSoftwareVersionRequest = &bulkWritableSoftwareVersionRequest
	return r
}

func (r ApiDcimSoftwareVersionsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareVersionsBulkUpdateRequest) Execute() ([]SoftwareVersion, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsBulkUpdateExecute(r)
}

/*
DcimSoftwareVersionsBulkUpdate Method for DcimSoftwareVersionsBulkUpdate

Update a list of software version objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareVersionsBulkUpdateRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsBulkUpdate(ctx context.Context) ApiDcimSoftwareVersionsBulkUpdateRequest {
	return ApiDcimSoftwareVersionsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SoftwareVersion
func (a *DcimAPIService) DcimSoftwareVersionsBulkUpdateExecute(r ApiDcimSoftwareVersionsBulkUpdateRequest) ([]SoftwareVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SoftwareVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableSoftwareVersionRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableSoftwareVersionRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableSoftwareVersionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	softwareVersionRequest *SoftwareVersionRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareVersionsCreateRequest) SoftwareVersionRequest(softwareVersionRequest SoftwareVersionRequest) ApiDcimSoftwareVersionsCreateRequest {
	r.softwareVersionRequest = &softwareVersionRequest
	return r
}

func (r ApiDcimSoftwareVersionsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareVersionsCreateRequest) Execute() (*SoftwareVersion, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsCreateExecute(r)
}

/*
DcimSoftwareVersionsCreate Method for DcimSoftwareVersionsCreate

Create one or more software version objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareVersionsCreateRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsCreate(ctx context.Context) ApiDcimSoftwareVersionsCreateRequest {
	return ApiDcimSoftwareVersionsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SoftwareVersion
func (a *DcimAPIService) DcimSoftwareVersionsCreateExecute(r ApiDcimSoftwareVersionsCreateRequest) (*SoftwareVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.softwareVersionRequest == nil {
		return localVarReturnValue, nil, reportError("softwareVersionRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareVersionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareVersionsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareVersionsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsDestroyExecute(r)
}

/*
DcimSoftwareVersionsDestroy Method for DcimSoftwareVersionsDestroy

Destroy a software version object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software version.
 @return ApiDcimSoftwareVersionsDestroyRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsDestroy(ctx context.Context, id string) ApiDcimSoftwareVersionsDestroyRequest {
	return ApiDcimSoftwareVersionsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimSoftwareVersionsDestroyExecute(r ApiDcimSoftwareVersionsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	alias *[]string
	aliasIc *[]string
	aliasIe *[]string
	aliasIew *[]string
	aliasIre *[]string
	aliasIsw *[]string
	aliasN *[]string
	aliasNic *[]string
	aliasNie *[]string
	aliasNiew *[]string
	aliasNire *[]string
	aliasNisw *[]string
	aliasNre *[]string
	aliasRe *[]string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	deviceTypes *[]string
	deviceTypesIsnull *bool
	deviceTypesN *[]string
	devices *[]string
	devicesIsnull *bool
	devicesN *[]string
	documentationUrl *[]string
	documentationUrlIc *[]string
	documentationUrlIe *[]string
	documentationUrlIew *[]string
	documentationUrlIre *[]string
	documentationUrlIsw *[]string
	documentationUrlN *[]string
	documentationUrlNic *[]string
	documentationUrlNie *[]string
	documentationUrlNiew *[]string
	documentationUrlNire *[]string
	documentationUrlNisw *[]string
	documentationUrlNre *[]string
	documentationUrlRe *[]string
	endOfSupportDate *[]string
	endOfSupportDateGt *[]string
	endOfSupportDateGte *[]string
	endOfSupportDateIsnull *bool
	endOfSupportDateLt *[]string
	endOfSupportDateLte *[]string
	endOfSupportDateN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasDevices *bool
	hasInventoryItems *bool
	hasSoftwareImageFiles *bool
	hasVirtualMachines *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	inventoryItems *[]string
	inventoryItemsIsnull *bool
	inventoryItemsN *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	longTermSupport *bool
	offset *int32
	platform *[]string
	platformN *[]string
	preRelease *bool
	q *string
	releaseDate *[]string
	releaseDateGt *[]string
	releaseDateGte *[]string
	releaseDateIsnull *bool
	releaseDateLt *[]string
	releaseDateLte *[]string
	releaseDateN *[]string
	softwareImageFiles *[]string
	softwareImageFilesIsnull *bool
	softwareImageFilesN *[]string
	sort *string
	status *[]string
	statusN *[]string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	version *[]string
	versionIc *[]string
	versionIe *[]string
	versionIew *[]string
	versionIre *[]string
	versionIsw *[]string
	versionN *[]string
	versionNic *[]string
	versionNie *[]string
	versionNiew *[]string
	versionNire *[]string
	versionNisw *[]string
	versionNre *[]string
	versionRe *[]string
	virtualMachines *[]string
	virtualMachinesIsnull *bool
	virtualMachinesN *[]string
	depth *int32
}

func (r ApiDcimSoftwareVersionsListRequest) Alias(alias []string) ApiDcimSoftwareVersionsListRequest {
	r.alias = &alias
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasIc(aliasIc []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasIc = &aliasIc
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasIe(aliasIe []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasIe = &aliasIe
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasIew(aliasIew []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasIew = &aliasIew
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasIre(aliasIre []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasIre = &aliasIre
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasIsw(aliasIsw []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasIsw = &aliasIsw
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasN(aliasN []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasN = &aliasN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasNic(aliasNic []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasNic = &aliasNic
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasNie(aliasNie []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasNie = &aliasNie
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasNiew(aliasNiew []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasNiew = &aliasNiew
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasNire(aliasNire []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasNire = &aliasNire
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasNisw(aliasNisw []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasNisw = &aliasNisw
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasNre(aliasNre []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasNre = &aliasNre
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) AliasRe(aliasRe []string) ApiDcimSoftwareVersionsListRequest {
	r.aliasRe = &aliasRe
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) Created(created []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.created = &created
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) CreatedGt(createdGt []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) CreatedGte(createdGte []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) CreatedIsnull(createdIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) CreatedLt(createdLt []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) CreatedLte(createdLte []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) CreatedN(createdN []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DeviceTypes(deviceTypes []string) ApiDcimSoftwareVersionsListRequest {
	r.deviceTypes = &deviceTypes
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DeviceTypesIsnull(deviceTypesIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.deviceTypesIsnull = &deviceTypesIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DeviceTypesN(deviceTypesN []string) ApiDcimSoftwareVersionsListRequest {
	r.deviceTypesN = &deviceTypesN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) Devices(devices []string) ApiDcimSoftwareVersionsListRequest {
	r.devices = &devices
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DevicesIsnull(devicesIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.devicesIsnull = &devicesIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DevicesN(devicesN []string) ApiDcimSoftwareVersionsListRequest {
	r.devicesN = &devicesN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrl(documentationUrl []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrl = &documentationUrl
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlIc(documentationUrlIc []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlIc = &documentationUrlIc
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlIe(documentationUrlIe []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlIe = &documentationUrlIe
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlIew(documentationUrlIew []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlIew = &documentationUrlIew
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlIre(documentationUrlIre []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlIre = &documentationUrlIre
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlIsw(documentationUrlIsw []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlIsw = &documentationUrlIsw
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlN(documentationUrlN []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlN = &documentationUrlN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlNic(documentationUrlNic []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlNic = &documentationUrlNic
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlNie(documentationUrlNie []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlNie = &documentationUrlNie
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlNiew(documentationUrlNiew []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlNiew = &documentationUrlNiew
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlNire(documentationUrlNire []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlNire = &documentationUrlNire
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlNisw(documentationUrlNisw []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlNisw = &documentationUrlNisw
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlNre(documentationUrlNre []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlNre = &documentationUrlNre
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) DocumentationUrlRe(documentationUrlRe []string) ApiDcimSoftwareVersionsListRequest {
	r.documentationUrlRe = &documentationUrlRe
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) EndOfSupportDate(endOfSupportDate []string) ApiDcimSoftwareVersionsListRequest {
	r.endOfSupportDate = &endOfSupportDate
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) EndOfSupportDateGt(endOfSupportDateGt []string) ApiDcimSoftwareVersionsListRequest {
	r.endOfSupportDateGt = &endOfSupportDateGt
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) EndOfSupportDateGte(endOfSupportDateGte []string) ApiDcimSoftwareVersionsListRequest {
	r.endOfSupportDateGte = &endOfSupportDateGte
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) EndOfSupportDateIsnull(endOfSupportDateIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.endOfSupportDateIsnull = &endOfSupportDateIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) EndOfSupportDateLt(endOfSupportDateLt []string) ApiDcimSoftwareVersionsListRequest {
	r.endOfSupportDateLt = &endOfSupportDateLt
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) EndOfSupportDateLte(endOfSupportDateLte []string) ApiDcimSoftwareVersionsListRequest {
	r.endOfSupportDateLte = &endOfSupportDateLte
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) EndOfSupportDateN(endOfSupportDateN []string) ApiDcimSoftwareVersionsListRequest {
	r.endOfSupportDateN = &endOfSupportDateN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsListRequest {
	r.format = &format
	return r
}

// Has devices
func (r ApiDcimSoftwareVersionsListRequest) HasDevices(hasDevices bool) ApiDcimSoftwareVersionsListRequest {
	r.hasDevices = &hasDevices
	return r
}

// Has inventory items
func (r ApiDcimSoftwareVersionsListRequest) HasInventoryItems(hasInventoryItems bool) ApiDcimSoftwareVersionsListRequest {
	r.hasInventoryItems = &hasInventoryItems
	return r
}

// Has software image files
func (r ApiDcimSoftwareVersionsListRequest) HasSoftwareImageFiles(hasSoftwareImageFiles bool) ApiDcimSoftwareVersionsListRequest {
	r.hasSoftwareImageFiles = &hasSoftwareImageFiles
	return r
}

// Has virtual machines
func (r ApiDcimSoftwareVersionsListRequest) HasVirtualMachines(hasVirtualMachines bool) ApiDcimSoftwareVersionsListRequest {
	r.hasVirtualMachines = &hasVirtualMachines
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimSoftwareVersionsListRequest) Id(id []string) ApiDcimSoftwareVersionsListRequest {
	r.id = &id
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdIc(idIc []string) ApiDcimSoftwareVersionsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdIe(idIe []string) ApiDcimSoftwareVersionsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdIew(idIew []string) ApiDcimSoftwareVersionsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdIre(idIre []string) ApiDcimSoftwareVersionsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdIsw(idIsw []string) ApiDcimSoftwareVersionsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdN(idN []string) ApiDcimSoftwareVersionsListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdNic(idNic []string) ApiDcimSoftwareVersionsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdNie(idNie []string) ApiDcimSoftwareVersionsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdNiew(idNiew []string) ApiDcimSoftwareVersionsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdNire(idNire []string) ApiDcimSoftwareVersionsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdNisw(idNisw []string) ApiDcimSoftwareVersionsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdNre(idNre []string) ApiDcimSoftwareVersionsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) IdRe(idRe []string) ApiDcimSoftwareVersionsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) InventoryItems(inventoryItems []string) ApiDcimSoftwareVersionsListRequest {
	r.inventoryItems = &inventoryItems
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) InventoryItemsIsnull(inventoryItemsIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.inventoryItemsIsnull = &inventoryItemsIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) InventoryItemsN(inventoryItemsN []string) ApiDcimSoftwareVersionsListRequest {
	r.inventoryItemsN = &inventoryItemsN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimSoftwareVersionsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimSoftwareVersionsListRequest) Limit(limit int32) ApiDcimSoftwareVersionsListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) LongTermSupport(longTermSupport bool) ApiDcimSoftwareVersionsListRequest {
	r.longTermSupport = &longTermSupport
	return r
}

// The initial index from which to return the results.
func (r ApiDcimSoftwareVersionsListRequest) Offset(offset int32) ApiDcimSoftwareVersionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) Platform(platform []string) ApiDcimSoftwareVersionsListRequest {
	r.platform = &platform
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) PlatformN(platformN []string) ApiDcimSoftwareVersionsListRequest {
	r.platformN = &platformN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) PreRelease(preRelease bool) ApiDcimSoftwareVersionsListRequest {
	r.preRelease = &preRelease
	return r
}

// Search
func (r ApiDcimSoftwareVersionsListRequest) Q(q string) ApiDcimSoftwareVersionsListRequest {
	r.q = &q
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) ReleaseDate(releaseDate []string) ApiDcimSoftwareVersionsListRequest {
	r.releaseDate = &releaseDate
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) ReleaseDateGt(releaseDateGt []string) ApiDcimSoftwareVersionsListRequest {
	r.releaseDateGt = &releaseDateGt
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) ReleaseDateGte(releaseDateGte []string) ApiDcimSoftwareVersionsListRequest {
	r.releaseDateGte = &releaseDateGte
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) ReleaseDateIsnull(releaseDateIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.releaseDateIsnull = &releaseDateIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) ReleaseDateLt(releaseDateLt []string) ApiDcimSoftwareVersionsListRequest {
	r.releaseDateLt = &releaseDateLt
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) ReleaseDateLte(releaseDateLte []string) ApiDcimSoftwareVersionsListRequest {
	r.releaseDateLte = &releaseDateLte
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) ReleaseDateN(releaseDateN []string) ApiDcimSoftwareVersionsListRequest {
	r.releaseDateN = &releaseDateN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) SoftwareImageFiles(softwareImageFiles []string) ApiDcimSoftwareVersionsListRequest {
	r.softwareImageFiles = &softwareImageFiles
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) SoftwareImageFilesIsnull(softwareImageFilesIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.softwareImageFilesIsnull = &softwareImageFilesIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) SoftwareImageFilesN(softwareImageFilesN []string) ApiDcimSoftwareVersionsListRequest {
	r.softwareImageFilesN = &softwareImageFilesN
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimSoftwareVersionsListRequest) Sort(sort string) ApiDcimSoftwareVersionsListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) Status(status []string) ApiDcimSoftwareVersionsListRequest {
	r.status = &status
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) StatusN(statusN []string) ApiDcimSoftwareVersionsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) Tags(tags []string) ApiDcimSoftwareVersionsListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) TagsIsnull(tagsIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) TagsN(tagsN []string) ApiDcimSoftwareVersionsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) Version(version []string) ApiDcimSoftwareVersionsListRequest {
	r.version = &version
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionIc(versionIc []string) ApiDcimSoftwareVersionsListRequest {
	r.versionIc = &versionIc
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionIe(versionIe []string) ApiDcimSoftwareVersionsListRequest {
	r.versionIe = &versionIe
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionIew(versionIew []string) ApiDcimSoftwareVersionsListRequest {
	r.versionIew = &versionIew
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionIre(versionIre []string) ApiDcimSoftwareVersionsListRequest {
	r.versionIre = &versionIre
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionIsw(versionIsw []string) ApiDcimSoftwareVersionsListRequest {
	r.versionIsw = &versionIsw
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionN(versionN []string) ApiDcimSoftwareVersionsListRequest {
	r.versionN = &versionN
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionNic(versionNic []string) ApiDcimSoftwareVersionsListRequest {
	r.versionNic = &versionNic
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionNie(versionNie []string) ApiDcimSoftwareVersionsListRequest {
	r.versionNie = &versionNie
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionNiew(versionNiew []string) ApiDcimSoftwareVersionsListRequest {
	r.versionNiew = &versionNiew
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionNire(versionNire []string) ApiDcimSoftwareVersionsListRequest {
	r.versionNire = &versionNire
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionNisw(versionNisw []string) ApiDcimSoftwareVersionsListRequest {
	r.versionNisw = &versionNisw
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionNre(versionNre []string) ApiDcimSoftwareVersionsListRequest {
	r.versionNre = &versionNre
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VersionRe(versionRe []string) ApiDcimSoftwareVersionsListRequest {
	r.versionRe = &versionRe
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VirtualMachines(virtualMachines []string) ApiDcimSoftwareVersionsListRequest {
	r.virtualMachines = &virtualMachines
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VirtualMachinesIsnull(virtualMachinesIsnull bool) ApiDcimSoftwareVersionsListRequest {
	r.virtualMachinesIsnull = &virtualMachinesIsnull
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) VirtualMachinesN(virtualMachinesN []string) ApiDcimSoftwareVersionsListRequest {
	r.virtualMachinesN = &virtualMachinesN
	return r
}

// Serializer Depth
func (r ApiDcimSoftwareVersionsListRequest) Depth(depth int32) ApiDcimSoftwareVersionsListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimSoftwareVersionsListRequest) Execute() (*PaginatedSoftwareVersionList, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsListExecute(r)
}

/*
DcimSoftwareVersionsList Method for DcimSoftwareVersionsList

Retrieve a list of software version objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimSoftwareVersionsListRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsList(ctx context.Context) ApiDcimSoftwareVersionsListRequest {
	return ApiDcimSoftwareVersionsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedSoftwareVersionList
func (a *DcimAPIService) DcimSoftwareVersionsListExecute(r ApiDcimSoftwareVersionsListRequest) (*PaginatedSoftwareVersionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSoftwareVersionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.alias != nil {
		t := *r.alias
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias", t, "multi")
		}
	}
	if r.aliasIc != nil {
		t := *r.aliasIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__ic", t, "multi")
		}
	}
	if r.aliasIe != nil {
		t := *r.aliasIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__ie", t, "multi")
		}
	}
	if r.aliasIew != nil {
		t := *r.aliasIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__iew", t, "multi")
		}
	}
	if r.aliasIre != nil {
		t := *r.aliasIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__ire", t, "multi")
		}
	}
	if r.aliasIsw != nil {
		t := *r.aliasIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__isw", t, "multi")
		}
	}
	if r.aliasN != nil {
		t := *r.aliasN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__n", t, "multi")
		}
	}
	if r.aliasNic != nil {
		t := *r.aliasNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nic", t, "multi")
		}
	}
	if r.aliasNie != nil {
		t := *r.aliasNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nie", t, "multi")
		}
	}
	if r.aliasNiew != nil {
		t := *r.aliasNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__niew", t, "multi")
		}
	}
	if r.aliasNire != nil {
		t := *r.aliasNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nire", t, "multi")
		}
	}
	if r.aliasNisw != nil {
		t := *r.aliasNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nisw", t, "multi")
		}
	}
	if r.aliasNre != nil {
		t := *r.aliasNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__nre", t, "multi")
		}
	}
	if r.aliasRe != nil {
		t := *r.aliasRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alias__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alias__re", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_types", t, "multi")
		}
	}
	if r.deviceTypesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__isnull", r.deviceTypesIsnull, "")
	}
	if r.deviceTypesN != nil {
		t := *r.deviceTypesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_types__n", t, "multi")
		}
	}
	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices", t, "multi")
		}
	}
	if r.devicesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices__isnull", r.devicesIsnull, "")
	}
	if r.devicesN != nil {
		t := *r.devicesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "devices__n", t, "multi")
		}
	}
	if r.documentationUrl != nil {
		t := *r.documentationUrl
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url", t, "multi")
		}
	}
	if r.documentationUrlIc != nil {
		t := *r.documentationUrlIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__ic", t, "multi")
		}
	}
	if r.documentationUrlIe != nil {
		t := *r.documentationUrlIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__ie", t, "multi")
		}
	}
	if r.documentationUrlIew != nil {
		t := *r.documentationUrlIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__iew", t, "multi")
		}
	}
	if r.documentationUrlIre != nil {
		t := *r.documentationUrlIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__ire", t, "multi")
		}
	}
	if r.documentationUrlIsw != nil {
		t := *r.documentationUrlIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__isw", t, "multi")
		}
	}
	if r.documentationUrlN != nil {
		t := *r.documentationUrlN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__n", t, "multi")
		}
	}
	if r.documentationUrlNic != nil {
		t := *r.documentationUrlNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nic", t, "multi")
		}
	}
	if r.documentationUrlNie != nil {
		t := *r.documentationUrlNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nie", t, "multi")
		}
	}
	if r.documentationUrlNiew != nil {
		t := *r.documentationUrlNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__niew", t, "multi")
		}
	}
	if r.documentationUrlNire != nil {
		t := *r.documentationUrlNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nire", t, "multi")
		}
	}
	if r.documentationUrlNisw != nil {
		t := *r.documentationUrlNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nisw", t, "multi")
		}
	}
	if r.documentationUrlNre != nil {
		t := *r.documentationUrlNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__nre", t, "multi")
		}
	}
	if r.documentationUrlRe != nil {
		t := *r.documentationUrlRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentation_url__re", t, "multi")
		}
	}
	if r.endOfSupportDate != nil {
		t := *r.endOfSupportDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date", t, "multi")
		}
	}
	if r.endOfSupportDateGt != nil {
		t := *r.endOfSupportDateGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__gt", t, "multi")
		}
	}
	if r.endOfSupportDateGte != nil {
		t := *r.endOfSupportDateGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__gte", t, "multi")
		}
	}
	if r.endOfSupportDateIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__isnull", r.endOfSupportDateIsnull, "")
	}
	if r.endOfSupportDateLt != nil {
		t := *r.endOfSupportDateLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__lt", t, "multi")
		}
	}
	if r.endOfSupportDateLte != nil {
		t := *r.endOfSupportDateLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__lte", t, "multi")
		}
	}
	if r.endOfSupportDateN != nil {
		t := *r.endOfSupportDateN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end_of_support_date__n", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_devices", r.hasDevices, "")
	}
	if r.hasInventoryItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_inventory_items", r.hasInventoryItems, "")
	}
	if r.hasSoftwareImageFiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_software_image_files", r.hasSoftwareImageFiles, "")
	}
	if r.hasVirtualMachines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_virtual_machines", r.hasVirtualMachines, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.inventoryItems != nil {
		t := *r.inventoryItems
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items", t, "multi")
		}
	}
	if r.inventoryItemsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items__isnull", r.inventoryItemsIsnull, "")
	}
	if r.inventoryItemsN != nil {
		t := *r.inventoryItemsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inventory_items__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.longTermSupport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "long_term_support", r.longTermSupport, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.platform != nil {
		t := *r.platform
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "platform", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "platform", t, "multi")
		}
	}
	if r.platformN != nil {
		t := *r.platformN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "platform__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "platform__n", t, "multi")
		}
	}
	if r.preRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pre_release", r.preRelease, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.releaseDate != nil {
		t := *r.releaseDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "release_date", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "release_date", t, "multi")
		}
	}
	if r.releaseDateGt != nil {
		t := *r.releaseDateGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__gt", t, "multi")
		}
	}
	if r.releaseDateGte != nil {
		t := *r.releaseDateGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__gte", t, "multi")
		}
	}
	if r.releaseDateIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__isnull", r.releaseDateIsnull, "")
	}
	if r.releaseDateLt != nil {
		t := *r.releaseDateLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__lt", t, "multi")
		}
	}
	if r.releaseDateLte != nil {
		t := *r.releaseDateLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__lte", t, "multi")
		}
	}
	if r.releaseDateN != nil {
		t := *r.releaseDateN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "release_date__n", t, "multi")
		}
	}
	if r.softwareImageFiles != nil {
		t := *r.softwareImageFiles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files", t, "multi")
		}
	}
	if r.softwareImageFilesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__isnull", r.softwareImageFilesIsnull, "")
	}
	if r.softwareImageFilesN != nil {
		t := *r.softwareImageFilesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_image_files__n", t, "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.version != nil {
		t := *r.version
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version", t, "multi")
		}
	}
	if r.versionIc != nil {
		t := *r.versionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__ic", t, "multi")
		}
	}
	if r.versionIe != nil {
		t := *r.versionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__ie", t, "multi")
		}
	}
	if r.versionIew != nil {
		t := *r.versionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__iew", t, "multi")
		}
	}
	if r.versionIre != nil {
		t := *r.versionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__ire", t, "multi")
		}
	}
	if r.versionIsw != nil {
		t := *r.versionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__isw", t, "multi")
		}
	}
	if r.versionN != nil {
		t := *r.versionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__n", t, "multi")
		}
	}
	if r.versionNic != nil {
		t := *r.versionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__nic", t, "multi")
		}
	}
	if r.versionNie != nil {
		t := *r.versionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__nie", t, "multi")
		}
	}
	if r.versionNiew != nil {
		t := *r.versionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__niew", t, "multi")
		}
	}
	if r.versionNire != nil {
		t := *r.versionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__nire", t, "multi")
		}
	}
	if r.versionNisw != nil {
		t := *r.versionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__nisw", t, "multi")
		}
	}
	if r.versionNre != nil {
		t := *r.versionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__nre", t, "multi")
		}
	}
	if r.versionRe != nil {
		t := *r.versionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__re", t, "multi")
		}
	}
	if r.virtualMachines != nil {
		t := *r.virtualMachines
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines", t, "multi")
		}
	}
	if r.virtualMachinesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines__isnull", r.virtualMachinesIsnull, "")
	}
	if r.virtualMachinesN != nil {
		t := *r.virtualMachinesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machines__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareVersionsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimSoftwareVersionsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimSoftwareVersionsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareVersionsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsNotesCreateExecute(r)
}

/*
DcimSoftwareVersionsNotesCreate Method for DcimSoftwareVersionsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software version.
 @return ApiDcimSoftwareVersionsNotesCreateRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsNotesCreate(ctx context.Context, id string) ApiDcimSoftwareVersionsNotesCreateRequest {
	return ApiDcimSoftwareVersionsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimSoftwareVersionsNotesCreateExecute(r ApiDcimSoftwareVersionsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimSoftwareVersionsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimSoftwareVersionsNotesListRequest) Limit(limit int32) ApiDcimSoftwareVersionsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimSoftwareVersionsNotesListRequest) Offset(offset int32) ApiDcimSoftwareVersionsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimSoftwareVersionsNotesListRequest) Depth(depth int32) ApiDcimSoftwareVersionsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimSoftwareVersionsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsNotesListExecute(r)
}

/*
DcimSoftwareVersionsNotesList Method for DcimSoftwareVersionsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software version.
 @return ApiDcimSoftwareVersionsNotesListRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsNotesList(ctx context.Context, id string) ApiDcimSoftwareVersionsNotesListRequest {
	return ApiDcimSoftwareVersionsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimSoftwareVersionsNotesListExecute(r ApiDcimSoftwareVersionsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedSoftwareVersionRequest *PatchedSoftwareVersionRequest
}

func (r ApiDcimSoftwareVersionsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareVersionsPartialUpdateRequest) PatchedSoftwareVersionRequest(patchedSoftwareVersionRequest PatchedSoftwareVersionRequest) ApiDcimSoftwareVersionsPartialUpdateRequest {
	r.patchedSoftwareVersionRequest = &patchedSoftwareVersionRequest
	return r
}

func (r ApiDcimSoftwareVersionsPartialUpdateRequest) Execute() (*SoftwareVersion, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsPartialUpdateExecute(r)
}

/*
DcimSoftwareVersionsPartialUpdate Method for DcimSoftwareVersionsPartialUpdate

Partial update a software version object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software version.
 @return ApiDcimSoftwareVersionsPartialUpdateRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsPartialUpdate(ctx context.Context, id string) ApiDcimSoftwareVersionsPartialUpdateRequest {
	return ApiDcimSoftwareVersionsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SoftwareVersion
func (a *DcimAPIService) DcimSoftwareVersionsPartialUpdateExecute(r ApiDcimSoftwareVersionsPartialUpdateRequest) (*SoftwareVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSoftwareVersionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimSoftwareVersionsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimSoftwareVersionsRetrieveRequest) Depth(depth int32) ApiDcimSoftwareVersionsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimSoftwareVersionsRetrieveRequest) Execute() (*SoftwareVersion, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsRetrieveExecute(r)
}

/*
DcimSoftwareVersionsRetrieve Method for DcimSoftwareVersionsRetrieve

Retrieve a software version object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software version.
 @return ApiDcimSoftwareVersionsRetrieveRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsRetrieve(ctx context.Context, id string) ApiDcimSoftwareVersionsRetrieveRequest {
	return ApiDcimSoftwareVersionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SoftwareVersion
func (a *DcimAPIService) DcimSoftwareVersionsRetrieveExecute(r ApiDcimSoftwareVersionsRetrieveRequest) (*SoftwareVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimSoftwareVersionsUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	softwareVersionRequest *SoftwareVersionRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimSoftwareVersionsUpdateRequest) SoftwareVersionRequest(softwareVersionRequest SoftwareVersionRequest) ApiDcimSoftwareVersionsUpdateRequest {
	r.softwareVersionRequest = &softwareVersionRequest
	return r
}

func (r ApiDcimSoftwareVersionsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimSoftwareVersionsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimSoftwareVersionsUpdateRequest) Execute() (*SoftwareVersion, *http.Response, error) {
	return r.ApiService.DcimSoftwareVersionsUpdateExecute(r)
}

/*
DcimSoftwareVersionsUpdate Method for DcimSoftwareVersionsUpdate

Update a software version object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this software version.
 @return ApiDcimSoftwareVersionsUpdateRequest
*/
func (a *DcimAPIService) DcimSoftwareVersionsUpdate(ctx context.Context, id string) ApiDcimSoftwareVersionsUpdateRequest {
	return ApiDcimSoftwareVersionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SoftwareVersion
func (a *DcimAPIService) DcimSoftwareVersionsUpdateExecute(r ApiDcimSoftwareVersionsUpdateRequest) (*SoftwareVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SoftwareVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimSoftwareVersionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/software-versions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.softwareVersionRequest == nil {
		return localVarReturnValue, nil, reportError("softwareVersionRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.softwareVersionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisBulkDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimVirtualChassisBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiDcimVirtualChassisBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiDcimVirtualChassisBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimVirtualChassisBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimVirtualChassisBulkDestroyExecute(r)
}

/*
DcimVirtualChassisBulkDestroy Method for DcimVirtualChassisBulkDestroy

Destroy a list of virtual chassis objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisBulkDestroyRequest
*/
func (a *DcimAPIService) DcimVirtualChassisBulkDestroy(ctx context.Context) ApiDcimVirtualChassisBulkDestroyRequest {
	return ApiDcimVirtualChassisBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimVirtualChassisBulkDestroyExecute(r ApiDcimVirtualChassisBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	patchedBulkWritableVirtualChassisRequest *[]PatchedBulkWritableVirtualChassisRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimVirtualChassisBulkPartialUpdateRequest) PatchedBulkWritableVirtualChassisRequest(patchedBulkWritableVirtualChassisRequest []PatchedBulkWritableVirtualChassisRequest) ApiDcimVirtualChassisBulkPartialUpdateRequest {
	r.patchedBulkWritableVirtualChassisRequest = &patchedBulkWritableVirtualChassisRequest
	return r
}

func (r ApiDcimVirtualChassisBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimVirtualChassisBulkPartialUpdateRequest) Execute() ([]VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisBulkPartialUpdateExecute(r)
}

/*
DcimVirtualChassisBulkPartialUpdate Method for DcimVirtualChassisBulkPartialUpdate

Partial update a list of virtual chassis objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisBulkPartialUpdateRequest
*/
func (a *DcimAPIService) DcimVirtualChassisBulkPartialUpdate(ctx context.Context) ApiDcimVirtualChassisBulkPartialUpdateRequest {
	return ApiDcimVirtualChassisBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VirtualChassis
func (a *DcimAPIService) DcimVirtualChassisBulkPartialUpdateExecute(r ApiDcimVirtualChassisBulkPartialUpdateRequest) ([]VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableVirtualChassisRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableVirtualChassisRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableVirtualChassisRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisBulkUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	bulkWritableVirtualChassisRequest *[]BulkWritableVirtualChassisRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimVirtualChassisBulkUpdateRequest) BulkWritableVirtualChassisRequest(bulkWritableVirtualChassisRequest []BulkWritableVirtualChassisRequest) ApiDcimVirtualChassisBulkUpdateRequest {
	r.bulkWritableVirtualChassisRequest = &bulkWritableVirtualChassisRequest
	return r
}

func (r ApiDcimVirtualChassisBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimVirtualChassisBulkUpdateRequest) Execute() ([]VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisBulkUpdateExecute(r)
}

/*
DcimVirtualChassisBulkUpdate Method for DcimVirtualChassisBulkUpdate

Update a list of virtual chassis objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisBulkUpdateRequest
*/
func (a *DcimAPIService) DcimVirtualChassisBulkUpdate(ctx context.Context) ApiDcimVirtualChassisBulkUpdateRequest {
	return ApiDcimVirtualChassisBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VirtualChassis
func (a *DcimAPIService) DcimVirtualChassisBulkUpdateExecute(r ApiDcimVirtualChassisBulkUpdateRequest) ([]VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableVirtualChassisRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableVirtualChassisRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableVirtualChassisRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	virtualChassisRequest *VirtualChassisRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimVirtualChassisCreateRequest) VirtualChassisRequest(virtualChassisRequest VirtualChassisRequest) ApiDcimVirtualChassisCreateRequest {
	r.virtualChassisRequest = &virtualChassisRequest
	return r
}

func (r ApiDcimVirtualChassisCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimVirtualChassisCreateRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisCreateExecute(r)
}

/*
DcimVirtualChassisCreate Method for DcimVirtualChassisCreate

Create one or more virtual chassis objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisCreateRequest
*/
func (a *DcimAPIService) DcimVirtualChassisCreate(ctx context.Context) ApiDcimVirtualChassisCreateRequest {
	return ApiDcimVirtualChassisCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimAPIService) DcimVirtualChassisCreateExecute(r ApiDcimVirtualChassisCreateRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.virtualChassisRequest == nil {
		return localVarReturnValue, nil, reportError("virtualChassisRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.virtualChassisRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisDestroyRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimVirtualChassisDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisDestroyRequest {
	r.format = &format
	return r
}

func (r ApiDcimVirtualChassisDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DcimVirtualChassisDestroyExecute(r)
}

/*
DcimVirtualChassisDestroy Method for DcimVirtualChassisDestroy

Destroy a virtual chassis object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this virtual chassis.
 @return ApiDcimVirtualChassisDestroyRequest
*/
func (a *DcimAPIService) DcimVirtualChassisDestroy(ctx context.Context, id string) ApiDcimVirtualChassisDestroyRequest {
	return ApiDcimVirtualChassisDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DcimAPIService) DcimVirtualChassisDestroyExecute(r ApiDcimVirtualChassisDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	domain *[]string
	domainIc *[]string
	domainIe *[]string
	domainIew *[]string
	domainIre *[]string
	domainIsw *[]string
	domainN *[]string
	domainNic *[]string
	domainNie *[]string
	domainNiew *[]string
	domainNire *[]string
	domainNisw *[]string
	domainNre *[]string
	domainRe *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasMembers *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	master *[]string
	masterIsnull *bool
	masterN *[]string
	members *[]string
	membersIsnull *bool
	membersN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	depth *int32
}

func (r ApiDcimVirtualChassisListRequest) Created(created []time.Time) ApiDcimVirtualChassisListRequest {
	r.created = &created
	return r
}

func (r ApiDcimVirtualChassisListRequest) CreatedGt(createdGt []time.Time) ApiDcimVirtualChassisListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiDcimVirtualChassisListRequest) CreatedGte(createdGte []time.Time) ApiDcimVirtualChassisListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiDcimVirtualChassisListRequest) CreatedIsnull(createdIsnull bool) ApiDcimVirtualChassisListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiDcimVirtualChassisListRequest) CreatedLt(createdLt []time.Time) ApiDcimVirtualChassisListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiDcimVirtualChassisListRequest) CreatedLte(createdLte []time.Time) ApiDcimVirtualChassisListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiDcimVirtualChassisListRequest) CreatedN(createdN []time.Time) ApiDcimVirtualChassisListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiDcimVirtualChassisListRequest) Domain(domain []string) ApiDcimVirtualChassisListRequest {
	r.domain = &domain
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIc(domainIc []string) ApiDcimVirtualChassisListRequest {
	r.domainIc = &domainIc
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIe(domainIe []string) ApiDcimVirtualChassisListRequest {
	r.domainIe = &domainIe
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIew(domainIew []string) ApiDcimVirtualChassisListRequest {
	r.domainIew = &domainIew
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIre(domainIre []string) ApiDcimVirtualChassisListRequest {
	r.domainIre = &domainIre
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainIsw(domainIsw []string) ApiDcimVirtualChassisListRequest {
	r.domainIsw = &domainIsw
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainN(domainN []string) ApiDcimVirtualChassisListRequest {
	r.domainN = &domainN
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNic(domainNic []string) ApiDcimVirtualChassisListRequest {
	r.domainNic = &domainNic
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNie(domainNie []string) ApiDcimVirtualChassisListRequest {
	r.domainNie = &domainNie
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNiew(domainNiew []string) ApiDcimVirtualChassisListRequest {
	r.domainNiew = &domainNiew
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNire(domainNire []string) ApiDcimVirtualChassisListRequest {
	r.domainNire = &domainNire
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNisw(domainNisw []string) ApiDcimVirtualChassisListRequest {
	r.domainNisw = &domainNisw
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainNre(domainNre []string) ApiDcimVirtualChassisListRequest {
	r.domainNre = &domainNre
	return r
}

func (r ApiDcimVirtualChassisListRequest) DomainRe(domainRe []string) ApiDcimVirtualChassisListRequest {
	r.domainRe = &domainRe
	return r
}

func (r ApiDcimVirtualChassisListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisListRequest {
	r.format = &format
	return r
}

// Has device members
func (r ApiDcimVirtualChassisListRequest) HasMembers(hasMembers bool) ApiDcimVirtualChassisListRequest {
	r.hasMembers = &hasMembers
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiDcimVirtualChassisListRequest) Id(id []string) ApiDcimVirtualChassisListRequest {
	r.id = &id
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdIc(idIc []string) ApiDcimVirtualChassisListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdIe(idIe []string) ApiDcimVirtualChassisListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdIew(idIew []string) ApiDcimVirtualChassisListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdIre(idIre []string) ApiDcimVirtualChassisListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdIsw(idIsw []string) ApiDcimVirtualChassisListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdN(idN []string) ApiDcimVirtualChassisListRequest {
	r.idN = &idN
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdNic(idNic []string) ApiDcimVirtualChassisListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdNie(idNie []string) ApiDcimVirtualChassisListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdNiew(idNiew []string) ApiDcimVirtualChassisListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdNire(idNire []string) ApiDcimVirtualChassisListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdNisw(idNisw []string) ApiDcimVirtualChassisListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdNre(idNre []string) ApiDcimVirtualChassisListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiDcimVirtualChassisListRequest) IdRe(idRe []string) ApiDcimVirtualChassisListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdated(lastUpdated []time.Time) ApiDcimVirtualChassisListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiDcimVirtualChassisListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiDcimVirtualChassisListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiDcimVirtualChassisListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiDcimVirtualChassisListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiDcimVirtualChassisListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiDcimVirtualChassisListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiDcimVirtualChassisListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiDcimVirtualChassisListRequest) Limit(limit int32) ApiDcimVirtualChassisListRequest {
	r.limit = &limit
	return r
}

func (r ApiDcimVirtualChassisListRequest) Location(location []string) ApiDcimVirtualChassisListRequest {
	r.location = &location
	return r
}

func (r ApiDcimVirtualChassisListRequest) LocationN(locationN []string) ApiDcimVirtualChassisListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiDcimVirtualChassisListRequest) Master(master []string) ApiDcimVirtualChassisListRequest {
	r.master = &master
	return r
}

func (r ApiDcimVirtualChassisListRequest) MasterIsnull(masterIsnull bool) ApiDcimVirtualChassisListRequest {
	r.masterIsnull = &masterIsnull
	return r
}

func (r ApiDcimVirtualChassisListRequest) MasterN(masterN []string) ApiDcimVirtualChassisListRequest {
	r.masterN = &masterN
	return r
}

func (r ApiDcimVirtualChassisListRequest) Members(members []string) ApiDcimVirtualChassisListRequest {
	r.members = &members
	return r
}

func (r ApiDcimVirtualChassisListRequest) MembersIsnull(membersIsnull bool) ApiDcimVirtualChassisListRequest {
	r.membersIsnull = &membersIsnull
	return r
}

func (r ApiDcimVirtualChassisListRequest) MembersN(membersN []string) ApiDcimVirtualChassisListRequest {
	r.membersN = &membersN
	return r
}

func (r ApiDcimVirtualChassisListRequest) Name(name []string) ApiDcimVirtualChassisListRequest {
	r.name = &name
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIc(nameIc []string) ApiDcimVirtualChassisListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIe(nameIe []string) ApiDcimVirtualChassisListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIew(nameIew []string) ApiDcimVirtualChassisListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIre(nameIre []string) ApiDcimVirtualChassisListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameIsw(nameIsw []string) ApiDcimVirtualChassisListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameN(nameN []string) ApiDcimVirtualChassisListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNic(nameNic []string) ApiDcimVirtualChassisListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNie(nameNie []string) ApiDcimVirtualChassisListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNiew(nameNiew []string) ApiDcimVirtualChassisListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNire(nameNire []string) ApiDcimVirtualChassisListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNisw(nameNisw []string) ApiDcimVirtualChassisListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameNre(nameNre []string) ApiDcimVirtualChassisListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiDcimVirtualChassisListRequest) NameRe(nameRe []string) ApiDcimVirtualChassisListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiDcimVirtualChassisListRequest) Offset(offset int32) ApiDcimVirtualChassisListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiDcimVirtualChassisListRequest) Q(q string) ApiDcimVirtualChassisListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiDcimVirtualChassisListRequest) Sort(sort string) ApiDcimVirtualChassisListRequest {
	r.sort = &sort
	return r
}

func (r ApiDcimVirtualChassisListRequest) Tags(tags []string) ApiDcimVirtualChassisListRequest {
	r.tags = &tags
	return r
}

func (r ApiDcimVirtualChassisListRequest) TagsIsnull(tagsIsnull bool) ApiDcimVirtualChassisListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiDcimVirtualChassisListRequest) TagsN(tagsN []string) ApiDcimVirtualChassisListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiDcimVirtualChassisListRequest) Tenant(tenant []string) ApiDcimVirtualChassisListRequest {
	r.tenant = &tenant
	return r
}

func (r ApiDcimVirtualChassisListRequest) TenantIsnull(tenantIsnull bool) ApiDcimVirtualChassisListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiDcimVirtualChassisListRequest) TenantN(tenantN []string) ApiDcimVirtualChassisListRequest {
	r.tenantN = &tenantN
	return r
}

// Serializer Depth
func (r ApiDcimVirtualChassisListRequest) Depth(depth int32) ApiDcimVirtualChassisListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimVirtualChassisListRequest) Execute() (*PaginatedVirtualChassisList, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisListExecute(r)
}

/*
DcimVirtualChassisList Method for DcimVirtualChassisList

Retrieve a list of virtual chassis objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDcimVirtualChassisListRequest
*/
func (a *DcimAPIService) DcimVirtualChassisList(ctx context.Context) ApiDcimVirtualChassisListRequest {
	return ApiDcimVirtualChassisListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVirtualChassisList
func (a *DcimAPIService) DcimVirtualChassisListExecute(r ApiDcimVirtualChassisListRequest) (*PaginatedVirtualChassisList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVirtualChassisList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.domain != nil {
		t := *r.domain
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain", t, "multi")
		}
	}
	if r.domainIc != nil {
		t := *r.domainIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__ic", t, "multi")
		}
	}
	if r.domainIe != nil {
		t := *r.domainIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__ie", t, "multi")
		}
	}
	if r.domainIew != nil {
		t := *r.domainIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__iew", t, "multi")
		}
	}
	if r.domainIre != nil {
		t := *r.domainIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__ire", t, "multi")
		}
	}
	if r.domainIsw != nil {
		t := *r.domainIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__isw", t, "multi")
		}
	}
	if r.domainN != nil {
		t := *r.domainN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__n", t, "multi")
		}
	}
	if r.domainNic != nil {
		t := *r.domainNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nic", t, "multi")
		}
	}
	if r.domainNie != nil {
		t := *r.domainNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nie", t, "multi")
		}
	}
	if r.domainNiew != nil {
		t := *r.domainNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__niew", t, "multi")
		}
	}
	if r.domainNire != nil {
		t := *r.domainNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nire", t, "multi")
		}
	}
	if r.domainNisw != nil {
		t := *r.domainNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nisw", t, "multi")
		}
	}
	if r.domainNre != nil {
		t := *r.domainNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__nre", t, "multi")
		}
	}
	if r.domainRe != nil {
		t := *r.domainRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain__re", t, "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.hasMembers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_members", r.hasMembers, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "multi")
		}
	}
	if r.master != nil {
		t := *r.master
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "master", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "master", t, "multi")
		}
	}
	if r.masterIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "master__isnull", r.masterIsnull, "")
	}
	if r.masterN != nil {
		t := *r.masterN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "master__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "master__n", t, "multi")
		}
	}
	if r.members != nil {
		t := *r.members
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "members", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "members", t, "multi")
		}
	}
	if r.membersIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "members__isnull", r.membersIsnull, "")
	}
	if r.membersN != nil {
		t := *r.membersN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "members__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "members__n", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisNotesCreateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimVirtualChassisNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiDcimVirtualChassisNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiDcimVirtualChassisNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiDcimVirtualChassisNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisNotesCreateExecute(r)
}

/*
DcimVirtualChassisNotesCreate Method for DcimVirtualChassisNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this virtual chassis.
 @return ApiDcimVirtualChassisNotesCreateRequest
*/
func (a *DcimAPIService) DcimVirtualChassisNotesCreate(ctx context.Context, id string) ApiDcimVirtualChassisNotesCreateRequest {
	return ApiDcimVirtualChassisNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *DcimAPIService) DcimVirtualChassisNotesCreateExecute(r ApiDcimVirtualChassisNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisNotesListRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiDcimVirtualChassisNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiDcimVirtualChassisNotesListRequest) Limit(limit int32) ApiDcimVirtualChassisNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiDcimVirtualChassisNotesListRequest) Offset(offset int32) ApiDcimVirtualChassisNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiDcimVirtualChassisNotesListRequest) Depth(depth int32) ApiDcimVirtualChassisNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimVirtualChassisNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisNotesListExecute(r)
}

/*
DcimVirtualChassisNotesList Method for DcimVirtualChassisNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this virtual chassis.
 @return ApiDcimVirtualChassisNotesListRequest
*/
func (a *DcimAPIService) DcimVirtualChassisNotesList(ctx context.Context, id string) ApiDcimVirtualChassisNotesListRequest {
	return ApiDcimVirtualChassisNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *DcimAPIService) DcimVirtualChassisNotesListExecute(r ApiDcimVirtualChassisNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedVirtualChassisRequest *PatchedVirtualChassisRequest
}

func (r ApiDcimVirtualChassisPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimVirtualChassisPartialUpdateRequest) PatchedVirtualChassisRequest(patchedVirtualChassisRequest PatchedVirtualChassisRequest) ApiDcimVirtualChassisPartialUpdateRequest {
	r.patchedVirtualChassisRequest = &patchedVirtualChassisRequest
	return r
}

func (r ApiDcimVirtualChassisPartialUpdateRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisPartialUpdateExecute(r)
}

/*
DcimVirtualChassisPartialUpdate Method for DcimVirtualChassisPartialUpdate

Partial update a virtual chassis object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this virtual chassis.
 @return ApiDcimVirtualChassisPartialUpdateRequest
*/
func (a *DcimAPIService) DcimVirtualChassisPartialUpdate(ctx context.Context, id string) ApiDcimVirtualChassisPartialUpdateRequest {
	return ApiDcimVirtualChassisPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimAPIService) DcimVirtualChassisPartialUpdateExecute(r ApiDcimVirtualChassisPartialUpdateRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVirtualChassisRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisRetrieveRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiDcimVirtualChassisRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiDcimVirtualChassisRetrieveRequest) Depth(depth int32) ApiDcimVirtualChassisRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiDcimVirtualChassisRetrieveRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisRetrieveExecute(r)
}

/*
DcimVirtualChassisRetrieve Method for DcimVirtualChassisRetrieve

Retrieve a virtual chassis object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this virtual chassis.
 @return ApiDcimVirtualChassisRetrieveRequest
*/
func (a *DcimAPIService) DcimVirtualChassisRetrieve(ctx context.Context, id string) ApiDcimVirtualChassisRetrieveRequest {
	return ApiDcimVirtualChassisRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimAPIService) DcimVirtualChassisRetrieveExecute(r ApiDcimVirtualChassisRetrieveRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDcimVirtualChassisUpdateRequest struct {
	ctx context.Context
	ApiService *DcimAPIService
	id string
	virtualChassisRequest *VirtualChassisRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiDcimVirtualChassisUpdateRequest) VirtualChassisRequest(virtualChassisRequest VirtualChassisRequest) ApiDcimVirtualChassisUpdateRequest {
	r.virtualChassisRequest = &virtualChassisRequest
	return r
}

func (r ApiDcimVirtualChassisUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiDcimVirtualChassisUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDcimVirtualChassisUpdateRequest) Execute() (*VirtualChassis, *http.Response, error) {
	return r.ApiService.DcimVirtualChassisUpdateExecute(r)
}

/*
DcimVirtualChassisUpdate Method for DcimVirtualChassisUpdate

Update a virtual chassis object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this virtual chassis.
 @return ApiDcimVirtualChassisUpdateRequest
*/
func (a *DcimAPIService) DcimVirtualChassisUpdate(ctx context.Context, id string) ApiDcimVirtualChassisUpdateRequest {
	return ApiDcimVirtualChassisUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VirtualChassis
func (a *DcimAPIService) DcimVirtualChassisUpdateExecute(r ApiDcimVirtualChassisUpdateRequest) (*VirtualChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DcimAPIService.DcimVirtualChassisUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.virtualChassisRequest == nil {
		return localVarReturnValue, nil, reportError("virtualChassisRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.virtualChassisRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
