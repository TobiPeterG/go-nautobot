
/*
 * API Documentation
 *
 * Source of truth and network automation platform
 *
 * API version: 2.2.5 (2.2)
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package go-nautobot

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type DcimApiService service
/*
DcimApiService
Destroy a list of cable objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimCablesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimCablesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimCablesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimCablesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of cable objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimCablesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Cable
*/

type DcimApiDcimCablesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimCablesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableCableRequest, localVarOptionals *DcimApiDcimCablesBulkPartialUpdateOpts) ([]Cable, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Cable
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Cable
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of cable objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimCablesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Cable
*/

type DcimApiDcimCablesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimCablesBulkUpdate(ctx context.Context, body []BulkWritableCableRequest, localVarOptionals *DcimApiDcimCablesBulkUpdateOpts) ([]Cable, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Cable
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Cable
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more cable objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimCablesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Cable
*/

type DcimApiDcimCablesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimCablesCreate(ctx context.Context, body WritableCableRequest, localVarOptionals *DcimApiDcimCablesCreateOpts) (Cable, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Cable
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Cable
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a cable object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this cable.
 * @param optional nil or *DcimApiDcimCablesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimCablesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimCablesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimCablesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of cable objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimCablesListOpts - Optional Parameters:
     * @param "Color" (optional.Interface of []string) - 
     * @param "ColorIc" (optional.Interface of []string) - 
     * @param "ColorIe" (optional.Interface of []string) - 
     * @param "ColorIew" (optional.Interface of []string) - 
     * @param "ColorIre" (optional.Interface of []string) - 
     * @param "ColorIsw" (optional.Interface of []string) - 
     * @param "ColorN" (optional.Interface of []string) - 
     * @param "ColorNic" (optional.Interface of []string) - 
     * @param "ColorNie" (optional.Interface of []string) - 
     * @param "ColorNiew" (optional.Interface of []string) - 
     * @param "ColorNire" (optional.Interface of []string) - 
     * @param "ColorNisw" (optional.Interface of []string) - 
     * @param "ColorNre" (optional.Interface of []string) - 
     * @param "ColorRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Device" (optional.Interface of []string) -  Device (name)
     * @param "DeviceId" (optional.Interface of []string) -  Device (ID)
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Length" (optional.Interface of []int32) - 
     * @param "LengthGt" (optional.Interface of []int32) - 
     * @param "LengthGte" (optional.Interface of []int32) - 
     * @param "LengthIsnull" (optional.Bool) - 
     * @param "LengthLt" (optional.Interface of []int32) - 
     * @param "LengthLte" (optional.Interface of []int32) - 
     * @param "LengthN" (optional.Interface of []int32) - 
     * @param "LengthUnit" (optional.Interface of []string) - 
     * @param "LengthUnitIc" (optional.Interface of []string) - 
     * @param "LengthUnitIe" (optional.Interface of []string) - 
     * @param "LengthUnitIew" (optional.Interface of []string) - 
     * @param "LengthUnitIre" (optional.Interface of []string) - 
     * @param "LengthUnitIsw" (optional.Interface of []string) - 
     * @param "LengthUnitN" (optional.Interface of []string) - 
     * @param "LengthUnitNic" (optional.Interface of []string) - 
     * @param "LengthUnitNie" (optional.Interface of []string) - 
     * @param "LengthUnitNiew" (optional.Interface of []string) - 
     * @param "LengthUnitNire" (optional.Interface of []string) - 
     * @param "LengthUnitNisw" (optional.Interface of []string) - 
     * @param "LengthUnitNre" (optional.Interface of []string) - 
     * @param "LengthUnitRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) -  Location (name)
     * @param "LocationId" (optional.Interface of []string) -  Location (ID)
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Rack" (optional.Interface of []string) -  Rack (name)
     * @param "RackId" (optional.Interface of []string) -  Rack (ID)
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Tenant" (optional.Interface of []string) -  Tenant (name)
     * @param "TenantId" (optional.Interface of []string) -  Tenant (ID)
     * @param "TerminationAId" (optional.Interface of []string) - 
     * @param "TerminationAIdIc" (optional.Interface of []string) - 
     * @param "TerminationAIdIe" (optional.Interface of []string) - 
     * @param "TerminationAIdIew" (optional.Interface of []string) - 
     * @param "TerminationAIdIre" (optional.Interface of []string) - 
     * @param "TerminationAIdIsw" (optional.Interface of []string) - 
     * @param "TerminationAIdN" (optional.Interface of []string) - 
     * @param "TerminationAIdNic" (optional.Interface of []string) - 
     * @param "TerminationAIdNie" (optional.Interface of []string) - 
     * @param "TerminationAIdNiew" (optional.Interface of []string) - 
     * @param "TerminationAIdNire" (optional.Interface of []string) - 
     * @param "TerminationAIdNisw" (optional.Interface of []string) - 
     * @param "TerminationAIdNre" (optional.Interface of []string) - 
     * @param "TerminationAIdRe" (optional.Interface of []string) - 
     * @param "TerminationAType" (optional.Interface of []int32) - 
     * @param "TerminationATypeN" (optional.Interface of []int32) - 
     * @param "TerminationBId" (optional.Interface of []string) - 
     * @param "TerminationBIdIc" (optional.Interface of []string) - 
     * @param "TerminationBIdIe" (optional.Interface of []string) - 
     * @param "TerminationBIdIew" (optional.Interface of []string) - 
     * @param "TerminationBIdIre" (optional.Interface of []string) - 
     * @param "TerminationBIdIsw" (optional.Interface of []string) - 
     * @param "TerminationBIdN" (optional.Interface of []string) - 
     * @param "TerminationBIdNic" (optional.Interface of []string) - 
     * @param "TerminationBIdNie" (optional.Interface of []string) - 
     * @param "TerminationBIdNiew" (optional.Interface of []string) - 
     * @param "TerminationBIdNire" (optional.Interface of []string) - 
     * @param "TerminationBIdNisw" (optional.Interface of []string) - 
     * @param "TerminationBIdNre" (optional.Interface of []string) - 
     * @param "TerminationBIdRe" (optional.Interface of []string) - 
     * @param "TerminationBType" (optional.Interface of []int32) - 
     * @param "TerminationBTypeN" (optional.Interface of []int32) - 
     * @param "TerminationType" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCableList
*/

type DcimApiDcimCablesListOpts struct {
    Color optional.Interface
    ColorIc optional.Interface
    ColorIe optional.Interface
    ColorIew optional.Interface
    ColorIre optional.Interface
    ColorIsw optional.Interface
    ColorN optional.Interface
    ColorNic optional.Interface
    ColorNie optional.Interface
    ColorNiew optional.Interface
    ColorNire optional.Interface
    ColorNisw optional.Interface
    ColorNre optional.Interface
    ColorRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Device optional.Interface
    DeviceId optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Length optional.Interface
    LengthGt optional.Interface
    LengthGte optional.Interface
    LengthIsnull optional.Bool
    LengthLt optional.Interface
    LengthLte optional.Interface
    LengthN optional.Interface
    LengthUnit optional.Interface
    LengthUnitIc optional.Interface
    LengthUnitIe optional.Interface
    LengthUnitIew optional.Interface
    LengthUnitIre optional.Interface
    LengthUnitIsw optional.Interface
    LengthUnitN optional.Interface
    LengthUnitNic optional.Interface
    LengthUnitNie optional.Interface
    LengthUnitNiew optional.Interface
    LengthUnitNire optional.Interface
    LengthUnitNisw optional.Interface
    LengthUnitNre optional.Interface
    LengthUnitRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationId optional.Interface
    Offset optional.Int32
    Q optional.String
    Rack optional.Interface
    RackId optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Tenant optional.Interface
    TenantId optional.Interface
    TerminationAId optional.Interface
    TerminationAIdIc optional.Interface
    TerminationAIdIe optional.Interface
    TerminationAIdIew optional.Interface
    TerminationAIdIre optional.Interface
    TerminationAIdIsw optional.Interface
    TerminationAIdN optional.Interface
    TerminationAIdNic optional.Interface
    TerminationAIdNie optional.Interface
    TerminationAIdNiew optional.Interface
    TerminationAIdNire optional.Interface
    TerminationAIdNisw optional.Interface
    TerminationAIdNre optional.Interface
    TerminationAIdRe optional.Interface
    TerminationAType optional.Interface
    TerminationATypeN optional.Interface
    TerminationBId optional.Interface
    TerminationBIdIc optional.Interface
    TerminationBIdIe optional.Interface
    TerminationBIdIew optional.Interface
    TerminationBIdIre optional.Interface
    TerminationBIdIsw optional.Interface
    TerminationBIdN optional.Interface
    TerminationBIdNic optional.Interface
    TerminationBIdNie optional.Interface
    TerminationBIdNiew optional.Interface
    TerminationBIdNire optional.Interface
    TerminationBIdNisw optional.Interface
    TerminationBIdNre optional.Interface
    TerminationBIdRe optional.Interface
    TerminationBType optional.Interface
    TerminationBTypeN optional.Interface
    TerminationType optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimCablesList(ctx context.Context, localVarOptionals *DcimApiDcimCablesListOpts) (PaginatedCableList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCableList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Color.IsSet() {
		localVarQueryParams.Add("color", parameterToString(localVarOptionals.Color.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIc.IsSet() {
		localVarQueryParams.Add("color__ic", parameterToString(localVarOptionals.ColorIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIe.IsSet() {
		localVarQueryParams.Add("color__ie", parameterToString(localVarOptionals.ColorIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIew.IsSet() {
		localVarQueryParams.Add("color__iew", parameterToString(localVarOptionals.ColorIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIre.IsSet() {
		localVarQueryParams.Add("color__ire", parameterToString(localVarOptionals.ColorIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIsw.IsSet() {
		localVarQueryParams.Add("color__isw", parameterToString(localVarOptionals.ColorIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorN.IsSet() {
		localVarQueryParams.Add("color__n", parameterToString(localVarOptionals.ColorN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNic.IsSet() {
		localVarQueryParams.Add("color__nic", parameterToString(localVarOptionals.ColorNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNie.IsSet() {
		localVarQueryParams.Add("color__nie", parameterToString(localVarOptionals.ColorNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNiew.IsSet() {
		localVarQueryParams.Add("color__niew", parameterToString(localVarOptionals.ColorNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNire.IsSet() {
		localVarQueryParams.Add("color__nire", parameterToString(localVarOptionals.ColorNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNisw.IsSet() {
		localVarQueryParams.Add("color__nisw", parameterToString(localVarOptionals.ColorNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNre.IsSet() {
		localVarQueryParams.Add("color__nre", parameterToString(localVarOptionals.ColorNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ColorRe.IsSet() {
		localVarQueryParams.Add("color__re", parameterToString(localVarOptionals.ColorRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Length.IsSet() {
		localVarQueryParams.Add("length", parameterToString(localVarOptionals.Length.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthGt.IsSet() {
		localVarQueryParams.Add("length__gt", parameterToString(localVarOptionals.LengthGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthGte.IsSet() {
		localVarQueryParams.Add("length__gte", parameterToString(localVarOptionals.LengthGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthIsnull.IsSet() {
		localVarQueryParams.Add("length__isnull", parameterToString(localVarOptionals.LengthIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LengthLt.IsSet() {
		localVarQueryParams.Add("length__lt", parameterToString(localVarOptionals.LengthLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthLte.IsSet() {
		localVarQueryParams.Add("length__lte", parameterToString(localVarOptionals.LengthLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthN.IsSet() {
		localVarQueryParams.Add("length__n", parameterToString(localVarOptionals.LengthN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnit.IsSet() {
		localVarQueryParams.Add("length_unit", parameterToString(localVarOptionals.LengthUnit.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitIc.IsSet() {
		localVarQueryParams.Add("length_unit__ic", parameterToString(localVarOptionals.LengthUnitIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitIe.IsSet() {
		localVarQueryParams.Add("length_unit__ie", parameterToString(localVarOptionals.LengthUnitIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitIew.IsSet() {
		localVarQueryParams.Add("length_unit__iew", parameterToString(localVarOptionals.LengthUnitIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitIre.IsSet() {
		localVarQueryParams.Add("length_unit__ire", parameterToString(localVarOptionals.LengthUnitIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitIsw.IsSet() {
		localVarQueryParams.Add("length_unit__isw", parameterToString(localVarOptionals.LengthUnitIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitN.IsSet() {
		localVarQueryParams.Add("length_unit__n", parameterToString(localVarOptionals.LengthUnitN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitNic.IsSet() {
		localVarQueryParams.Add("length_unit__nic", parameterToString(localVarOptionals.LengthUnitNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitNie.IsSet() {
		localVarQueryParams.Add("length_unit__nie", parameterToString(localVarOptionals.LengthUnitNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitNiew.IsSet() {
		localVarQueryParams.Add("length_unit__niew", parameterToString(localVarOptionals.LengthUnitNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitNire.IsSet() {
		localVarQueryParams.Add("length_unit__nire", parameterToString(localVarOptionals.LengthUnitNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitNisw.IsSet() {
		localVarQueryParams.Add("length_unit__nisw", parameterToString(localVarOptionals.LengthUnitNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitNre.IsSet() {
		localVarQueryParams.Add("length_unit__nre", parameterToString(localVarOptionals.LengthUnitNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LengthUnitRe.IsSet() {
		localVarQueryParams.Add("length_unit__re", parameterToString(localVarOptionals.LengthUnitRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationId.IsSet() {
		localVarQueryParams.Add("location_id", parameterToString(localVarOptionals.LocationId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Rack.IsSet() {
		localVarQueryParams.Add("rack", parameterToString(localVarOptionals.Rack.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackId.IsSet() {
		localVarQueryParams.Add("rack_id", parameterToString(localVarOptionals.RackId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAId.IsSet() {
		localVarQueryParams.Add("termination_a_id", parameterToString(localVarOptionals.TerminationAId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdIc.IsSet() {
		localVarQueryParams.Add("termination_a_id__ic", parameterToString(localVarOptionals.TerminationAIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdIe.IsSet() {
		localVarQueryParams.Add("termination_a_id__ie", parameterToString(localVarOptionals.TerminationAIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdIew.IsSet() {
		localVarQueryParams.Add("termination_a_id__iew", parameterToString(localVarOptionals.TerminationAIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdIre.IsSet() {
		localVarQueryParams.Add("termination_a_id__ire", parameterToString(localVarOptionals.TerminationAIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdIsw.IsSet() {
		localVarQueryParams.Add("termination_a_id__isw", parameterToString(localVarOptionals.TerminationAIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdN.IsSet() {
		localVarQueryParams.Add("termination_a_id__n", parameterToString(localVarOptionals.TerminationAIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdNic.IsSet() {
		localVarQueryParams.Add("termination_a_id__nic", parameterToString(localVarOptionals.TerminationAIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdNie.IsSet() {
		localVarQueryParams.Add("termination_a_id__nie", parameterToString(localVarOptionals.TerminationAIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdNiew.IsSet() {
		localVarQueryParams.Add("termination_a_id__niew", parameterToString(localVarOptionals.TerminationAIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdNire.IsSet() {
		localVarQueryParams.Add("termination_a_id__nire", parameterToString(localVarOptionals.TerminationAIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdNisw.IsSet() {
		localVarQueryParams.Add("termination_a_id__nisw", parameterToString(localVarOptionals.TerminationAIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdNre.IsSet() {
		localVarQueryParams.Add("termination_a_id__nre", parameterToString(localVarOptionals.TerminationAIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAIdRe.IsSet() {
		localVarQueryParams.Add("termination_a_id__re", parameterToString(localVarOptionals.TerminationAIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationAType.IsSet() {
		localVarQueryParams.Add("termination_a_type", parameterToString(localVarOptionals.TerminationAType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationATypeN.IsSet() {
		localVarQueryParams.Add("termination_a_type__n", parameterToString(localVarOptionals.TerminationATypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBId.IsSet() {
		localVarQueryParams.Add("termination_b_id", parameterToString(localVarOptionals.TerminationBId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdIc.IsSet() {
		localVarQueryParams.Add("termination_b_id__ic", parameterToString(localVarOptionals.TerminationBIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdIe.IsSet() {
		localVarQueryParams.Add("termination_b_id__ie", parameterToString(localVarOptionals.TerminationBIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdIew.IsSet() {
		localVarQueryParams.Add("termination_b_id__iew", parameterToString(localVarOptionals.TerminationBIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdIre.IsSet() {
		localVarQueryParams.Add("termination_b_id__ire", parameterToString(localVarOptionals.TerminationBIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdIsw.IsSet() {
		localVarQueryParams.Add("termination_b_id__isw", parameterToString(localVarOptionals.TerminationBIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdN.IsSet() {
		localVarQueryParams.Add("termination_b_id__n", parameterToString(localVarOptionals.TerminationBIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdNic.IsSet() {
		localVarQueryParams.Add("termination_b_id__nic", parameterToString(localVarOptionals.TerminationBIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdNie.IsSet() {
		localVarQueryParams.Add("termination_b_id__nie", parameterToString(localVarOptionals.TerminationBIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdNiew.IsSet() {
		localVarQueryParams.Add("termination_b_id__niew", parameterToString(localVarOptionals.TerminationBIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdNire.IsSet() {
		localVarQueryParams.Add("termination_b_id__nire", parameterToString(localVarOptionals.TerminationBIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdNisw.IsSet() {
		localVarQueryParams.Add("termination_b_id__nisw", parameterToString(localVarOptionals.TerminationBIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdNre.IsSet() {
		localVarQueryParams.Add("termination_b_id__nre", parameterToString(localVarOptionals.TerminationBIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBIdRe.IsSet() {
		localVarQueryParams.Add("termination_b_id__re", parameterToString(localVarOptionals.TerminationBIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBType.IsSet() {
		localVarQueryParams.Add("termination_b_type", parameterToString(localVarOptionals.TerminationBType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationBTypeN.IsSet() {
		localVarQueryParams.Add("termination_b_type__n", parameterToString(localVarOptionals.TerminationBTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TerminationType.IsSet() {
		localVarQueryParams.Add("termination_type", parameterToString(localVarOptionals.TerminationType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCableList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this cable.
 * @param optional nil or *DcimApiDcimCablesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimCablesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimCablesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimCablesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this cable.
 * @param optional nil or *DcimApiDcimCablesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimCablesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimCablesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimCablesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a cable object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this cable.
 * @param optional nil or *DcimApiDcimCablesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableCableRequest) - 
     * @param "Format" (optional.String) - 
@return Cable
*/

type DcimApiDcimCablesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimCablesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimCablesPartialUpdateOpts) (Cable, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Cable
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Cable
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a cable object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this cable.
 * @param optional nil or *DcimApiDcimCablesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Cable
*/

type DcimApiDcimCablesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimCablesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimCablesRetrieveOpts) (Cable, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Cable
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Cable
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a cable object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this cable.
 * @param optional nil or *DcimApiDcimCablesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Cable
*/

type DcimApiDcimCablesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimCablesUpdate(ctx context.Context, body WritableCableRequest, id string, localVarOptionals *DcimApiDcimCablesUpdateOpts) (Cable, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Cable
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/cables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Cable
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * &#x60;peer_device&#x60;: The name of the peer device * &#x60;peer_interface&#x60;: The name of the peer interface
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param peerDevice The name of the peer device
 * @param peerInterface The name of the peer interface
 * @param optional nil or *DcimApiDcimConnectedDeviceListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return []Device
*/

type DcimApiDcimConnectedDeviceListOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimConnectedDeviceList(ctx context.Context, peerDevice string, peerInterface string, localVarOptionals *DcimApiDcimConnectedDeviceListOpts) ([]Device, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Device
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/connected-device/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	localVarQueryParams.Add("peer_device", parameterToString(peerDevice, ""))
	localVarQueryParams.Add("peer_interface", parameterToString(peerInterface, ""))
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Device
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of console port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimConsoleConnectionsListOpts - Optional Parameters:
     * @param "Device" (optional.Interface of []string) -  Device (name)
     * @param "DeviceId" (optional.Interface of []string) -  Device (ID)
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.String) -  Location (name)
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedConsolePortList
*/

type DcimApiDcimConsoleConnectionsListOpts struct {
    Device optional.Interface
    DeviceId optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Location optional.String
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsoleConnectionsList(ctx context.Context, localVarOptionals *DcimApiDcimConsoleConnectionsListOpts) (PaginatedConsolePortList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedConsolePortList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedConsolePortList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of console port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsolePortTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimConsolePortTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimConsolePortTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of console port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsolePortTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConsolePortTemplate
*/

type DcimApiDcimConsolePortTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableConsolePortTemplateRequest, localVarOptionals *DcimApiDcimConsolePortTemplatesBulkPartialUpdateOpts) ([]ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConsolePortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConsolePortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of console port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsolePortTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConsolePortTemplate
*/

type DcimApiDcimConsolePortTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortTemplatesBulkUpdate(ctx context.Context, body []BulkWritableConsolePortTemplateRequest, localVarOptionals *DcimApiDcimConsolePortTemplatesBulkUpdateOpts) ([]ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConsolePortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConsolePortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more console port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsolePortTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConsolePortTemplate
*/

type DcimApiDcimConsolePortTemplatesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortTemplatesCreate(ctx context.Context, body WritableConsolePortTemplateRequest, localVarOptionals *DcimApiDcimConsolePortTemplatesCreateOpts) (ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ConsolePortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a console port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port template.
 * @param optional nil or *DcimApiDcimConsolePortTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimConsolePortTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortTemplatesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of console port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimConsolePortTemplatesListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) -  Description
     * @param "DescriptionIc" (optional.Interface of []string) -  Description
     * @param "DescriptionIe" (optional.Interface of []string) -  Description
     * @param "DescriptionIew" (optional.Interface of []string) -  Description
     * @param "DescriptionIre" (optional.Interface of []string) -  Description
     * @param "DescriptionIsw" (optional.Interface of []string) -  Description
     * @param "DescriptionN" (optional.Interface of []string) -  Description
     * @param "DescriptionNic" (optional.Interface of []string) -  Description
     * @param "DescriptionNie" (optional.Interface of []string) -  Description
     * @param "DescriptionNiew" (optional.Interface of []string) -  Description
     * @param "DescriptionNire" (optional.Interface of []string) -  Description
     * @param "DescriptionNisw" (optional.Interface of []string) -  Description
     * @param "DescriptionNre" (optional.Interface of []string) -  Description
     * @param "DescriptionRe" (optional.Interface of []string) -  Description
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  ID
     * @param "IdIc" (optional.Interface of []string) -  ID
     * @param "IdIe" (optional.Interface of []string) -  ID
     * @param "IdIew" (optional.Interface of []string) -  ID
     * @param "IdIre" (optional.Interface of []string) -  ID
     * @param "IdIsw" (optional.Interface of []string) -  ID
     * @param "IdN" (optional.Interface of []string) -  ID
     * @param "IdNic" (optional.Interface of []string) -  ID
     * @param "IdNie" (optional.Interface of []string) -  ID
     * @param "IdNiew" (optional.Interface of []string) -  ID
     * @param "IdNire" (optional.Interface of []string) -  ID
     * @param "IdNisw" (optional.Interface of []string) -  ID
     * @param "IdNre" (optional.Interface of []string) -  ID
     * @param "IdRe" (optional.Interface of []string) -  ID
     * @param "Label" (optional.Interface of []string) -  Label
     * @param "LabelIc" (optional.Interface of []string) -  Label
     * @param "LabelIe" (optional.Interface of []string) -  Label
     * @param "LabelIew" (optional.Interface of []string) -  Label
     * @param "LabelIre" (optional.Interface of []string) -  Label
     * @param "LabelIsw" (optional.Interface of []string) -  Label
     * @param "LabelN" (optional.Interface of []string) -  Label
     * @param "LabelNic" (optional.Interface of []string) -  Label
     * @param "LabelNie" (optional.Interface of []string) -  Label
     * @param "LabelNiew" (optional.Interface of []string) -  Label
     * @param "LabelNire" (optional.Interface of []string) -  Label
     * @param "LabelNisw" (optional.Interface of []string) -  Label
     * @param "LabelNre" (optional.Interface of []string) -  Label
     * @param "LabelRe" (optional.Interface of []string) -  Label
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) -  Name
     * @param "NameIc" (optional.Interface of []string) -  Name
     * @param "NameIe" (optional.Interface of []string) -  Name
     * @param "NameIew" (optional.Interface of []string) -  Name
     * @param "NameIre" (optional.Interface of []string) -  Name
     * @param "NameIsw" (optional.Interface of []string) -  Name
     * @param "NameN" (optional.Interface of []string) -  Name
     * @param "NameNic" (optional.Interface of []string) -  Name
     * @param "NameNie" (optional.Interface of []string) -  Name
     * @param "NameNiew" (optional.Interface of []string) -  Name
     * @param "NameNire" (optional.Interface of []string) -  Name
     * @param "NameNisw" (optional.Interface of []string) -  Name
     * @param "NameNre" (optional.Interface of []string) -  Name
     * @param "NameRe" (optional.Interface of []string) -  Name
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedConsolePortTemplateList
*/

type DcimApiDcimConsolePortTemplatesListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsolePortTemplatesList(ctx context.Context, localVarOptionals *DcimApiDcimConsolePortTemplatesListOpts) (PaginatedConsolePortTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedConsolePortTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedConsolePortTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this console port template.
 * @param optional nil or *DcimApiDcimConsolePortTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimConsolePortTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimConsolePortTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port template.
 * @param optional nil or *DcimApiDcimConsolePortTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimConsolePortTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsolePortTemplatesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a console port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port template.
 * @param optional nil or *DcimApiDcimConsolePortTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableConsolePortTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return ConsolePortTemplate
*/

type DcimApiDcimConsolePortTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortTemplatesPartialUpdateOpts) (ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsolePortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a console port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port template.
 * @param optional nil or *DcimApiDcimConsolePortTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ConsolePortTemplate
*/

type DcimApiDcimConsolePortTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsolePortTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortTemplatesRetrieveOpts) (ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsolePortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a console port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this console port template.
 * @param optional nil or *DcimApiDcimConsolePortTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConsolePortTemplate
*/

type DcimApiDcimConsolePortTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortTemplatesUpdate(ctx context.Context, body WritableConsolePortTemplateRequest, id string, localVarOptionals *DcimApiDcimConsolePortTemplatesUpdateOpts) (ConsolePortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsolePortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of console port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsolePortsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimConsolePortsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimConsolePortsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of console port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsolePortsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConsolePort
*/

type DcimApiDcimConsolePortsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableConsolePortRequest, localVarOptionals *DcimApiDcimConsolePortsBulkPartialUpdateOpts) ([]ConsolePort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConsolePort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConsolePort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of console port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsolePortsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConsolePort
*/

type DcimApiDcimConsolePortsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortsBulkUpdate(ctx context.Context, body []BulkWritableConsolePortRequest, localVarOptionals *DcimApiDcimConsolePortsBulkUpdateOpts) ([]ConsolePort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConsolePort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConsolePort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more console port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsolePortsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConsolePort
*/

type DcimApiDcimConsolePortsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortsCreate(ctx context.Context, body WritableConsolePortRequest, localVarOptionals *DcimApiDcimConsolePortsCreateOpts) (ConsolePort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ConsolePort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a console port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port.
 * @param optional nil or *DcimApiDcimConsolePortsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimConsolePortsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of console port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimConsolePortsListOpts - Optional Parameters:
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "Connected" (optional.Bool) -  Connected status (bool)
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) - 
     * @param "DeviceN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) -  Physical port type
     * @param "TypeIc" (optional.Interface of []string) -  Physical port type
     * @param "TypeIe" (optional.Interface of []string) -  Physical port type
     * @param "TypeIew" (optional.Interface of []string) -  Physical port type
     * @param "TypeIre" (optional.Interface of []string) -  Physical port type
     * @param "TypeIsw" (optional.Interface of []string) -  Physical port type
     * @param "TypeN" (optional.Interface of []string) -  Physical port type
     * @param "TypeNic" (optional.Interface of []string) -  Physical port type
     * @param "TypeNie" (optional.Interface of []string) -  Physical port type
     * @param "TypeNiew" (optional.Interface of []string) -  Physical port type
     * @param "TypeNire" (optional.Interface of []string) -  Physical port type
     * @param "TypeNisw" (optional.Interface of []string) -  Physical port type
     * @param "TypeNre" (optional.Interface of []string) -  Physical port type
     * @param "TypeRe" (optional.Interface of []string) -  Physical port type
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedConsolePortList
*/

type DcimApiDcimConsolePortsListOpts struct {
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    Connected optional.Bool
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceN optional.Interface
    Format optional.String
    HasCable optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsolePortsList(ctx context.Context, localVarOptionals *DcimApiDcimConsolePortsListOpts) (PaginatedConsolePortList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedConsolePortList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Connected.IsSet() {
		localVarQueryParams.Add("connected", parameterToString(localVarOptionals.Connected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceN.IsSet() {
		localVarQueryParams.Add("device__n", parameterToString(localVarOptionals.DeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedConsolePortList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this console port.
 * @param optional nil or *DcimApiDcimConsolePortsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimConsolePortsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimConsolePortsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port.
 * @param optional nil or *DcimApiDcimConsolePortsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimConsolePortsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsolePortsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a console port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port.
 * @param optional nil or *DcimApiDcimConsolePortsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableConsolePortRequest) - 
     * @param "Format" (optional.String) - 
@return ConsolePort
*/

type DcimApiDcimConsolePortsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortsPartialUpdateOpts) (ConsolePort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsolePort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a console port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port.
 * @param optional nil or *DcimApiDcimConsolePortsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ConsolePort
*/

type DcimApiDcimConsolePortsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsolePortsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortsRetrieveOpts) (ConsolePort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsolePort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console port.
 * @param optional nil or *DcimApiDcimConsolePortsTraceRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ConsolePort
*/

type DcimApiDcimConsolePortsTraceRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsolePortsTraceRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsolePortsTraceRetrieveOpts) (ConsolePort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsolePort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a console port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this console port.
 * @param optional nil or *DcimApiDcimConsolePortsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConsolePort
*/

type DcimApiDcimConsolePortsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsolePortsUpdate(ctx context.Context, body WritableConsolePortRequest, id string, localVarOptionals *DcimApiDcimConsolePortsUpdateOpts) (ConsolePort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsolePort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsolePort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of console server port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimConsoleServerPortTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of console server port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConsoleServerPortTemplate
*/

type DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableConsoleServerPortTemplateRequest, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateOpts) ([]ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConsoleServerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConsoleServerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of console server port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConsoleServerPortTemplate
*/

type DcimApiDcimConsoleServerPortTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesBulkUpdate(ctx context.Context, body []BulkWritableConsoleServerPortTemplateRequest, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesBulkUpdateOpts) ([]ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConsoleServerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConsoleServerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more console server port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConsoleServerPortTemplate
*/

type DcimApiDcimConsoleServerPortTemplatesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesCreate(ctx context.Context, body WritableConsoleServerPortTemplateRequest, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesCreateOpts) (ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ConsoleServerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a console server port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port template.
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimConsoleServerPortTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of console server port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) -  Description
     * @param "DescriptionIc" (optional.Interface of []string) -  Description
     * @param "DescriptionIe" (optional.Interface of []string) -  Description
     * @param "DescriptionIew" (optional.Interface of []string) -  Description
     * @param "DescriptionIre" (optional.Interface of []string) -  Description
     * @param "DescriptionIsw" (optional.Interface of []string) -  Description
     * @param "DescriptionN" (optional.Interface of []string) -  Description
     * @param "DescriptionNic" (optional.Interface of []string) -  Description
     * @param "DescriptionNie" (optional.Interface of []string) -  Description
     * @param "DescriptionNiew" (optional.Interface of []string) -  Description
     * @param "DescriptionNire" (optional.Interface of []string) -  Description
     * @param "DescriptionNisw" (optional.Interface of []string) -  Description
     * @param "DescriptionNre" (optional.Interface of []string) -  Description
     * @param "DescriptionRe" (optional.Interface of []string) -  Description
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  ID
     * @param "IdIc" (optional.Interface of []string) -  ID
     * @param "IdIe" (optional.Interface of []string) -  ID
     * @param "IdIew" (optional.Interface of []string) -  ID
     * @param "IdIre" (optional.Interface of []string) -  ID
     * @param "IdIsw" (optional.Interface of []string) -  ID
     * @param "IdN" (optional.Interface of []string) -  ID
     * @param "IdNic" (optional.Interface of []string) -  ID
     * @param "IdNie" (optional.Interface of []string) -  ID
     * @param "IdNiew" (optional.Interface of []string) -  ID
     * @param "IdNire" (optional.Interface of []string) -  ID
     * @param "IdNisw" (optional.Interface of []string) -  ID
     * @param "IdNre" (optional.Interface of []string) -  ID
     * @param "IdRe" (optional.Interface of []string) -  ID
     * @param "Label" (optional.Interface of []string) -  Label
     * @param "LabelIc" (optional.Interface of []string) -  Label
     * @param "LabelIe" (optional.Interface of []string) -  Label
     * @param "LabelIew" (optional.Interface of []string) -  Label
     * @param "LabelIre" (optional.Interface of []string) -  Label
     * @param "LabelIsw" (optional.Interface of []string) -  Label
     * @param "LabelN" (optional.Interface of []string) -  Label
     * @param "LabelNic" (optional.Interface of []string) -  Label
     * @param "LabelNie" (optional.Interface of []string) -  Label
     * @param "LabelNiew" (optional.Interface of []string) -  Label
     * @param "LabelNire" (optional.Interface of []string) -  Label
     * @param "LabelNisw" (optional.Interface of []string) -  Label
     * @param "LabelNre" (optional.Interface of []string) -  Label
     * @param "LabelRe" (optional.Interface of []string) -  Label
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) -  Name
     * @param "NameIc" (optional.Interface of []string) -  Name
     * @param "NameIe" (optional.Interface of []string) -  Name
     * @param "NameIew" (optional.Interface of []string) -  Name
     * @param "NameIre" (optional.Interface of []string) -  Name
     * @param "NameIsw" (optional.Interface of []string) -  Name
     * @param "NameN" (optional.Interface of []string) -  Name
     * @param "NameNic" (optional.Interface of []string) -  Name
     * @param "NameNie" (optional.Interface of []string) -  Name
     * @param "NameNiew" (optional.Interface of []string) -  Name
     * @param "NameNire" (optional.Interface of []string) -  Name
     * @param "NameNisw" (optional.Interface of []string) -  Name
     * @param "NameNre" (optional.Interface of []string) -  Name
     * @param "NameRe" (optional.Interface of []string) -  Name
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedConsoleServerPortTemplateList
*/

type DcimApiDcimConsoleServerPortTemplatesListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesList(ctx context.Context, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesListOpts) (PaginatedConsoleServerPortTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedConsoleServerPortTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedConsoleServerPortTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this console server port template.
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimConsoleServerPortTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port template.
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimConsoleServerPortTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a console server port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port template.
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableConsoleServerPortTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return ConsoleServerPortTemplate
*/

type DcimApiDcimConsoleServerPortTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesPartialUpdateOpts) (ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsoleServerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a console server port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port template.
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ConsoleServerPortTemplate
*/

type DcimApiDcimConsoleServerPortTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesRetrieveOpts) (ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsoleServerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a console server port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this console server port template.
 * @param optional nil or *DcimApiDcimConsoleServerPortTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConsoleServerPortTemplate
*/

type DcimApiDcimConsoleServerPortTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortTemplatesUpdate(ctx context.Context, body WritableConsoleServerPortTemplateRequest, id string, localVarOptionals *DcimApiDcimConsoleServerPortTemplatesUpdateOpts) (ConsoleServerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsoleServerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of console server port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsoleServerPortsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimConsoleServerPortsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimConsoleServerPortsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of console server port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsoleServerPortsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConsoleServerPort
*/

type DcimApiDcimConsoleServerPortsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableConsoleServerPortRequest, localVarOptionals *DcimApiDcimConsoleServerPortsBulkPartialUpdateOpts) ([]ConsoleServerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConsoleServerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConsoleServerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of console server port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsoleServerPortsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ConsoleServerPort
*/

type DcimApiDcimConsoleServerPortsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortsBulkUpdate(ctx context.Context, body []BulkWritableConsoleServerPortRequest, localVarOptionals *DcimApiDcimConsoleServerPortsBulkUpdateOpts) ([]ConsoleServerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ConsoleServerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ConsoleServerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more console server port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimConsoleServerPortsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConsoleServerPort
*/

type DcimApiDcimConsoleServerPortsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortsCreate(ctx context.Context, body WritableConsoleServerPortRequest, localVarOptionals *DcimApiDcimConsoleServerPortsCreateOpts) (ConsoleServerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ConsoleServerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a console server port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port.
 * @param optional nil or *DcimApiDcimConsoleServerPortsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimConsoleServerPortsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of console server port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimConsoleServerPortsListOpts - Optional Parameters:
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "Connected" (optional.Bool) -  Connected status (bool)
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) - 
     * @param "DeviceN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) -  Physical port type
     * @param "TypeIc" (optional.Interface of []string) -  Physical port type
     * @param "TypeIe" (optional.Interface of []string) -  Physical port type
     * @param "TypeIew" (optional.Interface of []string) -  Physical port type
     * @param "TypeIre" (optional.Interface of []string) -  Physical port type
     * @param "TypeIsw" (optional.Interface of []string) -  Physical port type
     * @param "TypeN" (optional.Interface of []string) -  Physical port type
     * @param "TypeNic" (optional.Interface of []string) -  Physical port type
     * @param "TypeNie" (optional.Interface of []string) -  Physical port type
     * @param "TypeNiew" (optional.Interface of []string) -  Physical port type
     * @param "TypeNire" (optional.Interface of []string) -  Physical port type
     * @param "TypeNisw" (optional.Interface of []string) -  Physical port type
     * @param "TypeNre" (optional.Interface of []string) -  Physical port type
     * @param "TypeRe" (optional.Interface of []string) -  Physical port type
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedConsoleServerPortList
*/

type DcimApiDcimConsoleServerPortsListOpts struct {
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    Connected optional.Bool
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceN optional.Interface
    Format optional.String
    HasCable optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsoleServerPortsList(ctx context.Context, localVarOptionals *DcimApiDcimConsoleServerPortsListOpts) (PaginatedConsoleServerPortList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedConsoleServerPortList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Connected.IsSet() {
		localVarQueryParams.Add("connected", parameterToString(localVarOptionals.Connected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceN.IsSet() {
		localVarQueryParams.Add("device__n", parameterToString(localVarOptionals.DeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedConsoleServerPortList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this console server port.
 * @param optional nil or *DcimApiDcimConsoleServerPortsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimConsoleServerPortsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimConsoleServerPortsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port.
 * @param optional nil or *DcimApiDcimConsoleServerPortsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimConsoleServerPortsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsoleServerPortsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a console server port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port.
 * @param optional nil or *DcimApiDcimConsoleServerPortsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableConsoleServerPortRequest) - 
     * @param "Format" (optional.String) - 
@return ConsoleServerPort
*/

type DcimApiDcimConsoleServerPortsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortsPartialUpdateOpts) (ConsoleServerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsoleServerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a console server port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port.
 * @param optional nil or *DcimApiDcimConsoleServerPortsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ConsoleServerPort
*/

type DcimApiDcimConsoleServerPortsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsoleServerPortsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortsRetrieveOpts) (ConsoleServerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsoleServerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this console server port.
 * @param optional nil or *DcimApiDcimConsoleServerPortsTraceRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ConsoleServerPort
*/

type DcimApiDcimConsoleServerPortsTraceRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimConsoleServerPortsTraceRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimConsoleServerPortsTraceRetrieveOpts) (ConsoleServerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsoleServerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a console server port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this console server port.
 * @param optional nil or *DcimApiDcimConsoleServerPortsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ConsoleServerPort
*/

type DcimApiDcimConsoleServerPortsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimConsoleServerPortsUpdate(ctx context.Context, body WritableConsoleServerPortRequest, id string, localVarOptionals *DcimApiDcimConsoleServerPortsUpdateOpts) (ConsoleServerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConsoleServerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/console-server-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ConsoleServerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of controller managed device group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimControllerManagedDeviceGroupsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of controller managed device group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ControllerManagedDeviceGroup
*/

type DcimApiDcimControllerManagedDeviceGroupsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableControllerManagedDeviceGroupRequest, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsBulkPartialUpdateOpts) ([]ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ControllerManagedDeviceGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ControllerManagedDeviceGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of controller managed device group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ControllerManagedDeviceGroup
*/

type DcimApiDcimControllerManagedDeviceGroupsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsBulkUpdate(ctx context.Context, body []BulkWritableControllerManagedDeviceGroupRequest, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsBulkUpdateOpts) ([]ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ControllerManagedDeviceGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ControllerManagedDeviceGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more controller managed device group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ControllerManagedDeviceGroup
*/

type DcimApiDcimControllerManagedDeviceGroupsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsCreate(ctx context.Context, body ControllerManagedDeviceGroupRequest, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsCreateOpts) (ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ControllerManagedDeviceGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ControllerManagedDeviceGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a controller managed device group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this controller managed device group.
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimControllerManagedDeviceGroupsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of controller managed device group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsListOpts - Optional Parameters:
     * @param "Controller" (optional.Interface of []string) - 
     * @param "ControllerN" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Parent" (optional.Interface of []string) - 
     * @param "ParentIsnull" (optional.Bool) - 
     * @param "ParentN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Subtree" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Weight" (optional.Interface of []int32) - 
     * @param "WeightGt" (optional.Interface of []int32) - 
     * @param "WeightGte" (optional.Interface of []int32) - 
     * @param "WeightLt" (optional.Interface of []int32) - 
     * @param "WeightLte" (optional.Interface of []int32) - 
     * @param "WeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedControllerManagedDeviceGroupList
*/

type DcimApiDcimControllerManagedDeviceGroupsListOpts struct {
    Controller optional.Interface
    ControllerN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Parent optional.Interface
    ParentIsnull optional.Bool
    ParentN optional.Interface
    Q optional.String
    Sort optional.String
    Subtree optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Weight optional.Interface
    WeightGt optional.Interface
    WeightGte optional.Interface
    WeightLt optional.Interface
    WeightLte optional.Interface
    WeightN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsList(ctx context.Context, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsListOpts) (PaginatedControllerManagedDeviceGroupList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedControllerManagedDeviceGroupList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Controller.IsSet() {
		localVarQueryParams.Add("controller", parameterToString(localVarOptionals.Controller.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerN.IsSet() {
		localVarQueryParams.Add("controller__n", parameterToString(localVarOptionals.ControllerN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parent.IsSet() {
		localVarQueryParams.Add("parent", parameterToString(localVarOptionals.Parent.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentIsnull.IsSet() {
		localVarQueryParams.Add("parent__isnull", parameterToString(localVarOptionals.ParentIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentN.IsSet() {
		localVarQueryParams.Add("parent__n", parameterToString(localVarOptionals.ParentN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subtree.IsSet() {
		localVarQueryParams.Add("subtree", parameterToString(localVarOptionals.Subtree.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Weight.IsSet() {
		localVarQueryParams.Add("weight", parameterToString(localVarOptionals.Weight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGt.IsSet() {
		localVarQueryParams.Add("weight__gt", parameterToString(localVarOptionals.WeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightGte.IsSet() {
		localVarQueryParams.Add("weight__gte", parameterToString(localVarOptionals.WeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLt.IsSet() {
		localVarQueryParams.Add("weight__lt", parameterToString(localVarOptionals.WeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightLte.IsSet() {
		localVarQueryParams.Add("weight__lte", parameterToString(localVarOptionals.WeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WeightN.IsSet() {
		localVarQueryParams.Add("weight__n", parameterToString(localVarOptionals.WeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedControllerManagedDeviceGroupList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this controller managed device group.
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimControllerManagedDeviceGroupsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this controller managed device group.
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimControllerManagedDeviceGroupsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a controller managed device group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this controller managed device group.
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedControllerManagedDeviceGroupRequest) - 
     * @param "Format" (optional.String) - 
@return ControllerManagedDeviceGroup
*/

type DcimApiDcimControllerManagedDeviceGroupsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsPartialUpdateOpts) (ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ControllerManagedDeviceGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ControllerManagedDeviceGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a controller managed device group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this controller managed device group.
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ControllerManagedDeviceGroup
*/

type DcimApiDcimControllerManagedDeviceGroupsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsRetrieveOpts) (ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ControllerManagedDeviceGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ControllerManagedDeviceGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a controller managed device group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this controller managed device group.
 * @param optional nil or *DcimApiDcimControllerManagedDeviceGroupsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ControllerManagedDeviceGroup
*/

type DcimApiDcimControllerManagedDeviceGroupsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllerManagedDeviceGroupsUpdate(ctx context.Context, body ControllerManagedDeviceGroupRequest, id string, localVarOptionals *DcimApiDcimControllerManagedDeviceGroupsUpdateOpts) (ControllerManagedDeviceGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ControllerManagedDeviceGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controller-managed-device-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ControllerManagedDeviceGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of controller objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimControllersBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimControllersBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllersBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimControllersBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of controller objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimControllersBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Controller
*/

type DcimApiDcimControllersBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllersBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableControllerRequest, localVarOptionals *DcimApiDcimControllersBulkPartialUpdateOpts) ([]Controller, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Controller
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Controller
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of controller objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimControllersBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Controller
*/

type DcimApiDcimControllersBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllersBulkUpdate(ctx context.Context, body []BulkWritableControllerRequest, localVarOptionals *DcimApiDcimControllersBulkUpdateOpts) ([]Controller, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Controller
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Controller
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more controller objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimControllersCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Controller
*/

type DcimApiDcimControllersCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllersCreate(ctx context.Context, body ControllerRequest, localVarOptionals *DcimApiDcimControllersCreateOpts) (Controller, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Controller
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Controller
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a controller object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this controller.
 * @param optional nil or *DcimApiDcimControllersDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimControllersDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllersDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimControllersDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of controller objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimControllersListOpts - Optional Parameters:
     * @param "ControllerDevice" (optional.Interface of []string) - 
     * @param "ControllerDeviceIsnull" (optional.Bool) - 
     * @param "ControllerDeviceN" (optional.Interface of []string) - 
     * @param "ControllerDeviceRedundancyGroup" (optional.Interface of []string) - 
     * @param "ControllerDeviceRedundancyGroupIsnull" (optional.Bool) - 
     * @param "ControllerDeviceRedundancyGroupN" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "ExternalIntegration" (optional.Interface of []string) - 
     * @param "ExternalIntegrationIsnull" (optional.Bool) - 
     * @param "ExternalIntegrationN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Platform" (optional.Interface of []string) - 
     * @param "PlatformIsnull" (optional.Bool) - 
     * @param "PlatformN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Role" (optional.Interface of []string) - 
     * @param "RoleIsnull" (optional.Bool) - 
     * @param "RoleN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Tenant" (optional.Interface of []string) - 
     * @param "TenantIsnull" (optional.Bool) - 
     * @param "TenantN" (optional.Interface of []string) - 
     * @param "TenantGroup" (optional.Interface of []string) - 
     * @param "TenantGroupIsnull" (optional.Bool) - 
     * @param "TenantGroupN" (optional.Interface of []string) - 
     * @param "TenantId" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "TenantIdIsnull" (optional.Bool) - 
     * @param "TenantIdN" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedControllerList
*/

type DcimApiDcimControllersListOpts struct {
    ControllerDevice optional.Interface
    ControllerDeviceIsnull optional.Bool
    ControllerDeviceN optional.Interface
    ControllerDeviceRedundancyGroup optional.Interface
    ControllerDeviceRedundancyGroupIsnull optional.Bool
    ControllerDeviceRedundancyGroupN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    ExternalIntegration optional.Interface
    ExternalIntegrationIsnull optional.Bool
    ExternalIntegrationN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Platform optional.Interface
    PlatformIsnull optional.Bool
    PlatformN optional.Interface
    Q optional.String
    Role optional.Interface
    RoleIsnull optional.Bool
    RoleN optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Tenant optional.Interface
    TenantIsnull optional.Bool
    TenantN optional.Interface
    TenantGroup optional.Interface
    TenantGroupIsnull optional.Bool
    TenantGroupN optional.Interface
    TenantId optional.Interface
    TenantIdIsnull optional.Bool
    TenantIdN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimControllersList(ctx context.Context, localVarOptionals *DcimApiDcimControllersListOpts) (PaginatedControllerList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedControllerList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ControllerDevice.IsSet() {
		localVarQueryParams.Add("controller_device", parameterToString(localVarOptionals.ControllerDevice.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerDeviceIsnull.IsSet() {
		localVarQueryParams.Add("controller_device__isnull", parameterToString(localVarOptionals.ControllerDeviceIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerDeviceN.IsSet() {
		localVarQueryParams.Add("controller_device__n", parameterToString(localVarOptionals.ControllerDeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerDeviceRedundancyGroup.IsSet() {
		localVarQueryParams.Add("controller_device_redundancy_group", parameterToString(localVarOptionals.ControllerDeviceRedundancyGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerDeviceRedundancyGroupIsnull.IsSet() {
		localVarQueryParams.Add("controller_device_redundancy_group__isnull", parameterToString(localVarOptionals.ControllerDeviceRedundancyGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerDeviceRedundancyGroupN.IsSet() {
		localVarQueryParams.Add("controller_device_redundancy_group__n", parameterToString(localVarOptionals.ControllerDeviceRedundancyGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExternalIntegration.IsSet() {
		localVarQueryParams.Add("external_integration", parameterToString(localVarOptionals.ExternalIntegration.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExternalIntegrationIsnull.IsSet() {
		localVarQueryParams.Add("external_integration__isnull", parameterToString(localVarOptionals.ExternalIntegrationIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExternalIntegrationN.IsSet() {
		localVarQueryParams.Add("external_integration__n", parameterToString(localVarOptionals.ExternalIntegrationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Platform.IsSet() {
		localVarQueryParams.Add("platform", parameterToString(localVarOptionals.Platform.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformIsnull.IsSet() {
		localVarQueryParams.Add("platform__isnull", parameterToString(localVarOptionals.PlatformIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformN.IsSet() {
		localVarQueryParams.Add("platform__n", parameterToString(localVarOptionals.PlatformN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Role.IsSet() {
		localVarQueryParams.Add("role", parameterToString(localVarOptionals.Role.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RoleIsnull.IsSet() {
		localVarQueryParams.Add("role__isnull", parameterToString(localVarOptionals.RoleIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoleN.IsSet() {
		localVarQueryParams.Add("role__n", parameterToString(localVarOptionals.RoleN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIsnull.IsSet() {
		localVarQueryParams.Add("tenant__isnull", parameterToString(localVarOptionals.TenantIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIsnull.IsSet() {
		localVarQueryParams.Add("tenant_group__isnull", parameterToString(localVarOptionals.TenantGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdIsnull.IsSet() {
		localVarQueryParams.Add("tenant_id__isnull", parameterToString(localVarOptionals.TenantIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdN.IsSet() {
		localVarQueryParams.Add("tenant_id__n", parameterToString(localVarOptionals.TenantIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedControllerList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this controller.
 * @param optional nil or *DcimApiDcimControllersNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimControllersNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllersNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimControllersNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this controller.
 * @param optional nil or *DcimApiDcimControllersNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimControllersNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimControllersNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimControllersNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a controller object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this controller.
 * @param optional nil or *DcimApiDcimControllersPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedControllerRequest) - 
     * @param "Format" (optional.String) - 
@return Controller
*/

type DcimApiDcimControllersPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimControllersPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimControllersPartialUpdateOpts) (Controller, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Controller
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Controller
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a controller object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this controller.
 * @param optional nil or *DcimApiDcimControllersRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Controller
*/

type DcimApiDcimControllersRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimControllersRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimControllersRetrieveOpts) (Controller, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Controller
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Controller
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a controller object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this controller.
 * @param optional nil or *DcimApiDcimControllersUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Controller
*/

type DcimApiDcimControllersUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimControllersUpdate(ctx context.Context, body ControllerRequest, id string, localVarOptionals *DcimApiDcimControllersUpdateOpts) (Controller, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Controller
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/controllers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Controller
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of device bay template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceBayTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBayTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimDeviceBayTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of device bay template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceBayTemplate
*/

type DcimApiDcimDeviceBayTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBayTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDeviceBayTemplateRequest, localVarOptionals *DcimApiDcimDeviceBayTemplatesBulkPartialUpdateOpts) ([]DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceBayTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceBayTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of device bay template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceBayTemplate
*/

type DcimApiDcimDeviceBayTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBayTemplatesBulkUpdate(ctx context.Context, body []BulkWritableDeviceBayTemplateRequest, localVarOptionals *DcimApiDcimDeviceBayTemplatesBulkUpdateOpts) ([]DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceBayTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceBayTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more device bay template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceBayTemplate
*/

type DcimApiDcimDeviceBayTemplatesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBayTemplatesCreate(ctx context.Context, body DeviceBayTemplateRequest, localVarOptionals *DcimApiDcimDeviceBayTemplatesCreateOpts) (DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceBayTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v DeviceBayTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a device bay template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device bay template.
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceBayTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBayTemplatesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceBayTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of device bay template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) -  Description
     * @param "DescriptionIc" (optional.Interface of []string) -  Description
     * @param "DescriptionIe" (optional.Interface of []string) -  Description
     * @param "DescriptionIew" (optional.Interface of []string) -  Description
     * @param "DescriptionIre" (optional.Interface of []string) -  Description
     * @param "DescriptionIsw" (optional.Interface of []string) -  Description
     * @param "DescriptionN" (optional.Interface of []string) -  Description
     * @param "DescriptionNic" (optional.Interface of []string) -  Description
     * @param "DescriptionNie" (optional.Interface of []string) -  Description
     * @param "DescriptionNiew" (optional.Interface of []string) -  Description
     * @param "DescriptionNire" (optional.Interface of []string) -  Description
     * @param "DescriptionNisw" (optional.Interface of []string) -  Description
     * @param "DescriptionNre" (optional.Interface of []string) -  Description
     * @param "DescriptionRe" (optional.Interface of []string) -  Description
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  ID
     * @param "IdIc" (optional.Interface of []string) -  ID
     * @param "IdIe" (optional.Interface of []string) -  ID
     * @param "IdIew" (optional.Interface of []string) -  ID
     * @param "IdIre" (optional.Interface of []string) -  ID
     * @param "IdIsw" (optional.Interface of []string) -  ID
     * @param "IdN" (optional.Interface of []string) -  ID
     * @param "IdNic" (optional.Interface of []string) -  ID
     * @param "IdNie" (optional.Interface of []string) -  ID
     * @param "IdNiew" (optional.Interface of []string) -  ID
     * @param "IdNire" (optional.Interface of []string) -  ID
     * @param "IdNisw" (optional.Interface of []string) -  ID
     * @param "IdNre" (optional.Interface of []string) -  ID
     * @param "IdRe" (optional.Interface of []string) -  ID
     * @param "Label" (optional.Interface of []string) -  Label
     * @param "LabelIc" (optional.Interface of []string) -  Label
     * @param "LabelIe" (optional.Interface of []string) -  Label
     * @param "LabelIew" (optional.Interface of []string) -  Label
     * @param "LabelIre" (optional.Interface of []string) -  Label
     * @param "LabelIsw" (optional.Interface of []string) -  Label
     * @param "LabelN" (optional.Interface of []string) -  Label
     * @param "LabelNic" (optional.Interface of []string) -  Label
     * @param "LabelNie" (optional.Interface of []string) -  Label
     * @param "LabelNiew" (optional.Interface of []string) -  Label
     * @param "LabelNire" (optional.Interface of []string) -  Label
     * @param "LabelNisw" (optional.Interface of []string) -  Label
     * @param "LabelNre" (optional.Interface of []string) -  Label
     * @param "LabelRe" (optional.Interface of []string) -  Label
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) -  Name
     * @param "NameIc" (optional.Interface of []string) -  Name
     * @param "NameIe" (optional.Interface of []string) -  Name
     * @param "NameIew" (optional.Interface of []string) -  Name
     * @param "NameIre" (optional.Interface of []string) -  Name
     * @param "NameIsw" (optional.Interface of []string) -  Name
     * @param "NameN" (optional.Interface of []string) -  Name
     * @param "NameNic" (optional.Interface of []string) -  Name
     * @param "NameNie" (optional.Interface of []string) -  Name
     * @param "NameNiew" (optional.Interface of []string) -  Name
     * @param "NameNire" (optional.Interface of []string) -  Name
     * @param "NameNisw" (optional.Interface of []string) -  Name
     * @param "NameNre" (optional.Interface of []string) -  Name
     * @param "NameRe" (optional.Interface of []string) -  Name
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDeviceBayTemplateList
*/

type DcimApiDcimDeviceBayTemplatesListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceBayTemplatesList(ctx context.Context, localVarOptionals *DcimApiDcimDeviceBayTemplatesListOpts) (PaginatedDeviceBayTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDeviceBayTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDeviceBayTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device bay template.
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimDeviceBayTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBayTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimDeviceBayTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device bay template.
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimDeviceBayTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceBayTemplatesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceBayTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a device bay template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device bay template.
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedDeviceBayTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return DeviceBayTemplate
*/

type DcimApiDcimDeviceBayTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBayTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceBayTemplatesPartialUpdateOpts) (DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceBayTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceBayTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a device bay template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device bay template.
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DeviceBayTemplate
*/

type DcimApiDcimDeviceBayTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceBayTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceBayTemplatesRetrieveOpts) (DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceBayTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceBayTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a device bay template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device bay template.
 * @param optional nil or *DcimApiDcimDeviceBayTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceBayTemplate
*/

type DcimApiDcimDeviceBayTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBayTemplatesUpdate(ctx context.Context, body DeviceBayTemplateRequest, id string, localVarOptionals *DcimApiDcimDeviceBayTemplatesUpdateOpts) (DeviceBayTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceBayTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bay-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceBayTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of device bay objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceBaysBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceBaysBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBaysBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimDeviceBaysBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of device bay objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceBaysBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceBay
*/

type DcimApiDcimDeviceBaysBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBaysBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDeviceBayRequest, localVarOptionals *DcimApiDcimDeviceBaysBulkPartialUpdateOpts) ([]DeviceBay, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceBay
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceBay
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of device bay objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceBaysBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceBay
*/

type DcimApiDcimDeviceBaysBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBaysBulkUpdate(ctx context.Context, body []BulkWritableDeviceBayRequest, localVarOptionals *DcimApiDcimDeviceBaysBulkUpdateOpts) ([]DeviceBay, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceBay
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceBay
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more device bay objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceBaysCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceBay
*/

type DcimApiDcimDeviceBaysCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBaysCreate(ctx context.Context, body DeviceBayRequest, localVarOptionals *DcimApiDcimDeviceBaysCreateOpts) (DeviceBay, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceBay
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v DeviceBay
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a device bay object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device bay.
 * @param optional nil or *DcimApiDcimDeviceBaysDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceBaysDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBaysDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceBaysDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of device bay objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimDeviceBaysListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) - 
     * @param "DeviceN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "InstalledDevice" (optional.Interface of []string) - 
     * @param "InstalledDeviceIsnull" (optional.Bool) - 
     * @param "InstalledDeviceN" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDeviceBayList
*/

type DcimApiDcimDeviceBaysListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    InstalledDevice optional.Interface
    InstalledDeviceIsnull optional.Bool
    InstalledDeviceN optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceBaysList(ctx context.Context, localVarOptionals *DcimApiDcimDeviceBaysListOpts) (PaginatedDeviceBayList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDeviceBayList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceN.IsSet() {
		localVarQueryParams.Add("device__n", parameterToString(localVarOptionals.DeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InstalledDevice.IsSet() {
		localVarQueryParams.Add("installed_device", parameterToString(localVarOptionals.InstalledDevice.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InstalledDeviceIsnull.IsSet() {
		localVarQueryParams.Add("installed_device__isnull", parameterToString(localVarOptionals.InstalledDeviceIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstalledDeviceN.IsSet() {
		localVarQueryParams.Add("installed_device__n", parameterToString(localVarOptionals.InstalledDeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDeviceBayList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device bay.
 * @param optional nil or *DcimApiDcimDeviceBaysNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimDeviceBaysNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBaysNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimDeviceBaysNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device bay.
 * @param optional nil or *DcimApiDcimDeviceBaysNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimDeviceBaysNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceBaysNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceBaysNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a device bay object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device bay.
 * @param optional nil or *DcimApiDcimDeviceBaysPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedDeviceBayRequest) - 
     * @param "Format" (optional.String) - 
@return DeviceBay
*/

type DcimApiDcimDeviceBaysPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBaysPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceBaysPartialUpdateOpts) (DeviceBay, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceBay
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceBay
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a device bay object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device bay.
 * @param optional nil or *DcimApiDcimDeviceBaysRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DeviceBay
*/

type DcimApiDcimDeviceBaysRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceBaysRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceBaysRetrieveOpts) (DeviceBay, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceBay
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceBay
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a device bay object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device bay.
 * @param optional nil or *DcimApiDcimDeviceBaysUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceBay
*/

type DcimApiDcimDeviceBaysUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceBaysUpdate(ctx context.Context, body DeviceBayRequest, id string, localVarOptionals *DcimApiDcimDeviceBaysUpdateOpts) (DeviceBay, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceBay
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-bays/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceBay
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of device family objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceFamiliesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceFamiliesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceFamiliesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimDeviceFamiliesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of device family objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceFamiliesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceFamily
*/

type DcimApiDcimDeviceFamiliesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceFamiliesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDeviceFamilyRequest, localVarOptionals *DcimApiDcimDeviceFamiliesBulkPartialUpdateOpts) ([]DeviceFamily, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceFamily
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceFamily
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of device family objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceFamiliesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceFamily
*/

type DcimApiDcimDeviceFamiliesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceFamiliesBulkUpdate(ctx context.Context, body []BulkWritableDeviceFamilyRequest, localVarOptionals *DcimApiDcimDeviceFamiliesBulkUpdateOpts) ([]DeviceFamily, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceFamily
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceFamily
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more device family objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceFamiliesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceFamily
*/

type DcimApiDcimDeviceFamiliesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceFamiliesCreate(ctx context.Context, body DeviceFamilyRequest, localVarOptionals *DcimApiDcimDeviceFamiliesCreateOpts) (DeviceFamily, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceFamily
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v DeviceFamily
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a device family object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device family.
 * @param optional nil or *DcimApiDcimDeviceFamiliesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceFamiliesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceFamiliesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceFamiliesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of device family objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimDeviceFamiliesListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "DeviceTypes" (optional.Interface of []string) - 
     * @param "DeviceTypesIsnull" (optional.Bool) - 
     * @param "DeviceTypesN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasDeviceTypes" (optional.Bool) -  Has device types
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDeviceFamilyList
*/

type DcimApiDcimDeviceFamiliesListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceTypes optional.Interface
    DeviceTypesIsnull optional.Bool
    DeviceTypesN optional.Interface
    Format optional.String
    HasDeviceTypes optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceFamiliesList(ctx context.Context, localVarOptionals *DcimApiDcimDeviceFamiliesListOpts) (PaginatedDeviceFamilyList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDeviceFamilyList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypes.IsSet() {
		localVarQueryParams.Add("device_types", parameterToString(localVarOptionals.DeviceTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypesIsnull.IsSet() {
		localVarQueryParams.Add("device_types__isnull", parameterToString(localVarOptionals.DeviceTypesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypesN.IsSet() {
		localVarQueryParams.Add("device_types__n", parameterToString(localVarOptionals.DeviceTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDeviceTypes.IsSet() {
		localVarQueryParams.Add("has_device_types", parameterToString(localVarOptionals.HasDeviceTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDeviceFamilyList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device family.
 * @param optional nil or *DcimApiDcimDeviceFamiliesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimDeviceFamiliesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceFamiliesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimDeviceFamiliesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device family.
 * @param optional nil or *DcimApiDcimDeviceFamiliesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimDeviceFamiliesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceFamiliesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceFamiliesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a device family object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device family.
 * @param optional nil or *DcimApiDcimDeviceFamiliesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedDeviceFamilyRequest) - 
     * @param "Format" (optional.String) - 
@return DeviceFamily
*/

type DcimApiDcimDeviceFamiliesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimDeviceFamiliesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceFamiliesPartialUpdateOpts) (DeviceFamily, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceFamily
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceFamily
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a device family object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device family.
 * @param optional nil or *DcimApiDcimDeviceFamiliesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DeviceFamily
*/

type DcimApiDcimDeviceFamiliesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceFamiliesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceFamiliesRetrieveOpts) (DeviceFamily, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceFamily
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceFamily
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a device family object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device family.
 * @param optional nil or *DcimApiDcimDeviceFamiliesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceFamily
*/

type DcimApiDcimDeviceFamiliesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceFamiliesUpdate(ctx context.Context, body DeviceFamilyRequest, id string, localVarOptionals *DcimApiDcimDeviceFamiliesUpdateOpts) (DeviceFamily, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceFamily
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-families/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceFamily
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of device redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceRedundancyGroupsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of device redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceRedundancyGroup
*/

type DcimApiDcimDeviceRedundancyGroupsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDeviceRedundancyGroupRequest, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsBulkPartialUpdateOpts) ([]DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of device redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceRedundancyGroup
*/

type DcimApiDcimDeviceRedundancyGroupsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsBulkUpdate(ctx context.Context, body []BulkWritableDeviceRedundancyGroupRequest, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsBulkUpdateOpts) ([]DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more device redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceRedundancyGroup
*/

type DcimApiDcimDeviceRedundancyGroupsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsCreate(ctx context.Context, body WritableDeviceRedundancyGroupRequest, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsCreateOpts) (DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v DeviceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a device redundancy group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device redundancy group.
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceRedundancyGroupsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of device redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "FailoverStrategy" (optional.Interface of []string) - 
     * @param "FailoverStrategyIc" (optional.Interface of []string) - 
     * @param "FailoverStrategyIe" (optional.Interface of []string) - 
     * @param "FailoverStrategyIew" (optional.Interface of []string) - 
     * @param "FailoverStrategyIre" (optional.Interface of []string) - 
     * @param "FailoverStrategyIsw" (optional.Interface of []string) - 
     * @param "FailoverStrategyN" (optional.Interface of []string) - 
     * @param "FailoverStrategyNic" (optional.Interface of []string) - 
     * @param "FailoverStrategyNie" (optional.Interface of []string) - 
     * @param "FailoverStrategyNiew" (optional.Interface of []string) - 
     * @param "FailoverStrategyNire" (optional.Interface of []string) - 
     * @param "FailoverStrategyNisw" (optional.Interface of []string) - 
     * @param "FailoverStrategyNre" (optional.Interface of []string) - 
     * @param "FailoverStrategyRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "SecretsGroup" (optional.Interface of []string) - 
     * @param "SecretsGroupIsnull" (optional.Bool) - 
     * @param "SecretsGroupN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDeviceRedundancyGroupList
*/

type DcimApiDcimDeviceRedundancyGroupsListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    FailoverStrategy optional.Interface
    FailoverStrategyIc optional.Interface
    FailoverStrategyIe optional.Interface
    FailoverStrategyIew optional.Interface
    FailoverStrategyIre optional.Interface
    FailoverStrategyIsw optional.Interface
    FailoverStrategyN optional.Interface
    FailoverStrategyNic optional.Interface
    FailoverStrategyNie optional.Interface
    FailoverStrategyNiew optional.Interface
    FailoverStrategyNire optional.Interface
    FailoverStrategyNisw optional.Interface
    FailoverStrategyNre optional.Interface
    FailoverStrategyRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    SecretsGroup optional.Interface
    SecretsGroupIsnull optional.Bool
    SecretsGroupN optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsList(ctx context.Context, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsListOpts) (PaginatedDeviceRedundancyGroupList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDeviceRedundancyGroupList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategy.IsSet() {
		localVarQueryParams.Add("failover_strategy", parameterToString(localVarOptionals.FailoverStrategy.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyIc.IsSet() {
		localVarQueryParams.Add("failover_strategy__ic", parameterToString(localVarOptionals.FailoverStrategyIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyIe.IsSet() {
		localVarQueryParams.Add("failover_strategy__ie", parameterToString(localVarOptionals.FailoverStrategyIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyIew.IsSet() {
		localVarQueryParams.Add("failover_strategy__iew", parameterToString(localVarOptionals.FailoverStrategyIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyIre.IsSet() {
		localVarQueryParams.Add("failover_strategy__ire", parameterToString(localVarOptionals.FailoverStrategyIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyIsw.IsSet() {
		localVarQueryParams.Add("failover_strategy__isw", parameterToString(localVarOptionals.FailoverStrategyIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyN.IsSet() {
		localVarQueryParams.Add("failover_strategy__n", parameterToString(localVarOptionals.FailoverStrategyN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyNic.IsSet() {
		localVarQueryParams.Add("failover_strategy__nic", parameterToString(localVarOptionals.FailoverStrategyNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyNie.IsSet() {
		localVarQueryParams.Add("failover_strategy__nie", parameterToString(localVarOptionals.FailoverStrategyNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyNiew.IsSet() {
		localVarQueryParams.Add("failover_strategy__niew", parameterToString(localVarOptionals.FailoverStrategyNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyNire.IsSet() {
		localVarQueryParams.Add("failover_strategy__nire", parameterToString(localVarOptionals.FailoverStrategyNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyNisw.IsSet() {
		localVarQueryParams.Add("failover_strategy__nisw", parameterToString(localVarOptionals.FailoverStrategyNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyNre.IsSet() {
		localVarQueryParams.Add("failover_strategy__nre", parameterToString(localVarOptionals.FailoverStrategyNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FailoverStrategyRe.IsSet() {
		localVarQueryParams.Add("failover_strategy__re", parameterToString(localVarOptionals.FailoverStrategyRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroup.IsSet() {
		localVarQueryParams.Add("secrets_group", parameterToString(localVarOptionals.SecretsGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupIsnull.IsSet() {
		localVarQueryParams.Add("secrets_group__isnull", parameterToString(localVarOptionals.SecretsGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupN.IsSet() {
		localVarQueryParams.Add("secrets_group__n", parameterToString(localVarOptionals.SecretsGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDeviceRedundancyGroupList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device redundancy group.
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimDeviceRedundancyGroupsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device redundancy group.
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimDeviceRedundancyGroupsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a device redundancy group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device redundancy group.
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableDeviceRedundancyGroupRequest) - 
     * @param "Format" (optional.String) - 
@return DeviceRedundancyGroup
*/

type DcimApiDcimDeviceRedundancyGroupsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsPartialUpdateOpts) (DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a device redundancy group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device redundancy group.
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DeviceRedundancyGroup
*/

type DcimApiDcimDeviceRedundancyGroupsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsRetrieveOpts) (DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a device redundancy group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device redundancy group.
 * @param optional nil or *DcimApiDcimDeviceRedundancyGroupsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceRedundancyGroup
*/

type DcimApiDcimDeviceRedundancyGroupsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceRedundancyGroupsUpdate(ctx context.Context, body WritableDeviceRedundancyGroupRequest, id string, localVarOptionals *DcimApiDcimDeviceRedundancyGroupsUpdateOpts) (DeviceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of device type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceTypesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceTypesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimDeviceTypesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of device type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceTypesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceType
*/

type DcimApiDcimDeviceTypesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDeviceTypeRequest, localVarOptionals *DcimApiDcimDeviceTypesBulkPartialUpdateOpts) ([]DeviceType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of device type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceTypesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceType
*/

type DcimApiDcimDeviceTypesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesBulkUpdate(ctx context.Context, body []BulkWritableDeviceTypeRequest, localVarOptionals *DcimApiDcimDeviceTypesBulkUpdateOpts) ([]DeviceType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more device type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceTypesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceType
*/

type DcimApiDcimDeviceTypesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesCreate(ctx context.Context, body WritableDeviceTypeRequest, localVarOptionals *DcimApiDcimDeviceTypesCreateOpts) (DeviceType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v DeviceType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a device type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device type.
 * @param optional nil or *DcimApiDcimDeviceTypesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceTypesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceTypesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of device type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimDeviceTypesListOpts - Optional Parameters:
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "ConsolePortTemplates" (optional.Interface of []string) - 
     * @param "ConsolePortTemplatesIsnull" (optional.Bool) - 
     * @param "ConsolePortTemplatesN" (optional.Interface of []string) - 
     * @param "ConsolePorts" (optional.Bool) -  Has console ports
     * @param "ConsoleServerPortTemplates" (optional.Interface of []string) - 
     * @param "ConsoleServerPortTemplatesIsnull" (optional.Bool) - 
     * @param "ConsoleServerPortTemplatesN" (optional.Interface of []string) - 
     * @param "ConsoleServerPorts" (optional.Bool) -  Has console server ports
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "DeviceBayTemplates" (optional.Interface of []string) - 
     * @param "DeviceBayTemplatesIsnull" (optional.Bool) - 
     * @param "DeviceBayTemplatesN" (optional.Interface of []string) - 
     * @param "DeviceBays" (optional.Bool) -  Has device bays
     * @param "DeviceFamily" (optional.Interface of []string) - 
     * @param "DeviceFamilyIsnull" (optional.Bool) - 
     * @param "DeviceFamilyN" (optional.Interface of []string) - 
     * @param "Devices" (optional.Interface of []string) - 
     * @param "DevicesIsnull" (optional.Bool) - 
     * @param "DevicesN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "FrontPortTemplates" (optional.Interface of []string) - 
     * @param "FrontPortTemplatesIsnull" (optional.Bool) - 
     * @param "FrontPortTemplatesN" (optional.Interface of []string) - 
     * @param "HasConsolePortTemplates" (optional.Bool) -  Has console port templates
     * @param "HasConsoleServerPortTemplates" (optional.Bool) -  Has console server port templates
     * @param "HasDeviceBayTemplates" (optional.Bool) -  Has device bay templates
     * @param "HasDevices" (optional.Bool) -  Has device instances
     * @param "HasFrontPortTemplates" (optional.Bool) -  Has front port templates
     * @param "HasInterfaceTemplates" (optional.Bool) -  Has interface templates
     * @param "HasPowerOutletTemplates" (optional.Bool) -  Has power outlet templates
     * @param "HasPowerPortTemplates" (optional.Bool) -  Has power port templates
     * @param "HasRearPortTemplates" (optional.Bool) -  Has rear port templates
     * @param "HasSoftwareImageFiles" (optional.Bool) -  Has software image files
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "InterfaceTemplates" (optional.Interface of []string) - 
     * @param "InterfaceTemplatesIsnull" (optional.Bool) - 
     * @param "InterfaceTemplatesN" (optional.Interface of []string) - 
     * @param "Interfaces" (optional.Bool) -  Has interfaces
     * @param "IsFullDepth" (optional.Bool) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Manufacturer" (optional.Interface of []string) - 
     * @param "ManufacturerN" (optional.Interface of []string) - 
     * @param "Model" (optional.Interface of []string) - 
     * @param "ModelIc" (optional.Interface of []string) - 
     * @param "ModelIe" (optional.Interface of []string) - 
     * @param "ModelIew" (optional.Interface of []string) - 
     * @param "ModelIre" (optional.Interface of []string) - 
     * @param "ModelIsw" (optional.Interface of []string) - 
     * @param "ModelN" (optional.Interface of []string) - 
     * @param "ModelNic" (optional.Interface of []string) - 
     * @param "ModelNie" (optional.Interface of []string) - 
     * @param "ModelNiew" (optional.Interface of []string) - 
     * @param "ModelNire" (optional.Interface of []string) - 
     * @param "ModelNisw" (optional.Interface of []string) - 
     * @param "ModelNre" (optional.Interface of []string) - 
     * @param "ModelRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PartNumber" (optional.Interface of []string) - 
     * @param "PartNumberIc" (optional.Interface of []string) - 
     * @param "PartNumberIe" (optional.Interface of []string) - 
     * @param "PartNumberIew" (optional.Interface of []string) - 
     * @param "PartNumberIre" (optional.Interface of []string) - 
     * @param "PartNumberIsw" (optional.Interface of []string) - 
     * @param "PartNumberN" (optional.Interface of []string) - 
     * @param "PartNumberNic" (optional.Interface of []string) - 
     * @param "PartNumberNie" (optional.Interface of []string) - 
     * @param "PartNumberNiew" (optional.Interface of []string) - 
     * @param "PartNumberNire" (optional.Interface of []string) - 
     * @param "PartNumberNisw" (optional.Interface of []string) - 
     * @param "PartNumberNre" (optional.Interface of []string) - 
     * @param "PartNumberRe" (optional.Interface of []string) - 
     * @param "PassThroughPorts" (optional.Bool) -  Has pass-through ports
     * @param "PowerOutletTemplates" (optional.Interface of []string) - 
     * @param "PowerOutletTemplatesIsnull" (optional.Bool) - 
     * @param "PowerOutletTemplatesN" (optional.Interface of []string) - 
     * @param "PowerOutlets" (optional.Bool) -  Has power outlets
     * @param "PowerPortTemplates" (optional.Interface of []string) - 
     * @param "PowerPortTemplatesIsnull" (optional.Bool) - 
     * @param "PowerPortTemplatesN" (optional.Interface of []string) - 
     * @param "PowerPorts" (optional.Bool) -  Has power ports
     * @param "Q" (optional.String) -  Search
     * @param "RearPortTemplates" (optional.Interface of []string) - 
     * @param "RearPortTemplatesIsnull" (optional.Bool) - 
     * @param "RearPortTemplatesN" (optional.Interface of []string) - 
     * @param "SoftwareImageFiles" (optional.Interface of []string) - 
     * @param "SoftwareImageFilesN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "SubdeviceRole" (optional.Interface of []string) -  Parent devices house child devices in device bays. Leave blank if this device type is neither a parent nor a child.
     * @param "SubdeviceRoleIc" (optional.Interface of []string) - 
     * @param "SubdeviceRoleIe" (optional.Interface of []string) - 
     * @param "SubdeviceRoleIew" (optional.Interface of []string) - 
     * @param "SubdeviceRoleIre" (optional.Interface of []string) - 
     * @param "SubdeviceRoleIsw" (optional.Interface of []string) - 
     * @param "SubdeviceRoleN" (optional.Interface of []string) -  Parent devices house child devices in device bays. Leave blank if this device type is neither a parent nor a child.
     * @param "SubdeviceRoleNic" (optional.Interface of []string) - 
     * @param "SubdeviceRoleNie" (optional.Interface of []string) - 
     * @param "SubdeviceRoleNiew" (optional.Interface of []string) - 
     * @param "SubdeviceRoleNire" (optional.Interface of []string) - 
     * @param "SubdeviceRoleNisw" (optional.Interface of []string) - 
     * @param "SubdeviceRoleNre" (optional.Interface of []string) - 
     * @param "SubdeviceRoleRe" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "UHeight" (optional.Interface of []int32) - 
     * @param "UHeightGt" (optional.Interface of []int32) - 
     * @param "UHeightGte" (optional.Interface of []int32) - 
     * @param "UHeightLt" (optional.Interface of []int32) - 
     * @param "UHeightLte" (optional.Interface of []int32) - 
     * @param "UHeightN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDeviceTypeList
*/

type DcimApiDcimDeviceTypesListOpts struct {
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    ConsolePortTemplates optional.Interface
    ConsolePortTemplatesIsnull optional.Bool
    ConsolePortTemplatesN optional.Interface
    ConsolePorts optional.Bool
    ConsoleServerPortTemplates optional.Interface
    ConsoleServerPortTemplatesIsnull optional.Bool
    ConsoleServerPortTemplatesN optional.Interface
    ConsoleServerPorts optional.Bool
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    DeviceBayTemplates optional.Interface
    DeviceBayTemplatesIsnull optional.Bool
    DeviceBayTemplatesN optional.Interface
    DeviceBays optional.Bool
    DeviceFamily optional.Interface
    DeviceFamilyIsnull optional.Bool
    DeviceFamilyN optional.Interface
    Devices optional.Interface
    DevicesIsnull optional.Bool
    DevicesN optional.Interface
    Format optional.String
    FrontPortTemplates optional.Interface
    FrontPortTemplatesIsnull optional.Bool
    FrontPortTemplatesN optional.Interface
    HasConsolePortTemplates optional.Bool
    HasConsoleServerPortTemplates optional.Bool
    HasDeviceBayTemplates optional.Bool
    HasDevices optional.Bool
    HasFrontPortTemplates optional.Bool
    HasInterfaceTemplates optional.Bool
    HasPowerOutletTemplates optional.Bool
    HasPowerPortTemplates optional.Bool
    HasRearPortTemplates optional.Bool
    HasSoftwareImageFiles optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    InterfaceTemplates optional.Interface
    InterfaceTemplatesIsnull optional.Bool
    InterfaceTemplatesN optional.Interface
    Interfaces optional.Bool
    IsFullDepth optional.Bool
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Manufacturer optional.Interface
    ManufacturerN optional.Interface
    Model optional.Interface
    ModelIc optional.Interface
    ModelIe optional.Interface
    ModelIew optional.Interface
    ModelIre optional.Interface
    ModelIsw optional.Interface
    ModelN optional.Interface
    ModelNic optional.Interface
    ModelNie optional.Interface
    ModelNiew optional.Interface
    ModelNire optional.Interface
    ModelNisw optional.Interface
    ModelNre optional.Interface
    ModelRe optional.Interface
    Offset optional.Int32
    PartNumber optional.Interface
    PartNumberIc optional.Interface
    PartNumberIe optional.Interface
    PartNumberIew optional.Interface
    PartNumberIre optional.Interface
    PartNumberIsw optional.Interface
    PartNumberN optional.Interface
    PartNumberNic optional.Interface
    PartNumberNie optional.Interface
    PartNumberNiew optional.Interface
    PartNumberNire optional.Interface
    PartNumberNisw optional.Interface
    PartNumberNre optional.Interface
    PartNumberRe optional.Interface
    PassThroughPorts optional.Bool
    PowerOutletTemplates optional.Interface
    PowerOutletTemplatesIsnull optional.Bool
    PowerOutletTemplatesN optional.Interface
    PowerOutlets optional.Bool
    PowerPortTemplates optional.Interface
    PowerPortTemplatesIsnull optional.Bool
    PowerPortTemplatesN optional.Interface
    PowerPorts optional.Bool
    Q optional.String
    RearPortTemplates optional.Interface
    RearPortTemplatesIsnull optional.Bool
    RearPortTemplatesN optional.Interface
    SoftwareImageFiles optional.Interface
    SoftwareImageFilesN optional.Interface
    Sort optional.String
    SubdeviceRole optional.Interface
    SubdeviceRoleIc optional.Interface
    SubdeviceRoleIe optional.Interface
    SubdeviceRoleIew optional.Interface
    SubdeviceRoleIre optional.Interface
    SubdeviceRoleIsw optional.Interface
    SubdeviceRoleN optional.Interface
    SubdeviceRoleNic optional.Interface
    SubdeviceRoleNie optional.Interface
    SubdeviceRoleNiew optional.Interface
    SubdeviceRoleNire optional.Interface
    SubdeviceRoleNisw optional.Interface
    SubdeviceRoleNre optional.Interface
    SubdeviceRoleRe optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    UHeight optional.Interface
    UHeightGt optional.Interface
    UHeightGte optional.Interface
    UHeightLt optional.Interface
    UHeightLte optional.Interface
    UHeightN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceTypesList(ctx context.Context, localVarOptionals *DcimApiDcimDeviceTypesListOpts) (PaginatedDeviceTypeList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDeviceTypeList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsolePortTemplates.IsSet() {
		localVarQueryParams.Add("console_port_templates", parameterToString(localVarOptionals.ConsolePortTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsolePortTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("console_port_templates__isnull", parameterToString(localVarOptionals.ConsolePortTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConsolePortTemplatesN.IsSet() {
		localVarQueryParams.Add("console_port_templates__n", parameterToString(localVarOptionals.ConsolePortTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsolePorts.IsSet() {
		localVarQueryParams.Add("console_ports", parameterToString(localVarOptionals.ConsolePorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConsoleServerPortTemplates.IsSet() {
		localVarQueryParams.Add("console_server_port_templates", parameterToString(localVarOptionals.ConsoleServerPortTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsoleServerPortTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("console_server_port_templates__isnull", parameterToString(localVarOptionals.ConsoleServerPortTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConsoleServerPortTemplatesN.IsSet() {
		localVarQueryParams.Add("console_server_port_templates__n", parameterToString(localVarOptionals.ConsoleServerPortTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsoleServerPorts.IsSet() {
		localVarQueryParams.Add("console_server_ports", parameterToString(localVarOptionals.ConsoleServerPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceBayTemplates.IsSet() {
		localVarQueryParams.Add("device_bay_templates", parameterToString(localVarOptionals.DeviceBayTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceBayTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("device_bay_templates__isnull", parameterToString(localVarOptionals.DeviceBayTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceBayTemplatesN.IsSet() {
		localVarQueryParams.Add("device_bay_templates__n", parameterToString(localVarOptionals.DeviceBayTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceBays.IsSet() {
		localVarQueryParams.Add("device_bays", parameterToString(localVarOptionals.DeviceBays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceFamily.IsSet() {
		localVarQueryParams.Add("device_family", parameterToString(localVarOptionals.DeviceFamily.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceFamilyIsnull.IsSet() {
		localVarQueryParams.Add("device_family__isnull", parameterToString(localVarOptionals.DeviceFamilyIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceFamilyN.IsSet() {
		localVarQueryParams.Add("device_family__n", parameterToString(localVarOptionals.DeviceFamilyN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarQueryParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesIsnull.IsSet() {
		localVarQueryParams.Add("devices__isnull", parameterToString(localVarOptionals.DevicesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesN.IsSet() {
		localVarQueryParams.Add("devices__n", parameterToString(localVarOptionals.DevicesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortTemplates.IsSet() {
		localVarQueryParams.Add("front_port_templates", parameterToString(localVarOptionals.FrontPortTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("front_port_templates__isnull", parameterToString(localVarOptionals.FrontPortTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortTemplatesN.IsSet() {
		localVarQueryParams.Add("front_port_templates__n", parameterToString(localVarOptionals.FrontPortTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HasConsolePortTemplates.IsSet() {
		localVarQueryParams.Add("has_console_port_templates", parameterToString(localVarOptionals.HasConsolePortTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasConsoleServerPortTemplates.IsSet() {
		localVarQueryParams.Add("has_console_server_port_templates", parameterToString(localVarOptionals.HasConsoleServerPortTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDeviceBayTemplates.IsSet() {
		localVarQueryParams.Add("has_device_bay_templates", parameterToString(localVarOptionals.HasDeviceBayTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDevices.IsSet() {
		localVarQueryParams.Add("has_devices", parameterToString(localVarOptionals.HasDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasFrontPortTemplates.IsSet() {
		localVarQueryParams.Add("has_front_port_templates", parameterToString(localVarOptionals.HasFrontPortTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasInterfaceTemplates.IsSet() {
		localVarQueryParams.Add("has_interface_templates", parameterToString(localVarOptionals.HasInterfaceTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerOutletTemplates.IsSet() {
		localVarQueryParams.Add("has_power_outlet_templates", parameterToString(localVarOptionals.HasPowerOutletTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerPortTemplates.IsSet() {
		localVarQueryParams.Add("has_power_port_templates", parameterToString(localVarOptionals.HasPowerPortTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRearPortTemplates.IsSet() {
		localVarQueryParams.Add("has_rear_port_templates", parameterToString(localVarOptionals.HasRearPortTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSoftwareImageFiles.IsSet() {
		localVarQueryParams.Add("has_software_image_files", parameterToString(localVarOptionals.HasSoftwareImageFiles.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceTemplates.IsSet() {
		localVarQueryParams.Add("interface_templates", parameterToString(localVarOptionals.InterfaceTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("interface_templates__isnull", parameterToString(localVarOptionals.InterfaceTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceTemplatesN.IsSet() {
		localVarQueryParams.Add("interface_templates__n", parameterToString(localVarOptionals.InterfaceTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Interfaces.IsSet() {
		localVarQueryParams.Add("interfaces", parameterToString(localVarOptionals.Interfaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsFullDepth.IsSet() {
		localVarQueryParams.Add("is_full_depth", parameterToString(localVarOptionals.IsFullDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarQueryParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ManufacturerN.IsSet() {
		localVarQueryParams.Add("manufacturer__n", parameterToString(localVarOptionals.ManufacturerN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Model.IsSet() {
		localVarQueryParams.Add("model", parameterToString(localVarOptionals.Model.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIc.IsSet() {
		localVarQueryParams.Add("model__ic", parameterToString(localVarOptionals.ModelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIe.IsSet() {
		localVarQueryParams.Add("model__ie", parameterToString(localVarOptionals.ModelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIew.IsSet() {
		localVarQueryParams.Add("model__iew", parameterToString(localVarOptionals.ModelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIre.IsSet() {
		localVarQueryParams.Add("model__ire", parameterToString(localVarOptionals.ModelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelIsw.IsSet() {
		localVarQueryParams.Add("model__isw", parameterToString(localVarOptionals.ModelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelN.IsSet() {
		localVarQueryParams.Add("model__n", parameterToString(localVarOptionals.ModelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNic.IsSet() {
		localVarQueryParams.Add("model__nic", parameterToString(localVarOptionals.ModelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNie.IsSet() {
		localVarQueryParams.Add("model__nie", parameterToString(localVarOptionals.ModelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNiew.IsSet() {
		localVarQueryParams.Add("model__niew", parameterToString(localVarOptionals.ModelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNire.IsSet() {
		localVarQueryParams.Add("model__nire", parameterToString(localVarOptionals.ModelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNisw.IsSet() {
		localVarQueryParams.Add("model__nisw", parameterToString(localVarOptionals.ModelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelNre.IsSet() {
		localVarQueryParams.Add("model__nre", parameterToString(localVarOptionals.ModelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModelRe.IsSet() {
		localVarQueryParams.Add("model__re", parameterToString(localVarOptionals.ModelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumber.IsSet() {
		localVarQueryParams.Add("part_number", parameterToString(localVarOptionals.PartNumber.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberIc.IsSet() {
		localVarQueryParams.Add("part_number__ic", parameterToString(localVarOptionals.PartNumberIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberIe.IsSet() {
		localVarQueryParams.Add("part_number__ie", parameterToString(localVarOptionals.PartNumberIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberIew.IsSet() {
		localVarQueryParams.Add("part_number__iew", parameterToString(localVarOptionals.PartNumberIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberIre.IsSet() {
		localVarQueryParams.Add("part_number__ire", parameterToString(localVarOptionals.PartNumberIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberIsw.IsSet() {
		localVarQueryParams.Add("part_number__isw", parameterToString(localVarOptionals.PartNumberIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberN.IsSet() {
		localVarQueryParams.Add("part_number__n", parameterToString(localVarOptionals.PartNumberN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberNic.IsSet() {
		localVarQueryParams.Add("part_number__nic", parameterToString(localVarOptionals.PartNumberNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberNie.IsSet() {
		localVarQueryParams.Add("part_number__nie", parameterToString(localVarOptionals.PartNumberNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberNiew.IsSet() {
		localVarQueryParams.Add("part_number__niew", parameterToString(localVarOptionals.PartNumberNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberNire.IsSet() {
		localVarQueryParams.Add("part_number__nire", parameterToString(localVarOptionals.PartNumberNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberNisw.IsSet() {
		localVarQueryParams.Add("part_number__nisw", parameterToString(localVarOptionals.PartNumberNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberNre.IsSet() {
		localVarQueryParams.Add("part_number__nre", parameterToString(localVarOptionals.PartNumberNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumberRe.IsSet() {
		localVarQueryParams.Add("part_number__re", parameterToString(localVarOptionals.PartNumberRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PassThroughPorts.IsSet() {
		localVarQueryParams.Add("pass_through_ports", parameterToString(localVarOptionals.PassThroughPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletTemplates.IsSet() {
		localVarQueryParams.Add("power_outlet_templates", parameterToString(localVarOptionals.PowerOutletTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("power_outlet_templates__isnull", parameterToString(localVarOptionals.PowerOutletTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletTemplatesN.IsSet() {
		localVarQueryParams.Add("power_outlet_templates__n", parameterToString(localVarOptionals.PowerOutletTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutlets.IsSet() {
		localVarQueryParams.Add("power_outlets", parameterToString(localVarOptionals.PowerOutlets.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortTemplates.IsSet() {
		localVarQueryParams.Add("power_port_templates", parameterToString(localVarOptionals.PowerPortTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("power_port_templates__isnull", parameterToString(localVarOptionals.PowerPortTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortTemplatesN.IsSet() {
		localVarQueryParams.Add("power_port_templates__n", parameterToString(localVarOptionals.PowerPortTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPorts.IsSet() {
		localVarQueryParams.Add("power_ports", parameterToString(localVarOptionals.PowerPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortTemplates.IsSet() {
		localVarQueryParams.Add("rear_port_templates", parameterToString(localVarOptionals.RearPortTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("rear_port_templates__isnull", parameterToString(localVarOptionals.RearPortTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortTemplatesN.IsSet() {
		localVarQueryParams.Add("rear_port_templates__n", parameterToString(localVarOptionals.RearPortTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFiles.IsSet() {
		localVarQueryParams.Add("software_image_files", parameterToString(localVarOptionals.SoftwareImageFiles.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFilesN.IsSet() {
		localVarQueryParams.Add("software_image_files__n", parameterToString(localVarOptionals.SoftwareImageFilesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRole.IsSet() {
		localVarQueryParams.Add("subdevice_role", parameterToString(localVarOptionals.SubdeviceRole.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleIc.IsSet() {
		localVarQueryParams.Add("subdevice_role__ic", parameterToString(localVarOptionals.SubdeviceRoleIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleIe.IsSet() {
		localVarQueryParams.Add("subdevice_role__ie", parameterToString(localVarOptionals.SubdeviceRoleIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleIew.IsSet() {
		localVarQueryParams.Add("subdevice_role__iew", parameterToString(localVarOptionals.SubdeviceRoleIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleIre.IsSet() {
		localVarQueryParams.Add("subdevice_role__ire", parameterToString(localVarOptionals.SubdeviceRoleIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleIsw.IsSet() {
		localVarQueryParams.Add("subdevice_role__isw", parameterToString(localVarOptionals.SubdeviceRoleIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleN.IsSet() {
		localVarQueryParams.Add("subdevice_role__n", parameterToString(localVarOptionals.SubdeviceRoleN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleNic.IsSet() {
		localVarQueryParams.Add("subdevice_role__nic", parameterToString(localVarOptionals.SubdeviceRoleNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleNie.IsSet() {
		localVarQueryParams.Add("subdevice_role__nie", parameterToString(localVarOptionals.SubdeviceRoleNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleNiew.IsSet() {
		localVarQueryParams.Add("subdevice_role__niew", parameterToString(localVarOptionals.SubdeviceRoleNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleNire.IsSet() {
		localVarQueryParams.Add("subdevice_role__nire", parameterToString(localVarOptionals.SubdeviceRoleNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleNisw.IsSet() {
		localVarQueryParams.Add("subdevice_role__nisw", parameterToString(localVarOptionals.SubdeviceRoleNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleNre.IsSet() {
		localVarQueryParams.Add("subdevice_role__nre", parameterToString(localVarOptionals.SubdeviceRoleNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SubdeviceRoleRe.IsSet() {
		localVarQueryParams.Add("subdevice_role__re", parameterToString(localVarOptionals.SubdeviceRoleRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeight.IsSet() {
		localVarQueryParams.Add("u_height", parameterToString(localVarOptionals.UHeight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightGt.IsSet() {
		localVarQueryParams.Add("u_height__gt", parameterToString(localVarOptionals.UHeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightGte.IsSet() {
		localVarQueryParams.Add("u_height__gte", parameterToString(localVarOptionals.UHeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightLt.IsSet() {
		localVarQueryParams.Add("u_height__lt", parameterToString(localVarOptionals.UHeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightLte.IsSet() {
		localVarQueryParams.Add("u_height__lte", parameterToString(localVarOptionals.UHeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightN.IsSet() {
		localVarQueryParams.Add("u_height__n", parameterToString(localVarOptionals.UHeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDeviceTypeList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device type.
 * @param optional nil or *DcimApiDcimDeviceTypesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimDeviceTypesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimDeviceTypesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device type.
 * @param optional nil or *DcimApiDcimDeviceTypesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimDeviceTypesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceTypesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceTypesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a device type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device type.
 * @param optional nil or *DcimApiDcimDeviceTypesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableDeviceTypeRequest) - 
     * @param "Format" (optional.String) - 
@return DeviceType
*/

type DcimApiDcimDeviceTypesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceTypesPartialUpdateOpts) (DeviceType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a device type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device type.
 * @param optional nil or *DcimApiDcimDeviceTypesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DeviceType
*/

type DcimApiDcimDeviceTypesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceTypesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceTypesRetrieveOpts) (DeviceType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of device type to software image file mapping objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of device type to software image file mapping objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceTypeToSoftwareImageFile
*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDeviceTypeToSoftwareImageFileRequest, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesBulkPartialUpdateOpts) ([]DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceTypeToSoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceTypeToSoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of device type to software image file mapping objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []DeviceTypeToSoftwareImageFile
*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesBulkUpdate(ctx context.Context, body []BulkWritableDeviceTypeToSoftwareImageFileRequest, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesBulkUpdateOpts) ([]DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DeviceTypeToSoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []DeviceTypeToSoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more device type to software image file mapping objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceTypeToSoftwareImageFile
*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesCreate(ctx context.Context, body DeviceTypeToSoftwareImageFileRequest, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesCreateOpts) (DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceTypeToSoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v DeviceTypeToSoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a device type to software image file mapping object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device type to software image file mapping.
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of device type to software image file mapping objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "SoftwareImageFile" (optional.Interface of []string) - 
     * @param "SoftwareImageFileN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDeviceTypeToSoftwareImageFileList
*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    SoftwareImageFile optional.Interface
    SoftwareImageFileN optional.Interface
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesList(ctx context.Context, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesListOpts) (PaginatedDeviceTypeToSoftwareImageFileList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDeviceTypeToSoftwareImageFileList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFile.IsSet() {
		localVarQueryParams.Add("software_image_file", parameterToString(localVarOptionals.SoftwareImageFile.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFileN.IsSet() {
		localVarQueryParams.Add("software_image_file__n", parameterToString(localVarOptionals.SoftwareImageFileN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDeviceTypeToSoftwareImageFileList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a device type to software image file mapping object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device type to software image file mapping.
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedDeviceTypeToSoftwareImageFileRequest) - 
     * @param "Format" (optional.String) - 
@return DeviceTypeToSoftwareImageFile
*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesPartialUpdateOpts) (DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceTypeToSoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceTypeToSoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a device type to software image file mapping object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device type to software image file mapping.
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DeviceTypeToSoftwareImageFile
*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesRetrieveOpts) (DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceTypeToSoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceTypeToSoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a device type to software image file mapping object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device type to software image file mapping.
 * @param optional nil or *DcimApiDcimDeviceTypesToSoftwareImageFilesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceTypeToSoftwareImageFile
*/

type DcimApiDcimDeviceTypesToSoftwareImageFilesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesToSoftwareImageFilesUpdate(ctx context.Context, body DeviceTypeToSoftwareImageFileRequest, id string, localVarOptionals *DcimApiDcimDeviceTypesToSoftwareImageFilesUpdateOpts) (DeviceTypeToSoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceTypeToSoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types-to-software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceTypeToSoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a device type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device type.
 * @param optional nil or *DcimApiDcimDeviceTypesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return DeviceType
*/

type DcimApiDcimDeviceTypesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDeviceTypesUpdate(ctx context.Context, body WritableDeviceTypeRequest, id string, localVarOptionals *DcimApiDcimDeviceTypesUpdateOpts) (DeviceType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/device-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of device objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDevicesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDevicesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDevicesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimDevicesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of device objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDevicesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Device
*/

type DcimApiDcimDevicesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDevicesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableDeviceRequest, localVarOptionals *DcimApiDcimDevicesBulkPartialUpdateOpts) ([]Device, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Device
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Device
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of device objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDevicesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Device
*/

type DcimApiDcimDevicesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDevicesBulkUpdate(ctx context.Context, body []BulkWritableDeviceRequest, localVarOptionals *DcimApiDcimDevicesBulkUpdateOpts) ([]Device, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Device
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Device
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more device objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimDevicesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Device
*/

type DcimApiDcimDevicesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDevicesCreate(ctx context.Context, body WritableDeviceRequest, localVarOptionals *DcimApiDcimDevicesCreateOpts) (Device, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Device
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Device
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a device object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device.
 * @param optional nil or *DcimApiDcimDevicesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimDevicesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDevicesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimDevicesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of device objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimDevicesListOpts - Optional Parameters:
     * @param "AssetTag" (optional.Interface of []string) - 
     * @param "AssetTagIc" (optional.Interface of []string) - 
     * @param "AssetTagIe" (optional.Interface of []string) - 
     * @param "AssetTagIew" (optional.Interface of []string) - 
     * @param "AssetTagIre" (optional.Interface of []string) - 
     * @param "AssetTagIsnull" (optional.Bool) - 
     * @param "AssetTagIsw" (optional.Interface of []string) - 
     * @param "AssetTagN" (optional.Interface of []string) - 
     * @param "AssetTagNic" (optional.Interface of []string) - 
     * @param "AssetTagNie" (optional.Interface of []string) - 
     * @param "AssetTagNiew" (optional.Interface of []string) - 
     * @param "AssetTagNire" (optional.Interface of []string) - 
     * @param "AssetTagNisw" (optional.Interface of []string) - 
     * @param "AssetTagNre" (optional.Interface of []string) - 
     * @param "AssetTagRe" (optional.Interface of []string) - 
     * @param "Cluster" (optional.Interface of []string) - 
     * @param "ClusterIsnull" (optional.Bool) - 
     * @param "ClusterN" (optional.Interface of []string) - 
     * @param "ConsolePorts" (optional.Interface of []string) -  Console Ports
     * @param "ConsolePortsIsnull" (optional.Bool) - 
     * @param "ConsolePortsN" (optional.Interface of []string) -  Console Ports
     * @param "ConsoleServerPorts" (optional.Interface of []string) -  Console Server Ports
     * @param "ConsoleServerPortsIsnull" (optional.Bool) - 
     * @param "ConsoleServerPortsN" (optional.Interface of []string) -  Console Server Ports
     * @param "ControllerManagedDeviceGroup" (optional.Interface of []string) - 
     * @param "ControllerManagedDeviceGroupIsnull" (optional.Bool) - 
     * @param "ControllerManagedDeviceGroupN" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "DeviceBays" (optional.Interface of []string) -  Device Bays
     * @param "DeviceBaysIsnull" (optional.Bool) - 
     * @param "DeviceBaysN" (optional.Interface of []string) -  Device Bays
     * @param "DeviceFamily" (optional.Interface of []string) - 
     * @param "DeviceFamilyIsnull" (optional.Bool) - 
     * @param "DeviceFamilyN" (optional.Interface of []string) - 
     * @param "DeviceRedundancyGroup" (optional.Interface of []string) - 
     * @param "DeviceRedundancyGroupIsnull" (optional.Bool) - 
     * @param "DeviceRedundancyGroupN" (optional.Interface of []string) - 
     * @param "DeviceRedundancyGroupPriority" (optional.Interface of []int32) - 
     * @param "DeviceRedundancyGroupPriorityGt" (optional.Interface of []int32) - 
     * @param "DeviceRedundancyGroupPriorityGte" (optional.Interface of []int32) - 
     * @param "DeviceRedundancyGroupPriorityIsnull" (optional.Bool) - 
     * @param "DeviceRedundancyGroupPriorityLt" (optional.Interface of []int32) - 
     * @param "DeviceRedundancyGroupPriorityLte" (optional.Interface of []int32) - 
     * @param "DeviceRedundancyGroupPriorityN" (optional.Interface of []int32) - 
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Face" (optional.Interface of []string) - 
     * @param "FaceIc" (optional.Interface of []string) - 
     * @param "FaceIe" (optional.Interface of []string) - 
     * @param "FaceIew" (optional.Interface of []string) - 
     * @param "FaceIre" (optional.Interface of []string) - 
     * @param "FaceIsw" (optional.Interface of []string) - 
     * @param "FaceN" (optional.Interface of []string) - 
     * @param "FaceNic" (optional.Interface of []string) - 
     * @param "FaceNie" (optional.Interface of []string) - 
     * @param "FaceNiew" (optional.Interface of []string) - 
     * @param "FaceNire" (optional.Interface of []string) - 
     * @param "FaceNisw" (optional.Interface of []string) - 
     * @param "FaceNre" (optional.Interface of []string) - 
     * @param "FaceRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "FrontPorts" (optional.Interface of []string) -  Front Port
     * @param "FrontPortsIsnull" (optional.Bool) - 
     * @param "FrontPortsN" (optional.Interface of []string) -  Front Port
     * @param "HasConsolePorts" (optional.Bool) -  Has console ports
     * @param "HasConsoleServerPorts" (optional.Bool) -  Has console server ports
     * @param "HasDeviceBays" (optional.Bool) -  Has device bays
     * @param "HasFrontPorts" (optional.Bool) -  Has front ports
     * @param "HasInterfaces" (optional.Bool) -  Has interfaces
     * @param "HasPowerOutlets" (optional.Bool) -  Has power outlets
     * @param "HasPowerPorts" (optional.Bool) -  Has power ports
     * @param "HasPrimaryIp" (optional.Bool) -  Has a primary IP
     * @param "HasRearPorts" (optional.Bool) -  Has rear ports
     * @param "HasSoftwareImageFiles" (optional.Bool) -  Has software image files
     * @param "HasSoftwareVersion" (optional.Bool) -  Has software version
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Interfaces" (optional.Interface of []string) - 
     * @param "InterfacesIsnull" (optional.Bool) - 
     * @param "InterfacesN" (optional.Interface of []string) - 
     * @param "IsFullDepth" (optional.Bool) -  Is full depth
     * @param "IsVirtualChassisMember" (optional.Bool) -  Is a virtual chassis member
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "LocalConfigContextData" (optional.Bool) -  Has local config context data
     * @param "LocalConfigContextSchema" (optional.Interface of []string) - 
     * @param "LocalConfigContextSchemaIsnull" (optional.Bool) - 
     * @param "LocalConfigContextSchemaN" (optional.Interface of []string) - 
     * @param "LocalConfigContextSchemaId" (optional.Interface of []string) -  Schema (ID) - Deprecated (use local_context_schema filter)
     * @param "LocalConfigContextSchemaIdIsnull" (optional.Bool) - 
     * @param "LocalConfigContextSchemaIdN" (optional.Interface of []string) -  Schema (ID) - Deprecated (use local_context_schema filter)
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "MacAddress" (optional.Interface of []string) -  MAC address
     * @param "MacAddressIc" (optional.Interface of []string) -  MAC address
     * @param "MacAddressIe" (optional.Interface of []string) -  MAC address
     * @param "MacAddressIew" (optional.Interface of []string) -  MAC address
     * @param "MacAddressIre" (optional.Interface of []string) -  MAC address
     * @param "MacAddressIsw" (optional.Interface of []string) -  MAC address
     * @param "MacAddressN" (optional.Interface of []string) -  MAC address
     * @param "MacAddressNic" (optional.Interface of []string) -  MAC address
     * @param "MacAddressNie" (optional.Interface of []string) -  MAC address
     * @param "MacAddressNiew" (optional.Interface of []string) -  MAC address
     * @param "MacAddressNire" (optional.Interface of []string) -  MAC address
     * @param "MacAddressNisw" (optional.Interface of []string) -  MAC address
     * @param "MacAddressNre" (optional.Interface of []string) -  MAC address
     * @param "MacAddressRe" (optional.Interface of []string) -  MAC address
     * @param "Manufacturer" (optional.Interface of []string) - 
     * @param "ManufacturerN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsnull" (optional.Bool) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Platform" (optional.Interface of []string) - 
     * @param "PlatformIsnull" (optional.Bool) - 
     * @param "PlatformN" (optional.Interface of []string) - 
     * @param "Position" (optional.Interface of []int32) - 
     * @param "PositionGt" (optional.Interface of []int32) - 
     * @param "PositionGte" (optional.Interface of []int32) - 
     * @param "PositionIsnull" (optional.Bool) - 
     * @param "PositionLt" (optional.Interface of []int32) - 
     * @param "PositionLte" (optional.Interface of []int32) - 
     * @param "PositionN" (optional.Interface of []int32) - 
     * @param "PowerOutlets" (optional.Interface of []string) -  Power Outlets
     * @param "PowerOutletsIsnull" (optional.Bool) - 
     * @param "PowerOutletsN" (optional.Interface of []string) -  Power Outlets
     * @param "PowerPorts" (optional.Interface of []string) -  Power Ports
     * @param "PowerPortsIsnull" (optional.Bool) - 
     * @param "PowerPortsN" (optional.Interface of []string) -  Power Ports
     * @param "Q" (optional.String) -  Search
     * @param "Rack" (optional.Interface of []string) - 
     * @param "RackIsnull" (optional.Bool) - 
     * @param "RackN" (optional.Interface of []string) - 
     * @param "RackGroup" (optional.Interface of []string) - 
     * @param "RackGroupIsnull" (optional.Bool) - 
     * @param "RackGroupN" (optional.Interface of []string) - 
     * @param "RearPorts" (optional.Interface of []string) -  Rear Port
     * @param "RearPortsIsnull" (optional.Bool) - 
     * @param "RearPortsN" (optional.Interface of []string) -  Rear Port
     * @param "Role" (optional.Interface of []string) - 
     * @param "RoleN" (optional.Interface of []string) - 
     * @param "SecretsGroup" (optional.Interface of []string) - 
     * @param "SecretsGroupIsnull" (optional.Bool) - 
     * @param "SecretsGroupN" (optional.Interface of []string) - 
     * @param "Serial" (optional.Interface of []string) - 
     * @param "SoftwareImageFiles" (optional.Interface of []string) - 
     * @param "SoftwareImageFilesN" (optional.Interface of []string) - 
     * @param "SoftwareVersion" (optional.Interface of []string) - 
     * @param "SoftwareVersionIsnull" (optional.Bool) - 
     * @param "SoftwareVersionN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Tenant" (optional.Interface of []string) - 
     * @param "TenantIsnull" (optional.Bool) - 
     * @param "TenantN" (optional.Interface of []string) - 
     * @param "TenantGroup" (optional.Interface of []string) - 
     * @param "TenantGroupIsnull" (optional.Bool) - 
     * @param "TenantGroupN" (optional.Interface of []string) - 
     * @param "TenantId" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "TenantIdIsnull" (optional.Bool) - 
     * @param "TenantIdN" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "VcPosition" (optional.Interface of []int32) - 
     * @param "VcPositionGt" (optional.Interface of []int32) - 
     * @param "VcPositionGte" (optional.Interface of []int32) - 
     * @param "VcPositionIsnull" (optional.Bool) - 
     * @param "VcPositionLt" (optional.Interface of []int32) - 
     * @param "VcPositionLte" (optional.Interface of []int32) - 
     * @param "VcPositionN" (optional.Interface of []int32) - 
     * @param "VcPriority" (optional.Interface of []int32) - 
     * @param "VcPriorityGt" (optional.Interface of []int32) - 
     * @param "VcPriorityGte" (optional.Interface of []int32) - 
     * @param "VcPriorityIsnull" (optional.Bool) - 
     * @param "VcPriorityLt" (optional.Interface of []int32) - 
     * @param "VcPriorityLte" (optional.Interface of []int32) - 
     * @param "VcPriorityN" (optional.Interface of []int32) - 
     * @param "VirtualChassis" (optional.Interface of []string) - 
     * @param "VirtualChassisIsnull" (optional.Bool) - 
     * @param "VirtualChassisN" (optional.Interface of []string) - 
     * @param "VirtualChassisMember" (optional.Bool) -  Is a virtual chassis member
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedDeviceList
*/

type DcimApiDcimDevicesListOpts struct {
    AssetTag optional.Interface
    AssetTagIc optional.Interface
    AssetTagIe optional.Interface
    AssetTagIew optional.Interface
    AssetTagIre optional.Interface
    AssetTagIsnull optional.Bool
    AssetTagIsw optional.Interface
    AssetTagN optional.Interface
    AssetTagNic optional.Interface
    AssetTagNie optional.Interface
    AssetTagNiew optional.Interface
    AssetTagNire optional.Interface
    AssetTagNisw optional.Interface
    AssetTagNre optional.Interface
    AssetTagRe optional.Interface
    Cluster optional.Interface
    ClusterIsnull optional.Bool
    ClusterN optional.Interface
    ConsolePorts optional.Interface
    ConsolePortsIsnull optional.Bool
    ConsolePortsN optional.Interface
    ConsoleServerPorts optional.Interface
    ConsoleServerPortsIsnull optional.Bool
    ConsoleServerPortsN optional.Interface
    ControllerManagedDeviceGroup optional.Interface
    ControllerManagedDeviceGroupIsnull optional.Bool
    ControllerManagedDeviceGroupN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    DeviceBays optional.Interface
    DeviceBaysIsnull optional.Bool
    DeviceBaysN optional.Interface
    DeviceFamily optional.Interface
    DeviceFamilyIsnull optional.Bool
    DeviceFamilyN optional.Interface
    DeviceRedundancyGroup optional.Interface
    DeviceRedundancyGroupIsnull optional.Bool
    DeviceRedundancyGroupN optional.Interface
    DeviceRedundancyGroupPriority optional.Interface
    DeviceRedundancyGroupPriorityGt optional.Interface
    DeviceRedundancyGroupPriorityGte optional.Interface
    DeviceRedundancyGroupPriorityIsnull optional.Bool
    DeviceRedundancyGroupPriorityLt optional.Interface
    DeviceRedundancyGroupPriorityLte optional.Interface
    DeviceRedundancyGroupPriorityN optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Face optional.Interface
    FaceIc optional.Interface
    FaceIe optional.Interface
    FaceIew optional.Interface
    FaceIre optional.Interface
    FaceIsw optional.Interface
    FaceN optional.Interface
    FaceNic optional.Interface
    FaceNie optional.Interface
    FaceNiew optional.Interface
    FaceNire optional.Interface
    FaceNisw optional.Interface
    FaceNre optional.Interface
    FaceRe optional.Interface
    Format optional.String
    FrontPorts optional.Interface
    FrontPortsIsnull optional.Bool
    FrontPortsN optional.Interface
    HasConsolePorts optional.Bool
    HasConsoleServerPorts optional.Bool
    HasDeviceBays optional.Bool
    HasFrontPorts optional.Bool
    HasInterfaces optional.Bool
    HasPowerOutlets optional.Bool
    HasPowerPorts optional.Bool
    HasPrimaryIp optional.Bool
    HasRearPorts optional.Bool
    HasSoftwareImageFiles optional.Bool
    HasSoftwareVersion optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Interfaces optional.Interface
    InterfacesIsnull optional.Bool
    InterfacesN optional.Interface
    IsFullDepth optional.Bool
    IsVirtualChassisMember optional.Bool
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    LocalConfigContextData optional.Bool
    LocalConfigContextSchema optional.Interface
    LocalConfigContextSchemaIsnull optional.Bool
    LocalConfigContextSchemaN optional.Interface
    LocalConfigContextSchemaId optional.Interface
    LocalConfigContextSchemaIdIsnull optional.Bool
    LocalConfigContextSchemaIdN optional.Interface
    Location optional.Interface
    LocationN optional.Interface
    MacAddress optional.Interface
    MacAddressIc optional.Interface
    MacAddressIe optional.Interface
    MacAddressIew optional.Interface
    MacAddressIre optional.Interface
    MacAddressIsw optional.Interface
    MacAddressN optional.Interface
    MacAddressNic optional.Interface
    MacAddressNie optional.Interface
    MacAddressNiew optional.Interface
    MacAddressNire optional.Interface
    MacAddressNisw optional.Interface
    MacAddressNre optional.Interface
    MacAddressRe optional.Interface
    Manufacturer optional.Interface
    ManufacturerN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsnull optional.Bool
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Platform optional.Interface
    PlatformIsnull optional.Bool
    PlatformN optional.Interface
    Position optional.Interface
    PositionGt optional.Interface
    PositionGte optional.Interface
    PositionIsnull optional.Bool
    PositionLt optional.Interface
    PositionLte optional.Interface
    PositionN optional.Interface
    PowerOutlets optional.Interface
    PowerOutletsIsnull optional.Bool
    PowerOutletsN optional.Interface
    PowerPorts optional.Interface
    PowerPortsIsnull optional.Bool
    PowerPortsN optional.Interface
    Q optional.String
    Rack optional.Interface
    RackIsnull optional.Bool
    RackN optional.Interface
    RackGroup optional.Interface
    RackGroupIsnull optional.Bool
    RackGroupN optional.Interface
    RearPorts optional.Interface
    RearPortsIsnull optional.Bool
    RearPortsN optional.Interface
    Role optional.Interface
    RoleN optional.Interface
    SecretsGroup optional.Interface
    SecretsGroupIsnull optional.Bool
    SecretsGroupN optional.Interface
    Serial optional.Interface
    SoftwareImageFiles optional.Interface
    SoftwareImageFilesN optional.Interface
    SoftwareVersion optional.Interface
    SoftwareVersionIsnull optional.Bool
    SoftwareVersionN optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Tenant optional.Interface
    TenantIsnull optional.Bool
    TenantN optional.Interface
    TenantGroup optional.Interface
    TenantGroupIsnull optional.Bool
    TenantGroupN optional.Interface
    TenantId optional.Interface
    TenantIdIsnull optional.Bool
    TenantIdN optional.Interface
    VcPosition optional.Interface
    VcPositionGt optional.Interface
    VcPositionGte optional.Interface
    VcPositionIsnull optional.Bool
    VcPositionLt optional.Interface
    VcPositionLte optional.Interface
    VcPositionN optional.Interface
    VcPriority optional.Interface
    VcPriorityGt optional.Interface
    VcPriorityGte optional.Interface
    VcPriorityIsnull optional.Bool
    VcPriorityLt optional.Interface
    VcPriorityLte optional.Interface
    VcPriorityN optional.Interface
    VirtualChassis optional.Interface
    VirtualChassisIsnull optional.Bool
    VirtualChassisN optional.Interface
    VirtualChassisMember optional.Bool
    Depth optional.Int32
}

func (a *DcimApiService) DcimDevicesList(ctx context.Context, localVarOptionals *DcimApiDcimDevicesListOpts) (PaginatedDeviceList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedDeviceList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AssetTag.IsSet() {
		localVarQueryParams.Add("asset_tag", parameterToString(localVarOptionals.AssetTag.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIc.IsSet() {
		localVarQueryParams.Add("asset_tag__ic", parameterToString(localVarOptionals.AssetTagIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIe.IsSet() {
		localVarQueryParams.Add("asset_tag__ie", parameterToString(localVarOptionals.AssetTagIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIew.IsSet() {
		localVarQueryParams.Add("asset_tag__iew", parameterToString(localVarOptionals.AssetTagIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIre.IsSet() {
		localVarQueryParams.Add("asset_tag__ire", parameterToString(localVarOptionals.AssetTagIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIsnull.IsSet() {
		localVarQueryParams.Add("asset_tag__isnull", parameterToString(localVarOptionals.AssetTagIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIsw.IsSet() {
		localVarQueryParams.Add("asset_tag__isw", parameterToString(localVarOptionals.AssetTagIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagN.IsSet() {
		localVarQueryParams.Add("asset_tag__n", parameterToString(localVarOptionals.AssetTagN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNic.IsSet() {
		localVarQueryParams.Add("asset_tag__nic", parameterToString(localVarOptionals.AssetTagNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNie.IsSet() {
		localVarQueryParams.Add("asset_tag__nie", parameterToString(localVarOptionals.AssetTagNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNiew.IsSet() {
		localVarQueryParams.Add("asset_tag__niew", parameterToString(localVarOptionals.AssetTagNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNire.IsSet() {
		localVarQueryParams.Add("asset_tag__nire", parameterToString(localVarOptionals.AssetTagNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNisw.IsSet() {
		localVarQueryParams.Add("asset_tag__nisw", parameterToString(localVarOptionals.AssetTagNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNre.IsSet() {
		localVarQueryParams.Add("asset_tag__nre", parameterToString(localVarOptionals.AssetTagNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagRe.IsSet() {
		localVarQueryParams.Add("asset_tag__re", parameterToString(localVarOptionals.AssetTagRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Cluster.IsSet() {
		localVarQueryParams.Add("cluster", parameterToString(localVarOptionals.Cluster.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterIsnull.IsSet() {
		localVarQueryParams.Add("cluster__isnull", parameterToString(localVarOptionals.ClusterIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterN.IsSet() {
		localVarQueryParams.Add("cluster__n", parameterToString(localVarOptionals.ClusterN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsolePorts.IsSet() {
		localVarQueryParams.Add("console_ports", parameterToString(localVarOptionals.ConsolePorts.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsolePortsIsnull.IsSet() {
		localVarQueryParams.Add("console_ports__isnull", parameterToString(localVarOptionals.ConsolePortsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConsolePortsN.IsSet() {
		localVarQueryParams.Add("console_ports__n", parameterToString(localVarOptionals.ConsolePortsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsoleServerPorts.IsSet() {
		localVarQueryParams.Add("console_server_ports", parameterToString(localVarOptionals.ConsoleServerPorts.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ConsoleServerPortsIsnull.IsSet() {
		localVarQueryParams.Add("console_server_ports__isnull", parameterToString(localVarOptionals.ConsoleServerPortsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConsoleServerPortsN.IsSet() {
		localVarQueryParams.Add("console_server_ports__n", parameterToString(localVarOptionals.ConsoleServerPortsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerManagedDeviceGroup.IsSet() {
		localVarQueryParams.Add("controller_managed_device_group", parameterToString(localVarOptionals.ControllerManagedDeviceGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerManagedDeviceGroupIsnull.IsSet() {
		localVarQueryParams.Add("controller_managed_device_group__isnull", parameterToString(localVarOptionals.ControllerManagedDeviceGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerManagedDeviceGroupN.IsSet() {
		localVarQueryParams.Add("controller_managed_device_group__n", parameterToString(localVarOptionals.ControllerManagedDeviceGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceBays.IsSet() {
		localVarQueryParams.Add("device_bays", parameterToString(localVarOptionals.DeviceBays.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceBaysIsnull.IsSet() {
		localVarQueryParams.Add("device_bays__isnull", parameterToString(localVarOptionals.DeviceBaysIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceBaysN.IsSet() {
		localVarQueryParams.Add("device_bays__n", parameterToString(localVarOptionals.DeviceBaysN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceFamily.IsSet() {
		localVarQueryParams.Add("device_family", parameterToString(localVarOptionals.DeviceFamily.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceFamilyIsnull.IsSet() {
		localVarQueryParams.Add("device_family__isnull", parameterToString(localVarOptionals.DeviceFamilyIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceFamilyN.IsSet() {
		localVarQueryParams.Add("device_family__n", parameterToString(localVarOptionals.DeviceFamilyN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroup.IsSet() {
		localVarQueryParams.Add("device_redundancy_group", parameterToString(localVarOptionals.DeviceRedundancyGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupIsnull.IsSet() {
		localVarQueryParams.Add("device_redundancy_group__isnull", parameterToString(localVarOptionals.DeviceRedundancyGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupN.IsSet() {
		localVarQueryParams.Add("device_redundancy_group__n", parameterToString(localVarOptionals.DeviceRedundancyGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupPriority.IsSet() {
		localVarQueryParams.Add("device_redundancy_group_priority", parameterToString(localVarOptionals.DeviceRedundancyGroupPriority.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupPriorityGt.IsSet() {
		localVarQueryParams.Add("device_redundancy_group_priority__gt", parameterToString(localVarOptionals.DeviceRedundancyGroupPriorityGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupPriorityGte.IsSet() {
		localVarQueryParams.Add("device_redundancy_group_priority__gte", parameterToString(localVarOptionals.DeviceRedundancyGroupPriorityGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupPriorityIsnull.IsSet() {
		localVarQueryParams.Add("device_redundancy_group_priority__isnull", parameterToString(localVarOptionals.DeviceRedundancyGroupPriorityIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupPriorityLt.IsSet() {
		localVarQueryParams.Add("device_redundancy_group_priority__lt", parameterToString(localVarOptionals.DeviceRedundancyGroupPriorityLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupPriorityLte.IsSet() {
		localVarQueryParams.Add("device_redundancy_group_priority__lte", parameterToString(localVarOptionals.DeviceRedundancyGroupPriorityLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceRedundancyGroupPriorityN.IsSet() {
		localVarQueryParams.Add("device_redundancy_group_priority__n", parameterToString(localVarOptionals.DeviceRedundancyGroupPriorityN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Face.IsSet() {
		localVarQueryParams.Add("face", parameterToString(localVarOptionals.Face.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceIc.IsSet() {
		localVarQueryParams.Add("face__ic", parameterToString(localVarOptionals.FaceIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceIe.IsSet() {
		localVarQueryParams.Add("face__ie", parameterToString(localVarOptionals.FaceIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceIew.IsSet() {
		localVarQueryParams.Add("face__iew", parameterToString(localVarOptionals.FaceIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceIre.IsSet() {
		localVarQueryParams.Add("face__ire", parameterToString(localVarOptionals.FaceIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceIsw.IsSet() {
		localVarQueryParams.Add("face__isw", parameterToString(localVarOptionals.FaceIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceN.IsSet() {
		localVarQueryParams.Add("face__n", parameterToString(localVarOptionals.FaceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceNic.IsSet() {
		localVarQueryParams.Add("face__nic", parameterToString(localVarOptionals.FaceNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceNie.IsSet() {
		localVarQueryParams.Add("face__nie", parameterToString(localVarOptionals.FaceNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceNiew.IsSet() {
		localVarQueryParams.Add("face__niew", parameterToString(localVarOptionals.FaceNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceNire.IsSet() {
		localVarQueryParams.Add("face__nire", parameterToString(localVarOptionals.FaceNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceNisw.IsSet() {
		localVarQueryParams.Add("face__nisw", parameterToString(localVarOptionals.FaceNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceNre.IsSet() {
		localVarQueryParams.Add("face__nre", parameterToString(localVarOptionals.FaceNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FaceRe.IsSet() {
		localVarQueryParams.Add("face__re", parameterToString(localVarOptionals.FaceRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPorts.IsSet() {
		localVarQueryParams.Add("front_ports", parameterToString(localVarOptionals.FrontPorts.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortsIsnull.IsSet() {
		localVarQueryParams.Add("front_ports__isnull", parameterToString(localVarOptionals.FrontPortsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortsN.IsSet() {
		localVarQueryParams.Add("front_ports__n", parameterToString(localVarOptionals.FrontPortsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HasConsolePorts.IsSet() {
		localVarQueryParams.Add("has_console_ports", parameterToString(localVarOptionals.HasConsolePorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasConsoleServerPorts.IsSet() {
		localVarQueryParams.Add("has_console_server_ports", parameterToString(localVarOptionals.HasConsoleServerPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDeviceBays.IsSet() {
		localVarQueryParams.Add("has_device_bays", parameterToString(localVarOptionals.HasDeviceBays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasFrontPorts.IsSet() {
		localVarQueryParams.Add("has_front_ports", parameterToString(localVarOptionals.HasFrontPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasInterfaces.IsSet() {
		localVarQueryParams.Add("has_interfaces", parameterToString(localVarOptionals.HasInterfaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerOutlets.IsSet() {
		localVarQueryParams.Add("has_power_outlets", parameterToString(localVarOptionals.HasPowerOutlets.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerPorts.IsSet() {
		localVarQueryParams.Add("has_power_ports", parameterToString(localVarOptionals.HasPowerPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPrimaryIp.IsSet() {
		localVarQueryParams.Add("has_primary_ip", parameterToString(localVarOptionals.HasPrimaryIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRearPorts.IsSet() {
		localVarQueryParams.Add("has_rear_ports", parameterToString(localVarOptionals.HasRearPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSoftwareImageFiles.IsSet() {
		localVarQueryParams.Add("has_software_image_files", parameterToString(localVarOptionals.HasSoftwareImageFiles.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSoftwareVersion.IsSet() {
		localVarQueryParams.Add("has_software_version", parameterToString(localVarOptionals.HasSoftwareVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Interfaces.IsSet() {
		localVarQueryParams.Add("interfaces", parameterToString(localVarOptionals.Interfaces.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InterfacesIsnull.IsSet() {
		localVarQueryParams.Add("interfaces__isnull", parameterToString(localVarOptionals.InterfacesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfacesN.IsSet() {
		localVarQueryParams.Add("interfaces__n", parameterToString(localVarOptionals.InterfacesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsFullDepth.IsSet() {
		localVarQueryParams.Add("is_full_depth", parameterToString(localVarOptionals.IsFullDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsVirtualChassisMember.IsSet() {
		localVarQueryParams.Add("is_virtual_chassis_member", parameterToString(localVarOptionals.IsVirtualChassisMember.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocalConfigContextData.IsSet() {
		localVarQueryParams.Add("local_config_context_data", parameterToString(localVarOptionals.LocalConfigContextData.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocalConfigContextSchema.IsSet() {
		localVarQueryParams.Add("local_config_context_schema", parameterToString(localVarOptionals.LocalConfigContextSchema.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocalConfigContextSchemaIsnull.IsSet() {
		localVarQueryParams.Add("local_config_context_schema__isnull", parameterToString(localVarOptionals.LocalConfigContextSchemaIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocalConfigContextSchemaN.IsSet() {
		localVarQueryParams.Add("local_config_context_schema__n", parameterToString(localVarOptionals.LocalConfigContextSchemaN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocalConfigContextSchemaId.IsSet() {
		localVarQueryParams.Add("local_config_context_schema_id", parameterToString(localVarOptionals.LocalConfigContextSchemaId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocalConfigContextSchemaIdIsnull.IsSet() {
		localVarQueryParams.Add("local_config_context_schema_id__isnull", parameterToString(localVarOptionals.LocalConfigContextSchemaIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocalConfigContextSchemaIdN.IsSet() {
		localVarQueryParams.Add("local_config_context_schema_id__n", parameterToString(localVarOptionals.LocalConfigContextSchemaIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddress.IsSet() {
		localVarQueryParams.Add("mac_address", parameterToString(localVarOptionals.MacAddress.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIc.IsSet() {
		localVarQueryParams.Add("mac_address__ic", parameterToString(localVarOptionals.MacAddressIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIe.IsSet() {
		localVarQueryParams.Add("mac_address__ie", parameterToString(localVarOptionals.MacAddressIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIew.IsSet() {
		localVarQueryParams.Add("mac_address__iew", parameterToString(localVarOptionals.MacAddressIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIre.IsSet() {
		localVarQueryParams.Add("mac_address__ire", parameterToString(localVarOptionals.MacAddressIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIsw.IsSet() {
		localVarQueryParams.Add("mac_address__isw", parameterToString(localVarOptionals.MacAddressIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressN.IsSet() {
		localVarQueryParams.Add("mac_address__n", parameterToString(localVarOptionals.MacAddressN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNic.IsSet() {
		localVarQueryParams.Add("mac_address__nic", parameterToString(localVarOptionals.MacAddressNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNie.IsSet() {
		localVarQueryParams.Add("mac_address__nie", parameterToString(localVarOptionals.MacAddressNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNiew.IsSet() {
		localVarQueryParams.Add("mac_address__niew", parameterToString(localVarOptionals.MacAddressNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNire.IsSet() {
		localVarQueryParams.Add("mac_address__nire", parameterToString(localVarOptionals.MacAddressNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNisw.IsSet() {
		localVarQueryParams.Add("mac_address__nisw", parameterToString(localVarOptionals.MacAddressNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNre.IsSet() {
		localVarQueryParams.Add("mac_address__nre", parameterToString(localVarOptionals.MacAddressNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressRe.IsSet() {
		localVarQueryParams.Add("mac_address__re", parameterToString(localVarOptionals.MacAddressRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarQueryParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ManufacturerN.IsSet() {
		localVarQueryParams.Add("manufacturer__n", parameterToString(localVarOptionals.ManufacturerN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsnull.IsSet() {
		localVarQueryParams.Add("name__isnull", parameterToString(localVarOptionals.NameIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Platform.IsSet() {
		localVarQueryParams.Add("platform", parameterToString(localVarOptionals.Platform.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformIsnull.IsSet() {
		localVarQueryParams.Add("platform__isnull", parameterToString(localVarOptionals.PlatformIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformN.IsSet() {
		localVarQueryParams.Add("platform__n", parameterToString(localVarOptionals.PlatformN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Position.IsSet() {
		localVarQueryParams.Add("position", parameterToString(localVarOptionals.Position.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionGt.IsSet() {
		localVarQueryParams.Add("position__gt", parameterToString(localVarOptionals.PositionGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionGte.IsSet() {
		localVarQueryParams.Add("position__gte", parameterToString(localVarOptionals.PositionGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionIsnull.IsSet() {
		localVarQueryParams.Add("position__isnull", parameterToString(localVarOptionals.PositionIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PositionLt.IsSet() {
		localVarQueryParams.Add("position__lt", parameterToString(localVarOptionals.PositionLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionLte.IsSet() {
		localVarQueryParams.Add("position__lte", parameterToString(localVarOptionals.PositionLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionN.IsSet() {
		localVarQueryParams.Add("position__n", parameterToString(localVarOptionals.PositionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutlets.IsSet() {
		localVarQueryParams.Add("power_outlets", parameterToString(localVarOptionals.PowerOutlets.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletsIsnull.IsSet() {
		localVarQueryParams.Add("power_outlets__isnull", parameterToString(localVarOptionals.PowerOutletsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletsN.IsSet() {
		localVarQueryParams.Add("power_outlets__n", parameterToString(localVarOptionals.PowerOutletsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPorts.IsSet() {
		localVarQueryParams.Add("power_ports", parameterToString(localVarOptionals.PowerPorts.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortsIsnull.IsSet() {
		localVarQueryParams.Add("power_ports__isnull", parameterToString(localVarOptionals.PowerPortsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortsN.IsSet() {
		localVarQueryParams.Add("power_ports__n", parameterToString(localVarOptionals.PowerPortsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Rack.IsSet() {
		localVarQueryParams.Add("rack", parameterToString(localVarOptionals.Rack.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackIsnull.IsSet() {
		localVarQueryParams.Add("rack__isnull", parameterToString(localVarOptionals.RackIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackN.IsSet() {
		localVarQueryParams.Add("rack__n", parameterToString(localVarOptionals.RackN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroup.IsSet() {
		localVarQueryParams.Add("rack_group", parameterToString(localVarOptionals.RackGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupIsnull.IsSet() {
		localVarQueryParams.Add("rack_group__isnull", parameterToString(localVarOptionals.RackGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupN.IsSet() {
		localVarQueryParams.Add("rack_group__n", parameterToString(localVarOptionals.RackGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPorts.IsSet() {
		localVarQueryParams.Add("rear_ports", parameterToString(localVarOptionals.RearPorts.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortsIsnull.IsSet() {
		localVarQueryParams.Add("rear_ports__isnull", parameterToString(localVarOptionals.RearPortsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortsN.IsSet() {
		localVarQueryParams.Add("rear_ports__n", parameterToString(localVarOptionals.RearPortsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Role.IsSet() {
		localVarQueryParams.Add("role", parameterToString(localVarOptionals.Role.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RoleN.IsSet() {
		localVarQueryParams.Add("role__n", parameterToString(localVarOptionals.RoleN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroup.IsSet() {
		localVarQueryParams.Add("secrets_group", parameterToString(localVarOptionals.SecretsGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupIsnull.IsSet() {
		localVarQueryParams.Add("secrets_group__isnull", parameterToString(localVarOptionals.SecretsGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupN.IsSet() {
		localVarQueryParams.Add("secrets_group__n", parameterToString(localVarOptionals.SecretsGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Serial.IsSet() {
		localVarQueryParams.Add("serial", parameterToString(localVarOptionals.Serial.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFiles.IsSet() {
		localVarQueryParams.Add("software_image_files", parameterToString(localVarOptionals.SoftwareImageFiles.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFilesN.IsSet() {
		localVarQueryParams.Add("software_image_files__n", parameterToString(localVarOptionals.SoftwareImageFilesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareVersion.IsSet() {
		localVarQueryParams.Add("software_version", parameterToString(localVarOptionals.SoftwareVersion.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareVersionIsnull.IsSet() {
		localVarQueryParams.Add("software_version__isnull", parameterToString(localVarOptionals.SoftwareVersionIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareVersionN.IsSet() {
		localVarQueryParams.Add("software_version__n", parameterToString(localVarOptionals.SoftwareVersionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIsnull.IsSet() {
		localVarQueryParams.Add("tenant__isnull", parameterToString(localVarOptionals.TenantIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIsnull.IsSet() {
		localVarQueryParams.Add("tenant_group__isnull", parameterToString(localVarOptionals.TenantGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdIsnull.IsSet() {
		localVarQueryParams.Add("tenant_id__isnull", parameterToString(localVarOptionals.TenantIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdN.IsSet() {
		localVarQueryParams.Add("tenant_id__n", parameterToString(localVarOptionals.TenantIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPosition.IsSet() {
		localVarQueryParams.Add("vc_position", parameterToString(localVarOptionals.VcPosition.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPositionGt.IsSet() {
		localVarQueryParams.Add("vc_position__gt", parameterToString(localVarOptionals.VcPositionGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPositionGte.IsSet() {
		localVarQueryParams.Add("vc_position__gte", parameterToString(localVarOptionals.VcPositionGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPositionIsnull.IsSet() {
		localVarQueryParams.Add("vc_position__isnull", parameterToString(localVarOptionals.VcPositionIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VcPositionLt.IsSet() {
		localVarQueryParams.Add("vc_position__lt", parameterToString(localVarOptionals.VcPositionLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPositionLte.IsSet() {
		localVarQueryParams.Add("vc_position__lte", parameterToString(localVarOptionals.VcPositionLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPositionN.IsSet() {
		localVarQueryParams.Add("vc_position__n", parameterToString(localVarOptionals.VcPositionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPriority.IsSet() {
		localVarQueryParams.Add("vc_priority", parameterToString(localVarOptionals.VcPriority.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPriorityGt.IsSet() {
		localVarQueryParams.Add("vc_priority__gt", parameterToString(localVarOptionals.VcPriorityGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPriorityGte.IsSet() {
		localVarQueryParams.Add("vc_priority__gte", parameterToString(localVarOptionals.VcPriorityGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPriorityIsnull.IsSet() {
		localVarQueryParams.Add("vc_priority__isnull", parameterToString(localVarOptionals.VcPriorityIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VcPriorityLt.IsSet() {
		localVarQueryParams.Add("vc_priority__lt", parameterToString(localVarOptionals.VcPriorityLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPriorityLte.IsSet() {
		localVarQueryParams.Add("vc_priority__lte", parameterToString(localVarOptionals.VcPriorityLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VcPriorityN.IsSet() {
		localVarQueryParams.Add("vc_priority__n", parameterToString(localVarOptionals.VcPriorityN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualChassis.IsSet() {
		localVarQueryParams.Add("virtual_chassis", parameterToString(localVarOptionals.VirtualChassis.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualChassisIsnull.IsSet() {
		localVarQueryParams.Add("virtual_chassis__isnull", parameterToString(localVarOptionals.VirtualChassisIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualChassisN.IsSet() {
		localVarQueryParams.Add("virtual_chassis__n", parameterToString(localVarOptionals.VirtualChassisN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualChassisMember.IsSet() {
		localVarQueryParams.Add("virtual_chassis_member", parameterToString(localVarOptionals.VirtualChassisMember.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedDeviceList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Execute a NAPALM method on a Device
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device.
 * @param method
 * @param optional nil or *DcimApiDcimDevicesNapalmRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return DeviceNapalm
*/

type DcimApiDcimDevicesNapalmRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDevicesNapalmRetrieve(ctx context.Context, id string, method string, localVarOptionals *DcimApiDcimDevicesNapalmRetrieveOpts) (DeviceNapalm, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceNapalm
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/{id}/napalm/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	localVarQueryParams.Add("method", parameterToString(method, ""))
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceNapalm
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device.
 * @param optional nil or *DcimApiDcimDevicesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimDevicesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDevicesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimDevicesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device.
 * @param optional nil or *DcimApiDcimDevicesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimDevicesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimDevicesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimDevicesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a device object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device.
 * @param optional nil or *DcimApiDcimDevicesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableDeviceRequest) - 
     * @param "Format" (optional.String) - 
@return Device
*/

type DcimApiDcimDevicesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimDevicesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimDevicesPartialUpdateOpts) (Device, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Device
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Device
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a device object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this device.
 * @param optional nil or *DcimApiDcimDevicesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Device
*/

type DcimApiDcimDevicesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimDevicesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimDevicesRetrieveOpts) (Device, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Device
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Device
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a device object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this device.
 * @param optional nil or *DcimApiDcimDevicesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Device
*/

type DcimApiDcimDevicesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimDevicesUpdate(ctx context.Context, body WritableDeviceRequest, id string, localVarOptionals *DcimApiDcimDevicesUpdateOpts) (Device, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Device
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Device
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of front port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimFrontPortTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimFrontPortTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimFrontPortTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of front port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimFrontPortTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []FrontPortTemplate
*/

type DcimApiDcimFrontPortTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableFrontPortTemplateRequest, localVarOptionals *DcimApiDcimFrontPortTemplatesBulkPartialUpdateOpts) ([]FrontPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []FrontPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FrontPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of front port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimFrontPortTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []FrontPortTemplate
*/

type DcimApiDcimFrontPortTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortTemplatesBulkUpdate(ctx context.Context, body []BulkWritableFrontPortTemplateRequest, localVarOptionals *DcimApiDcimFrontPortTemplatesBulkUpdateOpts) ([]FrontPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []FrontPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FrontPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more front port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimFrontPortTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return FrontPortTemplate
*/

type DcimApiDcimFrontPortTemplatesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortTemplatesCreate(ctx context.Context, body WritableFrontPortTemplateRequest, localVarOptionals *DcimApiDcimFrontPortTemplatesCreateOpts) (FrontPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v FrontPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a front port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port template.
 * @param optional nil or *DcimApiDcimFrontPortTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimFrontPortTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortTemplatesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of front port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimFrontPortTemplatesListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) -  Description
     * @param "DescriptionIc" (optional.Interface of []string) -  Description
     * @param "DescriptionIe" (optional.Interface of []string) -  Description
     * @param "DescriptionIew" (optional.Interface of []string) -  Description
     * @param "DescriptionIre" (optional.Interface of []string) -  Description
     * @param "DescriptionIsw" (optional.Interface of []string) -  Description
     * @param "DescriptionN" (optional.Interface of []string) -  Description
     * @param "DescriptionNic" (optional.Interface of []string) -  Description
     * @param "DescriptionNie" (optional.Interface of []string) -  Description
     * @param "DescriptionNiew" (optional.Interface of []string) -  Description
     * @param "DescriptionNire" (optional.Interface of []string) -  Description
     * @param "DescriptionNisw" (optional.Interface of []string) -  Description
     * @param "DescriptionNre" (optional.Interface of []string) -  Description
     * @param "DescriptionRe" (optional.Interface of []string) -  Description
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  ID
     * @param "IdIc" (optional.Interface of []string) -  ID
     * @param "IdIe" (optional.Interface of []string) -  ID
     * @param "IdIew" (optional.Interface of []string) -  ID
     * @param "IdIre" (optional.Interface of []string) -  ID
     * @param "IdIsw" (optional.Interface of []string) -  ID
     * @param "IdN" (optional.Interface of []string) -  ID
     * @param "IdNic" (optional.Interface of []string) -  ID
     * @param "IdNie" (optional.Interface of []string) -  ID
     * @param "IdNiew" (optional.Interface of []string) -  ID
     * @param "IdNire" (optional.Interface of []string) -  ID
     * @param "IdNisw" (optional.Interface of []string) -  ID
     * @param "IdNre" (optional.Interface of []string) -  ID
     * @param "IdRe" (optional.Interface of []string) -  ID
     * @param "Label" (optional.Interface of []string) -  Label
     * @param "LabelIc" (optional.Interface of []string) -  Label
     * @param "LabelIe" (optional.Interface of []string) -  Label
     * @param "LabelIew" (optional.Interface of []string) -  Label
     * @param "LabelIre" (optional.Interface of []string) -  Label
     * @param "LabelIsw" (optional.Interface of []string) -  Label
     * @param "LabelN" (optional.Interface of []string) -  Label
     * @param "LabelNic" (optional.Interface of []string) -  Label
     * @param "LabelNie" (optional.Interface of []string) -  Label
     * @param "LabelNiew" (optional.Interface of []string) -  Label
     * @param "LabelNire" (optional.Interface of []string) -  Label
     * @param "LabelNisw" (optional.Interface of []string) -  Label
     * @param "LabelNre" (optional.Interface of []string) -  Label
     * @param "LabelRe" (optional.Interface of []string) -  Label
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) -  Name
     * @param "NameIc" (optional.Interface of []string) -  Name
     * @param "NameIe" (optional.Interface of []string) -  Name
     * @param "NameIew" (optional.Interface of []string) -  Name
     * @param "NameIre" (optional.Interface of []string) -  Name
     * @param "NameIsw" (optional.Interface of []string) -  Name
     * @param "NameN" (optional.Interface of []string) -  Name
     * @param "NameNic" (optional.Interface of []string) -  Name
     * @param "NameNie" (optional.Interface of []string) -  Name
     * @param "NameNiew" (optional.Interface of []string) -  Name
     * @param "NameNire" (optional.Interface of []string) -  Name
     * @param "NameNisw" (optional.Interface of []string) -  Name
     * @param "NameNre" (optional.Interface of []string) -  Name
     * @param "NameRe" (optional.Interface of []string) -  Name
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "RearPortPosition" (optional.Interface of []int32) - 
     * @param "RearPortPositionGt" (optional.Interface of []int32) - 
     * @param "RearPortPositionGte" (optional.Interface of []int32) - 
     * @param "RearPortPositionLt" (optional.Interface of []int32) - 
     * @param "RearPortPositionLte" (optional.Interface of []int32) - 
     * @param "RearPortPositionN" (optional.Interface of []int32) - 
     * @param "RearPortTemplate" (optional.Interface of []string) -  Rear port template
     * @param "RearPortTemplateN" (optional.Interface of []string) -  Rear port template
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedFrontPortTemplateList
*/

type DcimApiDcimFrontPortTemplatesListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    RearPortPosition optional.Interface
    RearPortPositionGt optional.Interface
    RearPortPositionGte optional.Interface
    RearPortPositionLt optional.Interface
    RearPortPositionLte optional.Interface
    RearPortPositionN optional.Interface
    RearPortTemplate optional.Interface
    RearPortTemplateN optional.Interface
    Sort optional.String
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimFrontPortTemplatesList(ctx context.Context, localVarOptionals *DcimApiDcimFrontPortTemplatesListOpts) (PaginatedFrontPortTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedFrontPortTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPosition.IsSet() {
		localVarQueryParams.Add("rear_port_position", parameterToString(localVarOptionals.RearPortPosition.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionGt.IsSet() {
		localVarQueryParams.Add("rear_port_position__gt", parameterToString(localVarOptionals.RearPortPositionGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionGte.IsSet() {
		localVarQueryParams.Add("rear_port_position__gte", parameterToString(localVarOptionals.RearPortPositionGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionLt.IsSet() {
		localVarQueryParams.Add("rear_port_position__lt", parameterToString(localVarOptionals.RearPortPositionLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionLte.IsSet() {
		localVarQueryParams.Add("rear_port_position__lte", parameterToString(localVarOptionals.RearPortPositionLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionN.IsSet() {
		localVarQueryParams.Add("rear_port_position__n", parameterToString(localVarOptionals.RearPortPositionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortTemplate.IsSet() {
		localVarQueryParams.Add("rear_port_template", parameterToString(localVarOptionals.RearPortTemplate.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortTemplateN.IsSet() {
		localVarQueryParams.Add("rear_port_template__n", parameterToString(localVarOptionals.RearPortTemplateN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedFrontPortTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this front port template.
 * @param optional nil or *DcimApiDcimFrontPortTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimFrontPortTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimFrontPortTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port template.
 * @param optional nil or *DcimApiDcimFrontPortTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimFrontPortTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimFrontPortTemplatesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a front port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port template.
 * @param optional nil or *DcimApiDcimFrontPortTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableFrontPortTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return FrontPortTemplate
*/

type DcimApiDcimFrontPortTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortTemplatesPartialUpdateOpts) (FrontPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FrontPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a front port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port template.
 * @param optional nil or *DcimApiDcimFrontPortTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return FrontPortTemplate
*/

type DcimApiDcimFrontPortTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimFrontPortTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortTemplatesRetrieveOpts) (FrontPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FrontPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a front port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this front port template.
 * @param optional nil or *DcimApiDcimFrontPortTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return FrontPortTemplate
*/

type DcimApiDcimFrontPortTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortTemplatesUpdate(ctx context.Context, body WritableFrontPortTemplateRequest, id string, localVarOptionals *DcimApiDcimFrontPortTemplatesUpdateOpts) (FrontPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FrontPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of front port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimFrontPortsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimFrontPortsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimFrontPortsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of front port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimFrontPortsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []FrontPort
*/

type DcimApiDcimFrontPortsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableFrontPortRequest, localVarOptionals *DcimApiDcimFrontPortsBulkPartialUpdateOpts) ([]FrontPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []FrontPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FrontPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of front port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimFrontPortsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []FrontPort
*/

type DcimApiDcimFrontPortsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortsBulkUpdate(ctx context.Context, body []BulkWritableFrontPortRequest, localVarOptionals *DcimApiDcimFrontPortsBulkUpdateOpts) ([]FrontPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []FrontPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []FrontPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more front port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimFrontPortsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return FrontPort
*/

type DcimApiDcimFrontPortsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortsCreate(ctx context.Context, body WritableFrontPortRequest, localVarOptionals *DcimApiDcimFrontPortsCreateOpts) (FrontPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v FrontPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a front port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port.
 * @param optional nil or *DcimApiDcimFrontPortsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimFrontPortsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of front port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimFrontPortsListOpts - Optional Parameters:
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) - 
     * @param "DeviceN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "RearPort" (optional.Interface of []string) - 
     * @param "RearPortN" (optional.Interface of []string) - 
     * @param "RearPortPosition" (optional.Interface of []int32) - 
     * @param "RearPortPositionGt" (optional.Interface of []int32) - 
     * @param "RearPortPositionGte" (optional.Interface of []int32) - 
     * @param "RearPortPositionLt" (optional.Interface of []int32) - 
     * @param "RearPortPositionLte" (optional.Interface of []int32) - 
     * @param "RearPortPositionN" (optional.Interface of []int32) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedFrontPortList
*/

type DcimApiDcimFrontPortsListOpts struct {
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceN optional.Interface
    Format optional.String
    HasCable optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    RearPort optional.Interface
    RearPortN optional.Interface
    RearPortPosition optional.Interface
    RearPortPositionGt optional.Interface
    RearPortPositionGte optional.Interface
    RearPortPositionLt optional.Interface
    RearPortPositionLte optional.Interface
    RearPortPositionN optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimFrontPortsList(ctx context.Context, localVarOptionals *DcimApiDcimFrontPortsListOpts) (PaginatedFrontPortList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedFrontPortList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceN.IsSet() {
		localVarQueryParams.Add("device__n", parameterToString(localVarOptionals.DeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RearPort.IsSet() {
		localVarQueryParams.Add("rear_port", parameterToString(localVarOptionals.RearPort.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortN.IsSet() {
		localVarQueryParams.Add("rear_port__n", parameterToString(localVarOptionals.RearPortN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPosition.IsSet() {
		localVarQueryParams.Add("rear_port_position", parameterToString(localVarOptionals.RearPortPosition.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionGt.IsSet() {
		localVarQueryParams.Add("rear_port_position__gt", parameterToString(localVarOptionals.RearPortPositionGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionGte.IsSet() {
		localVarQueryParams.Add("rear_port_position__gte", parameterToString(localVarOptionals.RearPortPositionGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionLt.IsSet() {
		localVarQueryParams.Add("rear_port_position__lt", parameterToString(localVarOptionals.RearPortPositionLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionLte.IsSet() {
		localVarQueryParams.Add("rear_port_position__lte", parameterToString(localVarOptionals.RearPortPositionLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RearPortPositionN.IsSet() {
		localVarQueryParams.Add("rear_port_position__n", parameterToString(localVarOptionals.RearPortPositionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedFrontPortList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this front port.
 * @param optional nil or *DcimApiDcimFrontPortsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimFrontPortsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimFrontPortsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port.
 * @param optional nil or *DcimApiDcimFrontPortsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimFrontPortsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimFrontPortsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a front port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port.
 * @param optional nil or *DcimApiDcimFrontPortsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableFrontPortRequest) - 
     * @param "Format" (optional.String) - 
@return FrontPort
*/

type DcimApiDcimFrontPortsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortsPartialUpdateOpts) (FrontPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FrontPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Return all CablePaths which traverse a given pass-through port.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port.
 * @param optional nil or *DcimApiDcimFrontPortsPathsListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCablePathList
*/

type DcimApiDcimFrontPortsPathsListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimFrontPortsPathsList(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortsPathsListOpts) (PaginatedCablePathList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCablePathList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/{id}/paths/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCablePathList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a front port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this front port.
 * @param optional nil or *DcimApiDcimFrontPortsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return FrontPort
*/

type DcimApiDcimFrontPortsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimFrontPortsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimFrontPortsRetrieveOpts) (FrontPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FrontPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a front port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this front port.
 * @param optional nil or *DcimApiDcimFrontPortsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return FrontPort
*/

type DcimApiDcimFrontPortsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimFrontPortsUpdate(ctx context.Context, body WritableFrontPortRequest, id string, localVarOptionals *DcimApiDcimFrontPortsUpdateOpts) (FrontPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/front-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FrontPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of interface objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimInterfaceConnectionsListOpts - Optional Parameters:
     * @param "Device" (optional.Interface of []string) -  Device (name)
     * @param "DeviceId" (optional.Interface of []string) -  Device (ID)
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.String) -  Location (name)
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedInterfaceConnectionList
*/

type DcimApiDcimInterfaceConnectionsListOpts struct {
    Device optional.Interface
    DeviceId optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Location optional.String
    Offset optional.Int32
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceConnectionsList(ctx context.Context, localVarOptionals *DcimApiDcimInterfaceConnectionsListOpts) (PaginatedInterfaceConnectionList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedInterfaceConnectionList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedInterfaceConnectionList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of interface redundancy group association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of interface redundancy group association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []InterfaceRedundancyGroupAssociation
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableInterfaceRedundancyGroupAssociationRequest, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsBulkPartialUpdateOpts) ([]InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InterfaceRedundancyGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InterfaceRedundancyGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of interface redundancy group association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []InterfaceRedundancyGroupAssociation
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsBulkUpdate(ctx context.Context, body []BulkWritableInterfaceRedundancyGroupAssociationRequest, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsBulkUpdateOpts) ([]InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InterfaceRedundancyGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InterfaceRedundancyGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more interface redundancy group association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return InterfaceRedundancyGroupAssociation
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsCreate(ctx context.Context, body InterfaceRedundancyGroupAssociationRequest, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsCreateOpts) (InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceRedundancyGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v InterfaceRedundancyGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a interface redundancy group association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface redundancy group association.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of interface redundancy group association objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Interface_" (optional.Interface of []string) - 
     * @param "InterfaceN" (optional.Interface of []string) - 
     * @param "InterfaceRedundancyGroup" (optional.Interface of []string) - 
     * @param "InterfaceRedundancyGroupN" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Priority" (optional.Interface of []int32) - 
     * @param "PriorityGt" (optional.Interface of []int32) - 
     * @param "PriorityGte" (optional.Interface of []int32) - 
     * @param "PriorityLt" (optional.Interface of []int32) - 
     * @param "PriorityLte" (optional.Interface of []int32) - 
     * @param "PriorityN" (optional.Interface of []int32) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedInterfaceRedundancyGroupAssociationList
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsListOpts struct {
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Interface_ optional.Interface
    InterfaceN optional.Interface
    InterfaceRedundancyGroup optional.Interface
    InterfaceRedundancyGroupN optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Priority optional.Interface
    PriorityGt optional.Interface
    PriorityGte optional.Interface
    PriorityLt optional.Interface
    PriorityLte optional.Interface
    PriorityN optional.Interface
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsList(ctx context.Context, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsListOpts) (PaginatedInterfaceRedundancyGroupAssociationList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedInterfaceRedundancyGroupAssociationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Interface_.IsSet() {
		localVarQueryParams.Add("interface", parameterToString(localVarOptionals.Interface_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceN.IsSet() {
		localVarQueryParams.Add("interface__n", parameterToString(localVarOptionals.InterfaceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceRedundancyGroup.IsSet() {
		localVarQueryParams.Add("interface_redundancy_group", parameterToString(localVarOptionals.InterfaceRedundancyGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceRedundancyGroupN.IsSet() {
		localVarQueryParams.Add("interface_redundancy_group__n", parameterToString(localVarOptionals.InterfaceRedundancyGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Priority.IsSet() {
		localVarQueryParams.Add("priority", parameterToString(localVarOptionals.Priority.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PriorityGt.IsSet() {
		localVarQueryParams.Add("priority__gt", parameterToString(localVarOptionals.PriorityGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PriorityGte.IsSet() {
		localVarQueryParams.Add("priority__gte", parameterToString(localVarOptionals.PriorityGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PriorityLt.IsSet() {
		localVarQueryParams.Add("priority__lt", parameterToString(localVarOptionals.PriorityLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PriorityLte.IsSet() {
		localVarQueryParams.Add("priority__lte", parameterToString(localVarOptionals.PriorityLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PriorityN.IsSet() {
		localVarQueryParams.Add("priority__n", parameterToString(localVarOptionals.PriorityN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedInterfaceRedundancyGroupAssociationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this interface redundancy group association.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface redundancy group association.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a interface redundancy group association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface redundancy group association.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedInterfaceRedundancyGroupAssociationRequest) - 
     * @param "Format" (optional.String) - 
@return InterfaceRedundancyGroupAssociation
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsPartialUpdateOpts) (InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceRedundancyGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceRedundancyGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a interface redundancy group association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface redundancy group association.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return InterfaceRedundancyGroupAssociation
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsRetrieveOpts) (InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceRedundancyGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceRedundancyGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a interface redundancy group association object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this interface redundancy group association.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupAssociationsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return InterfaceRedundancyGroupAssociation
*/

type DcimApiDcimInterfaceRedundancyGroupAssociationsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupAssociationsUpdate(ctx context.Context, body InterfaceRedundancyGroupAssociationRequest, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupAssociationsUpdateOpts) (InterfaceRedundancyGroupAssociation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceRedundancyGroupAssociation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-group-associations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceRedundancyGroupAssociation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of interface redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInterfaceRedundancyGroupsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of interface redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []InterfaceRedundancyGroup
*/

type DcimApiDcimInterfaceRedundancyGroupsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableInterfaceRedundancyGroupRequest, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsBulkPartialUpdateOpts) ([]InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InterfaceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InterfaceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of interface redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []InterfaceRedundancyGroup
*/

type DcimApiDcimInterfaceRedundancyGroupsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsBulkUpdate(ctx context.Context, body []BulkWritableInterfaceRedundancyGroupRequest, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsBulkUpdateOpts) ([]InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InterfaceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InterfaceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more interface redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return InterfaceRedundancyGroup
*/

type DcimApiDcimInterfaceRedundancyGroupsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsCreate(ctx context.Context, body WritableInterfaceRedundancyGroupRequest, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsCreateOpts) (InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v InterfaceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a interface redundancy group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface redundancy group.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInterfaceRedundancyGroupsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of interface redundancy group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Protocol" (optional.Interface of []string) - 
     * @param "ProtocolIc" (optional.Interface of []string) - 
     * @param "ProtocolIe" (optional.Interface of []string) - 
     * @param "ProtocolIew" (optional.Interface of []string) - 
     * @param "ProtocolIre" (optional.Interface of []string) - 
     * @param "ProtocolIsw" (optional.Interface of []string) - 
     * @param "ProtocolN" (optional.Interface of []string) - 
     * @param "ProtocolNic" (optional.Interface of []string) - 
     * @param "ProtocolNie" (optional.Interface of []string) - 
     * @param "ProtocolNiew" (optional.Interface of []string) - 
     * @param "ProtocolNire" (optional.Interface of []string) - 
     * @param "ProtocolNisw" (optional.Interface of []string) - 
     * @param "ProtocolNre" (optional.Interface of []string) - 
     * @param "ProtocolRe" (optional.Interface of []string) - 
     * @param "ProtocolGroupId" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdIc" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdIe" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdIew" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdIre" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdIsw" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdN" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdNic" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdNie" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdNiew" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdNire" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdNisw" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdNre" (optional.Interface of []string) - 
     * @param "ProtocolGroupIdRe" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "SecretsGroup" (optional.Interface of []string) - 
     * @param "SecretsGroupIsnull" (optional.Bool) - 
     * @param "SecretsGroupN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "VirtualIp" (optional.Interface of []string) -  Virtual IP Address (address or ID)
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedInterfaceRedundancyGroupList
*/

type DcimApiDcimInterfaceRedundancyGroupsListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Protocol optional.Interface
    ProtocolIc optional.Interface
    ProtocolIe optional.Interface
    ProtocolIew optional.Interface
    ProtocolIre optional.Interface
    ProtocolIsw optional.Interface
    ProtocolN optional.Interface
    ProtocolNic optional.Interface
    ProtocolNie optional.Interface
    ProtocolNiew optional.Interface
    ProtocolNire optional.Interface
    ProtocolNisw optional.Interface
    ProtocolNre optional.Interface
    ProtocolRe optional.Interface
    ProtocolGroupId optional.Interface
    ProtocolGroupIdIc optional.Interface
    ProtocolGroupIdIe optional.Interface
    ProtocolGroupIdIew optional.Interface
    ProtocolGroupIdIre optional.Interface
    ProtocolGroupIdIsw optional.Interface
    ProtocolGroupIdN optional.Interface
    ProtocolGroupIdNic optional.Interface
    ProtocolGroupIdNie optional.Interface
    ProtocolGroupIdNiew optional.Interface
    ProtocolGroupIdNire optional.Interface
    ProtocolGroupIdNisw optional.Interface
    ProtocolGroupIdNre optional.Interface
    ProtocolGroupIdRe optional.Interface
    Q optional.String
    SecretsGroup optional.Interface
    SecretsGroupIsnull optional.Bool
    SecretsGroupN optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    VirtualIp optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsList(ctx context.Context, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsListOpts) (PaginatedInterfaceRedundancyGroupList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedInterfaceRedundancyGroupList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarQueryParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolIc.IsSet() {
		localVarQueryParams.Add("protocol__ic", parameterToString(localVarOptionals.ProtocolIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolIe.IsSet() {
		localVarQueryParams.Add("protocol__ie", parameterToString(localVarOptionals.ProtocolIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolIew.IsSet() {
		localVarQueryParams.Add("protocol__iew", parameterToString(localVarOptionals.ProtocolIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolIre.IsSet() {
		localVarQueryParams.Add("protocol__ire", parameterToString(localVarOptionals.ProtocolIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolIsw.IsSet() {
		localVarQueryParams.Add("protocol__isw", parameterToString(localVarOptionals.ProtocolIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolN.IsSet() {
		localVarQueryParams.Add("protocol__n", parameterToString(localVarOptionals.ProtocolN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolNic.IsSet() {
		localVarQueryParams.Add("protocol__nic", parameterToString(localVarOptionals.ProtocolNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolNie.IsSet() {
		localVarQueryParams.Add("protocol__nie", parameterToString(localVarOptionals.ProtocolNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolNiew.IsSet() {
		localVarQueryParams.Add("protocol__niew", parameterToString(localVarOptionals.ProtocolNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolNire.IsSet() {
		localVarQueryParams.Add("protocol__nire", parameterToString(localVarOptionals.ProtocolNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolNisw.IsSet() {
		localVarQueryParams.Add("protocol__nisw", parameterToString(localVarOptionals.ProtocolNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolNre.IsSet() {
		localVarQueryParams.Add("protocol__nre", parameterToString(localVarOptionals.ProtocolNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolRe.IsSet() {
		localVarQueryParams.Add("protocol__re", parameterToString(localVarOptionals.ProtocolRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupId.IsSet() {
		localVarQueryParams.Add("protocol_group_id", parameterToString(localVarOptionals.ProtocolGroupId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdIc.IsSet() {
		localVarQueryParams.Add("protocol_group_id__ic", parameterToString(localVarOptionals.ProtocolGroupIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdIe.IsSet() {
		localVarQueryParams.Add("protocol_group_id__ie", parameterToString(localVarOptionals.ProtocolGroupIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdIew.IsSet() {
		localVarQueryParams.Add("protocol_group_id__iew", parameterToString(localVarOptionals.ProtocolGroupIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdIre.IsSet() {
		localVarQueryParams.Add("protocol_group_id__ire", parameterToString(localVarOptionals.ProtocolGroupIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdIsw.IsSet() {
		localVarQueryParams.Add("protocol_group_id__isw", parameterToString(localVarOptionals.ProtocolGroupIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdN.IsSet() {
		localVarQueryParams.Add("protocol_group_id__n", parameterToString(localVarOptionals.ProtocolGroupIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdNic.IsSet() {
		localVarQueryParams.Add("protocol_group_id__nic", parameterToString(localVarOptionals.ProtocolGroupIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdNie.IsSet() {
		localVarQueryParams.Add("protocol_group_id__nie", parameterToString(localVarOptionals.ProtocolGroupIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdNiew.IsSet() {
		localVarQueryParams.Add("protocol_group_id__niew", parameterToString(localVarOptionals.ProtocolGroupIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdNire.IsSet() {
		localVarQueryParams.Add("protocol_group_id__nire", parameterToString(localVarOptionals.ProtocolGroupIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdNisw.IsSet() {
		localVarQueryParams.Add("protocol_group_id__nisw", parameterToString(localVarOptionals.ProtocolGroupIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdNre.IsSet() {
		localVarQueryParams.Add("protocol_group_id__nre", parameterToString(localVarOptionals.ProtocolGroupIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolGroupIdRe.IsSet() {
		localVarQueryParams.Add("protocol_group_id__re", parameterToString(localVarOptionals.ProtocolGroupIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroup.IsSet() {
		localVarQueryParams.Add("secrets_group", parameterToString(localVarOptionals.SecretsGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupIsnull.IsSet() {
		localVarQueryParams.Add("secrets_group__isnull", parameterToString(localVarOptionals.SecretsGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretsGroupN.IsSet() {
		localVarQueryParams.Add("secrets_group__n", parameterToString(localVarOptionals.SecretsGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualIp.IsSet() {
		localVarQueryParams.Add("virtual_ip", parameterToString(localVarOptionals.VirtualIp.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedInterfaceRedundancyGroupList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this interface redundancy group.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimInterfaceRedundancyGroupsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface redundancy group.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimInterfaceRedundancyGroupsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a interface redundancy group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface redundancy group.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableInterfaceRedundancyGroupRequest) - 
     * @param "Format" (optional.String) - 
@return InterfaceRedundancyGroup
*/

type DcimApiDcimInterfaceRedundancyGroupsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsPartialUpdateOpts) (InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a interface redundancy group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface redundancy group.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return InterfaceRedundancyGroup
*/

type DcimApiDcimInterfaceRedundancyGroupsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsRetrieveOpts) (InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a interface redundancy group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this interface redundancy group.
 * @param optional nil or *DcimApiDcimInterfaceRedundancyGroupsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return InterfaceRedundancyGroup
*/

type DcimApiDcimInterfaceRedundancyGroupsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceRedundancyGroupsUpdate(ctx context.Context, body WritableInterfaceRedundancyGroupRequest, id string, localVarOptionals *DcimApiDcimInterfaceRedundancyGroupsUpdateOpts) (InterfaceRedundancyGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceRedundancyGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-redundancy-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceRedundancyGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of interface template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInterfaceTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimInterfaceTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of interface template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []InterfaceTemplate
*/

type DcimApiDcimInterfaceTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableInterfaceTemplateRequest, localVarOptionals *DcimApiDcimInterfaceTemplatesBulkPartialUpdateOpts) ([]InterfaceTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InterfaceTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InterfaceTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of interface template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []InterfaceTemplate
*/

type DcimApiDcimInterfaceTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceTemplatesBulkUpdate(ctx context.Context, body []BulkWritableInterfaceTemplateRequest, localVarOptionals *DcimApiDcimInterfaceTemplatesBulkUpdateOpts) ([]InterfaceTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InterfaceTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InterfaceTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more interface template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfaceTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return InterfaceTemplate
*/

type DcimApiDcimInterfaceTemplatesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceTemplatesCreate(ctx context.Context, body WritableInterfaceTemplateRequest, localVarOptionals *DcimApiDcimInterfaceTemplatesCreateOpts) (InterfaceTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v InterfaceTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a interface template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface template.
 * @param optional nil or *DcimApiDcimInterfaceTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInterfaceTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceTemplatesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of interface template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimInterfaceTemplatesListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) -  Description
     * @param "DescriptionIc" (optional.Interface of []string) -  Description
     * @param "DescriptionIe" (optional.Interface of []string) -  Description
     * @param "DescriptionIew" (optional.Interface of []string) -  Description
     * @param "DescriptionIre" (optional.Interface of []string) -  Description
     * @param "DescriptionIsw" (optional.Interface of []string) -  Description
     * @param "DescriptionN" (optional.Interface of []string) -  Description
     * @param "DescriptionNic" (optional.Interface of []string) -  Description
     * @param "DescriptionNie" (optional.Interface of []string) -  Description
     * @param "DescriptionNiew" (optional.Interface of []string) -  Description
     * @param "DescriptionNire" (optional.Interface of []string) -  Description
     * @param "DescriptionNisw" (optional.Interface of []string) -  Description
     * @param "DescriptionNre" (optional.Interface of []string) -  Description
     * @param "DescriptionRe" (optional.Interface of []string) -  Description
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  ID
     * @param "IdIc" (optional.Interface of []string) -  ID
     * @param "IdIe" (optional.Interface of []string) -  ID
     * @param "IdIew" (optional.Interface of []string) -  ID
     * @param "IdIre" (optional.Interface of []string) -  ID
     * @param "IdIsw" (optional.Interface of []string) -  ID
     * @param "IdN" (optional.Interface of []string) -  ID
     * @param "IdNic" (optional.Interface of []string) -  ID
     * @param "IdNie" (optional.Interface of []string) -  ID
     * @param "IdNiew" (optional.Interface of []string) -  ID
     * @param "IdNire" (optional.Interface of []string) -  ID
     * @param "IdNisw" (optional.Interface of []string) -  ID
     * @param "IdNre" (optional.Interface of []string) -  ID
     * @param "IdRe" (optional.Interface of []string) -  ID
     * @param "Label" (optional.Interface of []string) -  Label
     * @param "LabelIc" (optional.Interface of []string) -  Label
     * @param "LabelIe" (optional.Interface of []string) -  Label
     * @param "LabelIew" (optional.Interface of []string) -  Label
     * @param "LabelIre" (optional.Interface of []string) -  Label
     * @param "LabelIsw" (optional.Interface of []string) -  Label
     * @param "LabelN" (optional.Interface of []string) -  Label
     * @param "LabelNic" (optional.Interface of []string) -  Label
     * @param "LabelNie" (optional.Interface of []string) -  Label
     * @param "LabelNiew" (optional.Interface of []string) -  Label
     * @param "LabelNire" (optional.Interface of []string) -  Label
     * @param "LabelNisw" (optional.Interface of []string) -  Label
     * @param "LabelNre" (optional.Interface of []string) -  Label
     * @param "LabelRe" (optional.Interface of []string) -  Label
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "MgmtOnly" (optional.Bool) - 
     * @param "Name" (optional.Interface of []string) -  Name
     * @param "NameIc" (optional.Interface of []string) -  Name
     * @param "NameIe" (optional.Interface of []string) -  Name
     * @param "NameIew" (optional.Interface of []string) -  Name
     * @param "NameIre" (optional.Interface of []string) -  Name
     * @param "NameIsw" (optional.Interface of []string) -  Name
     * @param "NameN" (optional.Interface of []string) -  Name
     * @param "NameNic" (optional.Interface of []string) -  Name
     * @param "NameNie" (optional.Interface of []string) -  Name
     * @param "NameNiew" (optional.Interface of []string) -  Name
     * @param "NameNire" (optional.Interface of []string) -  Name
     * @param "NameNisw" (optional.Interface of []string) -  Name
     * @param "NameNre" (optional.Interface of []string) -  Name
     * @param "NameRe" (optional.Interface of []string) -  Name
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedInterfaceTemplateList
*/

type DcimApiDcimInterfaceTemplatesListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    MgmtOnly optional.Bool
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceTemplatesList(ctx context.Context, localVarOptionals *DcimApiDcimInterfaceTemplatesListOpts) (PaginatedInterfaceTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedInterfaceTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MgmtOnly.IsSet() {
		localVarQueryParams.Add("mgmt_only", parameterToString(localVarOptionals.MgmtOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedInterfaceTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this interface template.
 * @param optional nil or *DcimApiDcimInterfaceTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimInterfaceTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimInterfaceTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface template.
 * @param optional nil or *DcimApiDcimInterfaceTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimInterfaceTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceTemplatesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a interface template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface template.
 * @param optional nil or *DcimApiDcimInterfaceTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableInterfaceTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return InterfaceTemplate
*/

type DcimApiDcimInterfaceTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceTemplatesPartialUpdateOpts) (InterfaceTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a interface template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface template.
 * @param optional nil or *DcimApiDcimInterfaceTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return InterfaceTemplate
*/

type DcimApiDcimInterfaceTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfaceTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfaceTemplatesRetrieveOpts) (InterfaceTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a interface template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this interface template.
 * @param optional nil or *DcimApiDcimInterfaceTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return InterfaceTemplate
*/

type DcimApiDcimInterfaceTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfaceTemplatesUpdate(ctx context.Context, body WritableInterfaceTemplateRequest, id string, localVarOptionals *DcimApiDcimInterfaceTemplatesUpdateOpts) (InterfaceTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InterfaceTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interface-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InterfaceTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of interface objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfacesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInterfacesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfacesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimInterfacesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of interface objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfacesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ModelInterface
*/

type DcimApiDcimInterfacesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfacesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableInterfaceRequest, localVarOptionals *DcimApiDcimInterfacesBulkPartialUpdateOpts) ([]ModelInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ModelInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ModelInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of interface objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfacesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ModelInterface
*/

type DcimApiDcimInterfacesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfacesBulkUpdate(ctx context.Context, body []BulkWritableInterfaceRequest, localVarOptionals *DcimApiDcimInterfacesBulkUpdateOpts) ([]ModelInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ModelInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ModelInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more interface objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInterfacesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ModelInterface
*/

type DcimApiDcimInterfacesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfacesCreate(ctx context.Context, body WritableInterfaceRequest, localVarOptionals *DcimApiDcimInterfacesCreateOpts) (ModelInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ModelInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ModelInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a interface object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface.
 * @param optional nil or *DcimApiDcimInterfacesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInterfacesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfacesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfacesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of interface objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimInterfacesListOpts - Optional Parameters:
     * @param "Bridge" (optional.Interface of []string) - 
     * @param "BridgeIsnull" (optional.Bool) - 
     * @param "BridgeN" (optional.Interface of []string) - 
     * @param "BridgedInterfaces" (optional.Interface of []string) - 
     * @param "BridgedInterfacesIsnull" (optional.Bool) - 
     * @param "BridgedInterfacesN" (optional.Interface of []string) - 
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "ChildInterfaces" (optional.Interface of []string) - 
     * @param "ChildInterfacesIsnull" (optional.Bool) - 
     * @param "ChildInterfacesN" (optional.Interface of []string) - 
     * @param "Connected" (optional.Bool) -  Connected status (bool)
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) -  Device (name)
     * @param "DeviceId" (optional.Interface of []string) -  Device (ID)
     * @param "DeviceWithCommonVc" (optional.Interface of string) -  Virtual Chassis member Device (ID)
     * @param "Enabled" (optional.Bool) - 
     * @param "Format" (optional.String) - 
     * @param "HasBridgedInterfaces" (optional.Bool) -  Has bridged interfaces
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "HasChildInterfaces" (optional.Bool) -  Has child interfaces
     * @param "HasMemberInterfaces" (optional.Bool) -  Has member interfaces
     * @param "HasTaggedVlans" (optional.Bool) -  Has tagged VLANs
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "InterfaceRedundancyGroups" (optional.Interface of []string) - 
     * @param "InterfaceRedundancyGroupsIsnull" (optional.Bool) - 
     * @param "InterfaceRedundancyGroupsN" (optional.Interface of []string) - 
     * @param "Kind" (optional.String) -  Kind of interface
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Lag" (optional.Interface of []string) - 
     * @param "LagIsnull" (optional.Bool) - 
     * @param "LagN" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "MacAddress" (optional.Interface of []string) - 
     * @param "MacAddressIc" (optional.Interface of []string) - 
     * @param "MacAddressIe" (optional.Interface of []string) - 
     * @param "MacAddressIew" (optional.Interface of []string) - 
     * @param "MacAddressIre" (optional.Interface of []string) - 
     * @param "MacAddressIsw" (optional.Interface of []string) - 
     * @param "MacAddressN" (optional.Interface of []string) - 
     * @param "MacAddressNic" (optional.Interface of []string) - 
     * @param "MacAddressNie" (optional.Interface of []string) - 
     * @param "MacAddressNiew" (optional.Interface of []string) - 
     * @param "MacAddressNire" (optional.Interface of []string) - 
     * @param "MacAddressNisw" (optional.Interface of []string) - 
     * @param "MacAddressNre" (optional.Interface of []string) - 
     * @param "MacAddressRe" (optional.Interface of []string) - 
     * @param "MemberInterfaces" (optional.Interface of []string) - 
     * @param "MemberInterfacesIsnull" (optional.Bool) - 
     * @param "MemberInterfacesN" (optional.Interface of []string) - 
     * @param "MgmtOnly" (optional.Bool) - 
     * @param "Mode" (optional.Interface of []string) - 
     * @param "ModeIc" (optional.Interface of []string) - 
     * @param "ModeIe" (optional.Interface of []string) - 
     * @param "ModeIew" (optional.Interface of []string) - 
     * @param "ModeIre" (optional.Interface of []string) - 
     * @param "ModeIsw" (optional.Interface of []string) - 
     * @param "ModeN" (optional.Interface of []string) - 
     * @param "ModeNic" (optional.Interface of []string) - 
     * @param "ModeNie" (optional.Interface of []string) - 
     * @param "ModeNiew" (optional.Interface of []string) - 
     * @param "ModeNire" (optional.Interface of []string) - 
     * @param "ModeNisw" (optional.Interface of []string) - 
     * @param "ModeNre" (optional.Interface of []string) - 
     * @param "ModeRe" (optional.Interface of []string) - 
     * @param "Mtu" (optional.Interface of []int32) - 
     * @param "MtuGt" (optional.Interface of []int32) - 
     * @param "MtuGte" (optional.Interface of []int32) - 
     * @param "MtuIsnull" (optional.Bool) - 
     * @param "MtuLt" (optional.Interface of []int32) - 
     * @param "MtuLte" (optional.Interface of []int32) - 
     * @param "MtuN" (optional.Interface of []int32) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "ParentInterface" (optional.Interface of []string) - 
     * @param "ParentInterfaceIsnull" (optional.Bool) - 
     * @param "ParentInterfaceN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "TaggedVlans" (optional.Interface of []string) - 
     * @param "TaggedVlansN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "UntaggedVlan" (optional.Interface of []string) - 
     * @param "UntaggedVlanIsnull" (optional.Bool) - 
     * @param "UntaggedVlanN" (optional.Interface of []string) - 
     * @param "Vlan" (optional.Float64) -  Assigned VID
     * @param "VlanId" (optional.String) -  Assigned VLAN
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedInterfaceList
*/

type DcimApiDcimInterfacesListOpts struct {
    Bridge optional.Interface
    BridgeIsnull optional.Bool
    BridgeN optional.Interface
    BridgedInterfaces optional.Interface
    BridgedInterfacesIsnull optional.Bool
    BridgedInterfacesN optional.Interface
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    ChildInterfaces optional.Interface
    ChildInterfacesIsnull optional.Bool
    ChildInterfacesN optional.Interface
    Connected optional.Bool
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceId optional.Interface
    DeviceWithCommonVc optional.Interface
    Enabled optional.Bool
    Format optional.String
    HasBridgedInterfaces optional.Bool
    HasCable optional.Bool
    HasChildInterfaces optional.Bool
    HasMemberInterfaces optional.Bool
    HasTaggedVlans optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    InterfaceRedundancyGroups optional.Interface
    InterfaceRedundancyGroupsIsnull optional.Bool
    InterfaceRedundancyGroupsN optional.Interface
    Kind optional.String
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Lag optional.Interface
    LagIsnull optional.Bool
    LagN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    MacAddress optional.Interface
    MacAddressIc optional.Interface
    MacAddressIe optional.Interface
    MacAddressIew optional.Interface
    MacAddressIre optional.Interface
    MacAddressIsw optional.Interface
    MacAddressN optional.Interface
    MacAddressNic optional.Interface
    MacAddressNie optional.Interface
    MacAddressNiew optional.Interface
    MacAddressNire optional.Interface
    MacAddressNisw optional.Interface
    MacAddressNre optional.Interface
    MacAddressRe optional.Interface
    MemberInterfaces optional.Interface
    MemberInterfacesIsnull optional.Bool
    MemberInterfacesN optional.Interface
    MgmtOnly optional.Bool
    Mode optional.Interface
    ModeIc optional.Interface
    ModeIe optional.Interface
    ModeIew optional.Interface
    ModeIre optional.Interface
    ModeIsw optional.Interface
    ModeN optional.Interface
    ModeNic optional.Interface
    ModeNie optional.Interface
    ModeNiew optional.Interface
    ModeNire optional.Interface
    ModeNisw optional.Interface
    ModeNre optional.Interface
    ModeRe optional.Interface
    Mtu optional.Interface
    MtuGt optional.Interface
    MtuGte optional.Interface
    MtuIsnull optional.Bool
    MtuLt optional.Interface
    MtuLte optional.Interface
    MtuN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    ParentInterface optional.Interface
    ParentInterfaceIsnull optional.Bool
    ParentInterfaceN optional.Interface
    Q optional.String
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    TaggedVlans optional.Interface
    TaggedVlansN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    UntaggedVlan optional.Interface
    UntaggedVlanIsnull optional.Bool
    UntaggedVlanN optional.Interface
    Vlan optional.Float64
    VlanId optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfacesList(ctx context.Context, localVarOptionals *DcimApiDcimInterfacesListOpts) (PaginatedInterfaceList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedInterfaceList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Bridge.IsSet() {
		localVarQueryParams.Add("bridge", parameterToString(localVarOptionals.Bridge.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BridgeIsnull.IsSet() {
		localVarQueryParams.Add("bridge__isnull", parameterToString(localVarOptionals.BridgeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BridgeN.IsSet() {
		localVarQueryParams.Add("bridge__n", parameterToString(localVarOptionals.BridgeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BridgedInterfaces.IsSet() {
		localVarQueryParams.Add("bridged_interfaces", parameterToString(localVarOptionals.BridgedInterfaces.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.BridgedInterfacesIsnull.IsSet() {
		localVarQueryParams.Add("bridged_interfaces__isnull", parameterToString(localVarOptionals.BridgedInterfacesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BridgedInterfacesN.IsSet() {
		localVarQueryParams.Add("bridged_interfaces__n", parameterToString(localVarOptionals.BridgedInterfacesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChildInterfaces.IsSet() {
		localVarQueryParams.Add("child_interfaces", parameterToString(localVarOptionals.ChildInterfaces.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChildInterfacesIsnull.IsSet() {
		localVarQueryParams.Add("child_interfaces__isnull", parameterToString(localVarOptionals.ChildInterfacesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChildInterfacesN.IsSet() {
		localVarQueryParams.Add("child_interfaces__n", parameterToString(localVarOptionals.ChildInterfacesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Connected.IsSet() {
		localVarQueryParams.Add("connected", parameterToString(localVarOptionals.Connected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceWithCommonVc.IsSet() {
		localVarQueryParams.Add("device_with_common_vc", parameterToString(localVarOptionals.DeviceWithCommonVc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasBridgedInterfaces.IsSet() {
		localVarQueryParams.Add("has_bridged_interfaces", parameterToString(localVarOptionals.HasBridgedInterfaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasChildInterfaces.IsSet() {
		localVarQueryParams.Add("has_child_interfaces", parameterToString(localVarOptionals.HasChildInterfaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasMemberInterfaces.IsSet() {
		localVarQueryParams.Add("has_member_interfaces", parameterToString(localVarOptionals.HasMemberInterfaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasTaggedVlans.IsSet() {
		localVarQueryParams.Add("has_tagged_vlans", parameterToString(localVarOptionals.HasTaggedVlans.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceRedundancyGroups.IsSet() {
		localVarQueryParams.Add("interface_redundancy_groups", parameterToString(localVarOptionals.InterfaceRedundancyGroups.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceRedundancyGroupsIsnull.IsSet() {
		localVarQueryParams.Add("interface_redundancy_groups__isnull", parameterToString(localVarOptionals.InterfaceRedundancyGroupsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceRedundancyGroupsN.IsSet() {
		localVarQueryParams.Add("interface_redundancy_groups__n", parameterToString(localVarOptionals.InterfaceRedundancyGroupsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Kind.IsSet() {
		localVarQueryParams.Add("kind", parameterToString(localVarOptionals.Kind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Lag.IsSet() {
		localVarQueryParams.Add("lag", parameterToString(localVarOptionals.Lag.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LagIsnull.IsSet() {
		localVarQueryParams.Add("lag__isnull", parameterToString(localVarOptionals.LagIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagN.IsSet() {
		localVarQueryParams.Add("lag__n", parameterToString(localVarOptionals.LagN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddress.IsSet() {
		localVarQueryParams.Add("mac_address", parameterToString(localVarOptionals.MacAddress.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIc.IsSet() {
		localVarQueryParams.Add("mac_address__ic", parameterToString(localVarOptionals.MacAddressIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIe.IsSet() {
		localVarQueryParams.Add("mac_address__ie", parameterToString(localVarOptionals.MacAddressIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIew.IsSet() {
		localVarQueryParams.Add("mac_address__iew", parameterToString(localVarOptionals.MacAddressIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIre.IsSet() {
		localVarQueryParams.Add("mac_address__ire", parameterToString(localVarOptionals.MacAddressIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressIsw.IsSet() {
		localVarQueryParams.Add("mac_address__isw", parameterToString(localVarOptionals.MacAddressIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressN.IsSet() {
		localVarQueryParams.Add("mac_address__n", parameterToString(localVarOptionals.MacAddressN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNic.IsSet() {
		localVarQueryParams.Add("mac_address__nic", parameterToString(localVarOptionals.MacAddressNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNie.IsSet() {
		localVarQueryParams.Add("mac_address__nie", parameterToString(localVarOptionals.MacAddressNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNiew.IsSet() {
		localVarQueryParams.Add("mac_address__niew", parameterToString(localVarOptionals.MacAddressNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNire.IsSet() {
		localVarQueryParams.Add("mac_address__nire", parameterToString(localVarOptionals.MacAddressNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNisw.IsSet() {
		localVarQueryParams.Add("mac_address__nisw", parameterToString(localVarOptionals.MacAddressNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressNre.IsSet() {
		localVarQueryParams.Add("mac_address__nre", parameterToString(localVarOptionals.MacAddressNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddressRe.IsSet() {
		localVarQueryParams.Add("mac_address__re", parameterToString(localVarOptionals.MacAddressRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MemberInterfaces.IsSet() {
		localVarQueryParams.Add("member_interfaces", parameterToString(localVarOptionals.MemberInterfaces.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MemberInterfacesIsnull.IsSet() {
		localVarQueryParams.Add("member_interfaces__isnull", parameterToString(localVarOptionals.MemberInterfacesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MemberInterfacesN.IsSet() {
		localVarQueryParams.Add("member_interfaces__n", parameterToString(localVarOptionals.MemberInterfacesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MgmtOnly.IsSet() {
		localVarQueryParams.Add("mgmt_only", parameterToString(localVarOptionals.MgmtOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarQueryParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeIc.IsSet() {
		localVarQueryParams.Add("mode__ic", parameterToString(localVarOptionals.ModeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeIe.IsSet() {
		localVarQueryParams.Add("mode__ie", parameterToString(localVarOptionals.ModeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeIew.IsSet() {
		localVarQueryParams.Add("mode__iew", parameterToString(localVarOptionals.ModeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeIre.IsSet() {
		localVarQueryParams.Add("mode__ire", parameterToString(localVarOptionals.ModeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeIsw.IsSet() {
		localVarQueryParams.Add("mode__isw", parameterToString(localVarOptionals.ModeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeN.IsSet() {
		localVarQueryParams.Add("mode__n", parameterToString(localVarOptionals.ModeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeNic.IsSet() {
		localVarQueryParams.Add("mode__nic", parameterToString(localVarOptionals.ModeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeNie.IsSet() {
		localVarQueryParams.Add("mode__nie", parameterToString(localVarOptionals.ModeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeNiew.IsSet() {
		localVarQueryParams.Add("mode__niew", parameterToString(localVarOptionals.ModeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeNire.IsSet() {
		localVarQueryParams.Add("mode__nire", parameterToString(localVarOptionals.ModeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeNisw.IsSet() {
		localVarQueryParams.Add("mode__nisw", parameterToString(localVarOptionals.ModeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeNre.IsSet() {
		localVarQueryParams.Add("mode__nre", parameterToString(localVarOptionals.ModeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ModeRe.IsSet() {
		localVarQueryParams.Add("mode__re", parameterToString(localVarOptionals.ModeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Mtu.IsSet() {
		localVarQueryParams.Add("mtu", parameterToString(localVarOptionals.Mtu.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MtuGt.IsSet() {
		localVarQueryParams.Add("mtu__gt", parameterToString(localVarOptionals.MtuGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MtuGte.IsSet() {
		localVarQueryParams.Add("mtu__gte", parameterToString(localVarOptionals.MtuGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MtuIsnull.IsSet() {
		localVarQueryParams.Add("mtu__isnull", parameterToString(localVarOptionals.MtuIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MtuLt.IsSet() {
		localVarQueryParams.Add("mtu__lt", parameterToString(localVarOptionals.MtuLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MtuLte.IsSet() {
		localVarQueryParams.Add("mtu__lte", parameterToString(localVarOptionals.MtuLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MtuN.IsSet() {
		localVarQueryParams.Add("mtu__n", parameterToString(localVarOptionals.MtuN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentInterface.IsSet() {
		localVarQueryParams.Add("parent_interface", parameterToString(localVarOptionals.ParentInterface.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentInterfaceIsnull.IsSet() {
		localVarQueryParams.Add("parent_interface__isnull", parameterToString(localVarOptionals.ParentInterfaceIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentInterfaceN.IsSet() {
		localVarQueryParams.Add("parent_interface__n", parameterToString(localVarOptionals.ParentInterfaceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TaggedVlans.IsSet() {
		localVarQueryParams.Add("tagged_vlans", parameterToString(localVarOptionals.TaggedVlans.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TaggedVlansN.IsSet() {
		localVarQueryParams.Add("tagged_vlans__n", parameterToString(localVarOptionals.TaggedVlansN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UntaggedVlan.IsSet() {
		localVarQueryParams.Add("untagged_vlan", parameterToString(localVarOptionals.UntaggedVlan.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UntaggedVlanIsnull.IsSet() {
		localVarQueryParams.Add("untagged_vlan__isnull", parameterToString(localVarOptionals.UntaggedVlanIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UntaggedVlanN.IsSet() {
		localVarQueryParams.Add("untagged_vlan__n", parameterToString(localVarOptionals.UntaggedVlanN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Vlan.IsSet() {
		localVarQueryParams.Add("vlan", parameterToString(localVarOptionals.Vlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanId.IsSet() {
		localVarQueryParams.Add("vlan_id", parameterToString(localVarOptionals.VlanId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedInterfaceList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this interface.
 * @param optional nil or *DcimApiDcimInterfacesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimInterfacesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfacesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimInterfacesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface.
 * @param optional nil or *DcimApiDcimInterfacesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimInterfacesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfacesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfacesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a interface object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface.
 * @param optional nil or *DcimApiDcimInterfacesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableInterfaceRequest) - 
     * @param "Format" (optional.String) - 
@return ModelInterface
*/

type DcimApiDcimInterfacesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimInterfacesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfacesPartialUpdateOpts) (ModelInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ModelInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ModelInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a interface object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface.
 * @param optional nil or *DcimApiDcimInterfacesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ModelInterface
*/

type DcimApiDcimInterfacesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfacesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfacesRetrieveOpts) (ModelInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ModelInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ModelInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this interface.
 * @param optional nil or *DcimApiDcimInterfacesTraceRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ModelInterface
*/

type DcimApiDcimInterfacesTraceRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInterfacesTraceRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimInterfacesTraceRetrieveOpts) (ModelInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ModelInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ModelInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a interface object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this interface.
 * @param optional nil or *DcimApiDcimInterfacesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ModelInterface
*/

type DcimApiDcimInterfacesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInterfacesUpdate(ctx context.Context, body WritableInterfaceRequest, id string, localVarOptionals *DcimApiDcimInterfacesUpdateOpts) (ModelInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ModelInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/interfaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ModelInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of inventory item objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInventoryItemsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInventoryItemsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInventoryItemsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimInventoryItemsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of inventory item objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInventoryItemsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []InventoryItem
*/

type DcimApiDcimInventoryItemsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInventoryItemsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableInventoryItemRequest, localVarOptionals *DcimApiDcimInventoryItemsBulkPartialUpdateOpts) ([]InventoryItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InventoryItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InventoryItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of inventory item objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInventoryItemsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []InventoryItem
*/

type DcimApiDcimInventoryItemsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInventoryItemsBulkUpdate(ctx context.Context, body []BulkWritableInventoryItemRequest, localVarOptionals *DcimApiDcimInventoryItemsBulkUpdateOpts) ([]InventoryItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InventoryItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InventoryItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more inventory item objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimInventoryItemsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return InventoryItem
*/

type DcimApiDcimInventoryItemsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInventoryItemsCreate(ctx context.Context, body InventoryItemRequest, localVarOptionals *DcimApiDcimInventoryItemsCreateOpts) (InventoryItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InventoryItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v InventoryItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a inventory item object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this inventory item.
 * @param optional nil or *DcimApiDcimInventoryItemsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimInventoryItemsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInventoryItemsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimInventoryItemsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of inventory item objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimInventoryItemsListOpts - Optional Parameters:
     * @param "AssetTag" (optional.Interface of []string) - 
     * @param "AssetTagIc" (optional.Interface of []string) - 
     * @param "AssetTagIe" (optional.Interface of []string) - 
     * @param "AssetTagIew" (optional.Interface of []string) - 
     * @param "AssetTagIre" (optional.Interface of []string) - 
     * @param "AssetTagIsnull" (optional.Bool) - 
     * @param "AssetTagIsw" (optional.Interface of []string) - 
     * @param "AssetTagN" (optional.Interface of []string) - 
     * @param "AssetTagNic" (optional.Interface of []string) - 
     * @param "AssetTagNie" (optional.Interface of []string) - 
     * @param "AssetTagNiew" (optional.Interface of []string) - 
     * @param "AssetTagNire" (optional.Interface of []string) - 
     * @param "AssetTagNisw" (optional.Interface of []string) - 
     * @param "AssetTagNre" (optional.Interface of []string) - 
     * @param "AssetTagRe" (optional.Interface of []string) - 
     * @param "Children" (optional.Interface of []string) - 
     * @param "ChildrenIsnull" (optional.Bool) - 
     * @param "ChildrenN" (optional.Interface of []string) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) - 
     * @param "DeviceN" (optional.Interface of []string) - 
     * @param "Discovered" (optional.Bool) - 
     * @param "Format" (optional.String) - 
     * @param "HasChildren" (optional.Bool) -  Has child items
     * @param "HasSoftwareImageFiles" (optional.Bool) -  Has software image files
     * @param "HasSoftwareVersion" (optional.Bool) -  Has software version
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Manufacturer" (optional.Interface of []string) - 
     * @param "ManufacturerIsnull" (optional.Bool) - 
     * @param "ManufacturerN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Parent" (optional.Interface of []string) - 
     * @param "ParentIsnull" (optional.Bool) - 
     * @param "ParentN" (optional.Interface of []string) - 
     * @param "PartId" (optional.Interface of []string) - 
     * @param "PartIdIc" (optional.Interface of []string) - 
     * @param "PartIdIe" (optional.Interface of []string) - 
     * @param "PartIdIew" (optional.Interface of []string) - 
     * @param "PartIdIre" (optional.Interface of []string) - 
     * @param "PartIdIsw" (optional.Interface of []string) - 
     * @param "PartIdN" (optional.Interface of []string) - 
     * @param "PartIdNic" (optional.Interface of []string) - 
     * @param "PartIdNie" (optional.Interface of []string) - 
     * @param "PartIdNiew" (optional.Interface of []string) - 
     * @param "PartIdNire" (optional.Interface of []string) - 
     * @param "PartIdNisw" (optional.Interface of []string) - 
     * @param "PartIdNre" (optional.Interface of []string) - 
     * @param "PartIdRe" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Serial" (optional.Interface of []string) - 
     * @param "SoftwareImageFiles" (optional.Interface of []string) - 
     * @param "SoftwareImageFilesN" (optional.Interface of []string) - 
     * @param "SoftwareVersion" (optional.Interface of []string) - 
     * @param "SoftwareVersionIsnull" (optional.Bool) - 
     * @param "SoftwareVersionN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedInventoryItemList
*/

type DcimApiDcimInventoryItemsListOpts struct {
    AssetTag optional.Interface
    AssetTagIc optional.Interface
    AssetTagIe optional.Interface
    AssetTagIew optional.Interface
    AssetTagIre optional.Interface
    AssetTagIsnull optional.Bool
    AssetTagIsw optional.Interface
    AssetTagN optional.Interface
    AssetTagNic optional.Interface
    AssetTagNie optional.Interface
    AssetTagNiew optional.Interface
    AssetTagNire optional.Interface
    AssetTagNisw optional.Interface
    AssetTagNre optional.Interface
    AssetTagRe optional.Interface
    Children optional.Interface
    ChildrenIsnull optional.Bool
    ChildrenN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceN optional.Interface
    Discovered optional.Bool
    Format optional.String
    HasChildren optional.Bool
    HasSoftwareImageFiles optional.Bool
    HasSoftwareVersion optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Manufacturer optional.Interface
    ManufacturerIsnull optional.Bool
    ManufacturerN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Parent optional.Interface
    ParentIsnull optional.Bool
    ParentN optional.Interface
    PartId optional.Interface
    PartIdIc optional.Interface
    PartIdIe optional.Interface
    PartIdIew optional.Interface
    PartIdIre optional.Interface
    PartIdIsw optional.Interface
    PartIdN optional.Interface
    PartIdNic optional.Interface
    PartIdNie optional.Interface
    PartIdNiew optional.Interface
    PartIdNire optional.Interface
    PartIdNisw optional.Interface
    PartIdNre optional.Interface
    PartIdRe optional.Interface
    Q optional.String
    Serial optional.Interface
    SoftwareImageFiles optional.Interface
    SoftwareImageFilesN optional.Interface
    SoftwareVersion optional.Interface
    SoftwareVersionIsnull optional.Bool
    SoftwareVersionN optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimInventoryItemsList(ctx context.Context, localVarOptionals *DcimApiDcimInventoryItemsListOpts) (PaginatedInventoryItemList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedInventoryItemList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AssetTag.IsSet() {
		localVarQueryParams.Add("asset_tag", parameterToString(localVarOptionals.AssetTag.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIc.IsSet() {
		localVarQueryParams.Add("asset_tag__ic", parameterToString(localVarOptionals.AssetTagIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIe.IsSet() {
		localVarQueryParams.Add("asset_tag__ie", parameterToString(localVarOptionals.AssetTagIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIew.IsSet() {
		localVarQueryParams.Add("asset_tag__iew", parameterToString(localVarOptionals.AssetTagIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIre.IsSet() {
		localVarQueryParams.Add("asset_tag__ire", parameterToString(localVarOptionals.AssetTagIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIsnull.IsSet() {
		localVarQueryParams.Add("asset_tag__isnull", parameterToString(localVarOptionals.AssetTagIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIsw.IsSet() {
		localVarQueryParams.Add("asset_tag__isw", parameterToString(localVarOptionals.AssetTagIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagN.IsSet() {
		localVarQueryParams.Add("asset_tag__n", parameterToString(localVarOptionals.AssetTagN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNic.IsSet() {
		localVarQueryParams.Add("asset_tag__nic", parameterToString(localVarOptionals.AssetTagNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNie.IsSet() {
		localVarQueryParams.Add("asset_tag__nie", parameterToString(localVarOptionals.AssetTagNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNiew.IsSet() {
		localVarQueryParams.Add("asset_tag__niew", parameterToString(localVarOptionals.AssetTagNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNire.IsSet() {
		localVarQueryParams.Add("asset_tag__nire", parameterToString(localVarOptionals.AssetTagNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNisw.IsSet() {
		localVarQueryParams.Add("asset_tag__nisw", parameterToString(localVarOptionals.AssetTagNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNre.IsSet() {
		localVarQueryParams.Add("asset_tag__nre", parameterToString(localVarOptionals.AssetTagNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagRe.IsSet() {
		localVarQueryParams.Add("asset_tag__re", parameterToString(localVarOptionals.AssetTagRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Children.IsSet() {
		localVarQueryParams.Add("children", parameterToString(localVarOptionals.Children.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChildrenIsnull.IsSet() {
		localVarQueryParams.Add("children__isnull", parameterToString(localVarOptionals.ChildrenIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChildrenN.IsSet() {
		localVarQueryParams.Add("children__n", parameterToString(localVarOptionals.ChildrenN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceN.IsSet() {
		localVarQueryParams.Add("device__n", parameterToString(localVarOptionals.DeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Discovered.IsSet() {
		localVarQueryParams.Add("discovered", parameterToString(localVarOptionals.Discovered.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasChildren.IsSet() {
		localVarQueryParams.Add("has_children", parameterToString(localVarOptionals.HasChildren.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSoftwareImageFiles.IsSet() {
		localVarQueryParams.Add("has_software_image_files", parameterToString(localVarOptionals.HasSoftwareImageFiles.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSoftwareVersion.IsSet() {
		localVarQueryParams.Add("has_software_version", parameterToString(localVarOptionals.HasSoftwareVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarQueryParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ManufacturerIsnull.IsSet() {
		localVarQueryParams.Add("manufacturer__isnull", parameterToString(localVarOptionals.ManufacturerIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ManufacturerN.IsSet() {
		localVarQueryParams.Add("manufacturer__n", parameterToString(localVarOptionals.ManufacturerN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parent.IsSet() {
		localVarQueryParams.Add("parent", parameterToString(localVarOptionals.Parent.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentIsnull.IsSet() {
		localVarQueryParams.Add("parent__isnull", parameterToString(localVarOptionals.ParentIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentN.IsSet() {
		localVarQueryParams.Add("parent__n", parameterToString(localVarOptionals.ParentN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartId.IsSet() {
		localVarQueryParams.Add("part_id", parameterToString(localVarOptionals.PartId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdIc.IsSet() {
		localVarQueryParams.Add("part_id__ic", parameterToString(localVarOptionals.PartIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdIe.IsSet() {
		localVarQueryParams.Add("part_id__ie", parameterToString(localVarOptionals.PartIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdIew.IsSet() {
		localVarQueryParams.Add("part_id__iew", parameterToString(localVarOptionals.PartIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdIre.IsSet() {
		localVarQueryParams.Add("part_id__ire", parameterToString(localVarOptionals.PartIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdIsw.IsSet() {
		localVarQueryParams.Add("part_id__isw", parameterToString(localVarOptionals.PartIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdN.IsSet() {
		localVarQueryParams.Add("part_id__n", parameterToString(localVarOptionals.PartIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdNic.IsSet() {
		localVarQueryParams.Add("part_id__nic", parameterToString(localVarOptionals.PartIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdNie.IsSet() {
		localVarQueryParams.Add("part_id__nie", parameterToString(localVarOptionals.PartIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdNiew.IsSet() {
		localVarQueryParams.Add("part_id__niew", parameterToString(localVarOptionals.PartIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdNire.IsSet() {
		localVarQueryParams.Add("part_id__nire", parameterToString(localVarOptionals.PartIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdNisw.IsSet() {
		localVarQueryParams.Add("part_id__nisw", parameterToString(localVarOptionals.PartIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdNre.IsSet() {
		localVarQueryParams.Add("part_id__nre", parameterToString(localVarOptionals.PartIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PartIdRe.IsSet() {
		localVarQueryParams.Add("part_id__re", parameterToString(localVarOptionals.PartIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Serial.IsSet() {
		localVarQueryParams.Add("serial", parameterToString(localVarOptionals.Serial.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFiles.IsSet() {
		localVarQueryParams.Add("software_image_files", parameterToString(localVarOptionals.SoftwareImageFiles.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFilesN.IsSet() {
		localVarQueryParams.Add("software_image_files__n", parameterToString(localVarOptionals.SoftwareImageFilesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareVersion.IsSet() {
		localVarQueryParams.Add("software_version", parameterToString(localVarOptionals.SoftwareVersion.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareVersionIsnull.IsSet() {
		localVarQueryParams.Add("software_version__isnull", parameterToString(localVarOptionals.SoftwareVersionIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareVersionN.IsSet() {
		localVarQueryParams.Add("software_version__n", parameterToString(localVarOptionals.SoftwareVersionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedInventoryItemList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this inventory item.
 * @param optional nil or *DcimApiDcimInventoryItemsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimInventoryItemsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInventoryItemsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimInventoryItemsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this inventory item.
 * @param optional nil or *DcimApiDcimInventoryItemsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimInventoryItemsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimInventoryItemsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimInventoryItemsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a inventory item object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this inventory item.
 * @param optional nil or *DcimApiDcimInventoryItemsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedInventoryItemRequest) - 
     * @param "Format" (optional.String) - 
@return InventoryItem
*/

type DcimApiDcimInventoryItemsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimInventoryItemsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimInventoryItemsPartialUpdateOpts) (InventoryItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InventoryItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InventoryItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a inventory item object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this inventory item.
 * @param optional nil or *DcimApiDcimInventoryItemsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return InventoryItem
*/

type DcimApiDcimInventoryItemsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimInventoryItemsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimInventoryItemsRetrieveOpts) (InventoryItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InventoryItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InventoryItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a inventory item object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this inventory item.
 * @param optional nil or *DcimApiDcimInventoryItemsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return InventoryItem
*/

type DcimApiDcimInventoryItemsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimInventoryItemsUpdate(ctx context.Context, body InventoryItemRequest, id string, localVarOptionals *DcimApiDcimInventoryItemsUpdateOpts) (InventoryItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InventoryItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/inventory-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v InventoryItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of location type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimLocationTypesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimLocationTypesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationTypesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimLocationTypesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of location type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimLocationTypesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []LocationType
*/

type DcimApiDcimLocationTypesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationTypesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableLocationTypeRequest, localVarOptionals *DcimApiDcimLocationTypesBulkPartialUpdateOpts) ([]LocationType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []LocationType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []LocationType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of location type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimLocationTypesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []LocationType
*/

type DcimApiDcimLocationTypesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationTypesBulkUpdate(ctx context.Context, body []BulkWritableLocationTypeRequest, localVarOptionals *DcimApiDcimLocationTypesBulkUpdateOpts) ([]LocationType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []LocationType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []LocationType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more location type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimLocationTypesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return LocationType
*/

type DcimApiDcimLocationTypesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationTypesCreate(ctx context.Context, body LocationTypeRequest, localVarOptionals *DcimApiDcimLocationTypesCreateOpts) (LocationType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v LocationType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a location type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this location type.
 * @param optional nil or *DcimApiDcimLocationTypesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimLocationTypesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationTypesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimLocationTypesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of location type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimLocationTypesListOpts - Optional Parameters:
     * @param "ContentTypes" (optional.Interface of []int32) - 
     * @param "ContentTypesIc" (optional.Interface of []int32) - 
     * @param "ContentTypesIe" (optional.Interface of []int32) - 
     * @param "ContentTypesIew" (optional.Interface of []int32) - 
     * @param "ContentTypesIre" (optional.Interface of []int32) - 
     * @param "ContentTypesIsw" (optional.Interface of []int32) - 
     * @param "ContentTypesN" (optional.Interface of []int32) - 
     * @param "ContentTypesNic" (optional.Interface of []int32) - 
     * @param "ContentTypesNie" (optional.Interface of []int32) - 
     * @param "ContentTypesNiew" (optional.Interface of []int32) - 
     * @param "ContentTypesNire" (optional.Interface of []int32) - 
     * @param "ContentTypesNisw" (optional.Interface of []int32) - 
     * @param "ContentTypesNre" (optional.Interface of []int32) - 
     * @param "ContentTypesRe" (optional.Interface of []int32) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Nestable" (optional.Bool) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Parent" (optional.Interface of []string) - 
     * @param "ParentIsnull" (optional.Bool) - 
     * @param "ParentN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedLocationTypeList
*/

type DcimApiDcimLocationTypesListOpts struct {
    ContentTypes optional.Interface
    ContentTypesIc optional.Interface
    ContentTypesIe optional.Interface
    ContentTypesIew optional.Interface
    ContentTypesIre optional.Interface
    ContentTypesIsw optional.Interface
    ContentTypesN optional.Interface
    ContentTypesNic optional.Interface
    ContentTypesNie optional.Interface
    ContentTypesNiew optional.Interface
    ContentTypesNire optional.Interface
    ContentTypesNisw optional.Interface
    ContentTypesNre optional.Interface
    ContentTypesRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Nestable optional.Bool
    Offset optional.Int32
    Parent optional.Interface
    ParentIsnull optional.Bool
    ParentN optional.Interface
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimLocationTypesList(ctx context.Context, localVarOptionals *DcimApiDcimLocationTypesListOpts) (PaginatedLocationTypeList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedLocationTypeList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentTypes.IsSet() {
		localVarQueryParams.Add("content_types", parameterToString(localVarOptionals.ContentTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIc.IsSet() {
		localVarQueryParams.Add("content_types__ic", parameterToString(localVarOptionals.ContentTypesIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIe.IsSet() {
		localVarQueryParams.Add("content_types__ie", parameterToString(localVarOptionals.ContentTypesIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIew.IsSet() {
		localVarQueryParams.Add("content_types__iew", parameterToString(localVarOptionals.ContentTypesIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIre.IsSet() {
		localVarQueryParams.Add("content_types__ire", parameterToString(localVarOptionals.ContentTypesIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesIsw.IsSet() {
		localVarQueryParams.Add("content_types__isw", parameterToString(localVarOptionals.ContentTypesIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesN.IsSet() {
		localVarQueryParams.Add("content_types__n", parameterToString(localVarOptionals.ContentTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNic.IsSet() {
		localVarQueryParams.Add("content_types__nic", parameterToString(localVarOptionals.ContentTypesNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNie.IsSet() {
		localVarQueryParams.Add("content_types__nie", parameterToString(localVarOptionals.ContentTypesNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNiew.IsSet() {
		localVarQueryParams.Add("content_types__niew", parameterToString(localVarOptionals.ContentTypesNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNire.IsSet() {
		localVarQueryParams.Add("content_types__nire", parameterToString(localVarOptionals.ContentTypesNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNisw.IsSet() {
		localVarQueryParams.Add("content_types__nisw", parameterToString(localVarOptionals.ContentTypesNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesNre.IsSet() {
		localVarQueryParams.Add("content_types__nre", parameterToString(localVarOptionals.ContentTypesNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypesRe.IsSet() {
		localVarQueryParams.Add("content_types__re", parameterToString(localVarOptionals.ContentTypesRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Nestable.IsSet() {
		localVarQueryParams.Add("nestable", parameterToString(localVarOptionals.Nestable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parent.IsSet() {
		localVarQueryParams.Add("parent", parameterToString(localVarOptionals.Parent.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentIsnull.IsSet() {
		localVarQueryParams.Add("parent__isnull", parameterToString(localVarOptionals.ParentIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentN.IsSet() {
		localVarQueryParams.Add("parent__n", parameterToString(localVarOptionals.ParentN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedLocationTypeList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this location type.
 * @param optional nil or *DcimApiDcimLocationTypesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimLocationTypesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationTypesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimLocationTypesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this location type.
 * @param optional nil or *DcimApiDcimLocationTypesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimLocationTypesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimLocationTypesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimLocationTypesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a location type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this location type.
 * @param optional nil or *DcimApiDcimLocationTypesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedLocationTypeRequest) - 
     * @param "Format" (optional.String) - 
@return LocationType
*/

type DcimApiDcimLocationTypesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimLocationTypesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimLocationTypesPartialUpdateOpts) (LocationType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a location type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this location type.
 * @param optional nil or *DcimApiDcimLocationTypesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return LocationType
*/

type DcimApiDcimLocationTypesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimLocationTypesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimLocationTypesRetrieveOpts) (LocationType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a location type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this location type.
 * @param optional nil or *DcimApiDcimLocationTypesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return LocationType
*/

type DcimApiDcimLocationTypesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationTypesUpdate(ctx context.Context, body LocationTypeRequest, id string, localVarOptionals *DcimApiDcimLocationTypesUpdateOpts) (LocationType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/location-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of location objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimLocationsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimLocationsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimLocationsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of location objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimLocationsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Location
*/

type DcimApiDcimLocationsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableLocationRequest, localVarOptionals *DcimApiDcimLocationsBulkPartialUpdateOpts) ([]Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of location objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimLocationsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Location
*/

type DcimApiDcimLocationsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationsBulkUpdate(ctx context.Context, body []BulkWritableLocationRequest, localVarOptionals *DcimApiDcimLocationsBulkUpdateOpts) ([]Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more location objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimLocationsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Location
*/

type DcimApiDcimLocationsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationsCreate(ctx context.Context, body LocationRequest, localVarOptionals *DcimApiDcimLocationsCreateOpts) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a location object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this location.
 * @param optional nil or *DcimApiDcimLocationsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimLocationsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimLocationsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of location objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimLocationsListOpts - Optional Parameters:
     * @param "Asn" (optional.Interface of []int32) - 
     * @param "AsnGt" (optional.Interface of []int32) - 
     * @param "AsnGte" (optional.Interface of []int32) - 
     * @param "AsnIsnull" (optional.Bool) - 
     * @param "AsnLt" (optional.Interface of []int32) - 
     * @param "AsnLte" (optional.Interface of []int32) - 
     * @param "AsnN" (optional.Interface of []int32) - 
     * @param "ChildLocationType" (optional.Interface of []string) - 
     * @param "CircuitTerminations" (optional.Interface of []string) - 
     * @param "CircuitTerminationsIsnull" (optional.Bool) - 
     * @param "CircuitTerminationsN" (optional.Interface of []string) - 
     * @param "Clusters" (optional.Interface of []string) - 
     * @param "ClustersIsnull" (optional.Bool) - 
     * @param "ClustersN" (optional.Interface of []string) - 
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "ContactEmail" (optional.Interface of []string) - 
     * @param "ContactEmailIc" (optional.Interface of []string) - 
     * @param "ContactEmailIe" (optional.Interface of []string) - 
     * @param "ContactEmailIew" (optional.Interface of []string) - 
     * @param "ContactEmailIre" (optional.Interface of []string) - 
     * @param "ContactEmailIsw" (optional.Interface of []string) - 
     * @param "ContactEmailN" (optional.Interface of []string) - 
     * @param "ContactEmailNic" (optional.Interface of []string) - 
     * @param "ContactEmailNie" (optional.Interface of []string) - 
     * @param "ContactEmailNiew" (optional.Interface of []string) - 
     * @param "ContactEmailNire" (optional.Interface of []string) - 
     * @param "ContactEmailNisw" (optional.Interface of []string) - 
     * @param "ContactEmailNre" (optional.Interface of []string) - 
     * @param "ContactEmailRe" (optional.Interface of []string) - 
     * @param "ContactName" (optional.Interface of []string) - 
     * @param "ContactNameIc" (optional.Interface of []string) - 
     * @param "ContactNameIe" (optional.Interface of []string) - 
     * @param "ContactNameIew" (optional.Interface of []string) - 
     * @param "ContactNameIre" (optional.Interface of []string) - 
     * @param "ContactNameIsw" (optional.Interface of []string) - 
     * @param "ContactNameN" (optional.Interface of []string) - 
     * @param "ContactNameNic" (optional.Interface of []string) - 
     * @param "ContactNameNie" (optional.Interface of []string) - 
     * @param "ContactNameNiew" (optional.Interface of []string) - 
     * @param "ContactNameNire" (optional.Interface of []string) - 
     * @param "ContactNameNisw" (optional.Interface of []string) - 
     * @param "ContactNameNre" (optional.Interface of []string) - 
     * @param "ContactNameRe" (optional.Interface of []string) - 
     * @param "ContactPhone" (optional.Interface of []string) - 
     * @param "ContactPhoneIc" (optional.Interface of []string) - 
     * @param "ContactPhoneIe" (optional.Interface of []string) - 
     * @param "ContactPhoneIew" (optional.Interface of []string) - 
     * @param "ContactPhoneIre" (optional.Interface of []string) - 
     * @param "ContactPhoneIsw" (optional.Interface of []string) - 
     * @param "ContactPhoneN" (optional.Interface of []string) - 
     * @param "ContactPhoneNic" (optional.Interface of []string) - 
     * @param "ContactPhoneNie" (optional.Interface of []string) - 
     * @param "ContactPhoneNiew" (optional.Interface of []string) - 
     * @param "ContactPhoneNire" (optional.Interface of []string) - 
     * @param "ContactPhoneNisw" (optional.Interface of []string) - 
     * @param "ContactPhoneNre" (optional.Interface of []string) - 
     * @param "ContactPhoneRe" (optional.Interface of []string) - 
     * @param "ContentType" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeIc" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeIe" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeIew" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeIre" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeIsw" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeN" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeNic" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeNie" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeNiew" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeNire" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeNisw" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeNre" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "ContentTypeRe" (optional.Interface of []int32) -  Object types allowed to be associated with this Location Type
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Devices" (optional.Interface of []string) - 
     * @param "DevicesIsnull" (optional.Bool) - 
     * @param "DevicesN" (optional.Interface of []string) - 
     * @param "Facility" (optional.Interface of []string) - 
     * @param "FacilityIc" (optional.Interface of []string) - 
     * @param "FacilityIe" (optional.Interface of []string) - 
     * @param "FacilityIew" (optional.Interface of []string) - 
     * @param "FacilityIre" (optional.Interface of []string) - 
     * @param "FacilityIsw" (optional.Interface of []string) - 
     * @param "FacilityN" (optional.Interface of []string) - 
     * @param "FacilityNic" (optional.Interface of []string) - 
     * @param "FacilityNie" (optional.Interface of []string) - 
     * @param "FacilityNiew" (optional.Interface of []string) - 
     * @param "FacilityNire" (optional.Interface of []string) - 
     * @param "FacilityNisw" (optional.Interface of []string) - 
     * @param "FacilityNre" (optional.Interface of []string) - 
     * @param "FacilityRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCircuitTerminations" (optional.Bool) -  Has circuit terminations
     * @param "HasClusters" (optional.Bool) -  Has clusters
     * @param "HasDevices" (optional.Bool) -  Has devices
     * @param "HasPowerPanels" (optional.Bool) -  Has power panels
     * @param "HasPrefixes" (optional.Bool) -  Has prefixes
     * @param "HasRackGroups" (optional.Bool) -  Has rack groups
     * @param "HasRacks" (optional.Bool) -  Has racks
     * @param "HasVlanGroups" (optional.Bool) -  Has VLAN groups
     * @param "HasVlans" (optional.Bool) -  Has VLANs
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Latitude" (optional.Interface of []float64) - 
     * @param "LatitudeGt" (optional.Interface of []float64) - 
     * @param "LatitudeGte" (optional.Interface of []float64) - 
     * @param "LatitudeIsnull" (optional.Bool) - 
     * @param "LatitudeLt" (optional.Interface of []float64) - 
     * @param "LatitudeLte" (optional.Interface of []float64) - 
     * @param "LatitudeN" (optional.Interface of []float64) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "LocationType" (optional.Interface of []string) - 
     * @param "LocationTypeN" (optional.Interface of []string) - 
     * @param "Longitude" (optional.Interface of []float64) - 
     * @param "LongitudeGt" (optional.Interface of []float64) - 
     * @param "LongitudeGte" (optional.Interface of []float64) - 
     * @param "LongitudeIsnull" (optional.Bool) - 
     * @param "LongitudeLt" (optional.Interface of []float64) - 
     * @param "LongitudeLte" (optional.Interface of []float64) - 
     * @param "LongitudeN" (optional.Interface of []float64) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Parent" (optional.Interface of []string) - 
     * @param "ParentIsnull" (optional.Bool) - 
     * @param "ParentN" (optional.Interface of []string) - 
     * @param "PhysicalAddress" (optional.Interface of []string) - 
     * @param "PhysicalAddressIc" (optional.Interface of []string) - 
     * @param "PhysicalAddressIe" (optional.Interface of []string) - 
     * @param "PhysicalAddressIew" (optional.Interface of []string) - 
     * @param "PhysicalAddressIre" (optional.Interface of []string) - 
     * @param "PhysicalAddressIsw" (optional.Interface of []string) - 
     * @param "PhysicalAddressN" (optional.Interface of []string) - 
     * @param "PhysicalAddressNic" (optional.Interface of []string) - 
     * @param "PhysicalAddressNie" (optional.Interface of []string) - 
     * @param "PhysicalAddressNiew" (optional.Interface of []string) - 
     * @param "PhysicalAddressNire" (optional.Interface of []string) - 
     * @param "PhysicalAddressNisw" (optional.Interface of []string) - 
     * @param "PhysicalAddressNre" (optional.Interface of []string) - 
     * @param "PhysicalAddressRe" (optional.Interface of []string) - 
     * @param "PowerPanels" (optional.Interface of []string) - 
     * @param "PowerPanelsIsnull" (optional.Bool) - 
     * @param "PowerPanelsN" (optional.Interface of []string) - 
     * @param "Prefixes" (optional.Interface of []string) - 
     * @param "PrefixesIsnull" (optional.Bool) - 
     * @param "PrefixesN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "RackGroups" (optional.Interface of []string) - 
     * @param "RackGroupsIsnull" (optional.Bool) - 
     * @param "RackGroupsN" (optional.Interface of []string) - 
     * @param "Racks" (optional.Interface of []string) - 
     * @param "RacksIsnull" (optional.Bool) - 
     * @param "RacksN" (optional.Interface of []string) - 
     * @param "ShippingAddress" (optional.Interface of []string) - 
     * @param "ShippingAddressIc" (optional.Interface of []string) - 
     * @param "ShippingAddressIe" (optional.Interface of []string) - 
     * @param "ShippingAddressIew" (optional.Interface of []string) - 
     * @param "ShippingAddressIre" (optional.Interface of []string) - 
     * @param "ShippingAddressIsw" (optional.Interface of []string) - 
     * @param "ShippingAddressN" (optional.Interface of []string) - 
     * @param "ShippingAddressNic" (optional.Interface of []string) - 
     * @param "ShippingAddressNie" (optional.Interface of []string) - 
     * @param "ShippingAddressNiew" (optional.Interface of []string) - 
     * @param "ShippingAddressNire" (optional.Interface of []string) - 
     * @param "ShippingAddressNisw" (optional.Interface of []string) - 
     * @param "ShippingAddressNre" (optional.Interface of []string) - 
     * @param "ShippingAddressRe" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Subtree" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Tenant" (optional.Interface of []string) - 
     * @param "TenantIsnull" (optional.Bool) - 
     * @param "TenantN" (optional.Interface of []string) - 
     * @param "TenantGroup" (optional.Interface of []string) - 
     * @param "TenantGroupIsnull" (optional.Bool) - 
     * @param "TenantGroupN" (optional.Interface of []string) - 
     * @param "TenantId" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "TenantIdIsnull" (optional.Bool) - 
     * @param "TenantIdN" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "TimeZone" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneIc" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneIe" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneIew" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneIre" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneIsw" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneN" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneNic" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneNie" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneNiew" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneNire" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneNisw" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneNre" (optional.Interface of []string) -  Time zone  
     * @param "TimeZoneRe" (optional.Interface of []string) -  Time zone  
     * @param "VlanGroups" (optional.Interface of []string) - 
     * @param "VlanGroupsIsnull" (optional.Bool) - 
     * @param "VlanGroupsN" (optional.Interface of []string) - 
     * @param "Vlans" (optional.Interface of []string) - 
     * @param "VlansIsnull" (optional.Bool) - 
     * @param "VlansN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedLocationList
*/

type DcimApiDcimLocationsListOpts struct {
    Asn optional.Interface
    AsnGt optional.Interface
    AsnGte optional.Interface
    AsnIsnull optional.Bool
    AsnLt optional.Interface
    AsnLte optional.Interface
    AsnN optional.Interface
    ChildLocationType optional.Interface
    CircuitTerminations optional.Interface
    CircuitTerminationsIsnull optional.Bool
    CircuitTerminationsN optional.Interface
    Clusters optional.Interface
    ClustersIsnull optional.Bool
    ClustersN optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    ContactEmail optional.Interface
    ContactEmailIc optional.Interface
    ContactEmailIe optional.Interface
    ContactEmailIew optional.Interface
    ContactEmailIre optional.Interface
    ContactEmailIsw optional.Interface
    ContactEmailN optional.Interface
    ContactEmailNic optional.Interface
    ContactEmailNie optional.Interface
    ContactEmailNiew optional.Interface
    ContactEmailNire optional.Interface
    ContactEmailNisw optional.Interface
    ContactEmailNre optional.Interface
    ContactEmailRe optional.Interface
    ContactName optional.Interface
    ContactNameIc optional.Interface
    ContactNameIe optional.Interface
    ContactNameIew optional.Interface
    ContactNameIre optional.Interface
    ContactNameIsw optional.Interface
    ContactNameN optional.Interface
    ContactNameNic optional.Interface
    ContactNameNie optional.Interface
    ContactNameNiew optional.Interface
    ContactNameNire optional.Interface
    ContactNameNisw optional.Interface
    ContactNameNre optional.Interface
    ContactNameRe optional.Interface
    ContactPhone optional.Interface
    ContactPhoneIc optional.Interface
    ContactPhoneIe optional.Interface
    ContactPhoneIew optional.Interface
    ContactPhoneIre optional.Interface
    ContactPhoneIsw optional.Interface
    ContactPhoneN optional.Interface
    ContactPhoneNic optional.Interface
    ContactPhoneNie optional.Interface
    ContactPhoneNiew optional.Interface
    ContactPhoneNire optional.Interface
    ContactPhoneNisw optional.Interface
    ContactPhoneNre optional.Interface
    ContactPhoneRe optional.Interface
    ContentType optional.Interface
    ContentTypeIc optional.Interface
    ContentTypeIe optional.Interface
    ContentTypeIew optional.Interface
    ContentTypeIre optional.Interface
    ContentTypeIsw optional.Interface
    ContentTypeN optional.Interface
    ContentTypeNic optional.Interface
    ContentTypeNie optional.Interface
    ContentTypeNiew optional.Interface
    ContentTypeNire optional.Interface
    ContentTypeNisw optional.Interface
    ContentTypeNre optional.Interface
    ContentTypeRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Devices optional.Interface
    DevicesIsnull optional.Bool
    DevicesN optional.Interface
    Facility optional.Interface
    FacilityIc optional.Interface
    FacilityIe optional.Interface
    FacilityIew optional.Interface
    FacilityIre optional.Interface
    FacilityIsw optional.Interface
    FacilityN optional.Interface
    FacilityNic optional.Interface
    FacilityNie optional.Interface
    FacilityNiew optional.Interface
    FacilityNire optional.Interface
    FacilityNisw optional.Interface
    FacilityNre optional.Interface
    FacilityRe optional.Interface
    Format optional.String
    HasCircuitTerminations optional.Bool
    HasClusters optional.Bool
    HasDevices optional.Bool
    HasPowerPanels optional.Bool
    HasPrefixes optional.Bool
    HasRackGroups optional.Bool
    HasRacks optional.Bool
    HasVlanGroups optional.Bool
    HasVlans optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Latitude optional.Interface
    LatitudeGt optional.Interface
    LatitudeGte optional.Interface
    LatitudeIsnull optional.Bool
    LatitudeLt optional.Interface
    LatitudeLte optional.Interface
    LatitudeN optional.Interface
    Limit optional.Int32
    LocationType optional.Interface
    LocationTypeN optional.Interface
    Longitude optional.Interface
    LongitudeGt optional.Interface
    LongitudeGte optional.Interface
    LongitudeIsnull optional.Bool
    LongitudeLt optional.Interface
    LongitudeLte optional.Interface
    LongitudeN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Parent optional.Interface
    ParentIsnull optional.Bool
    ParentN optional.Interface
    PhysicalAddress optional.Interface
    PhysicalAddressIc optional.Interface
    PhysicalAddressIe optional.Interface
    PhysicalAddressIew optional.Interface
    PhysicalAddressIre optional.Interface
    PhysicalAddressIsw optional.Interface
    PhysicalAddressN optional.Interface
    PhysicalAddressNic optional.Interface
    PhysicalAddressNie optional.Interface
    PhysicalAddressNiew optional.Interface
    PhysicalAddressNire optional.Interface
    PhysicalAddressNisw optional.Interface
    PhysicalAddressNre optional.Interface
    PhysicalAddressRe optional.Interface
    PowerPanels optional.Interface
    PowerPanelsIsnull optional.Bool
    PowerPanelsN optional.Interface
    Prefixes optional.Interface
    PrefixesIsnull optional.Bool
    PrefixesN optional.Interface
    Q optional.String
    RackGroups optional.Interface
    RackGroupsIsnull optional.Bool
    RackGroupsN optional.Interface
    Racks optional.Interface
    RacksIsnull optional.Bool
    RacksN optional.Interface
    ShippingAddress optional.Interface
    ShippingAddressIc optional.Interface
    ShippingAddressIe optional.Interface
    ShippingAddressIew optional.Interface
    ShippingAddressIre optional.Interface
    ShippingAddressIsw optional.Interface
    ShippingAddressN optional.Interface
    ShippingAddressNic optional.Interface
    ShippingAddressNie optional.Interface
    ShippingAddressNiew optional.Interface
    ShippingAddressNire optional.Interface
    ShippingAddressNisw optional.Interface
    ShippingAddressNre optional.Interface
    ShippingAddressRe optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Subtree optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Tenant optional.Interface
    TenantIsnull optional.Bool
    TenantN optional.Interface
    TenantGroup optional.Interface
    TenantGroupIsnull optional.Bool
    TenantGroupN optional.Interface
    TenantId optional.Interface
    TenantIdIsnull optional.Bool
    TenantIdN optional.Interface
    TimeZone optional.Interface
    TimeZoneIc optional.Interface
    TimeZoneIe optional.Interface
    TimeZoneIew optional.Interface
    TimeZoneIre optional.Interface
    TimeZoneIsw optional.Interface
    TimeZoneN optional.Interface
    TimeZoneNic optional.Interface
    TimeZoneNie optional.Interface
    TimeZoneNiew optional.Interface
    TimeZoneNire optional.Interface
    TimeZoneNisw optional.Interface
    TimeZoneNre optional.Interface
    TimeZoneRe optional.Interface
    VlanGroups optional.Interface
    VlanGroupsIsnull optional.Bool
    VlanGroupsN optional.Interface
    Vlans optional.Interface
    VlansIsnull optional.Bool
    VlansN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimLocationsList(ctx context.Context, localVarOptionals *DcimApiDcimLocationsListOpts) (PaginatedLocationList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedLocationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Asn.IsSet() {
		localVarQueryParams.Add("asn", parameterToString(localVarOptionals.Asn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnGt.IsSet() {
		localVarQueryParams.Add("asn__gt", parameterToString(localVarOptionals.AsnGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnGte.IsSet() {
		localVarQueryParams.Add("asn__gte", parameterToString(localVarOptionals.AsnGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnIsnull.IsSet() {
		localVarQueryParams.Add("asn__isnull", parameterToString(localVarOptionals.AsnIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AsnLt.IsSet() {
		localVarQueryParams.Add("asn__lt", parameterToString(localVarOptionals.AsnLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnLte.IsSet() {
		localVarQueryParams.Add("asn__lte", parameterToString(localVarOptionals.AsnLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnN.IsSet() {
		localVarQueryParams.Add("asn__n", parameterToString(localVarOptionals.AsnN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChildLocationType.IsSet() {
		localVarQueryParams.Add("child_location_type", parameterToString(localVarOptionals.ChildLocationType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminations.IsSet() {
		localVarQueryParams.Add("circuit_terminations", parameterToString(localVarOptionals.CircuitTerminations.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationsIsnull.IsSet() {
		localVarQueryParams.Add("circuit_terminations__isnull", parameterToString(localVarOptionals.CircuitTerminationsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationsN.IsSet() {
		localVarQueryParams.Add("circuit_terminations__n", parameterToString(localVarOptionals.CircuitTerminationsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Clusters.IsSet() {
		localVarQueryParams.Add("clusters", parameterToString(localVarOptionals.Clusters.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ClustersIsnull.IsSet() {
		localVarQueryParams.Add("clusters__isnull", parameterToString(localVarOptionals.ClustersIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClustersN.IsSet() {
		localVarQueryParams.Add("clusters__n", parameterToString(localVarOptionals.ClustersN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmail.IsSet() {
		localVarQueryParams.Add("contact_email", parameterToString(localVarOptionals.ContactEmail.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailIc.IsSet() {
		localVarQueryParams.Add("contact_email__ic", parameterToString(localVarOptionals.ContactEmailIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailIe.IsSet() {
		localVarQueryParams.Add("contact_email__ie", parameterToString(localVarOptionals.ContactEmailIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailIew.IsSet() {
		localVarQueryParams.Add("contact_email__iew", parameterToString(localVarOptionals.ContactEmailIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailIre.IsSet() {
		localVarQueryParams.Add("contact_email__ire", parameterToString(localVarOptionals.ContactEmailIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailIsw.IsSet() {
		localVarQueryParams.Add("contact_email__isw", parameterToString(localVarOptionals.ContactEmailIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailN.IsSet() {
		localVarQueryParams.Add("contact_email__n", parameterToString(localVarOptionals.ContactEmailN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailNic.IsSet() {
		localVarQueryParams.Add("contact_email__nic", parameterToString(localVarOptionals.ContactEmailNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailNie.IsSet() {
		localVarQueryParams.Add("contact_email__nie", parameterToString(localVarOptionals.ContactEmailNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailNiew.IsSet() {
		localVarQueryParams.Add("contact_email__niew", parameterToString(localVarOptionals.ContactEmailNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailNire.IsSet() {
		localVarQueryParams.Add("contact_email__nire", parameterToString(localVarOptionals.ContactEmailNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailNisw.IsSet() {
		localVarQueryParams.Add("contact_email__nisw", parameterToString(localVarOptionals.ContactEmailNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailNre.IsSet() {
		localVarQueryParams.Add("contact_email__nre", parameterToString(localVarOptionals.ContactEmailNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactEmailRe.IsSet() {
		localVarQueryParams.Add("contact_email__re", parameterToString(localVarOptionals.ContactEmailRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactName.IsSet() {
		localVarQueryParams.Add("contact_name", parameterToString(localVarOptionals.ContactName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameIc.IsSet() {
		localVarQueryParams.Add("contact_name__ic", parameterToString(localVarOptionals.ContactNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameIe.IsSet() {
		localVarQueryParams.Add("contact_name__ie", parameterToString(localVarOptionals.ContactNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameIew.IsSet() {
		localVarQueryParams.Add("contact_name__iew", parameterToString(localVarOptionals.ContactNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameIre.IsSet() {
		localVarQueryParams.Add("contact_name__ire", parameterToString(localVarOptionals.ContactNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameIsw.IsSet() {
		localVarQueryParams.Add("contact_name__isw", parameterToString(localVarOptionals.ContactNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameN.IsSet() {
		localVarQueryParams.Add("contact_name__n", parameterToString(localVarOptionals.ContactNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameNic.IsSet() {
		localVarQueryParams.Add("contact_name__nic", parameterToString(localVarOptionals.ContactNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameNie.IsSet() {
		localVarQueryParams.Add("contact_name__nie", parameterToString(localVarOptionals.ContactNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameNiew.IsSet() {
		localVarQueryParams.Add("contact_name__niew", parameterToString(localVarOptionals.ContactNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameNire.IsSet() {
		localVarQueryParams.Add("contact_name__nire", parameterToString(localVarOptionals.ContactNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameNisw.IsSet() {
		localVarQueryParams.Add("contact_name__nisw", parameterToString(localVarOptionals.ContactNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameNre.IsSet() {
		localVarQueryParams.Add("contact_name__nre", parameterToString(localVarOptionals.ContactNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactNameRe.IsSet() {
		localVarQueryParams.Add("contact_name__re", parameterToString(localVarOptionals.ContactNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhone.IsSet() {
		localVarQueryParams.Add("contact_phone", parameterToString(localVarOptionals.ContactPhone.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneIc.IsSet() {
		localVarQueryParams.Add("contact_phone__ic", parameterToString(localVarOptionals.ContactPhoneIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneIe.IsSet() {
		localVarQueryParams.Add("contact_phone__ie", parameterToString(localVarOptionals.ContactPhoneIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneIew.IsSet() {
		localVarQueryParams.Add("contact_phone__iew", parameterToString(localVarOptionals.ContactPhoneIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneIre.IsSet() {
		localVarQueryParams.Add("contact_phone__ire", parameterToString(localVarOptionals.ContactPhoneIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneIsw.IsSet() {
		localVarQueryParams.Add("contact_phone__isw", parameterToString(localVarOptionals.ContactPhoneIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneN.IsSet() {
		localVarQueryParams.Add("contact_phone__n", parameterToString(localVarOptionals.ContactPhoneN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneNic.IsSet() {
		localVarQueryParams.Add("contact_phone__nic", parameterToString(localVarOptionals.ContactPhoneNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneNie.IsSet() {
		localVarQueryParams.Add("contact_phone__nie", parameterToString(localVarOptionals.ContactPhoneNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneNiew.IsSet() {
		localVarQueryParams.Add("contact_phone__niew", parameterToString(localVarOptionals.ContactPhoneNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneNire.IsSet() {
		localVarQueryParams.Add("contact_phone__nire", parameterToString(localVarOptionals.ContactPhoneNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneNisw.IsSet() {
		localVarQueryParams.Add("contact_phone__nisw", parameterToString(localVarOptionals.ContactPhoneNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneNre.IsSet() {
		localVarQueryParams.Add("contact_phone__nre", parameterToString(localVarOptionals.ContactPhoneNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContactPhoneRe.IsSet() {
		localVarQueryParams.Add("contact_phone__re", parameterToString(localVarOptionals.ContactPhoneRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentType.IsSet() {
		localVarQueryParams.Add("content_type", parameterToString(localVarOptionals.ContentType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeIc.IsSet() {
		localVarQueryParams.Add("content_type__ic", parameterToString(localVarOptionals.ContentTypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeIe.IsSet() {
		localVarQueryParams.Add("content_type__ie", parameterToString(localVarOptionals.ContentTypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeIew.IsSet() {
		localVarQueryParams.Add("content_type__iew", parameterToString(localVarOptionals.ContentTypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeIre.IsSet() {
		localVarQueryParams.Add("content_type__ire", parameterToString(localVarOptionals.ContentTypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeIsw.IsSet() {
		localVarQueryParams.Add("content_type__isw", parameterToString(localVarOptionals.ContentTypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeN.IsSet() {
		localVarQueryParams.Add("content_type__n", parameterToString(localVarOptionals.ContentTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeNic.IsSet() {
		localVarQueryParams.Add("content_type__nic", parameterToString(localVarOptionals.ContentTypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeNie.IsSet() {
		localVarQueryParams.Add("content_type__nie", parameterToString(localVarOptionals.ContentTypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeNiew.IsSet() {
		localVarQueryParams.Add("content_type__niew", parameterToString(localVarOptionals.ContentTypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeNire.IsSet() {
		localVarQueryParams.Add("content_type__nire", parameterToString(localVarOptionals.ContentTypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeNisw.IsSet() {
		localVarQueryParams.Add("content_type__nisw", parameterToString(localVarOptionals.ContentTypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeNre.IsSet() {
		localVarQueryParams.Add("content_type__nre", parameterToString(localVarOptionals.ContentTypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeRe.IsSet() {
		localVarQueryParams.Add("content_type__re", parameterToString(localVarOptionals.ContentTypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarQueryParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesIsnull.IsSet() {
		localVarQueryParams.Add("devices__isnull", parameterToString(localVarOptionals.DevicesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesN.IsSet() {
		localVarQueryParams.Add("devices__n", parameterToString(localVarOptionals.DevicesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Facility.IsSet() {
		localVarQueryParams.Add("facility", parameterToString(localVarOptionals.Facility.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIc.IsSet() {
		localVarQueryParams.Add("facility__ic", parameterToString(localVarOptionals.FacilityIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIe.IsSet() {
		localVarQueryParams.Add("facility__ie", parameterToString(localVarOptionals.FacilityIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIew.IsSet() {
		localVarQueryParams.Add("facility__iew", parameterToString(localVarOptionals.FacilityIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIre.IsSet() {
		localVarQueryParams.Add("facility__ire", parameterToString(localVarOptionals.FacilityIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIsw.IsSet() {
		localVarQueryParams.Add("facility__isw", parameterToString(localVarOptionals.FacilityIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityN.IsSet() {
		localVarQueryParams.Add("facility__n", parameterToString(localVarOptionals.FacilityN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityNic.IsSet() {
		localVarQueryParams.Add("facility__nic", parameterToString(localVarOptionals.FacilityNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityNie.IsSet() {
		localVarQueryParams.Add("facility__nie", parameterToString(localVarOptionals.FacilityNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityNiew.IsSet() {
		localVarQueryParams.Add("facility__niew", parameterToString(localVarOptionals.FacilityNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityNire.IsSet() {
		localVarQueryParams.Add("facility__nire", parameterToString(localVarOptionals.FacilityNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityNisw.IsSet() {
		localVarQueryParams.Add("facility__nisw", parameterToString(localVarOptionals.FacilityNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityNre.IsSet() {
		localVarQueryParams.Add("facility__nre", parameterToString(localVarOptionals.FacilityNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityRe.IsSet() {
		localVarQueryParams.Add("facility__re", parameterToString(localVarOptionals.FacilityRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCircuitTerminations.IsSet() {
		localVarQueryParams.Add("has_circuit_terminations", parameterToString(localVarOptionals.HasCircuitTerminations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasClusters.IsSet() {
		localVarQueryParams.Add("has_clusters", parameterToString(localVarOptionals.HasClusters.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDevices.IsSet() {
		localVarQueryParams.Add("has_devices", parameterToString(localVarOptionals.HasDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerPanels.IsSet() {
		localVarQueryParams.Add("has_power_panels", parameterToString(localVarOptionals.HasPowerPanels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPrefixes.IsSet() {
		localVarQueryParams.Add("has_prefixes", parameterToString(localVarOptionals.HasPrefixes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRackGroups.IsSet() {
		localVarQueryParams.Add("has_rack_groups", parameterToString(localVarOptionals.HasRackGroups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRacks.IsSet() {
		localVarQueryParams.Add("has_racks", parameterToString(localVarOptionals.HasRacks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasVlanGroups.IsSet() {
		localVarQueryParams.Add("has_vlan_groups", parameterToString(localVarOptionals.HasVlanGroups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasVlans.IsSet() {
		localVarQueryParams.Add("has_vlans", parameterToString(localVarOptionals.HasVlans.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Latitude.IsSet() {
		localVarQueryParams.Add("latitude", parameterToString(localVarOptionals.Latitude.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LatitudeGt.IsSet() {
		localVarQueryParams.Add("latitude__gt", parameterToString(localVarOptionals.LatitudeGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LatitudeGte.IsSet() {
		localVarQueryParams.Add("latitude__gte", parameterToString(localVarOptionals.LatitudeGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LatitudeIsnull.IsSet() {
		localVarQueryParams.Add("latitude__isnull", parameterToString(localVarOptionals.LatitudeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatitudeLt.IsSet() {
		localVarQueryParams.Add("latitude__lt", parameterToString(localVarOptionals.LatitudeLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LatitudeLte.IsSet() {
		localVarQueryParams.Add("latitude__lte", parameterToString(localVarOptionals.LatitudeLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LatitudeN.IsSet() {
		localVarQueryParams.Add("latitude__n", parameterToString(localVarOptionals.LatitudeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationType.IsSet() {
		localVarQueryParams.Add("location_type", parameterToString(localVarOptionals.LocationType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationTypeN.IsSet() {
		localVarQueryParams.Add("location_type__n", parameterToString(localVarOptionals.LocationTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Longitude.IsSet() {
		localVarQueryParams.Add("longitude", parameterToString(localVarOptionals.Longitude.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LongitudeGt.IsSet() {
		localVarQueryParams.Add("longitude__gt", parameterToString(localVarOptionals.LongitudeGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LongitudeGte.IsSet() {
		localVarQueryParams.Add("longitude__gte", parameterToString(localVarOptionals.LongitudeGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LongitudeIsnull.IsSet() {
		localVarQueryParams.Add("longitude__isnull", parameterToString(localVarOptionals.LongitudeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LongitudeLt.IsSet() {
		localVarQueryParams.Add("longitude__lt", parameterToString(localVarOptionals.LongitudeLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LongitudeLte.IsSet() {
		localVarQueryParams.Add("longitude__lte", parameterToString(localVarOptionals.LongitudeLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LongitudeN.IsSet() {
		localVarQueryParams.Add("longitude__n", parameterToString(localVarOptionals.LongitudeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parent.IsSet() {
		localVarQueryParams.Add("parent", parameterToString(localVarOptionals.Parent.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentIsnull.IsSet() {
		localVarQueryParams.Add("parent__isnull", parameterToString(localVarOptionals.ParentIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentN.IsSet() {
		localVarQueryParams.Add("parent__n", parameterToString(localVarOptionals.ParentN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddress.IsSet() {
		localVarQueryParams.Add("physical_address", parameterToString(localVarOptionals.PhysicalAddress.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressIc.IsSet() {
		localVarQueryParams.Add("physical_address__ic", parameterToString(localVarOptionals.PhysicalAddressIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressIe.IsSet() {
		localVarQueryParams.Add("physical_address__ie", parameterToString(localVarOptionals.PhysicalAddressIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressIew.IsSet() {
		localVarQueryParams.Add("physical_address__iew", parameterToString(localVarOptionals.PhysicalAddressIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressIre.IsSet() {
		localVarQueryParams.Add("physical_address__ire", parameterToString(localVarOptionals.PhysicalAddressIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressIsw.IsSet() {
		localVarQueryParams.Add("physical_address__isw", parameterToString(localVarOptionals.PhysicalAddressIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressN.IsSet() {
		localVarQueryParams.Add("physical_address__n", parameterToString(localVarOptionals.PhysicalAddressN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressNic.IsSet() {
		localVarQueryParams.Add("physical_address__nic", parameterToString(localVarOptionals.PhysicalAddressNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressNie.IsSet() {
		localVarQueryParams.Add("physical_address__nie", parameterToString(localVarOptionals.PhysicalAddressNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressNiew.IsSet() {
		localVarQueryParams.Add("physical_address__niew", parameterToString(localVarOptionals.PhysicalAddressNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressNire.IsSet() {
		localVarQueryParams.Add("physical_address__nire", parameterToString(localVarOptionals.PhysicalAddressNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressNisw.IsSet() {
		localVarQueryParams.Add("physical_address__nisw", parameterToString(localVarOptionals.PhysicalAddressNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressNre.IsSet() {
		localVarQueryParams.Add("physical_address__nre", parameterToString(localVarOptionals.PhysicalAddressNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalAddressRe.IsSet() {
		localVarQueryParams.Add("physical_address__re", parameterToString(localVarOptionals.PhysicalAddressRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPanels.IsSet() {
		localVarQueryParams.Add("power_panels", parameterToString(localVarOptionals.PowerPanels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPanelsIsnull.IsSet() {
		localVarQueryParams.Add("power_panels__isnull", parameterToString(localVarOptionals.PowerPanelsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPanelsN.IsSet() {
		localVarQueryParams.Add("power_panels__n", parameterToString(localVarOptionals.PowerPanelsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Prefixes.IsSet() {
		localVarQueryParams.Add("prefixes", parameterToString(localVarOptionals.Prefixes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PrefixesIsnull.IsSet() {
		localVarQueryParams.Add("prefixes__isnull", parameterToString(localVarOptionals.PrefixesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrefixesN.IsSet() {
		localVarQueryParams.Add("prefixes__n", parameterToString(localVarOptionals.PrefixesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroups.IsSet() {
		localVarQueryParams.Add("rack_groups", parameterToString(localVarOptionals.RackGroups.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupsIsnull.IsSet() {
		localVarQueryParams.Add("rack_groups__isnull", parameterToString(localVarOptionals.RackGroupsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupsN.IsSet() {
		localVarQueryParams.Add("rack_groups__n", parameterToString(localVarOptionals.RackGroupsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Racks.IsSet() {
		localVarQueryParams.Add("racks", parameterToString(localVarOptionals.Racks.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RacksIsnull.IsSet() {
		localVarQueryParams.Add("racks__isnull", parameterToString(localVarOptionals.RacksIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RacksN.IsSet() {
		localVarQueryParams.Add("racks__n", parameterToString(localVarOptionals.RacksN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddress.IsSet() {
		localVarQueryParams.Add("shipping_address", parameterToString(localVarOptionals.ShippingAddress.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressIc.IsSet() {
		localVarQueryParams.Add("shipping_address__ic", parameterToString(localVarOptionals.ShippingAddressIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressIe.IsSet() {
		localVarQueryParams.Add("shipping_address__ie", parameterToString(localVarOptionals.ShippingAddressIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressIew.IsSet() {
		localVarQueryParams.Add("shipping_address__iew", parameterToString(localVarOptionals.ShippingAddressIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressIre.IsSet() {
		localVarQueryParams.Add("shipping_address__ire", parameterToString(localVarOptionals.ShippingAddressIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressIsw.IsSet() {
		localVarQueryParams.Add("shipping_address__isw", parameterToString(localVarOptionals.ShippingAddressIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressN.IsSet() {
		localVarQueryParams.Add("shipping_address__n", parameterToString(localVarOptionals.ShippingAddressN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressNic.IsSet() {
		localVarQueryParams.Add("shipping_address__nic", parameterToString(localVarOptionals.ShippingAddressNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressNie.IsSet() {
		localVarQueryParams.Add("shipping_address__nie", parameterToString(localVarOptionals.ShippingAddressNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressNiew.IsSet() {
		localVarQueryParams.Add("shipping_address__niew", parameterToString(localVarOptionals.ShippingAddressNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressNire.IsSet() {
		localVarQueryParams.Add("shipping_address__nire", parameterToString(localVarOptionals.ShippingAddressNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressNisw.IsSet() {
		localVarQueryParams.Add("shipping_address__nisw", parameterToString(localVarOptionals.ShippingAddressNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressNre.IsSet() {
		localVarQueryParams.Add("shipping_address__nre", parameterToString(localVarOptionals.ShippingAddressNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ShippingAddressRe.IsSet() {
		localVarQueryParams.Add("shipping_address__re", parameterToString(localVarOptionals.ShippingAddressRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Subtree.IsSet() {
		localVarQueryParams.Add("subtree", parameterToString(localVarOptionals.Subtree.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIsnull.IsSet() {
		localVarQueryParams.Add("tenant__isnull", parameterToString(localVarOptionals.TenantIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIsnull.IsSet() {
		localVarQueryParams.Add("tenant_group__isnull", parameterToString(localVarOptionals.TenantGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdIsnull.IsSet() {
		localVarQueryParams.Add("tenant_id__isnull", parameterToString(localVarOptionals.TenantIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdN.IsSet() {
		localVarQueryParams.Add("tenant_id__n", parameterToString(localVarOptionals.TenantIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZone.IsSet() {
		localVarQueryParams.Add("time_zone", parameterToString(localVarOptionals.TimeZone.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneIc.IsSet() {
		localVarQueryParams.Add("time_zone__ic", parameterToString(localVarOptionals.TimeZoneIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneIe.IsSet() {
		localVarQueryParams.Add("time_zone__ie", parameterToString(localVarOptionals.TimeZoneIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneIew.IsSet() {
		localVarQueryParams.Add("time_zone__iew", parameterToString(localVarOptionals.TimeZoneIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneIre.IsSet() {
		localVarQueryParams.Add("time_zone__ire", parameterToString(localVarOptionals.TimeZoneIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneIsw.IsSet() {
		localVarQueryParams.Add("time_zone__isw", parameterToString(localVarOptionals.TimeZoneIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneN.IsSet() {
		localVarQueryParams.Add("time_zone__n", parameterToString(localVarOptionals.TimeZoneN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneNic.IsSet() {
		localVarQueryParams.Add("time_zone__nic", parameterToString(localVarOptionals.TimeZoneNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneNie.IsSet() {
		localVarQueryParams.Add("time_zone__nie", parameterToString(localVarOptionals.TimeZoneNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneNiew.IsSet() {
		localVarQueryParams.Add("time_zone__niew", parameterToString(localVarOptionals.TimeZoneNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneNire.IsSet() {
		localVarQueryParams.Add("time_zone__nire", parameterToString(localVarOptionals.TimeZoneNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneNisw.IsSet() {
		localVarQueryParams.Add("time_zone__nisw", parameterToString(localVarOptionals.TimeZoneNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneNre.IsSet() {
		localVarQueryParams.Add("time_zone__nre", parameterToString(localVarOptionals.TimeZoneNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TimeZoneRe.IsSet() {
		localVarQueryParams.Add("time_zone__re", parameterToString(localVarOptionals.TimeZoneRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VlanGroups.IsSet() {
		localVarQueryParams.Add("vlan_groups", parameterToString(localVarOptionals.VlanGroups.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VlanGroupsIsnull.IsSet() {
		localVarQueryParams.Add("vlan_groups__isnull", parameterToString(localVarOptionals.VlanGroupsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanGroupsN.IsSet() {
		localVarQueryParams.Add("vlan_groups__n", parameterToString(localVarOptionals.VlanGroupsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Vlans.IsSet() {
		localVarQueryParams.Add("vlans", parameterToString(localVarOptionals.Vlans.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VlansIsnull.IsSet() {
		localVarQueryParams.Add("vlans__isnull", parameterToString(localVarOptionals.VlansIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlansN.IsSet() {
		localVarQueryParams.Add("vlans__n", parameterToString(localVarOptionals.VlansN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedLocationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this location.
 * @param optional nil or *DcimApiDcimLocationsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimLocationsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimLocationsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this location.
 * @param optional nil or *DcimApiDcimLocationsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimLocationsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimLocationsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimLocationsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a location object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this location.
 * @param optional nil or *DcimApiDcimLocationsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedLocationRequest) - 
     * @param "Format" (optional.String) - 
@return Location
*/

type DcimApiDcimLocationsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimLocationsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimLocationsPartialUpdateOpts) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a location object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this location.
 * @param optional nil or *DcimApiDcimLocationsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Location
*/

type DcimApiDcimLocationsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimLocationsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimLocationsRetrieveOpts) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a location object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this location.
 * @param optional nil or *DcimApiDcimLocationsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Location
*/

type DcimApiDcimLocationsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimLocationsUpdate(ctx context.Context, body LocationRequest, id string, localVarOptionals *DcimApiDcimLocationsUpdateOpts) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/locations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of manufacturer objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimManufacturersBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimManufacturersBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimManufacturersBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimManufacturersBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of manufacturer objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimManufacturersBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Manufacturer
*/

type DcimApiDcimManufacturersBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimManufacturersBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableManufacturerRequest, localVarOptionals *DcimApiDcimManufacturersBulkPartialUpdateOpts) ([]Manufacturer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Manufacturer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Manufacturer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of manufacturer objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimManufacturersBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Manufacturer
*/

type DcimApiDcimManufacturersBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimManufacturersBulkUpdate(ctx context.Context, body []BulkWritableManufacturerRequest, localVarOptionals *DcimApiDcimManufacturersBulkUpdateOpts) ([]Manufacturer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Manufacturer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Manufacturer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more manufacturer objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimManufacturersCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Manufacturer
*/

type DcimApiDcimManufacturersCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimManufacturersCreate(ctx context.Context, body ManufacturerRequest, localVarOptionals *DcimApiDcimManufacturersCreateOpts) (Manufacturer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Manufacturer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Manufacturer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a manufacturer object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this manufacturer.
 * @param optional nil or *DcimApiDcimManufacturersDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimManufacturersDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimManufacturersDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimManufacturersDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of manufacturer objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimManufacturersListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "DeviceTypes" (optional.Interface of []string) - 
     * @param "DeviceTypesIsnull" (optional.Bool) - 
     * @param "DeviceTypesN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasDeviceTypes" (optional.Bool) -  Has device types
     * @param "HasInventoryItems" (optional.Bool) -  Has inventory items
     * @param "HasPlatforms" (optional.Bool) -  Has platforms
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "InventoryItems" (optional.Interface of []string) - 
     * @param "InventoryItemsIsnull" (optional.Bool) - 
     * @param "InventoryItemsN" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Platforms" (optional.Interface of []string) - 
     * @param "PlatformsIsnull" (optional.Bool) - 
     * @param "PlatformsN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedManufacturerList
*/

type DcimApiDcimManufacturersListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceTypes optional.Interface
    DeviceTypesIsnull optional.Bool
    DeviceTypesN optional.Interface
    Format optional.String
    HasDeviceTypes optional.Bool
    HasInventoryItems optional.Bool
    HasPlatforms optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    InventoryItems optional.Interface
    InventoryItemsIsnull optional.Bool
    InventoryItemsN optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Platforms optional.Interface
    PlatformsIsnull optional.Bool
    PlatformsN optional.Interface
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimManufacturersList(ctx context.Context, localVarOptionals *DcimApiDcimManufacturersListOpts) (PaginatedManufacturerList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedManufacturerList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypes.IsSet() {
		localVarQueryParams.Add("device_types", parameterToString(localVarOptionals.DeviceTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypesIsnull.IsSet() {
		localVarQueryParams.Add("device_types__isnull", parameterToString(localVarOptionals.DeviceTypesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypesN.IsSet() {
		localVarQueryParams.Add("device_types__n", parameterToString(localVarOptionals.DeviceTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDeviceTypes.IsSet() {
		localVarQueryParams.Add("has_device_types", parameterToString(localVarOptionals.HasDeviceTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasInventoryItems.IsSet() {
		localVarQueryParams.Add("has_inventory_items", parameterToString(localVarOptionals.HasInventoryItems.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPlatforms.IsSet() {
		localVarQueryParams.Add("has_platforms", parameterToString(localVarOptionals.HasPlatforms.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InventoryItems.IsSet() {
		localVarQueryParams.Add("inventory_items", parameterToString(localVarOptionals.InventoryItems.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InventoryItemsIsnull.IsSet() {
		localVarQueryParams.Add("inventory_items__isnull", parameterToString(localVarOptionals.InventoryItemsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InventoryItemsN.IsSet() {
		localVarQueryParams.Add("inventory_items__n", parameterToString(localVarOptionals.InventoryItemsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Platforms.IsSet() {
		localVarQueryParams.Add("platforms", parameterToString(localVarOptionals.Platforms.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformsIsnull.IsSet() {
		localVarQueryParams.Add("platforms__isnull", parameterToString(localVarOptionals.PlatformsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformsN.IsSet() {
		localVarQueryParams.Add("platforms__n", parameterToString(localVarOptionals.PlatformsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedManufacturerList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this manufacturer.
 * @param optional nil or *DcimApiDcimManufacturersNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimManufacturersNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimManufacturersNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimManufacturersNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this manufacturer.
 * @param optional nil or *DcimApiDcimManufacturersNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimManufacturersNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimManufacturersNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimManufacturersNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a manufacturer object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this manufacturer.
 * @param optional nil or *DcimApiDcimManufacturersPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedManufacturerRequest) - 
     * @param "Format" (optional.String) - 
@return Manufacturer
*/

type DcimApiDcimManufacturersPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimManufacturersPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimManufacturersPartialUpdateOpts) (Manufacturer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Manufacturer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Manufacturer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a manufacturer object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this manufacturer.
 * @param optional nil or *DcimApiDcimManufacturersRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Manufacturer
*/

type DcimApiDcimManufacturersRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimManufacturersRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimManufacturersRetrieveOpts) (Manufacturer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Manufacturer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Manufacturer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a manufacturer object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this manufacturer.
 * @param optional nil or *DcimApiDcimManufacturersUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Manufacturer
*/

type DcimApiDcimManufacturersUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimManufacturersUpdate(ctx context.Context, body ManufacturerRequest, id string, localVarOptionals *DcimApiDcimManufacturersUpdateOpts) (Manufacturer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Manufacturer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/manufacturers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Manufacturer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of platform objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPlatformsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPlatformsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPlatformsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimPlatformsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of platform objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPlatformsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Platform
*/

type DcimApiDcimPlatformsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPlatformsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritablePlatformRequest, localVarOptionals *DcimApiDcimPlatformsBulkPartialUpdateOpts) ([]Platform, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Platform
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Platform
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of platform objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPlatformsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Platform
*/

type DcimApiDcimPlatformsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPlatformsBulkUpdate(ctx context.Context, body []BulkWritablePlatformRequest, localVarOptionals *DcimApiDcimPlatformsBulkUpdateOpts) ([]Platform, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Platform
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Platform
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more platform objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPlatformsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Platform
*/

type DcimApiDcimPlatformsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPlatformsCreate(ctx context.Context, body PlatformRequest, localVarOptionals *DcimApiDcimPlatformsCreateOpts) (Platform, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Platform
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Platform
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a platform object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this platform.
 * @param optional nil or *DcimApiDcimPlatformsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPlatformsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPlatformsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimPlatformsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of platform objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimPlatformsListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Devices" (optional.Interface of []string) - 
     * @param "DevicesIsnull" (optional.Bool) - 
     * @param "DevicesN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasDevices" (optional.Bool) -  Has devices
     * @param "HasVirtualMachines" (optional.Bool) -  Has virtual machines
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Manufacturer" (optional.Interface of []string) - 
     * @param "ManufacturerIsnull" (optional.Bool) - 
     * @param "ManufacturerN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "NapalmArgs" (optional.Interface of []string) - 
     * @param "NapalmDriver" (optional.Interface of []string) - 
     * @param "NapalmDriverIc" (optional.Interface of []string) - 
     * @param "NapalmDriverIe" (optional.Interface of []string) - 
     * @param "NapalmDriverIew" (optional.Interface of []string) - 
     * @param "NapalmDriverIre" (optional.Interface of []string) - 
     * @param "NapalmDriverIsw" (optional.Interface of []string) - 
     * @param "NapalmDriverN" (optional.Interface of []string) - 
     * @param "NapalmDriverNic" (optional.Interface of []string) - 
     * @param "NapalmDriverNie" (optional.Interface of []string) - 
     * @param "NapalmDriverNiew" (optional.Interface of []string) - 
     * @param "NapalmDriverNire" (optional.Interface of []string) - 
     * @param "NapalmDriverNisw" (optional.Interface of []string) - 
     * @param "NapalmDriverNre" (optional.Interface of []string) - 
     * @param "NapalmDriverRe" (optional.Interface of []string) - 
     * @param "NetworkDriver" (optional.Interface of []string) - 
     * @param "NetworkDriverIc" (optional.Interface of []string) - 
     * @param "NetworkDriverIe" (optional.Interface of []string) - 
     * @param "NetworkDriverIew" (optional.Interface of []string) - 
     * @param "NetworkDriverIre" (optional.Interface of []string) - 
     * @param "NetworkDriverIsw" (optional.Interface of []string) - 
     * @param "NetworkDriverN" (optional.Interface of []string) - 
     * @param "NetworkDriverNic" (optional.Interface of []string) - 
     * @param "NetworkDriverNie" (optional.Interface of []string) - 
     * @param "NetworkDriverNiew" (optional.Interface of []string) - 
     * @param "NetworkDriverNire" (optional.Interface of []string) - 
     * @param "NetworkDriverNisw" (optional.Interface of []string) - 
     * @param "NetworkDriverNre" (optional.Interface of []string) - 
     * @param "NetworkDriverRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "VirtualMachines" (optional.Interface of []string) - 
     * @param "VirtualMachinesIsnull" (optional.Bool) - 
     * @param "VirtualMachinesN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedPlatformList
*/

type DcimApiDcimPlatformsListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Devices optional.Interface
    DevicesIsnull optional.Bool
    DevicesN optional.Interface
    Format optional.String
    HasDevices optional.Bool
    HasVirtualMachines optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Manufacturer optional.Interface
    ManufacturerIsnull optional.Bool
    ManufacturerN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    NapalmArgs optional.Interface
    NapalmDriver optional.Interface
    NapalmDriverIc optional.Interface
    NapalmDriverIe optional.Interface
    NapalmDriverIew optional.Interface
    NapalmDriverIre optional.Interface
    NapalmDriverIsw optional.Interface
    NapalmDriverN optional.Interface
    NapalmDriverNic optional.Interface
    NapalmDriverNie optional.Interface
    NapalmDriverNiew optional.Interface
    NapalmDriverNire optional.Interface
    NapalmDriverNisw optional.Interface
    NapalmDriverNre optional.Interface
    NapalmDriverRe optional.Interface
    NetworkDriver optional.Interface
    NetworkDriverIc optional.Interface
    NetworkDriverIe optional.Interface
    NetworkDriverIew optional.Interface
    NetworkDriverIre optional.Interface
    NetworkDriverIsw optional.Interface
    NetworkDriverN optional.Interface
    NetworkDriverNic optional.Interface
    NetworkDriverNie optional.Interface
    NetworkDriverNiew optional.Interface
    NetworkDriverNire optional.Interface
    NetworkDriverNisw optional.Interface
    NetworkDriverNre optional.Interface
    NetworkDriverRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    VirtualMachines optional.Interface
    VirtualMachinesIsnull optional.Bool
    VirtualMachinesN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimPlatformsList(ctx context.Context, localVarOptionals *DcimApiDcimPlatformsListOpts) (PaginatedPlatformList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedPlatformList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarQueryParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesIsnull.IsSet() {
		localVarQueryParams.Add("devices__isnull", parameterToString(localVarOptionals.DevicesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesN.IsSet() {
		localVarQueryParams.Add("devices__n", parameterToString(localVarOptionals.DevicesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDevices.IsSet() {
		localVarQueryParams.Add("has_devices", parameterToString(localVarOptionals.HasDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasVirtualMachines.IsSet() {
		localVarQueryParams.Add("has_virtual_machines", parameterToString(localVarOptionals.HasVirtualMachines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarQueryParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ManufacturerIsnull.IsSet() {
		localVarQueryParams.Add("manufacturer__isnull", parameterToString(localVarOptionals.ManufacturerIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ManufacturerN.IsSet() {
		localVarQueryParams.Add("manufacturer__n", parameterToString(localVarOptionals.ManufacturerN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmArgs.IsSet() {
		localVarQueryParams.Add("napalm_args", parameterToString(localVarOptionals.NapalmArgs.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriver.IsSet() {
		localVarQueryParams.Add("napalm_driver", parameterToString(localVarOptionals.NapalmDriver.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverIc.IsSet() {
		localVarQueryParams.Add("napalm_driver__ic", parameterToString(localVarOptionals.NapalmDriverIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverIe.IsSet() {
		localVarQueryParams.Add("napalm_driver__ie", parameterToString(localVarOptionals.NapalmDriverIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverIew.IsSet() {
		localVarQueryParams.Add("napalm_driver__iew", parameterToString(localVarOptionals.NapalmDriverIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverIre.IsSet() {
		localVarQueryParams.Add("napalm_driver__ire", parameterToString(localVarOptionals.NapalmDriverIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverIsw.IsSet() {
		localVarQueryParams.Add("napalm_driver__isw", parameterToString(localVarOptionals.NapalmDriverIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverN.IsSet() {
		localVarQueryParams.Add("napalm_driver__n", parameterToString(localVarOptionals.NapalmDriverN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverNic.IsSet() {
		localVarQueryParams.Add("napalm_driver__nic", parameterToString(localVarOptionals.NapalmDriverNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverNie.IsSet() {
		localVarQueryParams.Add("napalm_driver__nie", parameterToString(localVarOptionals.NapalmDriverNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverNiew.IsSet() {
		localVarQueryParams.Add("napalm_driver__niew", parameterToString(localVarOptionals.NapalmDriverNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverNire.IsSet() {
		localVarQueryParams.Add("napalm_driver__nire", parameterToString(localVarOptionals.NapalmDriverNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverNisw.IsSet() {
		localVarQueryParams.Add("napalm_driver__nisw", parameterToString(localVarOptionals.NapalmDriverNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverNre.IsSet() {
		localVarQueryParams.Add("napalm_driver__nre", parameterToString(localVarOptionals.NapalmDriverNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NapalmDriverRe.IsSet() {
		localVarQueryParams.Add("napalm_driver__re", parameterToString(localVarOptionals.NapalmDriverRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriver.IsSet() {
		localVarQueryParams.Add("network_driver", parameterToString(localVarOptionals.NetworkDriver.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverIc.IsSet() {
		localVarQueryParams.Add("network_driver__ic", parameterToString(localVarOptionals.NetworkDriverIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverIe.IsSet() {
		localVarQueryParams.Add("network_driver__ie", parameterToString(localVarOptionals.NetworkDriverIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverIew.IsSet() {
		localVarQueryParams.Add("network_driver__iew", parameterToString(localVarOptionals.NetworkDriverIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverIre.IsSet() {
		localVarQueryParams.Add("network_driver__ire", parameterToString(localVarOptionals.NetworkDriverIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverIsw.IsSet() {
		localVarQueryParams.Add("network_driver__isw", parameterToString(localVarOptionals.NetworkDriverIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverN.IsSet() {
		localVarQueryParams.Add("network_driver__n", parameterToString(localVarOptionals.NetworkDriverN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverNic.IsSet() {
		localVarQueryParams.Add("network_driver__nic", parameterToString(localVarOptionals.NetworkDriverNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverNie.IsSet() {
		localVarQueryParams.Add("network_driver__nie", parameterToString(localVarOptionals.NetworkDriverNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverNiew.IsSet() {
		localVarQueryParams.Add("network_driver__niew", parameterToString(localVarOptionals.NetworkDriverNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverNire.IsSet() {
		localVarQueryParams.Add("network_driver__nire", parameterToString(localVarOptionals.NetworkDriverNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverNisw.IsSet() {
		localVarQueryParams.Add("network_driver__nisw", parameterToString(localVarOptionals.NetworkDriverNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverNre.IsSet() {
		localVarQueryParams.Add("network_driver__nre", parameterToString(localVarOptionals.NetworkDriverNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkDriverRe.IsSet() {
		localVarQueryParams.Add("network_driver__re", parameterToString(localVarOptionals.NetworkDriverRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachines.IsSet() {
		localVarQueryParams.Add("virtual_machines", parameterToString(localVarOptionals.VirtualMachines.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachinesIsnull.IsSet() {
		localVarQueryParams.Add("virtual_machines__isnull", parameterToString(localVarOptionals.VirtualMachinesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachinesN.IsSet() {
		localVarQueryParams.Add("virtual_machines__n", parameterToString(localVarOptionals.VirtualMachinesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedPlatformList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this platform.
 * @param optional nil or *DcimApiDcimPlatformsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimPlatformsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPlatformsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimPlatformsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this platform.
 * @param optional nil or *DcimApiDcimPlatformsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimPlatformsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimPlatformsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimPlatformsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a platform object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this platform.
 * @param optional nil or *DcimApiDcimPlatformsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedPlatformRequest) - 
     * @param "Format" (optional.String) - 
@return Platform
*/

type DcimApiDcimPlatformsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimPlatformsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimPlatformsPartialUpdateOpts) (Platform, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Platform
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Platform
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a platform object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this platform.
 * @param optional nil or *DcimApiDcimPlatformsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Platform
*/

type DcimApiDcimPlatformsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPlatformsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPlatformsRetrieveOpts) (Platform, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Platform
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Platform
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a platform object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this platform.
 * @param optional nil or *DcimApiDcimPlatformsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Platform
*/

type DcimApiDcimPlatformsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPlatformsUpdate(ctx context.Context, body PlatformRequest, id string, localVarOptionals *DcimApiDcimPlatformsUpdateOpts) (Platform, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Platform
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/platforms/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Platform
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of power port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimPowerConnectionsListOpts - Optional Parameters:
     * @param "Device" (optional.Interface of []string) -  Device (name)
     * @param "DeviceId" (optional.Interface of []string) -  Device (ID)
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.String) -  Location (name)
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedPowerPortList
*/

type DcimApiDcimPowerConnectionsListOpts struct {
    Device optional.Interface
    DeviceId optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Location optional.String
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerConnectionsList(ctx context.Context, localVarOptionals *DcimApiDcimPowerConnectionsListOpts) (PaginatedPowerPortList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedPowerPortList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-connections/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedPowerPortList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of power feed objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerFeedsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerFeedsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerFeedsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimPowerFeedsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of power feed objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerFeedsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerFeed
*/

type DcimApiDcimPowerFeedsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerFeedsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritablePowerFeedRequest, localVarOptionals *DcimApiDcimPowerFeedsBulkPartialUpdateOpts) ([]PowerFeed, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerFeed
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerFeed
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of power feed objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerFeedsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerFeed
*/

type DcimApiDcimPowerFeedsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerFeedsBulkUpdate(ctx context.Context, body []BulkWritablePowerFeedRequest, localVarOptionals *DcimApiDcimPowerFeedsBulkUpdateOpts) ([]PowerFeed, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerFeed
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerFeed
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more power feed objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerFeedsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerFeed
*/

type DcimApiDcimPowerFeedsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerFeedsCreate(ctx context.Context, body WritablePowerFeedRequest, localVarOptionals *DcimApiDcimPowerFeedsCreateOpts) (PowerFeed, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerFeed
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v PowerFeed
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a power feed object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power feed.
 * @param optional nil or *DcimApiDcimPowerFeedsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerFeedsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerFeedsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerFeedsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of power feed objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimPowerFeedsListOpts - Optional Parameters:
     * @param "Amperage" (optional.Interface of []int32) - 
     * @param "AmperageGt" (optional.Interface of []int32) - 
     * @param "AmperageGte" (optional.Interface of []int32) - 
     * @param "AmperageLt" (optional.Interface of []int32) - 
     * @param "AmperageLte" (optional.Interface of []int32) - 
     * @param "AmperageN" (optional.Interface of []int32) - 
     * @param "AvailablePower" (optional.Interface of []int32) - 
     * @param "AvailablePowerGt" (optional.Interface of []int32) - 
     * @param "AvailablePowerGte" (optional.Interface of []int32) - 
     * @param "AvailablePowerLt" (optional.Interface of []int32) - 
     * @param "AvailablePowerLte" (optional.Interface of []int32) - 
     * @param "AvailablePowerN" (optional.Interface of []int32) - 
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "Connected" (optional.Bool) -  Connected status (bool)
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "MaxUtilization" (optional.Interface of []int32) - 
     * @param "MaxUtilizationGt" (optional.Interface of []int32) - 
     * @param "MaxUtilizationGte" (optional.Interface of []int32) - 
     * @param "MaxUtilizationLt" (optional.Interface of []int32) - 
     * @param "MaxUtilizationLte" (optional.Interface of []int32) - 
     * @param "MaxUtilizationN" (optional.Interface of []int32) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Phase" (optional.Interface of []string) - 
     * @param "PhaseIc" (optional.Interface of []string) - 
     * @param "PhaseIe" (optional.Interface of []string) - 
     * @param "PhaseIew" (optional.Interface of []string) - 
     * @param "PhaseIre" (optional.Interface of []string) - 
     * @param "PhaseIsw" (optional.Interface of []string) - 
     * @param "PhaseN" (optional.Interface of []string) - 
     * @param "PhaseNic" (optional.Interface of []string) - 
     * @param "PhaseNie" (optional.Interface of []string) - 
     * @param "PhaseNiew" (optional.Interface of []string) - 
     * @param "PhaseNire" (optional.Interface of []string) - 
     * @param "PhaseNisw" (optional.Interface of []string) - 
     * @param "PhaseNre" (optional.Interface of []string) - 
     * @param "PhaseRe" (optional.Interface of []string) - 
     * @param "PowerPanel" (optional.Interface of []string) - 
     * @param "PowerPanelN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Rack" (optional.Interface of []string) - 
     * @param "RackIsnull" (optional.Bool) - 
     * @param "RackN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Supply" (optional.Interface of []string) - 
     * @param "SupplyIc" (optional.Interface of []string) - 
     * @param "SupplyIe" (optional.Interface of []string) - 
     * @param "SupplyIew" (optional.Interface of []string) - 
     * @param "SupplyIre" (optional.Interface of []string) - 
     * @param "SupplyIsw" (optional.Interface of []string) - 
     * @param "SupplyN" (optional.Interface of []string) - 
     * @param "SupplyNic" (optional.Interface of []string) - 
     * @param "SupplyNie" (optional.Interface of []string) - 
     * @param "SupplyNiew" (optional.Interface of []string) - 
     * @param "SupplyNire" (optional.Interface of []string) - 
     * @param "SupplyNisw" (optional.Interface of []string) - 
     * @param "SupplyNre" (optional.Interface of []string) - 
     * @param "SupplyRe" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Voltage" (optional.Interface of []int32) - 
     * @param "VoltageGt" (optional.Interface of []int32) - 
     * @param "VoltageGte" (optional.Interface of []int32) - 
     * @param "VoltageLt" (optional.Interface of []int32) - 
     * @param "VoltageLte" (optional.Interface of []int32) - 
     * @param "VoltageN" (optional.Interface of []int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedPowerFeedList
*/

type DcimApiDcimPowerFeedsListOpts struct {
    Amperage optional.Interface
    AmperageGt optional.Interface
    AmperageGte optional.Interface
    AmperageLt optional.Interface
    AmperageLte optional.Interface
    AmperageN optional.Interface
    AvailablePower optional.Interface
    AvailablePowerGt optional.Interface
    AvailablePowerGte optional.Interface
    AvailablePowerLt optional.Interface
    AvailablePowerLte optional.Interface
    AvailablePowerN optional.Interface
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    Connected optional.Bool
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    HasCable optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    MaxUtilization optional.Interface
    MaxUtilizationGt optional.Interface
    MaxUtilizationGte optional.Interface
    MaxUtilizationLt optional.Interface
    MaxUtilizationLte optional.Interface
    MaxUtilizationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Phase optional.Interface
    PhaseIc optional.Interface
    PhaseIe optional.Interface
    PhaseIew optional.Interface
    PhaseIre optional.Interface
    PhaseIsw optional.Interface
    PhaseN optional.Interface
    PhaseNic optional.Interface
    PhaseNie optional.Interface
    PhaseNiew optional.Interface
    PhaseNire optional.Interface
    PhaseNisw optional.Interface
    PhaseNre optional.Interface
    PhaseRe optional.Interface
    PowerPanel optional.Interface
    PowerPanelN optional.Interface
    Q optional.String
    Rack optional.Interface
    RackIsnull optional.Bool
    RackN optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Supply optional.Interface
    SupplyIc optional.Interface
    SupplyIe optional.Interface
    SupplyIew optional.Interface
    SupplyIre optional.Interface
    SupplyIsw optional.Interface
    SupplyN optional.Interface
    SupplyNic optional.Interface
    SupplyNie optional.Interface
    SupplyNiew optional.Interface
    SupplyNire optional.Interface
    SupplyNisw optional.Interface
    SupplyNre optional.Interface
    SupplyRe optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Voltage optional.Interface
    VoltageGt optional.Interface
    VoltageGte optional.Interface
    VoltageLt optional.Interface
    VoltageLte optional.Interface
    VoltageN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerFeedsList(ctx context.Context, localVarOptionals *DcimApiDcimPowerFeedsListOpts) (PaginatedPowerFeedList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedPowerFeedList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Amperage.IsSet() {
		localVarQueryParams.Add("amperage", parameterToString(localVarOptionals.Amperage.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AmperageGt.IsSet() {
		localVarQueryParams.Add("amperage__gt", parameterToString(localVarOptionals.AmperageGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AmperageGte.IsSet() {
		localVarQueryParams.Add("amperage__gte", parameterToString(localVarOptionals.AmperageGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AmperageLt.IsSet() {
		localVarQueryParams.Add("amperage__lt", parameterToString(localVarOptionals.AmperageLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AmperageLte.IsSet() {
		localVarQueryParams.Add("amperage__lte", parameterToString(localVarOptionals.AmperageLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AmperageN.IsSet() {
		localVarQueryParams.Add("amperage__n", parameterToString(localVarOptionals.AmperageN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AvailablePower.IsSet() {
		localVarQueryParams.Add("available_power", parameterToString(localVarOptionals.AvailablePower.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AvailablePowerGt.IsSet() {
		localVarQueryParams.Add("available_power__gt", parameterToString(localVarOptionals.AvailablePowerGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AvailablePowerGte.IsSet() {
		localVarQueryParams.Add("available_power__gte", parameterToString(localVarOptionals.AvailablePowerGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AvailablePowerLt.IsSet() {
		localVarQueryParams.Add("available_power__lt", parameterToString(localVarOptionals.AvailablePowerLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AvailablePowerLte.IsSet() {
		localVarQueryParams.Add("available_power__lte", parameterToString(localVarOptionals.AvailablePowerLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AvailablePowerN.IsSet() {
		localVarQueryParams.Add("available_power__n", parameterToString(localVarOptionals.AvailablePowerN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Connected.IsSet() {
		localVarQueryParams.Add("connected", parameterToString(localVarOptionals.Connected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxUtilization.IsSet() {
		localVarQueryParams.Add("max_utilization", parameterToString(localVarOptionals.MaxUtilization.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxUtilizationGt.IsSet() {
		localVarQueryParams.Add("max_utilization__gt", parameterToString(localVarOptionals.MaxUtilizationGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxUtilizationGte.IsSet() {
		localVarQueryParams.Add("max_utilization__gte", parameterToString(localVarOptionals.MaxUtilizationGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxUtilizationLt.IsSet() {
		localVarQueryParams.Add("max_utilization__lt", parameterToString(localVarOptionals.MaxUtilizationLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxUtilizationLte.IsSet() {
		localVarQueryParams.Add("max_utilization__lte", parameterToString(localVarOptionals.MaxUtilizationLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxUtilizationN.IsSet() {
		localVarQueryParams.Add("max_utilization__n", parameterToString(localVarOptionals.MaxUtilizationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Phase.IsSet() {
		localVarQueryParams.Add("phase", parameterToString(localVarOptionals.Phase.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseIc.IsSet() {
		localVarQueryParams.Add("phase__ic", parameterToString(localVarOptionals.PhaseIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseIe.IsSet() {
		localVarQueryParams.Add("phase__ie", parameterToString(localVarOptionals.PhaseIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseIew.IsSet() {
		localVarQueryParams.Add("phase__iew", parameterToString(localVarOptionals.PhaseIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseIre.IsSet() {
		localVarQueryParams.Add("phase__ire", parameterToString(localVarOptionals.PhaseIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseIsw.IsSet() {
		localVarQueryParams.Add("phase__isw", parameterToString(localVarOptionals.PhaseIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseN.IsSet() {
		localVarQueryParams.Add("phase__n", parameterToString(localVarOptionals.PhaseN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseNic.IsSet() {
		localVarQueryParams.Add("phase__nic", parameterToString(localVarOptionals.PhaseNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseNie.IsSet() {
		localVarQueryParams.Add("phase__nie", parameterToString(localVarOptionals.PhaseNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseNiew.IsSet() {
		localVarQueryParams.Add("phase__niew", parameterToString(localVarOptionals.PhaseNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseNire.IsSet() {
		localVarQueryParams.Add("phase__nire", parameterToString(localVarOptionals.PhaseNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseNisw.IsSet() {
		localVarQueryParams.Add("phase__nisw", parameterToString(localVarOptionals.PhaseNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseNre.IsSet() {
		localVarQueryParams.Add("phase__nre", parameterToString(localVarOptionals.PhaseNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PhaseRe.IsSet() {
		localVarQueryParams.Add("phase__re", parameterToString(localVarOptionals.PhaseRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPanel.IsSet() {
		localVarQueryParams.Add("power_panel", parameterToString(localVarOptionals.PowerPanel.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPanelN.IsSet() {
		localVarQueryParams.Add("power_panel__n", parameterToString(localVarOptionals.PowerPanelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Rack.IsSet() {
		localVarQueryParams.Add("rack", parameterToString(localVarOptionals.Rack.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackIsnull.IsSet() {
		localVarQueryParams.Add("rack__isnull", parameterToString(localVarOptionals.RackIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackN.IsSet() {
		localVarQueryParams.Add("rack__n", parameterToString(localVarOptionals.RackN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Supply.IsSet() {
		localVarQueryParams.Add("supply", parameterToString(localVarOptionals.Supply.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyIc.IsSet() {
		localVarQueryParams.Add("supply__ic", parameterToString(localVarOptionals.SupplyIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyIe.IsSet() {
		localVarQueryParams.Add("supply__ie", parameterToString(localVarOptionals.SupplyIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyIew.IsSet() {
		localVarQueryParams.Add("supply__iew", parameterToString(localVarOptionals.SupplyIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyIre.IsSet() {
		localVarQueryParams.Add("supply__ire", parameterToString(localVarOptionals.SupplyIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyIsw.IsSet() {
		localVarQueryParams.Add("supply__isw", parameterToString(localVarOptionals.SupplyIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyN.IsSet() {
		localVarQueryParams.Add("supply__n", parameterToString(localVarOptionals.SupplyN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyNic.IsSet() {
		localVarQueryParams.Add("supply__nic", parameterToString(localVarOptionals.SupplyNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyNie.IsSet() {
		localVarQueryParams.Add("supply__nie", parameterToString(localVarOptionals.SupplyNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyNiew.IsSet() {
		localVarQueryParams.Add("supply__niew", parameterToString(localVarOptionals.SupplyNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyNire.IsSet() {
		localVarQueryParams.Add("supply__nire", parameterToString(localVarOptionals.SupplyNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyNisw.IsSet() {
		localVarQueryParams.Add("supply__nisw", parameterToString(localVarOptionals.SupplyNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyNre.IsSet() {
		localVarQueryParams.Add("supply__nre", parameterToString(localVarOptionals.SupplyNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SupplyRe.IsSet() {
		localVarQueryParams.Add("supply__re", parameterToString(localVarOptionals.SupplyRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Voltage.IsSet() {
		localVarQueryParams.Add("voltage", parameterToString(localVarOptionals.Voltage.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VoltageGt.IsSet() {
		localVarQueryParams.Add("voltage__gt", parameterToString(localVarOptionals.VoltageGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VoltageGte.IsSet() {
		localVarQueryParams.Add("voltage__gte", parameterToString(localVarOptionals.VoltageGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VoltageLt.IsSet() {
		localVarQueryParams.Add("voltage__lt", parameterToString(localVarOptionals.VoltageLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VoltageLte.IsSet() {
		localVarQueryParams.Add("voltage__lte", parameterToString(localVarOptionals.VoltageLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VoltageN.IsSet() {
		localVarQueryParams.Add("voltage__n", parameterToString(localVarOptionals.VoltageN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedPowerFeedList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power feed.
 * @param optional nil or *DcimApiDcimPowerFeedsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimPowerFeedsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerFeedsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimPowerFeedsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power feed.
 * @param optional nil or *DcimApiDcimPowerFeedsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimPowerFeedsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerFeedsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerFeedsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a power feed object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power feed.
 * @param optional nil or *DcimApiDcimPowerFeedsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritablePowerFeedRequest) - 
     * @param "Format" (optional.String) - 
@return PowerFeed
*/

type DcimApiDcimPowerFeedsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimPowerFeedsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerFeedsPartialUpdateOpts) (PowerFeed, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerFeed
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerFeed
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a power feed object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power feed.
 * @param optional nil or *DcimApiDcimPowerFeedsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerFeed
*/

type DcimApiDcimPowerFeedsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerFeedsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerFeedsRetrieveOpts) (PowerFeed, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerFeed
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerFeed
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power feed.
 * @param optional nil or *DcimApiDcimPowerFeedsTraceRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerFeed
*/

type DcimApiDcimPowerFeedsTraceRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerFeedsTraceRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerFeedsTraceRetrieveOpts) (PowerFeed, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerFeed
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerFeed
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a power feed object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power feed.
 * @param optional nil or *DcimApiDcimPowerFeedsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerFeed
*/

type DcimApiDcimPowerFeedsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerFeedsUpdate(ctx context.Context, body WritablePowerFeedRequest, id string, localVarOptionals *DcimApiDcimPowerFeedsUpdateOpts) (PowerFeed, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerFeed
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-feeds/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerFeed
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of power outlet template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerOutletTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimPowerOutletTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of power outlet template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerOutletTemplate
*/

type DcimApiDcimPowerOutletTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritablePowerOutletTemplateRequest, localVarOptionals *DcimApiDcimPowerOutletTemplatesBulkPartialUpdateOpts) ([]PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerOutletTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerOutletTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of power outlet template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerOutletTemplate
*/

type DcimApiDcimPowerOutletTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletTemplatesBulkUpdate(ctx context.Context, body []BulkWritablePowerOutletTemplateRequest, localVarOptionals *DcimApiDcimPowerOutletTemplatesBulkUpdateOpts) ([]PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerOutletTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerOutletTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more power outlet template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerOutletTemplate
*/

type DcimApiDcimPowerOutletTemplatesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletTemplatesCreate(ctx context.Context, body WritablePowerOutletTemplateRequest, localVarOptionals *DcimApiDcimPowerOutletTemplatesCreateOpts) (PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutletTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v PowerOutletTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a power outlet template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet template.
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerOutletTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletTemplatesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of power outlet template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) -  Description
     * @param "DescriptionIc" (optional.Interface of []string) -  Description
     * @param "DescriptionIe" (optional.Interface of []string) -  Description
     * @param "DescriptionIew" (optional.Interface of []string) -  Description
     * @param "DescriptionIre" (optional.Interface of []string) -  Description
     * @param "DescriptionIsw" (optional.Interface of []string) -  Description
     * @param "DescriptionN" (optional.Interface of []string) -  Description
     * @param "DescriptionNic" (optional.Interface of []string) -  Description
     * @param "DescriptionNie" (optional.Interface of []string) -  Description
     * @param "DescriptionNiew" (optional.Interface of []string) -  Description
     * @param "DescriptionNire" (optional.Interface of []string) -  Description
     * @param "DescriptionNisw" (optional.Interface of []string) -  Description
     * @param "DescriptionNre" (optional.Interface of []string) -  Description
     * @param "DescriptionRe" (optional.Interface of []string) -  Description
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "FeedLeg" (optional.Interface of []string) -  Phase (for three-phase feeds)
     * @param "FeedLegIc" (optional.Interface of []string) - 
     * @param "FeedLegIe" (optional.Interface of []string) - 
     * @param "FeedLegIew" (optional.Interface of []string) - 
     * @param "FeedLegIre" (optional.Interface of []string) - 
     * @param "FeedLegIsw" (optional.Interface of []string) - 
     * @param "FeedLegN" (optional.Interface of []string) -  Phase (for three-phase feeds)
     * @param "FeedLegNic" (optional.Interface of []string) - 
     * @param "FeedLegNie" (optional.Interface of []string) - 
     * @param "FeedLegNiew" (optional.Interface of []string) - 
     * @param "FeedLegNire" (optional.Interface of []string) - 
     * @param "FeedLegNisw" (optional.Interface of []string) - 
     * @param "FeedLegNre" (optional.Interface of []string) - 
     * @param "FeedLegRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  ID
     * @param "IdIc" (optional.Interface of []string) -  ID
     * @param "IdIe" (optional.Interface of []string) -  ID
     * @param "IdIew" (optional.Interface of []string) -  ID
     * @param "IdIre" (optional.Interface of []string) -  ID
     * @param "IdIsw" (optional.Interface of []string) -  ID
     * @param "IdN" (optional.Interface of []string) -  ID
     * @param "IdNic" (optional.Interface of []string) -  ID
     * @param "IdNie" (optional.Interface of []string) -  ID
     * @param "IdNiew" (optional.Interface of []string) -  ID
     * @param "IdNire" (optional.Interface of []string) -  ID
     * @param "IdNisw" (optional.Interface of []string) -  ID
     * @param "IdNre" (optional.Interface of []string) -  ID
     * @param "IdRe" (optional.Interface of []string) -  ID
     * @param "Label" (optional.Interface of []string) -  Label
     * @param "LabelIc" (optional.Interface of []string) -  Label
     * @param "LabelIe" (optional.Interface of []string) -  Label
     * @param "LabelIew" (optional.Interface of []string) -  Label
     * @param "LabelIre" (optional.Interface of []string) -  Label
     * @param "LabelIsw" (optional.Interface of []string) -  Label
     * @param "LabelN" (optional.Interface of []string) -  Label
     * @param "LabelNic" (optional.Interface of []string) -  Label
     * @param "LabelNie" (optional.Interface of []string) -  Label
     * @param "LabelNiew" (optional.Interface of []string) -  Label
     * @param "LabelNire" (optional.Interface of []string) -  Label
     * @param "LabelNisw" (optional.Interface of []string) -  Label
     * @param "LabelNre" (optional.Interface of []string) -  Label
     * @param "LabelRe" (optional.Interface of []string) -  Label
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) -  Name
     * @param "NameIc" (optional.Interface of []string) -  Name
     * @param "NameIe" (optional.Interface of []string) -  Name
     * @param "NameIew" (optional.Interface of []string) -  Name
     * @param "NameIre" (optional.Interface of []string) -  Name
     * @param "NameIsw" (optional.Interface of []string) -  Name
     * @param "NameN" (optional.Interface of []string) -  Name
     * @param "NameNic" (optional.Interface of []string) -  Name
     * @param "NameNie" (optional.Interface of []string) -  Name
     * @param "NameNiew" (optional.Interface of []string) -  Name
     * @param "NameNire" (optional.Interface of []string) -  Name
     * @param "NameNisw" (optional.Interface of []string) -  Name
     * @param "NameNre" (optional.Interface of []string) -  Name
     * @param "NameRe" (optional.Interface of []string) -  Name
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PowerPortTemplate" (optional.Interface of []string) - 
     * @param "PowerPortTemplateIsnull" (optional.Bool) - 
     * @param "PowerPortTemplateN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedPowerOutletTemplateList
*/

type DcimApiDcimPowerOutletTemplatesListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    FeedLeg optional.Interface
    FeedLegIc optional.Interface
    FeedLegIe optional.Interface
    FeedLegIew optional.Interface
    FeedLegIre optional.Interface
    FeedLegIsw optional.Interface
    FeedLegN optional.Interface
    FeedLegNic optional.Interface
    FeedLegNie optional.Interface
    FeedLegNiew optional.Interface
    FeedLegNire optional.Interface
    FeedLegNisw optional.Interface
    FeedLegNre optional.Interface
    FeedLegRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    PowerPortTemplate optional.Interface
    PowerPortTemplateIsnull optional.Bool
    PowerPortTemplateN optional.Interface
    Q optional.String
    Sort optional.String
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerOutletTemplatesList(ctx context.Context, localVarOptionals *DcimApiDcimPowerOutletTemplatesListOpts) (PaginatedPowerOutletTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedPowerOutletTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLeg.IsSet() {
		localVarQueryParams.Add("feed_leg", parameterToString(localVarOptionals.FeedLeg.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIc.IsSet() {
		localVarQueryParams.Add("feed_leg__ic", parameterToString(localVarOptionals.FeedLegIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIe.IsSet() {
		localVarQueryParams.Add("feed_leg__ie", parameterToString(localVarOptionals.FeedLegIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIew.IsSet() {
		localVarQueryParams.Add("feed_leg__iew", parameterToString(localVarOptionals.FeedLegIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIre.IsSet() {
		localVarQueryParams.Add("feed_leg__ire", parameterToString(localVarOptionals.FeedLegIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIsw.IsSet() {
		localVarQueryParams.Add("feed_leg__isw", parameterToString(localVarOptionals.FeedLegIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegN.IsSet() {
		localVarQueryParams.Add("feed_leg__n", parameterToString(localVarOptionals.FeedLegN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNic.IsSet() {
		localVarQueryParams.Add("feed_leg__nic", parameterToString(localVarOptionals.FeedLegNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNie.IsSet() {
		localVarQueryParams.Add("feed_leg__nie", parameterToString(localVarOptionals.FeedLegNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNiew.IsSet() {
		localVarQueryParams.Add("feed_leg__niew", parameterToString(localVarOptionals.FeedLegNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNire.IsSet() {
		localVarQueryParams.Add("feed_leg__nire", parameterToString(localVarOptionals.FeedLegNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNisw.IsSet() {
		localVarQueryParams.Add("feed_leg__nisw", parameterToString(localVarOptionals.FeedLegNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNre.IsSet() {
		localVarQueryParams.Add("feed_leg__nre", parameterToString(localVarOptionals.FeedLegNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegRe.IsSet() {
		localVarQueryParams.Add("feed_leg__re", parameterToString(localVarOptionals.FeedLegRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortTemplate.IsSet() {
		localVarQueryParams.Add("power_port_template", parameterToString(localVarOptionals.PowerPortTemplate.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortTemplateIsnull.IsSet() {
		localVarQueryParams.Add("power_port_template__isnull", parameterToString(localVarOptionals.PowerPortTemplateIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortTemplateN.IsSet() {
		localVarQueryParams.Add("power_port_template__n", parameterToString(localVarOptionals.PowerPortTemplateN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedPowerOutletTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power outlet template.
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimPowerOutletTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimPowerOutletTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet template.
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimPowerOutletTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerOutletTemplatesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a power outlet template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet template.
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritablePowerOutletTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return PowerOutletTemplate
*/

type DcimApiDcimPowerOutletTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletTemplatesPartialUpdateOpts) (PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutletTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerOutletTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a power outlet template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet template.
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerOutletTemplate
*/

type DcimApiDcimPowerOutletTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerOutletTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletTemplatesRetrieveOpts) (PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutletTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerOutletTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a power outlet template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power outlet template.
 * @param optional nil or *DcimApiDcimPowerOutletTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerOutletTemplate
*/

type DcimApiDcimPowerOutletTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletTemplatesUpdate(ctx context.Context, body WritablePowerOutletTemplateRequest, id string, localVarOptionals *DcimApiDcimPowerOutletTemplatesUpdateOpts) (PowerOutletTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutletTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlet-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerOutletTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of power outlet objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerOutletsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerOutletsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimPowerOutletsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of power outlet objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerOutletsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerOutlet
*/

type DcimApiDcimPowerOutletsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritablePowerOutletRequest, localVarOptionals *DcimApiDcimPowerOutletsBulkPartialUpdateOpts) ([]PowerOutlet, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerOutlet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerOutlet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of power outlet objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerOutletsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerOutlet
*/

type DcimApiDcimPowerOutletsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletsBulkUpdate(ctx context.Context, body []BulkWritablePowerOutletRequest, localVarOptionals *DcimApiDcimPowerOutletsBulkUpdateOpts) ([]PowerOutlet, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerOutlet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerOutlet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more power outlet objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerOutletsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerOutlet
*/

type DcimApiDcimPowerOutletsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletsCreate(ctx context.Context, body WritablePowerOutletRequest, localVarOptionals *DcimApiDcimPowerOutletsCreateOpts) (PowerOutlet, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutlet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v PowerOutlet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a power outlet object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet.
 * @param optional nil or *DcimApiDcimPowerOutletsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerOutletsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of power outlet objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimPowerOutletsListOpts - Optional Parameters:
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "Connected" (optional.Bool) -  Connected status (bool)
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) - 
     * @param "DeviceN" (optional.Interface of []string) - 
     * @param "FeedLeg" (optional.Interface of []string) -  Phase (for three-phase feeds)
     * @param "FeedLegIc" (optional.Interface of []string) - 
     * @param "FeedLegIe" (optional.Interface of []string) - 
     * @param "FeedLegIew" (optional.Interface of []string) - 
     * @param "FeedLegIre" (optional.Interface of []string) - 
     * @param "FeedLegIsw" (optional.Interface of []string) - 
     * @param "FeedLegN" (optional.Interface of []string) -  Phase (for three-phase feeds)
     * @param "FeedLegNic" (optional.Interface of []string) - 
     * @param "FeedLegNie" (optional.Interface of []string) - 
     * @param "FeedLegNiew" (optional.Interface of []string) - 
     * @param "FeedLegNire" (optional.Interface of []string) - 
     * @param "FeedLegNisw" (optional.Interface of []string) - 
     * @param "FeedLegNre" (optional.Interface of []string) - 
     * @param "FeedLegRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PowerPort" (optional.Interface of []string) -  Power port
     * @param "PowerPortIsnull" (optional.Bool) - 
     * @param "PowerPortN" (optional.Interface of []string) -  Power port
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) -  Physical port type
     * @param "TypeIc" (optional.Interface of []string) -  Physical port type
     * @param "TypeIe" (optional.Interface of []string) -  Physical port type
     * @param "TypeIew" (optional.Interface of []string) -  Physical port type
     * @param "TypeIre" (optional.Interface of []string) -  Physical port type
     * @param "TypeIsw" (optional.Interface of []string) -  Physical port type
     * @param "TypeN" (optional.Interface of []string) -  Physical port type
     * @param "TypeNic" (optional.Interface of []string) -  Physical port type
     * @param "TypeNie" (optional.Interface of []string) -  Physical port type
     * @param "TypeNiew" (optional.Interface of []string) -  Physical port type
     * @param "TypeNire" (optional.Interface of []string) -  Physical port type
     * @param "TypeNisw" (optional.Interface of []string) -  Physical port type
     * @param "TypeNre" (optional.Interface of []string) -  Physical port type
     * @param "TypeRe" (optional.Interface of []string) -  Physical port type
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedPowerOutletList
*/

type DcimApiDcimPowerOutletsListOpts struct {
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    Connected optional.Bool
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceN optional.Interface
    FeedLeg optional.Interface
    FeedLegIc optional.Interface
    FeedLegIe optional.Interface
    FeedLegIew optional.Interface
    FeedLegIre optional.Interface
    FeedLegIsw optional.Interface
    FeedLegN optional.Interface
    FeedLegNic optional.Interface
    FeedLegNie optional.Interface
    FeedLegNiew optional.Interface
    FeedLegNire optional.Interface
    FeedLegNisw optional.Interface
    FeedLegNre optional.Interface
    FeedLegRe optional.Interface
    Format optional.String
    HasCable optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    PowerPort optional.Interface
    PowerPortIsnull optional.Bool
    PowerPortN optional.Interface
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerOutletsList(ctx context.Context, localVarOptionals *DcimApiDcimPowerOutletsListOpts) (PaginatedPowerOutletList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedPowerOutletList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Connected.IsSet() {
		localVarQueryParams.Add("connected", parameterToString(localVarOptionals.Connected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceN.IsSet() {
		localVarQueryParams.Add("device__n", parameterToString(localVarOptionals.DeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLeg.IsSet() {
		localVarQueryParams.Add("feed_leg", parameterToString(localVarOptionals.FeedLeg.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIc.IsSet() {
		localVarQueryParams.Add("feed_leg__ic", parameterToString(localVarOptionals.FeedLegIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIe.IsSet() {
		localVarQueryParams.Add("feed_leg__ie", parameterToString(localVarOptionals.FeedLegIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIew.IsSet() {
		localVarQueryParams.Add("feed_leg__iew", parameterToString(localVarOptionals.FeedLegIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIre.IsSet() {
		localVarQueryParams.Add("feed_leg__ire", parameterToString(localVarOptionals.FeedLegIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegIsw.IsSet() {
		localVarQueryParams.Add("feed_leg__isw", parameterToString(localVarOptionals.FeedLegIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegN.IsSet() {
		localVarQueryParams.Add("feed_leg__n", parameterToString(localVarOptionals.FeedLegN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNic.IsSet() {
		localVarQueryParams.Add("feed_leg__nic", parameterToString(localVarOptionals.FeedLegNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNie.IsSet() {
		localVarQueryParams.Add("feed_leg__nie", parameterToString(localVarOptionals.FeedLegNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNiew.IsSet() {
		localVarQueryParams.Add("feed_leg__niew", parameterToString(localVarOptionals.FeedLegNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNire.IsSet() {
		localVarQueryParams.Add("feed_leg__nire", parameterToString(localVarOptionals.FeedLegNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNisw.IsSet() {
		localVarQueryParams.Add("feed_leg__nisw", parameterToString(localVarOptionals.FeedLegNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegNre.IsSet() {
		localVarQueryParams.Add("feed_leg__nre", parameterToString(localVarOptionals.FeedLegNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FeedLegRe.IsSet() {
		localVarQueryParams.Add("feed_leg__re", parameterToString(localVarOptionals.FeedLegRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPort.IsSet() {
		localVarQueryParams.Add("power_port", parameterToString(localVarOptionals.PowerPort.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortIsnull.IsSet() {
		localVarQueryParams.Add("power_port__isnull", parameterToString(localVarOptionals.PowerPortIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPortN.IsSet() {
		localVarQueryParams.Add("power_port__n", parameterToString(localVarOptionals.PowerPortN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedPowerOutletList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power outlet.
 * @param optional nil or *DcimApiDcimPowerOutletsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimPowerOutletsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimPowerOutletsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet.
 * @param optional nil or *DcimApiDcimPowerOutletsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimPowerOutletsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerOutletsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a power outlet object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet.
 * @param optional nil or *DcimApiDcimPowerOutletsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritablePowerOutletRequest) - 
     * @param "Format" (optional.String) - 
@return PowerOutlet
*/

type DcimApiDcimPowerOutletsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletsPartialUpdateOpts) (PowerOutlet, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutlet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerOutlet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a power outlet object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet.
 * @param optional nil or *DcimApiDcimPowerOutletsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerOutlet
*/

type DcimApiDcimPowerOutletsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerOutletsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletsRetrieveOpts) (PowerOutlet, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutlet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerOutlet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power outlet.
 * @param optional nil or *DcimApiDcimPowerOutletsTraceRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerOutlet
*/

type DcimApiDcimPowerOutletsTraceRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerOutletsTraceRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerOutletsTraceRetrieveOpts) (PowerOutlet, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutlet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerOutlet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a power outlet object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power outlet.
 * @param optional nil or *DcimApiDcimPowerOutletsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerOutlet
*/

type DcimApiDcimPowerOutletsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerOutletsUpdate(ctx context.Context, body WritablePowerOutletRequest, id string, localVarOptionals *DcimApiDcimPowerOutletsUpdateOpts) (PowerOutlet, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerOutlet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-outlets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerOutlet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of power panel objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPanelsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerPanelsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPanelsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimPowerPanelsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of power panel objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPanelsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerPanel
*/

type DcimApiDcimPowerPanelsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPanelsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritablePowerPanelRequest, localVarOptionals *DcimApiDcimPowerPanelsBulkPartialUpdateOpts) ([]PowerPanel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerPanel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerPanel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of power panel objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPanelsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerPanel
*/

type DcimApiDcimPowerPanelsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPanelsBulkUpdate(ctx context.Context, body []BulkWritablePowerPanelRequest, localVarOptionals *DcimApiDcimPowerPanelsBulkUpdateOpts) ([]PowerPanel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerPanel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerPanel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more power panel objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPanelsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerPanel
*/

type DcimApiDcimPowerPanelsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPanelsCreate(ctx context.Context, body PowerPanelRequest, localVarOptionals *DcimApiDcimPowerPanelsCreateOpts) (PowerPanel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPanel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v PowerPanel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a power panel object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power panel.
 * @param optional nil or *DcimApiDcimPowerPanelsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerPanelsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPanelsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPanelsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of power panel objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimPowerPanelsListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "HasPowerFeeds" (optional.Bool) -  Has power feeds
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PowerFeeds" (optional.Interface of []string) - 
     * @param "PowerFeedsIsnull" (optional.Bool) - 
     * @param "PowerFeedsN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "RackGroup" (optional.Interface of []string) - 
     * @param "RackGroupIsnull" (optional.Bool) - 
     * @param "RackGroupN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedPowerPanelList
*/

type DcimApiDcimPowerPanelsListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    HasPowerFeeds optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    PowerFeeds optional.Interface
    PowerFeedsIsnull optional.Bool
    PowerFeedsN optional.Interface
    Q optional.String
    RackGroup optional.Interface
    RackGroupIsnull optional.Bool
    RackGroupN optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPanelsList(ctx context.Context, localVarOptionals *DcimApiDcimPowerPanelsListOpts) (PaginatedPowerPanelList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedPowerPanelList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerFeeds.IsSet() {
		localVarQueryParams.Add("has_power_feeds", parameterToString(localVarOptionals.HasPowerFeeds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerFeeds.IsSet() {
		localVarQueryParams.Add("power_feeds", parameterToString(localVarOptionals.PowerFeeds.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerFeedsIsnull.IsSet() {
		localVarQueryParams.Add("power_feeds__isnull", parameterToString(localVarOptionals.PowerFeedsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerFeedsN.IsSet() {
		localVarQueryParams.Add("power_feeds__n", parameterToString(localVarOptionals.PowerFeedsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroup.IsSet() {
		localVarQueryParams.Add("rack_group", parameterToString(localVarOptionals.RackGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupIsnull.IsSet() {
		localVarQueryParams.Add("rack_group__isnull", parameterToString(localVarOptionals.RackGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupN.IsSet() {
		localVarQueryParams.Add("rack_group__n", parameterToString(localVarOptionals.RackGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedPowerPanelList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power panel.
 * @param optional nil or *DcimApiDcimPowerPanelsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimPowerPanelsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPanelsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimPowerPanelsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power panel.
 * @param optional nil or *DcimApiDcimPowerPanelsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimPowerPanelsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPanelsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPanelsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a power panel object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power panel.
 * @param optional nil or *DcimApiDcimPowerPanelsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedPowerPanelRequest) - 
     * @param "Format" (optional.String) - 
@return PowerPanel
*/

type DcimApiDcimPowerPanelsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimPowerPanelsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPanelsPartialUpdateOpts) (PowerPanel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPanel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPanel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a power panel object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power panel.
 * @param optional nil or *DcimApiDcimPowerPanelsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerPanel
*/

type DcimApiDcimPowerPanelsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPanelsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPanelsRetrieveOpts) (PowerPanel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPanel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPanel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a power panel object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power panel.
 * @param optional nil or *DcimApiDcimPowerPanelsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerPanel
*/

type DcimApiDcimPowerPanelsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPanelsUpdate(ctx context.Context, body PowerPanelRequest, id string, localVarOptionals *DcimApiDcimPowerPanelsUpdateOpts) (PowerPanel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPanel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-panels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPanel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of power port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPortTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerPortTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimPowerPortTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of power port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPortTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerPortTemplate
*/

type DcimApiDcimPowerPortTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritablePowerPortTemplateRequest, localVarOptionals *DcimApiDcimPowerPortTemplatesBulkPartialUpdateOpts) ([]PowerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of power port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPortTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerPortTemplate
*/

type DcimApiDcimPowerPortTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortTemplatesBulkUpdate(ctx context.Context, body []BulkWritablePowerPortTemplateRequest, localVarOptionals *DcimApiDcimPowerPortTemplatesBulkUpdateOpts) ([]PowerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more power port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPortTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerPortTemplate
*/

type DcimApiDcimPowerPortTemplatesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortTemplatesCreate(ctx context.Context, body WritablePowerPortTemplateRequest, localVarOptionals *DcimApiDcimPowerPortTemplatesCreateOpts) (PowerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v PowerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a power port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port template.
 * @param optional nil or *DcimApiDcimPowerPortTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerPortTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortTemplatesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of power port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimPowerPortTemplatesListOpts - Optional Parameters:
     * @param "AllocatedDraw" (optional.Interface of []int32) - 
     * @param "AllocatedDrawGt" (optional.Interface of []int32) - 
     * @param "AllocatedDrawGte" (optional.Interface of []int32) - 
     * @param "AllocatedDrawIsnull" (optional.Bool) - 
     * @param "AllocatedDrawLt" (optional.Interface of []int32) - 
     * @param "AllocatedDrawLte" (optional.Interface of []int32) - 
     * @param "AllocatedDrawN" (optional.Interface of []int32) - 
     * @param "Description" (optional.Interface of []string) -  Description
     * @param "DescriptionIc" (optional.Interface of []string) -  Description
     * @param "DescriptionIe" (optional.Interface of []string) -  Description
     * @param "DescriptionIew" (optional.Interface of []string) -  Description
     * @param "DescriptionIre" (optional.Interface of []string) -  Description
     * @param "DescriptionIsw" (optional.Interface of []string) -  Description
     * @param "DescriptionN" (optional.Interface of []string) -  Description
     * @param "DescriptionNic" (optional.Interface of []string) -  Description
     * @param "DescriptionNie" (optional.Interface of []string) -  Description
     * @param "DescriptionNiew" (optional.Interface of []string) -  Description
     * @param "DescriptionNire" (optional.Interface of []string) -  Description
     * @param "DescriptionNisw" (optional.Interface of []string) -  Description
     * @param "DescriptionNre" (optional.Interface of []string) -  Description
     * @param "DescriptionRe" (optional.Interface of []string) -  Description
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasPowerOutletTemplates" (optional.Bool) -  Has power outlet templates
     * @param "Id" (optional.Interface of []string) -  ID
     * @param "IdIc" (optional.Interface of []string) -  ID
     * @param "IdIe" (optional.Interface of []string) -  ID
     * @param "IdIew" (optional.Interface of []string) -  ID
     * @param "IdIre" (optional.Interface of []string) -  ID
     * @param "IdIsw" (optional.Interface of []string) -  ID
     * @param "IdN" (optional.Interface of []string) -  ID
     * @param "IdNic" (optional.Interface of []string) -  ID
     * @param "IdNie" (optional.Interface of []string) -  ID
     * @param "IdNiew" (optional.Interface of []string) -  ID
     * @param "IdNire" (optional.Interface of []string) -  ID
     * @param "IdNisw" (optional.Interface of []string) -  ID
     * @param "IdNre" (optional.Interface of []string) -  ID
     * @param "IdRe" (optional.Interface of []string) -  ID
     * @param "Label" (optional.Interface of []string) -  Label
     * @param "LabelIc" (optional.Interface of []string) -  Label
     * @param "LabelIe" (optional.Interface of []string) -  Label
     * @param "LabelIew" (optional.Interface of []string) -  Label
     * @param "LabelIre" (optional.Interface of []string) -  Label
     * @param "LabelIsw" (optional.Interface of []string) -  Label
     * @param "LabelN" (optional.Interface of []string) -  Label
     * @param "LabelNic" (optional.Interface of []string) -  Label
     * @param "LabelNie" (optional.Interface of []string) -  Label
     * @param "LabelNiew" (optional.Interface of []string) -  Label
     * @param "LabelNire" (optional.Interface of []string) -  Label
     * @param "LabelNisw" (optional.Interface of []string) -  Label
     * @param "LabelNre" (optional.Interface of []string) -  Label
     * @param "LabelRe" (optional.Interface of []string) -  Label
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "MaximumDraw" (optional.Interface of []int32) - 
     * @param "MaximumDrawGt" (optional.Interface of []int32) - 
     * @param "MaximumDrawGte" (optional.Interface of []int32) - 
     * @param "MaximumDrawIsnull" (optional.Bool) - 
     * @param "MaximumDrawLt" (optional.Interface of []int32) - 
     * @param "MaximumDrawLte" (optional.Interface of []int32) - 
     * @param "MaximumDrawN" (optional.Interface of []int32) - 
     * @param "Name" (optional.Interface of []string) -  Name
     * @param "NameIc" (optional.Interface of []string) -  Name
     * @param "NameIe" (optional.Interface of []string) -  Name
     * @param "NameIew" (optional.Interface of []string) -  Name
     * @param "NameIre" (optional.Interface of []string) -  Name
     * @param "NameIsw" (optional.Interface of []string) -  Name
     * @param "NameN" (optional.Interface of []string) -  Name
     * @param "NameNic" (optional.Interface of []string) -  Name
     * @param "NameNie" (optional.Interface of []string) -  Name
     * @param "NameNiew" (optional.Interface of []string) -  Name
     * @param "NameNire" (optional.Interface of []string) -  Name
     * @param "NameNisw" (optional.Interface of []string) -  Name
     * @param "NameNre" (optional.Interface of []string) -  Name
     * @param "NameRe" (optional.Interface of []string) -  Name
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PowerOutletTemplates" (optional.Interface of []string) - 
     * @param "PowerOutletTemplatesIsnull" (optional.Bool) - 
     * @param "PowerOutletTemplatesN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedPowerPortTemplateList
*/

type DcimApiDcimPowerPortTemplatesListOpts struct {
    AllocatedDraw optional.Interface
    AllocatedDrawGt optional.Interface
    AllocatedDrawGte optional.Interface
    AllocatedDrawIsnull optional.Bool
    AllocatedDrawLt optional.Interface
    AllocatedDrawLte optional.Interface
    AllocatedDrawN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Format optional.String
    HasPowerOutletTemplates optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    MaximumDraw optional.Interface
    MaximumDrawGt optional.Interface
    MaximumDrawGte optional.Interface
    MaximumDrawIsnull optional.Bool
    MaximumDrawLt optional.Interface
    MaximumDrawLte optional.Interface
    MaximumDrawN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    PowerOutletTemplates optional.Interface
    PowerOutletTemplatesIsnull optional.Bool
    PowerOutletTemplatesN optional.Interface
    Q optional.String
    Sort optional.String
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPortTemplatesList(ctx context.Context, localVarOptionals *DcimApiDcimPowerPortTemplatesListOpts) (PaginatedPowerPortTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedPowerPortTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AllocatedDraw.IsSet() {
		localVarQueryParams.Add("allocated_draw", parameterToString(localVarOptionals.AllocatedDraw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawGt.IsSet() {
		localVarQueryParams.Add("allocated_draw__gt", parameterToString(localVarOptionals.AllocatedDrawGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawGte.IsSet() {
		localVarQueryParams.Add("allocated_draw__gte", parameterToString(localVarOptionals.AllocatedDrawGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawIsnull.IsSet() {
		localVarQueryParams.Add("allocated_draw__isnull", parameterToString(localVarOptionals.AllocatedDrawIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawLt.IsSet() {
		localVarQueryParams.Add("allocated_draw__lt", parameterToString(localVarOptionals.AllocatedDrawLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawLte.IsSet() {
		localVarQueryParams.Add("allocated_draw__lte", parameterToString(localVarOptionals.AllocatedDrawLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawN.IsSet() {
		localVarQueryParams.Add("allocated_draw__n", parameterToString(localVarOptionals.AllocatedDrawN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerOutletTemplates.IsSet() {
		localVarQueryParams.Add("has_power_outlet_templates", parameterToString(localVarOptionals.HasPowerOutletTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDraw.IsSet() {
		localVarQueryParams.Add("maximum_draw", parameterToString(localVarOptionals.MaximumDraw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawGt.IsSet() {
		localVarQueryParams.Add("maximum_draw__gt", parameterToString(localVarOptionals.MaximumDrawGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawGte.IsSet() {
		localVarQueryParams.Add("maximum_draw__gte", parameterToString(localVarOptionals.MaximumDrawGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawIsnull.IsSet() {
		localVarQueryParams.Add("maximum_draw__isnull", parameterToString(localVarOptionals.MaximumDrawIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawLt.IsSet() {
		localVarQueryParams.Add("maximum_draw__lt", parameterToString(localVarOptionals.MaximumDrawLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawLte.IsSet() {
		localVarQueryParams.Add("maximum_draw__lte", parameterToString(localVarOptionals.MaximumDrawLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawN.IsSet() {
		localVarQueryParams.Add("maximum_draw__n", parameterToString(localVarOptionals.MaximumDrawN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletTemplates.IsSet() {
		localVarQueryParams.Add("power_outlet_templates", parameterToString(localVarOptionals.PowerOutletTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("power_outlet_templates__isnull", parameterToString(localVarOptionals.PowerOutletTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletTemplatesN.IsSet() {
		localVarQueryParams.Add("power_outlet_templates__n", parameterToString(localVarOptionals.PowerOutletTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedPowerPortTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power port template.
 * @param optional nil or *DcimApiDcimPowerPortTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimPowerPortTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimPowerPortTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port template.
 * @param optional nil or *DcimApiDcimPowerPortTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimPowerPortTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPortTemplatesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a power port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port template.
 * @param optional nil or *DcimApiDcimPowerPortTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritablePowerPortTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return PowerPortTemplate
*/

type DcimApiDcimPowerPortTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortTemplatesPartialUpdateOpts) (PowerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a power port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port template.
 * @param optional nil or *DcimApiDcimPowerPortTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerPortTemplate
*/

type DcimApiDcimPowerPortTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPortTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortTemplatesRetrieveOpts) (PowerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a power port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power port template.
 * @param optional nil or *DcimApiDcimPowerPortTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerPortTemplate
*/

type DcimApiDcimPowerPortTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortTemplatesUpdate(ctx context.Context, body WritablePowerPortTemplateRequest, id string, localVarOptionals *DcimApiDcimPowerPortTemplatesUpdateOpts) (PowerPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of power port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPortsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerPortsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimPowerPortsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of power port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPortsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerPort
*/

type DcimApiDcimPowerPortsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritablePowerPortRequest, localVarOptionals *DcimApiDcimPowerPortsBulkPartialUpdateOpts) ([]PowerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of power port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPortsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []PowerPort
*/

type DcimApiDcimPowerPortsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortsBulkUpdate(ctx context.Context, body []BulkWritablePowerPortRequest, localVarOptionals *DcimApiDcimPowerPortsBulkUpdateOpts) ([]PowerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PowerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PowerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more power port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimPowerPortsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerPort
*/

type DcimApiDcimPowerPortsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortsCreate(ctx context.Context, body WritablePowerPortRequest, localVarOptionals *DcimApiDcimPowerPortsCreateOpts) (PowerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v PowerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a power port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port.
 * @param optional nil or *DcimApiDcimPowerPortsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimPowerPortsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of power port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimPowerPortsListOpts - Optional Parameters:
     * @param "AllocatedDraw" (optional.Interface of []int32) - 
     * @param "AllocatedDrawGt" (optional.Interface of []int32) - 
     * @param "AllocatedDrawGte" (optional.Interface of []int32) - 
     * @param "AllocatedDrawIsnull" (optional.Bool) - 
     * @param "AllocatedDrawLt" (optional.Interface of []int32) - 
     * @param "AllocatedDrawLte" (optional.Interface of []int32) - 
     * @param "AllocatedDrawN" (optional.Interface of []int32) - 
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "Connected" (optional.Bool) -  Connected status (bool)
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) - 
     * @param "DeviceN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "HasPowerOutlets" (optional.Bool) -  Has power outlets
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "MaximumDraw" (optional.Interface of []int32) - 
     * @param "MaximumDrawGt" (optional.Interface of []int32) - 
     * @param "MaximumDrawGte" (optional.Interface of []int32) - 
     * @param "MaximumDrawIsnull" (optional.Bool) - 
     * @param "MaximumDrawLt" (optional.Interface of []int32) - 
     * @param "MaximumDrawLte" (optional.Interface of []int32) - 
     * @param "MaximumDrawN" (optional.Interface of []int32) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PowerOutlets" (optional.Interface of []string) - 
     * @param "PowerOutletsIsnull" (optional.Bool) - 
     * @param "PowerOutletsN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) -  Physical port type
     * @param "TypeIc" (optional.Interface of []string) -  Physical port type
     * @param "TypeIe" (optional.Interface of []string) -  Physical port type
     * @param "TypeIew" (optional.Interface of []string) -  Physical port type
     * @param "TypeIre" (optional.Interface of []string) -  Physical port type
     * @param "TypeIsw" (optional.Interface of []string) -  Physical port type
     * @param "TypeN" (optional.Interface of []string) -  Physical port type
     * @param "TypeNic" (optional.Interface of []string) -  Physical port type
     * @param "TypeNie" (optional.Interface of []string) -  Physical port type
     * @param "TypeNiew" (optional.Interface of []string) -  Physical port type
     * @param "TypeNire" (optional.Interface of []string) -  Physical port type
     * @param "TypeNisw" (optional.Interface of []string) -  Physical port type
     * @param "TypeNre" (optional.Interface of []string) -  Physical port type
     * @param "TypeRe" (optional.Interface of []string) -  Physical port type
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedPowerPortList
*/

type DcimApiDcimPowerPortsListOpts struct {
    AllocatedDraw optional.Interface
    AllocatedDrawGt optional.Interface
    AllocatedDrawGte optional.Interface
    AllocatedDrawIsnull optional.Bool
    AllocatedDrawLt optional.Interface
    AllocatedDrawLte optional.Interface
    AllocatedDrawN optional.Interface
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    Connected optional.Bool
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceN optional.Interface
    Format optional.String
    HasCable optional.Bool
    HasPowerOutlets optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    MaximumDraw optional.Interface
    MaximumDrawGt optional.Interface
    MaximumDrawGte optional.Interface
    MaximumDrawIsnull optional.Bool
    MaximumDrawLt optional.Interface
    MaximumDrawLte optional.Interface
    MaximumDrawN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    PowerOutlets optional.Interface
    PowerOutletsIsnull optional.Bool
    PowerOutletsN optional.Interface
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPortsList(ctx context.Context, localVarOptionals *DcimApiDcimPowerPortsListOpts) (PaginatedPowerPortList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedPowerPortList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AllocatedDraw.IsSet() {
		localVarQueryParams.Add("allocated_draw", parameterToString(localVarOptionals.AllocatedDraw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawGt.IsSet() {
		localVarQueryParams.Add("allocated_draw__gt", parameterToString(localVarOptionals.AllocatedDrawGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawGte.IsSet() {
		localVarQueryParams.Add("allocated_draw__gte", parameterToString(localVarOptionals.AllocatedDrawGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawIsnull.IsSet() {
		localVarQueryParams.Add("allocated_draw__isnull", parameterToString(localVarOptionals.AllocatedDrawIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawLt.IsSet() {
		localVarQueryParams.Add("allocated_draw__lt", parameterToString(localVarOptionals.AllocatedDrawLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawLte.IsSet() {
		localVarQueryParams.Add("allocated_draw__lte", parameterToString(localVarOptionals.AllocatedDrawLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AllocatedDrawN.IsSet() {
		localVarQueryParams.Add("allocated_draw__n", parameterToString(localVarOptionals.AllocatedDrawN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Connected.IsSet() {
		localVarQueryParams.Add("connected", parameterToString(localVarOptionals.Connected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceN.IsSet() {
		localVarQueryParams.Add("device__n", parameterToString(localVarOptionals.DeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerOutlets.IsSet() {
		localVarQueryParams.Add("has_power_outlets", parameterToString(localVarOptionals.HasPowerOutlets.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDraw.IsSet() {
		localVarQueryParams.Add("maximum_draw", parameterToString(localVarOptionals.MaximumDraw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawGt.IsSet() {
		localVarQueryParams.Add("maximum_draw__gt", parameterToString(localVarOptionals.MaximumDrawGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawGte.IsSet() {
		localVarQueryParams.Add("maximum_draw__gte", parameterToString(localVarOptionals.MaximumDrawGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawIsnull.IsSet() {
		localVarQueryParams.Add("maximum_draw__isnull", parameterToString(localVarOptionals.MaximumDrawIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawLt.IsSet() {
		localVarQueryParams.Add("maximum_draw__lt", parameterToString(localVarOptionals.MaximumDrawLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawLte.IsSet() {
		localVarQueryParams.Add("maximum_draw__lte", parameterToString(localVarOptionals.MaximumDrawLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumDrawN.IsSet() {
		localVarQueryParams.Add("maximum_draw__n", parameterToString(localVarOptionals.MaximumDrawN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutlets.IsSet() {
		localVarQueryParams.Add("power_outlets", parameterToString(localVarOptionals.PowerOutlets.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletsIsnull.IsSet() {
		localVarQueryParams.Add("power_outlets__isnull", parameterToString(localVarOptionals.PowerOutletsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerOutletsN.IsSet() {
		localVarQueryParams.Add("power_outlets__n", parameterToString(localVarOptionals.PowerOutletsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedPowerPortList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power port.
 * @param optional nil or *DcimApiDcimPowerPortsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimPowerPortsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimPowerPortsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port.
 * @param optional nil or *DcimApiDcimPowerPortsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimPowerPortsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPortsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a power port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port.
 * @param optional nil or *DcimApiDcimPowerPortsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritablePowerPortRequest) - 
     * @param "Format" (optional.String) - 
@return PowerPort
*/

type DcimApiDcimPowerPortsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortsPartialUpdateOpts) (PowerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a power port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port.
 * @param optional nil or *DcimApiDcimPowerPortsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerPort
*/

type DcimApiDcimPowerPortsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPortsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortsRetrieveOpts) (PowerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this power port.
 * @param optional nil or *DcimApiDcimPowerPortsTraceRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PowerPort
*/

type DcimApiDcimPowerPortsTraceRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimPowerPortsTraceRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimPowerPortsTraceRetrieveOpts) (PowerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a power port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this power port.
 * @param optional nil or *DcimApiDcimPowerPortsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return PowerPort
*/

type DcimApiDcimPowerPortsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimPowerPortsUpdate(ctx context.Context, body WritablePowerPortRequest, id string, localVarOptionals *DcimApiDcimPowerPortsUpdateOpts) (PowerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PowerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/power-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PowerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of rack group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRackGroupsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRackGroupsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackGroupsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimRackGroupsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of rack group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRackGroupsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RackGroup
*/

type DcimApiDcimRackGroupsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackGroupsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableRackGroupRequest, localVarOptionals *DcimApiDcimRackGroupsBulkPartialUpdateOpts) ([]RackGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RackGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RackGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of rack group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRackGroupsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RackGroup
*/

type DcimApiDcimRackGroupsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackGroupsBulkUpdate(ctx context.Context, body []BulkWritableRackGroupRequest, localVarOptionals *DcimApiDcimRackGroupsBulkUpdateOpts) ([]RackGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RackGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RackGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more rack group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRackGroupsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RackGroup
*/

type DcimApiDcimRackGroupsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackGroupsCreate(ctx context.Context, body RackGroupRequest, localVarOptionals *DcimApiDcimRackGroupsCreateOpts) (RackGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RackGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v RackGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a rack group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack group.
 * @param optional nil or *DcimApiDcimRackGroupsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRackGroupsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackGroupsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimRackGroupsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of rack group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimRackGroupsListOpts - Optional Parameters:
     * @param "Children" (optional.Interface of []string) - 
     * @param "ChildrenIsnull" (optional.Bool) - 
     * @param "ChildrenN" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasChildren" (optional.Bool) -  Has children
     * @param "HasPowerPanels" (optional.Bool) -  Has power panels
     * @param "HasRacks" (optional.Bool) -  Has racks
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Parent" (optional.Interface of []string) - 
     * @param "ParentIsnull" (optional.Bool) - 
     * @param "ParentN" (optional.Interface of []string) - 
     * @param "PowerPanels" (optional.Interface of []string) - 
     * @param "PowerPanelsIsnull" (optional.Bool) - 
     * @param "PowerPanelsN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Racks" (optional.Interface of []string) - 
     * @param "RacksIsnull" (optional.Bool) - 
     * @param "RacksN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRackGroupList
*/

type DcimApiDcimRackGroupsListOpts struct {
    Children optional.Interface
    ChildrenIsnull optional.Bool
    ChildrenN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    HasChildren optional.Bool
    HasPowerPanels optional.Bool
    HasRacks optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Parent optional.Interface
    ParentIsnull optional.Bool
    ParentN optional.Interface
    PowerPanels optional.Interface
    PowerPanelsIsnull optional.Bool
    PowerPanelsN optional.Interface
    Q optional.String
    Racks optional.Interface
    RacksIsnull optional.Bool
    RacksN optional.Interface
    Sort optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimRackGroupsList(ctx context.Context, localVarOptionals *DcimApiDcimRackGroupsListOpts) (PaginatedRackGroupList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRackGroupList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Children.IsSet() {
		localVarQueryParams.Add("children", parameterToString(localVarOptionals.Children.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChildrenIsnull.IsSet() {
		localVarQueryParams.Add("children__isnull", parameterToString(localVarOptionals.ChildrenIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChildrenN.IsSet() {
		localVarQueryParams.Add("children__n", parameterToString(localVarOptionals.ChildrenN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasChildren.IsSet() {
		localVarQueryParams.Add("has_children", parameterToString(localVarOptionals.HasChildren.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerPanels.IsSet() {
		localVarQueryParams.Add("has_power_panels", parameterToString(localVarOptionals.HasPowerPanels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRacks.IsSet() {
		localVarQueryParams.Add("has_racks", parameterToString(localVarOptionals.HasRacks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parent.IsSet() {
		localVarQueryParams.Add("parent", parameterToString(localVarOptionals.Parent.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentIsnull.IsSet() {
		localVarQueryParams.Add("parent__isnull", parameterToString(localVarOptionals.ParentIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentN.IsSet() {
		localVarQueryParams.Add("parent__n", parameterToString(localVarOptionals.ParentN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPanels.IsSet() {
		localVarQueryParams.Add("power_panels", parameterToString(localVarOptionals.PowerPanels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPanelsIsnull.IsSet() {
		localVarQueryParams.Add("power_panels__isnull", parameterToString(localVarOptionals.PowerPanelsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerPanelsN.IsSet() {
		localVarQueryParams.Add("power_panels__n", parameterToString(localVarOptionals.PowerPanelsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Racks.IsSet() {
		localVarQueryParams.Add("racks", parameterToString(localVarOptionals.Racks.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RacksIsnull.IsSet() {
		localVarQueryParams.Add("racks__isnull", parameterToString(localVarOptionals.RacksIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RacksN.IsSet() {
		localVarQueryParams.Add("racks__n", parameterToString(localVarOptionals.RacksN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRackGroupList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rack group.
 * @param optional nil or *DcimApiDcimRackGroupsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimRackGroupsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackGroupsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimRackGroupsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack group.
 * @param optional nil or *DcimApiDcimRackGroupsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimRackGroupsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimRackGroupsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimRackGroupsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a rack group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack group.
 * @param optional nil or *DcimApiDcimRackGroupsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedRackGroupRequest) - 
     * @param "Format" (optional.String) - 
@return RackGroup
*/

type DcimApiDcimRackGroupsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimRackGroupsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimRackGroupsPartialUpdateOpts) (RackGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RackGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RackGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a rack group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack group.
 * @param optional nil or *DcimApiDcimRackGroupsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return RackGroup
*/

type DcimApiDcimRackGroupsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimRackGroupsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimRackGroupsRetrieveOpts) (RackGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RackGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RackGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a rack group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rack group.
 * @param optional nil or *DcimApiDcimRackGroupsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RackGroup
*/

type DcimApiDcimRackGroupsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackGroupsUpdate(ctx context.Context, body RackGroupRequest, id string, localVarOptionals *DcimApiDcimRackGroupsUpdateOpts) (RackGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RackGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RackGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of rack reservation objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRackReservationsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRackReservationsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackReservationsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimRackReservationsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of rack reservation objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRackReservationsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RackReservation
*/

type DcimApiDcimRackReservationsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackReservationsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableRackReservationRequest, localVarOptionals *DcimApiDcimRackReservationsBulkPartialUpdateOpts) ([]RackReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RackReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RackReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of rack reservation objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRackReservationsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RackReservation
*/

type DcimApiDcimRackReservationsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackReservationsBulkUpdate(ctx context.Context, body []BulkWritableRackReservationRequest, localVarOptionals *DcimApiDcimRackReservationsBulkUpdateOpts) ([]RackReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RackReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RackReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more rack reservation objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRackReservationsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RackReservation
*/

type DcimApiDcimRackReservationsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackReservationsCreate(ctx context.Context, body RackReservationRequest, localVarOptionals *DcimApiDcimRackReservationsCreateOpts) (RackReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RackReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v RackReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a rack reservation object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack reservation.
 * @param optional nil or *DcimApiDcimRackReservationsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRackReservationsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackReservationsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimRackReservationsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of rack reservation objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimRackReservationsListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Rack" (optional.Interface of []string) - 
     * @param "RackN" (optional.Interface of []string) - 
     * @param "RackGroup" (optional.Interface of []string) - 
     * @param "RackGroupIsnull" (optional.Bool) - 
     * @param "RackGroupN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Tenant" (optional.Interface of []string) - 
     * @param "TenantIsnull" (optional.Bool) - 
     * @param "TenantN" (optional.Interface of []string) - 
     * @param "TenantGroup" (optional.Interface of []string) - 
     * @param "TenantGroupIsnull" (optional.Bool) - 
     * @param "TenantGroupN" (optional.Interface of []string) - 
     * @param "TenantId" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "TenantIdIsnull" (optional.Bool) - 
     * @param "TenantIdN" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "User" (optional.Interface of []string) - 
     * @param "UserN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRackReservationList
*/

type DcimApiDcimRackReservationsListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Rack optional.Interface
    RackN optional.Interface
    RackGroup optional.Interface
    RackGroupIsnull optional.Bool
    RackGroupN optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Tenant optional.Interface
    TenantIsnull optional.Bool
    TenantN optional.Interface
    TenantGroup optional.Interface
    TenantGroupIsnull optional.Bool
    TenantGroupN optional.Interface
    TenantId optional.Interface
    TenantIdIsnull optional.Bool
    TenantIdN optional.Interface
    User optional.Interface
    UserN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimRackReservationsList(ctx context.Context, localVarOptionals *DcimApiDcimRackReservationsListOpts) (PaginatedRackReservationList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRackReservationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Rack.IsSet() {
		localVarQueryParams.Add("rack", parameterToString(localVarOptionals.Rack.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackN.IsSet() {
		localVarQueryParams.Add("rack__n", parameterToString(localVarOptionals.RackN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroup.IsSet() {
		localVarQueryParams.Add("rack_group", parameterToString(localVarOptionals.RackGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupIsnull.IsSet() {
		localVarQueryParams.Add("rack_group__isnull", parameterToString(localVarOptionals.RackGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupN.IsSet() {
		localVarQueryParams.Add("rack_group__n", parameterToString(localVarOptionals.RackGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIsnull.IsSet() {
		localVarQueryParams.Add("tenant__isnull", parameterToString(localVarOptionals.TenantIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIsnull.IsSet() {
		localVarQueryParams.Add("tenant_group__isnull", parameterToString(localVarOptionals.TenantGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdIsnull.IsSet() {
		localVarQueryParams.Add("tenant_id__isnull", parameterToString(localVarOptionals.TenantIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdN.IsSet() {
		localVarQueryParams.Add("tenant_id__n", parameterToString(localVarOptionals.TenantIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.User.IsSet() {
		localVarQueryParams.Add("user", parameterToString(localVarOptionals.User.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UserN.IsSet() {
		localVarQueryParams.Add("user__n", parameterToString(localVarOptionals.UserN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRackReservationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rack reservation.
 * @param optional nil or *DcimApiDcimRackReservationsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimRackReservationsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackReservationsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimRackReservationsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack reservation.
 * @param optional nil or *DcimApiDcimRackReservationsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimRackReservationsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimRackReservationsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimRackReservationsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a rack reservation object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack reservation.
 * @param optional nil or *DcimApiDcimRackReservationsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedRackReservationRequest) - 
     * @param "Format" (optional.String) - 
@return RackReservation
*/

type DcimApiDcimRackReservationsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimRackReservationsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimRackReservationsPartialUpdateOpts) (RackReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RackReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RackReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a rack reservation object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack reservation.
 * @param optional nil or *DcimApiDcimRackReservationsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return RackReservation
*/

type DcimApiDcimRackReservationsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimRackReservationsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimRackReservationsRetrieveOpts) (RackReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RackReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RackReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a rack reservation object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rack reservation.
 * @param optional nil or *DcimApiDcimRackReservationsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RackReservation
*/

type DcimApiDcimRackReservationsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRackReservationsUpdate(ctx context.Context, body RackReservationRequest, id string, localVarOptionals *DcimApiDcimRackReservationsUpdateOpts) (RackReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RackReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rack-reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RackReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of rack objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRacksBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRacksBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRacksBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimRacksBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of rack objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRacksBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Rack
*/

type DcimApiDcimRacksBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRacksBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableRackRequest, localVarOptionals *DcimApiDcimRacksBulkPartialUpdateOpts) ([]Rack, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Rack
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Rack
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of rack objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRacksBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Rack
*/

type DcimApiDcimRacksBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRacksBulkUpdate(ctx context.Context, body []BulkWritableRackRequest, localVarOptionals *DcimApiDcimRacksBulkUpdateOpts) ([]Rack, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Rack
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Rack
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more rack objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRacksCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Rack
*/

type DcimApiDcimRacksCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRacksCreate(ctx context.Context, body WritableRackRequest, localVarOptionals *DcimApiDcimRacksCreateOpts) (Rack, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Rack
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Rack
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a rack object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack.
 * @param optional nil or *DcimApiDcimRacksDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRacksDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRacksDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimRacksDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack.
 * @param optional nil or *DcimApiDcimRacksElevationListOpts - Optional Parameters:
     * @param "DisplayFullname" (optional.Bool) - 
     * @param "Exclude" (optional.Interface of string) - 
     * @param "ExpandDevices" (optional.Bool) - 
     * @param "Face" (optional.String) - 
     * @param "Format" (optional.String) - 
     * @param "IncludeImages" (optional.Bool) - 
     * @param "LegendWidth" (optional.Int32) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) - 
     * @param "Render" (optional.String) - 
     * @param "UnitHeight" (optional.Int32) - 
     * @param "UnitWidth" (optional.Int32) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRackUnitList
*/

type DcimApiDcimRacksElevationListOpts struct {
    DisplayFullname optional.Bool
    Exclude optional.Interface
    ExpandDevices optional.Bool
    Face optional.String
    Format optional.String
    IncludeImages optional.Bool
    LegendWidth optional.Int32
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Render optional.String
    UnitHeight optional.Int32
    UnitWidth optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimRacksElevationList(ctx context.Context, id string, localVarOptionals *DcimApiDcimRacksElevationListOpts) (PaginatedRackUnitList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRackUnitList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/{id}/elevation/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DisplayFullname.IsSet() {
		localVarQueryParams.Add("display_fullname", parameterToString(localVarOptionals.DisplayFullname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Exclude.IsSet() {
		localVarQueryParams.Add("exclude", parameterToString(localVarOptionals.Exclude.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExpandDevices.IsSet() {
		localVarQueryParams.Add("expand_devices", parameterToString(localVarOptionals.ExpandDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Face.IsSet() {
		localVarQueryParams.Add("face", parameterToString(localVarOptionals.Face.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeImages.IsSet() {
		localVarQueryParams.Add("include_images", parameterToString(localVarOptionals.IncludeImages.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LegendWidth.IsSet() {
		localVarQueryParams.Add("legend_width", parameterToString(localVarOptionals.LegendWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Render.IsSet() {
		localVarQueryParams.Add("render", parameterToString(localVarOptionals.Render.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnitHeight.IsSet() {
		localVarQueryParams.Add("unit_height", parameterToString(localVarOptionals.UnitHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnitWidth.IsSet() {
		localVarQueryParams.Add("unit_width", parameterToString(localVarOptionals.UnitWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRackUnitList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of rack objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimRacksListOpts - Optional Parameters:
     * @param "AssetTag" (optional.Interface of []string) - 
     * @param "AssetTagIc" (optional.Interface of []string) - 
     * @param "AssetTagIe" (optional.Interface of []string) - 
     * @param "AssetTagIew" (optional.Interface of []string) - 
     * @param "AssetTagIre" (optional.Interface of []string) - 
     * @param "AssetTagIsnull" (optional.Bool) - 
     * @param "AssetTagIsw" (optional.Interface of []string) - 
     * @param "AssetTagN" (optional.Interface of []string) - 
     * @param "AssetTagNic" (optional.Interface of []string) - 
     * @param "AssetTagNie" (optional.Interface of []string) - 
     * @param "AssetTagNiew" (optional.Interface of []string) - 
     * @param "AssetTagNire" (optional.Interface of []string) - 
     * @param "AssetTagNisw" (optional.Interface of []string) - 
     * @param "AssetTagNre" (optional.Interface of []string) - 
     * @param "AssetTagRe" (optional.Interface of []string) - 
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "DescUnits" (optional.Bool) - 
     * @param "Devices" (optional.Interface of []string) - 
     * @param "DevicesIsnull" (optional.Bool) - 
     * @param "DevicesN" (optional.Interface of []string) - 
     * @param "FacilityId" (optional.Interface of []string) - 
     * @param "FacilityIdIc" (optional.Interface of []string) - 
     * @param "FacilityIdIe" (optional.Interface of []string) - 
     * @param "FacilityIdIew" (optional.Interface of []string) - 
     * @param "FacilityIdIre" (optional.Interface of []string) - 
     * @param "FacilityIdIsnull" (optional.Bool) - 
     * @param "FacilityIdIsw" (optional.Interface of []string) - 
     * @param "FacilityIdN" (optional.Interface of []string) - 
     * @param "FacilityIdNic" (optional.Interface of []string) - 
     * @param "FacilityIdNie" (optional.Interface of []string) - 
     * @param "FacilityIdNiew" (optional.Interface of []string) - 
     * @param "FacilityIdNire" (optional.Interface of []string) - 
     * @param "FacilityIdNisw" (optional.Interface of []string) - 
     * @param "FacilityIdNre" (optional.Interface of []string) - 
     * @param "FacilityIdRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasDevices" (optional.Bool) -  Has devices
     * @param "HasPowerFeeds" (optional.Bool) -  Has power feeds
     * @param "HasRackReservations" (optional.Bool) -  Has rack reservations
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "OuterDepth" (optional.Interface of []int32) - 
     * @param "OuterDepthGt" (optional.Interface of []int32) - 
     * @param "OuterDepthGte" (optional.Interface of []int32) - 
     * @param "OuterDepthIsnull" (optional.Bool) - 
     * @param "OuterDepthLt" (optional.Interface of []int32) - 
     * @param "OuterDepthLte" (optional.Interface of []int32) - 
     * @param "OuterDepthN" (optional.Interface of []int32) - 
     * @param "OuterUnit" (optional.Interface of []string) - 
     * @param "OuterUnitIc" (optional.Interface of []string) - 
     * @param "OuterUnitIe" (optional.Interface of []string) - 
     * @param "OuterUnitIew" (optional.Interface of []string) - 
     * @param "OuterUnitIre" (optional.Interface of []string) - 
     * @param "OuterUnitIsw" (optional.Interface of []string) - 
     * @param "OuterUnitN" (optional.Interface of []string) - 
     * @param "OuterUnitNic" (optional.Interface of []string) - 
     * @param "OuterUnitNie" (optional.Interface of []string) - 
     * @param "OuterUnitNiew" (optional.Interface of []string) - 
     * @param "OuterUnitNire" (optional.Interface of []string) - 
     * @param "OuterUnitNisw" (optional.Interface of []string) - 
     * @param "OuterUnitNre" (optional.Interface of []string) - 
     * @param "OuterUnitRe" (optional.Interface of []string) - 
     * @param "OuterWidth" (optional.Interface of []int32) - 
     * @param "OuterWidthGt" (optional.Interface of []int32) - 
     * @param "OuterWidthGte" (optional.Interface of []int32) - 
     * @param "OuterWidthIsnull" (optional.Bool) - 
     * @param "OuterWidthLt" (optional.Interface of []int32) - 
     * @param "OuterWidthLte" (optional.Interface of []int32) - 
     * @param "OuterWidthN" (optional.Interface of []int32) - 
     * @param "PowerFeeds" (optional.Interface of []string) - 
     * @param "PowerFeedsIsnull" (optional.Bool) - 
     * @param "PowerFeedsN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "RackGroup" (optional.Interface of []string) - 
     * @param "RackGroupIsnull" (optional.Bool) - 
     * @param "RackGroupN" (optional.Interface of []string) - 
     * @param "RackReservations" (optional.Interface of []string) - 
     * @param "RackReservationsIsnull" (optional.Bool) - 
     * @param "RackReservationsN" (optional.Interface of []string) - 
     * @param "Role" (optional.Interface of []string) - 
     * @param "RoleIsnull" (optional.Bool) - 
     * @param "RoleN" (optional.Interface of []string) - 
     * @param "Serial" (optional.Interface of []string) -  Serial Number
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Tenant" (optional.Interface of []string) - 
     * @param "TenantIsnull" (optional.Bool) - 
     * @param "TenantN" (optional.Interface of []string) - 
     * @param "TenantGroup" (optional.Interface of []string) - 
     * @param "TenantGroupIsnull" (optional.Bool) - 
     * @param "TenantGroupN" (optional.Interface of []string) - 
     * @param "TenantId" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "TenantIdIsnull" (optional.Bool) - 
     * @param "TenantIdN" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "UHeight" (optional.Interface of []int32) - 
     * @param "UHeightGt" (optional.Interface of []int32) - 
     * @param "UHeightGte" (optional.Interface of []int32) - 
     * @param "UHeightLt" (optional.Interface of []int32) - 
     * @param "UHeightLte" (optional.Interface of []int32) - 
     * @param "UHeightN" (optional.Interface of []int32) - 
     * @param "Width" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthIc" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthIe" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthIew" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthIre" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthIsw" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthN" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthNic" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthNie" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthNiew" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthNire" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthNisw" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthNre" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "WidthRe" (optional.Interface of []int32) -  Rail-to-rail width
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRackList
*/

type DcimApiDcimRacksListOpts struct {
    AssetTag optional.Interface
    AssetTagIc optional.Interface
    AssetTagIe optional.Interface
    AssetTagIew optional.Interface
    AssetTagIre optional.Interface
    AssetTagIsnull optional.Bool
    AssetTagIsw optional.Interface
    AssetTagN optional.Interface
    AssetTagNic optional.Interface
    AssetTagNie optional.Interface
    AssetTagNiew optional.Interface
    AssetTagNire optional.Interface
    AssetTagNisw optional.Interface
    AssetTagNre optional.Interface
    AssetTagRe optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    DescUnits optional.Bool
    Devices optional.Interface
    DevicesIsnull optional.Bool
    DevicesN optional.Interface
    FacilityId optional.Interface
    FacilityIdIc optional.Interface
    FacilityIdIe optional.Interface
    FacilityIdIew optional.Interface
    FacilityIdIre optional.Interface
    FacilityIdIsnull optional.Bool
    FacilityIdIsw optional.Interface
    FacilityIdN optional.Interface
    FacilityIdNic optional.Interface
    FacilityIdNie optional.Interface
    FacilityIdNiew optional.Interface
    FacilityIdNire optional.Interface
    FacilityIdNisw optional.Interface
    FacilityIdNre optional.Interface
    FacilityIdRe optional.Interface
    Format optional.String
    HasDevices optional.Bool
    HasPowerFeeds optional.Bool
    HasRackReservations optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    OuterDepth optional.Interface
    OuterDepthGt optional.Interface
    OuterDepthGte optional.Interface
    OuterDepthIsnull optional.Bool
    OuterDepthLt optional.Interface
    OuterDepthLte optional.Interface
    OuterDepthN optional.Interface
    OuterUnit optional.Interface
    OuterUnitIc optional.Interface
    OuterUnitIe optional.Interface
    OuterUnitIew optional.Interface
    OuterUnitIre optional.Interface
    OuterUnitIsw optional.Interface
    OuterUnitN optional.Interface
    OuterUnitNic optional.Interface
    OuterUnitNie optional.Interface
    OuterUnitNiew optional.Interface
    OuterUnitNire optional.Interface
    OuterUnitNisw optional.Interface
    OuterUnitNre optional.Interface
    OuterUnitRe optional.Interface
    OuterWidth optional.Interface
    OuterWidthGt optional.Interface
    OuterWidthGte optional.Interface
    OuterWidthIsnull optional.Bool
    OuterWidthLt optional.Interface
    OuterWidthLte optional.Interface
    OuterWidthN optional.Interface
    PowerFeeds optional.Interface
    PowerFeedsIsnull optional.Bool
    PowerFeedsN optional.Interface
    Q optional.String
    RackGroup optional.Interface
    RackGroupIsnull optional.Bool
    RackGroupN optional.Interface
    RackReservations optional.Interface
    RackReservationsIsnull optional.Bool
    RackReservationsN optional.Interface
    Role optional.Interface
    RoleIsnull optional.Bool
    RoleN optional.Interface
    Serial optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Tenant optional.Interface
    TenantIsnull optional.Bool
    TenantN optional.Interface
    TenantGroup optional.Interface
    TenantGroupIsnull optional.Bool
    TenantGroupN optional.Interface
    TenantId optional.Interface
    TenantIdIsnull optional.Bool
    TenantIdN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    UHeight optional.Interface
    UHeightGt optional.Interface
    UHeightGte optional.Interface
    UHeightLt optional.Interface
    UHeightLte optional.Interface
    UHeightN optional.Interface
    Width optional.Interface
    WidthIc optional.Interface
    WidthIe optional.Interface
    WidthIew optional.Interface
    WidthIre optional.Interface
    WidthIsw optional.Interface
    WidthN optional.Interface
    WidthNic optional.Interface
    WidthNie optional.Interface
    WidthNiew optional.Interface
    WidthNire optional.Interface
    WidthNisw optional.Interface
    WidthNre optional.Interface
    WidthRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimRacksList(ctx context.Context, localVarOptionals *DcimApiDcimRacksListOpts) (PaginatedRackList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRackList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AssetTag.IsSet() {
		localVarQueryParams.Add("asset_tag", parameterToString(localVarOptionals.AssetTag.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIc.IsSet() {
		localVarQueryParams.Add("asset_tag__ic", parameterToString(localVarOptionals.AssetTagIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIe.IsSet() {
		localVarQueryParams.Add("asset_tag__ie", parameterToString(localVarOptionals.AssetTagIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIew.IsSet() {
		localVarQueryParams.Add("asset_tag__iew", parameterToString(localVarOptionals.AssetTagIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIre.IsSet() {
		localVarQueryParams.Add("asset_tag__ire", parameterToString(localVarOptionals.AssetTagIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIsnull.IsSet() {
		localVarQueryParams.Add("asset_tag__isnull", parameterToString(localVarOptionals.AssetTagIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagIsw.IsSet() {
		localVarQueryParams.Add("asset_tag__isw", parameterToString(localVarOptionals.AssetTagIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagN.IsSet() {
		localVarQueryParams.Add("asset_tag__n", parameterToString(localVarOptionals.AssetTagN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNic.IsSet() {
		localVarQueryParams.Add("asset_tag__nic", parameterToString(localVarOptionals.AssetTagNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNie.IsSet() {
		localVarQueryParams.Add("asset_tag__nie", parameterToString(localVarOptionals.AssetTagNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNiew.IsSet() {
		localVarQueryParams.Add("asset_tag__niew", parameterToString(localVarOptionals.AssetTagNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNire.IsSet() {
		localVarQueryParams.Add("asset_tag__nire", parameterToString(localVarOptionals.AssetTagNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNisw.IsSet() {
		localVarQueryParams.Add("asset_tag__nisw", parameterToString(localVarOptionals.AssetTagNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagNre.IsSet() {
		localVarQueryParams.Add("asset_tag__nre", parameterToString(localVarOptionals.AssetTagNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AssetTagRe.IsSet() {
		localVarQueryParams.Add("asset_tag__re", parameterToString(localVarOptionals.AssetTagRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescUnits.IsSet() {
		localVarQueryParams.Add("desc_units", parameterToString(localVarOptionals.DescUnits.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarQueryParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesIsnull.IsSet() {
		localVarQueryParams.Add("devices__isnull", parameterToString(localVarOptionals.DevicesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesN.IsSet() {
		localVarQueryParams.Add("devices__n", parameterToString(localVarOptionals.DevicesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityId.IsSet() {
		localVarQueryParams.Add("facility_id", parameterToString(localVarOptionals.FacilityId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdIc.IsSet() {
		localVarQueryParams.Add("facility_id__ic", parameterToString(localVarOptionals.FacilityIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdIe.IsSet() {
		localVarQueryParams.Add("facility_id__ie", parameterToString(localVarOptionals.FacilityIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdIew.IsSet() {
		localVarQueryParams.Add("facility_id__iew", parameterToString(localVarOptionals.FacilityIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdIre.IsSet() {
		localVarQueryParams.Add("facility_id__ire", parameterToString(localVarOptionals.FacilityIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdIsnull.IsSet() {
		localVarQueryParams.Add("facility_id__isnull", parameterToString(localVarOptionals.FacilityIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdIsw.IsSet() {
		localVarQueryParams.Add("facility_id__isw", parameterToString(localVarOptionals.FacilityIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdN.IsSet() {
		localVarQueryParams.Add("facility_id__n", parameterToString(localVarOptionals.FacilityIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdNic.IsSet() {
		localVarQueryParams.Add("facility_id__nic", parameterToString(localVarOptionals.FacilityIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdNie.IsSet() {
		localVarQueryParams.Add("facility_id__nie", parameterToString(localVarOptionals.FacilityIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdNiew.IsSet() {
		localVarQueryParams.Add("facility_id__niew", parameterToString(localVarOptionals.FacilityIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdNire.IsSet() {
		localVarQueryParams.Add("facility_id__nire", parameterToString(localVarOptionals.FacilityIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdNisw.IsSet() {
		localVarQueryParams.Add("facility_id__nisw", parameterToString(localVarOptionals.FacilityIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdNre.IsSet() {
		localVarQueryParams.Add("facility_id__nre", parameterToString(localVarOptionals.FacilityIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FacilityIdRe.IsSet() {
		localVarQueryParams.Add("facility_id__re", parameterToString(localVarOptionals.FacilityIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDevices.IsSet() {
		localVarQueryParams.Add("has_devices", parameterToString(localVarOptionals.HasDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPowerFeeds.IsSet() {
		localVarQueryParams.Add("has_power_feeds", parameterToString(localVarOptionals.HasPowerFeeds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRackReservations.IsSet() {
		localVarQueryParams.Add("has_rack_reservations", parameterToString(localVarOptionals.HasRackReservations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OuterDepth.IsSet() {
		localVarQueryParams.Add("outer_depth", parameterToString(localVarOptionals.OuterDepth.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterDepthGt.IsSet() {
		localVarQueryParams.Add("outer_depth__gt", parameterToString(localVarOptionals.OuterDepthGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterDepthGte.IsSet() {
		localVarQueryParams.Add("outer_depth__gte", parameterToString(localVarOptionals.OuterDepthGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterDepthIsnull.IsSet() {
		localVarQueryParams.Add("outer_depth__isnull", parameterToString(localVarOptionals.OuterDepthIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OuterDepthLt.IsSet() {
		localVarQueryParams.Add("outer_depth__lt", parameterToString(localVarOptionals.OuterDepthLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterDepthLte.IsSet() {
		localVarQueryParams.Add("outer_depth__lte", parameterToString(localVarOptionals.OuterDepthLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterDepthN.IsSet() {
		localVarQueryParams.Add("outer_depth__n", parameterToString(localVarOptionals.OuterDepthN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnit.IsSet() {
		localVarQueryParams.Add("outer_unit", parameterToString(localVarOptionals.OuterUnit.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitIc.IsSet() {
		localVarQueryParams.Add("outer_unit__ic", parameterToString(localVarOptionals.OuterUnitIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitIe.IsSet() {
		localVarQueryParams.Add("outer_unit__ie", parameterToString(localVarOptionals.OuterUnitIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitIew.IsSet() {
		localVarQueryParams.Add("outer_unit__iew", parameterToString(localVarOptionals.OuterUnitIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitIre.IsSet() {
		localVarQueryParams.Add("outer_unit__ire", parameterToString(localVarOptionals.OuterUnitIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitIsw.IsSet() {
		localVarQueryParams.Add("outer_unit__isw", parameterToString(localVarOptionals.OuterUnitIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitN.IsSet() {
		localVarQueryParams.Add("outer_unit__n", parameterToString(localVarOptionals.OuterUnitN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitNic.IsSet() {
		localVarQueryParams.Add("outer_unit__nic", parameterToString(localVarOptionals.OuterUnitNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitNie.IsSet() {
		localVarQueryParams.Add("outer_unit__nie", parameterToString(localVarOptionals.OuterUnitNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitNiew.IsSet() {
		localVarQueryParams.Add("outer_unit__niew", parameterToString(localVarOptionals.OuterUnitNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitNire.IsSet() {
		localVarQueryParams.Add("outer_unit__nire", parameterToString(localVarOptionals.OuterUnitNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitNisw.IsSet() {
		localVarQueryParams.Add("outer_unit__nisw", parameterToString(localVarOptionals.OuterUnitNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitNre.IsSet() {
		localVarQueryParams.Add("outer_unit__nre", parameterToString(localVarOptionals.OuterUnitNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterUnitRe.IsSet() {
		localVarQueryParams.Add("outer_unit__re", parameterToString(localVarOptionals.OuterUnitRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterWidth.IsSet() {
		localVarQueryParams.Add("outer_width", parameterToString(localVarOptionals.OuterWidth.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterWidthGt.IsSet() {
		localVarQueryParams.Add("outer_width__gt", parameterToString(localVarOptionals.OuterWidthGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterWidthGte.IsSet() {
		localVarQueryParams.Add("outer_width__gte", parameterToString(localVarOptionals.OuterWidthGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterWidthIsnull.IsSet() {
		localVarQueryParams.Add("outer_width__isnull", parameterToString(localVarOptionals.OuterWidthIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OuterWidthLt.IsSet() {
		localVarQueryParams.Add("outer_width__lt", parameterToString(localVarOptionals.OuterWidthLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterWidthLte.IsSet() {
		localVarQueryParams.Add("outer_width__lte", parameterToString(localVarOptionals.OuterWidthLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OuterWidthN.IsSet() {
		localVarQueryParams.Add("outer_width__n", parameterToString(localVarOptionals.OuterWidthN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerFeeds.IsSet() {
		localVarQueryParams.Add("power_feeds", parameterToString(localVarOptionals.PowerFeeds.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PowerFeedsIsnull.IsSet() {
		localVarQueryParams.Add("power_feeds__isnull", parameterToString(localVarOptionals.PowerFeedsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerFeedsN.IsSet() {
		localVarQueryParams.Add("power_feeds__n", parameterToString(localVarOptionals.PowerFeedsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroup.IsSet() {
		localVarQueryParams.Add("rack_group", parameterToString(localVarOptionals.RackGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupIsnull.IsSet() {
		localVarQueryParams.Add("rack_group__isnull", parameterToString(localVarOptionals.RackGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackGroupN.IsSet() {
		localVarQueryParams.Add("rack_group__n", parameterToString(localVarOptionals.RackGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservations.IsSet() {
		localVarQueryParams.Add("rack_reservations", parameterToString(localVarOptionals.RackReservations.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservationsIsnull.IsSet() {
		localVarQueryParams.Add("rack_reservations__isnull", parameterToString(localVarOptionals.RackReservationsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservationsN.IsSet() {
		localVarQueryParams.Add("rack_reservations__n", parameterToString(localVarOptionals.RackReservationsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Role.IsSet() {
		localVarQueryParams.Add("role", parameterToString(localVarOptionals.Role.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RoleIsnull.IsSet() {
		localVarQueryParams.Add("role__isnull", parameterToString(localVarOptionals.RoleIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoleN.IsSet() {
		localVarQueryParams.Add("role__n", parameterToString(localVarOptionals.RoleN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Serial.IsSet() {
		localVarQueryParams.Add("serial", parameterToString(localVarOptionals.Serial.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIsnull.IsSet() {
		localVarQueryParams.Add("tenant__isnull", parameterToString(localVarOptionals.TenantIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIsnull.IsSet() {
		localVarQueryParams.Add("tenant_group__isnull", parameterToString(localVarOptionals.TenantGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdIsnull.IsSet() {
		localVarQueryParams.Add("tenant_id__isnull", parameterToString(localVarOptionals.TenantIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdN.IsSet() {
		localVarQueryParams.Add("tenant_id__n", parameterToString(localVarOptionals.TenantIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeight.IsSet() {
		localVarQueryParams.Add("u_height", parameterToString(localVarOptionals.UHeight.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightGt.IsSet() {
		localVarQueryParams.Add("u_height__gt", parameterToString(localVarOptionals.UHeightGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightGte.IsSet() {
		localVarQueryParams.Add("u_height__gte", parameterToString(localVarOptionals.UHeightGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightLt.IsSet() {
		localVarQueryParams.Add("u_height__lt", parameterToString(localVarOptionals.UHeightLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightLte.IsSet() {
		localVarQueryParams.Add("u_height__lte", parameterToString(localVarOptionals.UHeightLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UHeightN.IsSet() {
		localVarQueryParams.Add("u_height__n", parameterToString(localVarOptionals.UHeightN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthIc.IsSet() {
		localVarQueryParams.Add("width__ic", parameterToString(localVarOptionals.WidthIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthIe.IsSet() {
		localVarQueryParams.Add("width__ie", parameterToString(localVarOptionals.WidthIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthIew.IsSet() {
		localVarQueryParams.Add("width__iew", parameterToString(localVarOptionals.WidthIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthIre.IsSet() {
		localVarQueryParams.Add("width__ire", parameterToString(localVarOptionals.WidthIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthIsw.IsSet() {
		localVarQueryParams.Add("width__isw", parameterToString(localVarOptionals.WidthIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthN.IsSet() {
		localVarQueryParams.Add("width__n", parameterToString(localVarOptionals.WidthN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthNic.IsSet() {
		localVarQueryParams.Add("width__nic", parameterToString(localVarOptionals.WidthNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthNie.IsSet() {
		localVarQueryParams.Add("width__nie", parameterToString(localVarOptionals.WidthNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthNiew.IsSet() {
		localVarQueryParams.Add("width__niew", parameterToString(localVarOptionals.WidthNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthNire.IsSet() {
		localVarQueryParams.Add("width__nire", parameterToString(localVarOptionals.WidthNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthNisw.IsSet() {
		localVarQueryParams.Add("width__nisw", parameterToString(localVarOptionals.WidthNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthNre.IsSet() {
		localVarQueryParams.Add("width__nre", parameterToString(localVarOptionals.WidthNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WidthRe.IsSet() {
		localVarQueryParams.Add("width__re", parameterToString(localVarOptionals.WidthRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRackList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rack.
 * @param optional nil or *DcimApiDcimRacksNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimRacksNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRacksNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimRacksNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack.
 * @param optional nil or *DcimApiDcimRacksNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimRacksNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimRacksNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimRacksNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a rack object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack.
 * @param optional nil or *DcimApiDcimRacksPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableRackRequest) - 
     * @param "Format" (optional.String) - 
@return Rack
*/

type DcimApiDcimRacksPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimRacksPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimRacksPartialUpdateOpts) (Rack, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Rack
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Rack
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a rack object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rack.
 * @param optional nil or *DcimApiDcimRacksRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Rack
*/

type DcimApiDcimRacksRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimRacksRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimRacksRetrieveOpts) (Rack, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Rack
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Rack
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a rack object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rack.
 * @param optional nil or *DcimApiDcimRacksUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Rack
*/

type DcimApiDcimRacksUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRacksUpdate(ctx context.Context, body WritableRackRequest, id string, localVarOptionals *DcimApiDcimRacksUpdateOpts) (Rack, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Rack
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/racks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Rack
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of rear port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRearPortTemplatesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRearPortTemplatesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortTemplatesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimRearPortTemplatesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of rear port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRearPortTemplatesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RearPortTemplate
*/

type DcimApiDcimRearPortTemplatesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortTemplatesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableRearPortTemplateRequest, localVarOptionals *DcimApiDcimRearPortTemplatesBulkPartialUpdateOpts) ([]RearPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RearPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RearPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of rear port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRearPortTemplatesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RearPortTemplate
*/

type DcimApiDcimRearPortTemplatesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortTemplatesBulkUpdate(ctx context.Context, body []BulkWritableRearPortTemplateRequest, localVarOptionals *DcimApiDcimRearPortTemplatesBulkUpdateOpts) ([]RearPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RearPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RearPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more rear port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRearPortTemplatesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RearPortTemplate
*/

type DcimApiDcimRearPortTemplatesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortTemplatesCreate(ctx context.Context, body WritableRearPortTemplateRequest, localVarOptionals *DcimApiDcimRearPortTemplatesCreateOpts) (RearPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RearPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v RearPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a rear port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port template.
 * @param optional nil or *DcimApiDcimRearPortTemplatesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRearPortTemplatesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortTemplatesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortTemplatesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of rear port template objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimRearPortTemplatesListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) -  Description
     * @param "DescriptionIc" (optional.Interface of []string) -  Description
     * @param "DescriptionIe" (optional.Interface of []string) -  Description
     * @param "DescriptionIew" (optional.Interface of []string) -  Description
     * @param "DescriptionIre" (optional.Interface of []string) -  Description
     * @param "DescriptionIsw" (optional.Interface of []string) -  Description
     * @param "DescriptionN" (optional.Interface of []string) -  Description
     * @param "DescriptionNic" (optional.Interface of []string) -  Description
     * @param "DescriptionNie" (optional.Interface of []string) -  Description
     * @param "DescriptionNiew" (optional.Interface of []string) -  Description
     * @param "DescriptionNire" (optional.Interface of []string) -  Description
     * @param "DescriptionNisw" (optional.Interface of []string) -  Description
     * @param "DescriptionNre" (optional.Interface of []string) -  Description
     * @param "DescriptionRe" (optional.Interface of []string) -  Description
     * @param "DeviceType" (optional.Interface of []string) - 
     * @param "DeviceTypeN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "FrontPortTemplates" (optional.Interface of []string) -  Front port templates
     * @param "FrontPortTemplatesIsnull" (optional.Bool) - 
     * @param "FrontPortTemplatesN" (optional.Interface of []string) -  Front port templates
     * @param "HasFrontPortTemplates" (optional.Bool) -  Has front port templates
     * @param "Id" (optional.Interface of []string) -  ID
     * @param "IdIc" (optional.Interface of []string) -  ID
     * @param "IdIe" (optional.Interface of []string) -  ID
     * @param "IdIew" (optional.Interface of []string) -  ID
     * @param "IdIre" (optional.Interface of []string) -  ID
     * @param "IdIsw" (optional.Interface of []string) -  ID
     * @param "IdN" (optional.Interface of []string) -  ID
     * @param "IdNic" (optional.Interface of []string) -  ID
     * @param "IdNie" (optional.Interface of []string) -  ID
     * @param "IdNiew" (optional.Interface of []string) -  ID
     * @param "IdNire" (optional.Interface of []string) -  ID
     * @param "IdNisw" (optional.Interface of []string) -  ID
     * @param "IdNre" (optional.Interface of []string) -  ID
     * @param "IdRe" (optional.Interface of []string) -  ID
     * @param "Label" (optional.Interface of []string) -  Label
     * @param "LabelIc" (optional.Interface of []string) -  Label
     * @param "LabelIe" (optional.Interface of []string) -  Label
     * @param "LabelIew" (optional.Interface of []string) -  Label
     * @param "LabelIre" (optional.Interface of []string) -  Label
     * @param "LabelIsw" (optional.Interface of []string) -  Label
     * @param "LabelN" (optional.Interface of []string) -  Label
     * @param "LabelNic" (optional.Interface of []string) -  Label
     * @param "LabelNie" (optional.Interface of []string) -  Label
     * @param "LabelNiew" (optional.Interface of []string) -  Label
     * @param "LabelNire" (optional.Interface of []string) -  Label
     * @param "LabelNisw" (optional.Interface of []string) -  Label
     * @param "LabelNre" (optional.Interface of []string) -  Label
     * @param "LabelRe" (optional.Interface of []string) -  Label
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) -  Name
     * @param "NameIc" (optional.Interface of []string) -  Name
     * @param "NameIe" (optional.Interface of []string) -  Name
     * @param "NameIew" (optional.Interface of []string) -  Name
     * @param "NameIre" (optional.Interface of []string) -  Name
     * @param "NameIsw" (optional.Interface of []string) -  Name
     * @param "NameN" (optional.Interface of []string) -  Name
     * @param "NameNic" (optional.Interface of []string) -  Name
     * @param "NameNie" (optional.Interface of []string) -  Name
     * @param "NameNiew" (optional.Interface of []string) -  Name
     * @param "NameNire" (optional.Interface of []string) -  Name
     * @param "NameNisw" (optional.Interface of []string) -  Name
     * @param "NameNre" (optional.Interface of []string) -  Name
     * @param "NameRe" (optional.Interface of []string) -  Name
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Positions" (optional.Interface of []int32) - 
     * @param "PositionsGt" (optional.Interface of []int32) - 
     * @param "PositionsGte" (optional.Interface of []int32) - 
     * @param "PositionsLt" (optional.Interface of []int32) - 
     * @param "PositionsLte" (optional.Interface of []int32) - 
     * @param "PositionsN" (optional.Interface of []int32) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRearPortTemplateList
*/

type DcimApiDcimRearPortTemplatesListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    DeviceType optional.Interface
    DeviceTypeN optional.Interface
    Format optional.String
    FrontPortTemplates optional.Interface
    FrontPortTemplatesIsnull optional.Bool
    FrontPortTemplatesN optional.Interface
    HasFrontPortTemplates optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Positions optional.Interface
    PositionsGt optional.Interface
    PositionsGte optional.Interface
    PositionsLt optional.Interface
    PositionsLte optional.Interface
    PositionsN optional.Interface
    Q optional.String
    Sort optional.String
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimRearPortTemplatesList(ctx context.Context, localVarOptionals *DcimApiDcimRearPortTemplatesListOpts) (PaginatedRearPortTemplateList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRearPortTemplateList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceType.IsSet() {
		localVarQueryParams.Add("device_type", parameterToString(localVarOptionals.DeviceType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypeN.IsSet() {
		localVarQueryParams.Add("device_type__n", parameterToString(localVarOptionals.DeviceTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortTemplates.IsSet() {
		localVarQueryParams.Add("front_port_templates", parameterToString(localVarOptionals.FrontPortTemplates.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortTemplatesIsnull.IsSet() {
		localVarQueryParams.Add("front_port_templates__isnull", parameterToString(localVarOptionals.FrontPortTemplatesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortTemplatesN.IsSet() {
		localVarQueryParams.Add("front_port_templates__n", parameterToString(localVarOptionals.FrontPortTemplatesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HasFrontPortTemplates.IsSet() {
		localVarQueryParams.Add("has_front_port_templates", parameterToString(localVarOptionals.HasFrontPortTemplates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Positions.IsSet() {
		localVarQueryParams.Add("positions", parameterToString(localVarOptionals.Positions.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsGt.IsSet() {
		localVarQueryParams.Add("positions__gt", parameterToString(localVarOptionals.PositionsGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsGte.IsSet() {
		localVarQueryParams.Add("positions__gte", parameterToString(localVarOptionals.PositionsGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsLt.IsSet() {
		localVarQueryParams.Add("positions__lt", parameterToString(localVarOptionals.PositionsLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsLte.IsSet() {
		localVarQueryParams.Add("positions__lte", parameterToString(localVarOptionals.PositionsLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsN.IsSet() {
		localVarQueryParams.Add("positions__n", parameterToString(localVarOptionals.PositionsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRearPortTemplateList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rear port template.
 * @param optional nil or *DcimApiDcimRearPortTemplatesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimRearPortTemplatesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortTemplatesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimRearPortTemplatesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port template.
 * @param optional nil or *DcimApiDcimRearPortTemplatesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimRearPortTemplatesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimRearPortTemplatesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortTemplatesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a rear port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port template.
 * @param optional nil or *DcimApiDcimRearPortTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableRearPortTemplateRequest) - 
     * @param "Format" (optional.String) - 
@return RearPortTemplate
*/

type DcimApiDcimRearPortTemplatesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimRearPortTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortTemplatesPartialUpdateOpts) (RearPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RearPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RearPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a rear port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port template.
 * @param optional nil or *DcimApiDcimRearPortTemplatesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return RearPortTemplate
*/

type DcimApiDcimRearPortTemplatesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimRearPortTemplatesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortTemplatesRetrieveOpts) (RearPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RearPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RearPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a rear port template object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rear port template.
 * @param optional nil or *DcimApiDcimRearPortTemplatesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RearPortTemplate
*/

type DcimApiDcimRearPortTemplatesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortTemplatesUpdate(ctx context.Context, body WritableRearPortTemplateRequest, id string, localVarOptionals *DcimApiDcimRearPortTemplatesUpdateOpts) (RearPortTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RearPortTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-port-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RearPortTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of rear port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRearPortsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRearPortsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimRearPortsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of rear port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRearPortsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RearPort
*/

type DcimApiDcimRearPortsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableRearPortRequest, localVarOptionals *DcimApiDcimRearPortsBulkPartialUpdateOpts) ([]RearPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RearPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RearPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of rear port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRearPortsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []RearPort
*/

type DcimApiDcimRearPortsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortsBulkUpdate(ctx context.Context, body []BulkWritableRearPortRequest, localVarOptionals *DcimApiDcimRearPortsBulkUpdateOpts) ([]RearPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RearPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RearPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more rear port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimRearPortsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RearPort
*/

type DcimApiDcimRearPortsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortsCreate(ctx context.Context, body WritableRearPortRequest, localVarOptionals *DcimApiDcimRearPortsCreateOpts) (RearPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RearPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v RearPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a rear port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port.
 * @param optional nil or *DcimApiDcimRearPortsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimRearPortsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of rear port objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimRearPortsListOpts - Optional Parameters:
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Device" (optional.Interface of []string) - 
     * @param "DeviceN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "FrontPorts" (optional.Interface of []string) - 
     * @param "FrontPortsIsnull" (optional.Bool) - 
     * @param "FrontPortsN" (optional.Interface of []string) - 
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "HasFrontPorts" (optional.Bool) -  Has front ports
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Label" (optional.Interface of []string) - 
     * @param "LabelIc" (optional.Interface of []string) - 
     * @param "LabelIe" (optional.Interface of []string) - 
     * @param "LabelIew" (optional.Interface of []string) - 
     * @param "LabelIre" (optional.Interface of []string) - 
     * @param "LabelIsw" (optional.Interface of []string) - 
     * @param "LabelN" (optional.Interface of []string) - 
     * @param "LabelNic" (optional.Interface of []string) - 
     * @param "LabelNie" (optional.Interface of []string) - 
     * @param "LabelNiew" (optional.Interface of []string) - 
     * @param "LabelNire" (optional.Interface of []string) - 
     * @param "LabelNisw" (optional.Interface of []string) - 
     * @param "LabelNre" (optional.Interface of []string) - 
     * @param "LabelRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Positions" (optional.Interface of []int32) - 
     * @param "PositionsGt" (optional.Interface of []int32) - 
     * @param "PositionsGte" (optional.Interface of []int32) - 
     * @param "PositionsLt" (optional.Interface of []int32) - 
     * @param "PositionsLte" (optional.Interface of []int32) - 
     * @param "PositionsN" (optional.Interface of []int32) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Type_" (optional.Interface of []string) - 
     * @param "TypeIc" (optional.Interface of []string) - 
     * @param "TypeIe" (optional.Interface of []string) - 
     * @param "TypeIew" (optional.Interface of []string) - 
     * @param "TypeIre" (optional.Interface of []string) - 
     * @param "TypeIsw" (optional.Interface of []string) - 
     * @param "TypeN" (optional.Interface of []string) - 
     * @param "TypeNic" (optional.Interface of []string) - 
     * @param "TypeNie" (optional.Interface of []string) - 
     * @param "TypeNiew" (optional.Interface of []string) - 
     * @param "TypeNire" (optional.Interface of []string) - 
     * @param "TypeNisw" (optional.Interface of []string) - 
     * @param "TypeNre" (optional.Interface of []string) - 
     * @param "TypeRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedRearPortList
*/

type DcimApiDcimRearPortsListOpts struct {
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Device optional.Interface
    DeviceN optional.Interface
    Format optional.String
    FrontPorts optional.Interface
    FrontPortsIsnull optional.Bool
    FrontPortsN optional.Interface
    HasCable optional.Bool
    HasFrontPorts optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Label optional.Interface
    LabelIc optional.Interface
    LabelIe optional.Interface
    LabelIew optional.Interface
    LabelIre optional.Interface
    LabelIsw optional.Interface
    LabelN optional.Interface
    LabelNic optional.Interface
    LabelNie optional.Interface
    LabelNiew optional.Interface
    LabelNire optional.Interface
    LabelNisw optional.Interface
    LabelNre optional.Interface
    LabelRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Positions optional.Interface
    PositionsGt optional.Interface
    PositionsGte optional.Interface
    PositionsLt optional.Interface
    PositionsLte optional.Interface
    PositionsN optional.Interface
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Type_ optional.Interface
    TypeIc optional.Interface
    TypeIe optional.Interface
    TypeIew optional.Interface
    TypeIre optional.Interface
    TypeIsw optional.Interface
    TypeN optional.Interface
    TypeNic optional.Interface
    TypeNie optional.Interface
    TypeNiew optional.Interface
    TypeNire optional.Interface
    TypeNisw optional.Interface
    TypeNre optional.Interface
    TypeRe optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimRearPortsList(ctx context.Context, localVarOptionals *DcimApiDcimRearPortsListOpts) (PaginatedRearPortList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedRearPortList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceN.IsSet() {
		localVarQueryParams.Add("device__n", parameterToString(localVarOptionals.DeviceN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPorts.IsSet() {
		localVarQueryParams.Add("front_ports", parameterToString(localVarOptionals.FrontPorts.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortsIsnull.IsSet() {
		localVarQueryParams.Add("front_ports__isnull", parameterToString(localVarOptionals.FrontPortsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPortsN.IsSet() {
		localVarQueryParams.Add("front_ports__n", parameterToString(localVarOptionals.FrontPortsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasFrontPorts.IsSet() {
		localVarQueryParams.Add("has_front_ports", parameterToString(localVarOptionals.HasFrontPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIc.IsSet() {
		localVarQueryParams.Add("label__ic", parameterToString(localVarOptionals.LabelIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIe.IsSet() {
		localVarQueryParams.Add("label__ie", parameterToString(localVarOptionals.LabelIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIew.IsSet() {
		localVarQueryParams.Add("label__iew", parameterToString(localVarOptionals.LabelIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIre.IsSet() {
		localVarQueryParams.Add("label__ire", parameterToString(localVarOptionals.LabelIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelIsw.IsSet() {
		localVarQueryParams.Add("label__isw", parameterToString(localVarOptionals.LabelIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelN.IsSet() {
		localVarQueryParams.Add("label__n", parameterToString(localVarOptionals.LabelN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNic.IsSet() {
		localVarQueryParams.Add("label__nic", parameterToString(localVarOptionals.LabelNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNie.IsSet() {
		localVarQueryParams.Add("label__nie", parameterToString(localVarOptionals.LabelNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNiew.IsSet() {
		localVarQueryParams.Add("label__niew", parameterToString(localVarOptionals.LabelNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNire.IsSet() {
		localVarQueryParams.Add("label__nire", parameterToString(localVarOptionals.LabelNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNisw.IsSet() {
		localVarQueryParams.Add("label__nisw", parameterToString(localVarOptionals.LabelNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelNre.IsSet() {
		localVarQueryParams.Add("label__nre", parameterToString(localVarOptionals.LabelNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LabelRe.IsSet() {
		localVarQueryParams.Add("label__re", parameterToString(localVarOptionals.LabelRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Positions.IsSet() {
		localVarQueryParams.Add("positions", parameterToString(localVarOptionals.Positions.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsGt.IsSet() {
		localVarQueryParams.Add("positions__gt", parameterToString(localVarOptionals.PositionsGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsGte.IsSet() {
		localVarQueryParams.Add("positions__gte", parameterToString(localVarOptionals.PositionsGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsLt.IsSet() {
		localVarQueryParams.Add("positions__lt", parameterToString(localVarOptionals.PositionsLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsLte.IsSet() {
		localVarQueryParams.Add("positions__lte", parameterToString(localVarOptionals.PositionsLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PositionsN.IsSet() {
		localVarQueryParams.Add("positions__n", parameterToString(localVarOptionals.PositionsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIc.IsSet() {
		localVarQueryParams.Add("type__ic", parameterToString(localVarOptionals.TypeIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIe.IsSet() {
		localVarQueryParams.Add("type__ie", parameterToString(localVarOptionals.TypeIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIew.IsSet() {
		localVarQueryParams.Add("type__iew", parameterToString(localVarOptionals.TypeIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIre.IsSet() {
		localVarQueryParams.Add("type__ire", parameterToString(localVarOptionals.TypeIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeIsw.IsSet() {
		localVarQueryParams.Add("type__isw", parameterToString(localVarOptionals.TypeIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNic.IsSet() {
		localVarQueryParams.Add("type__nic", parameterToString(localVarOptionals.TypeNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNie.IsSet() {
		localVarQueryParams.Add("type__nie", parameterToString(localVarOptionals.TypeNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNiew.IsSet() {
		localVarQueryParams.Add("type__niew", parameterToString(localVarOptionals.TypeNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNire.IsSet() {
		localVarQueryParams.Add("type__nire", parameterToString(localVarOptionals.TypeNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNisw.IsSet() {
		localVarQueryParams.Add("type__nisw", parameterToString(localVarOptionals.TypeNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeNre.IsSet() {
		localVarQueryParams.Add("type__nre", parameterToString(localVarOptionals.TypeNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TypeRe.IsSet() {
		localVarQueryParams.Add("type__re", parameterToString(localVarOptionals.TypeRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedRearPortList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rear port.
 * @param optional nil or *DcimApiDcimRearPortsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimRearPortsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimRearPortsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port.
 * @param optional nil or *DcimApiDcimRearPortsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimRearPortsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimRearPortsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a rear port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port.
 * @param optional nil or *DcimApiDcimRearPortsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedWritableRearPortRequest) - 
     * @param "Format" (optional.String) - 
@return RearPort
*/

type DcimApiDcimRearPortsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimRearPortsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortsPartialUpdateOpts) (RearPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RearPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RearPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Return all CablePaths which traverse a given pass-through port.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port.
 * @param optional nil or *DcimApiDcimRearPortsPathsListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCablePathList
*/

type DcimApiDcimRearPortsPathsListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimRearPortsPathsList(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortsPathsListOpts) (PaginatedCablePathList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCablePathList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/{id}/paths/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCablePathList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a rear port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this rear port.
 * @param optional nil or *DcimApiDcimRearPortsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return RearPort
*/

type DcimApiDcimRearPortsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimRearPortsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimRearPortsRetrieveOpts) (RearPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RearPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RearPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a rear port object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this rear port.
 * @param optional nil or *DcimApiDcimRearPortsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return RearPort
*/

type DcimApiDcimRearPortsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimRearPortsUpdate(ctx context.Context, body WritableRearPortRequest, id string, localVarOptionals *DcimApiDcimRearPortsUpdateOpts) (RearPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RearPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/rear-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RearPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of software image file objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimSoftwareImageFilesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimSoftwareImageFilesBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareImageFilesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimSoftwareImageFilesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of software image file objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimSoftwareImageFilesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []SoftwareImageFile
*/

type DcimApiDcimSoftwareImageFilesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareImageFilesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableSoftwareImageFileRequest, localVarOptionals *DcimApiDcimSoftwareImageFilesBulkPartialUpdateOpts) ([]SoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []SoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of software image file objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimSoftwareImageFilesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []SoftwareImageFile
*/

type DcimApiDcimSoftwareImageFilesBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareImageFilesBulkUpdate(ctx context.Context, body []BulkWritableSoftwareImageFileRequest, localVarOptionals *DcimApiDcimSoftwareImageFilesBulkUpdateOpts) ([]SoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []SoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more software image file objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimSoftwareImageFilesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return SoftwareImageFile
*/

type DcimApiDcimSoftwareImageFilesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareImageFilesCreate(ctx context.Context, body SoftwareImageFileRequest, localVarOptionals *DcimApiDcimSoftwareImageFilesCreateOpts) (SoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v SoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a software image file object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this software image file.
 * @param optional nil or *DcimApiDcimSoftwareImageFilesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimSoftwareImageFilesDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareImageFilesDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimSoftwareImageFilesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of software image file objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimSoftwareImageFilesListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "DefaultImage" (optional.Bool) -  Is default image for associated software version
     * @param "DeviceTypes" (optional.Interface of []string) - 
     * @param "DeviceTypesIsnull" (optional.Bool) - 
     * @param "DeviceTypesN" (optional.Interface of []string) - 
     * @param "Devices" (optional.Interface of []string) - 
     * @param "DevicesIsnull" (optional.Bool) - 
     * @param "DevicesN" (optional.Interface of []string) - 
     * @param "DownloadUrl" (optional.Interface of []string) - 
     * @param "DownloadUrlIc" (optional.Interface of []string) - 
     * @param "DownloadUrlIe" (optional.Interface of []string) - 
     * @param "DownloadUrlIew" (optional.Interface of []string) - 
     * @param "DownloadUrlIre" (optional.Interface of []string) - 
     * @param "DownloadUrlIsw" (optional.Interface of []string) - 
     * @param "DownloadUrlN" (optional.Interface of []string) - 
     * @param "DownloadUrlNic" (optional.Interface of []string) - 
     * @param "DownloadUrlNie" (optional.Interface of []string) - 
     * @param "DownloadUrlNiew" (optional.Interface of []string) - 
     * @param "DownloadUrlNire" (optional.Interface of []string) - 
     * @param "DownloadUrlNisw" (optional.Interface of []string) - 
     * @param "DownloadUrlNre" (optional.Interface of []string) - 
     * @param "DownloadUrlRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasDeviceTypes" (optional.Bool) -  Has device types
     * @param "HasDevices" (optional.Bool) -  Has devices
     * @param "HashingAlgorithm" (optional.Interface of []string) -  Hashing algorithm for image file checksum
     * @param "HashingAlgorithmIc" (optional.Interface of []string) - 
     * @param "HashingAlgorithmIe" (optional.Interface of []string) - 
     * @param "HashingAlgorithmIew" (optional.Interface of []string) - 
     * @param "HashingAlgorithmIre" (optional.Interface of []string) - 
     * @param "HashingAlgorithmIsw" (optional.Interface of []string) - 
     * @param "HashingAlgorithmN" (optional.Interface of []string) -  Hashing algorithm for image file checksum
     * @param "HashingAlgorithmNic" (optional.Interface of []string) - 
     * @param "HashingAlgorithmNie" (optional.Interface of []string) - 
     * @param "HashingAlgorithmNiew" (optional.Interface of []string) - 
     * @param "HashingAlgorithmNire" (optional.Interface of []string) - 
     * @param "HashingAlgorithmNisw" (optional.Interface of []string) - 
     * @param "HashingAlgorithmNre" (optional.Interface of []string) - 
     * @param "HashingAlgorithmRe" (optional.Interface of []string) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "ImageFileChecksum" (optional.Interface of []string) - 
     * @param "ImageFileChecksumIc" (optional.Interface of []string) - 
     * @param "ImageFileChecksumIe" (optional.Interface of []string) - 
     * @param "ImageFileChecksumIew" (optional.Interface of []string) - 
     * @param "ImageFileChecksumIre" (optional.Interface of []string) - 
     * @param "ImageFileChecksumIsw" (optional.Interface of []string) - 
     * @param "ImageFileChecksumN" (optional.Interface of []string) - 
     * @param "ImageFileChecksumNic" (optional.Interface of []string) - 
     * @param "ImageFileChecksumNie" (optional.Interface of []string) - 
     * @param "ImageFileChecksumNiew" (optional.Interface of []string) - 
     * @param "ImageFileChecksumNire" (optional.Interface of []string) - 
     * @param "ImageFileChecksumNisw" (optional.Interface of []string) - 
     * @param "ImageFileChecksumNre" (optional.Interface of []string) - 
     * @param "ImageFileChecksumRe" (optional.Interface of []string) - 
     * @param "ImageFileName" (optional.Interface of []string) - 
     * @param "ImageFileNameIc" (optional.Interface of []string) - 
     * @param "ImageFileNameIe" (optional.Interface of []string) - 
     * @param "ImageFileNameIew" (optional.Interface of []string) - 
     * @param "ImageFileNameIre" (optional.Interface of []string) - 
     * @param "ImageFileNameIsw" (optional.Interface of []string) - 
     * @param "ImageFileNameN" (optional.Interface of []string) - 
     * @param "ImageFileNameNic" (optional.Interface of []string) - 
     * @param "ImageFileNameNie" (optional.Interface of []string) - 
     * @param "ImageFileNameNiew" (optional.Interface of []string) - 
     * @param "ImageFileNameNire" (optional.Interface of []string) - 
     * @param "ImageFileNameNisw" (optional.Interface of []string) - 
     * @param "ImageFileNameNre" (optional.Interface of []string) - 
     * @param "ImageFileNameRe" (optional.Interface of []string) - 
     * @param "ImageFileSize" (optional.Interface of []int32) - 
     * @param "ImageFileSizeGt" (optional.Interface of []int32) - 
     * @param "ImageFileSizeGte" (optional.Interface of []int32) - 
     * @param "ImageFileSizeIsnull" (optional.Bool) - 
     * @param "ImageFileSizeLt" (optional.Interface of []int32) - 
     * @param "ImageFileSizeLte" (optional.Interface of []int32) - 
     * @param "ImageFileSizeN" (optional.Interface of []int32) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "SoftwareVersion" (optional.Interface of []string) - 
     * @param "SoftwareVersionN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedSoftwareImageFileList
*/

type DcimApiDcimSoftwareImageFilesListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    DefaultImage optional.Bool
    DeviceTypes optional.Interface
    DeviceTypesIsnull optional.Bool
    DeviceTypesN optional.Interface
    Devices optional.Interface
    DevicesIsnull optional.Bool
    DevicesN optional.Interface
    DownloadUrl optional.Interface
    DownloadUrlIc optional.Interface
    DownloadUrlIe optional.Interface
    DownloadUrlIew optional.Interface
    DownloadUrlIre optional.Interface
    DownloadUrlIsw optional.Interface
    DownloadUrlN optional.Interface
    DownloadUrlNic optional.Interface
    DownloadUrlNie optional.Interface
    DownloadUrlNiew optional.Interface
    DownloadUrlNire optional.Interface
    DownloadUrlNisw optional.Interface
    DownloadUrlNre optional.Interface
    DownloadUrlRe optional.Interface
    Format optional.String
    HasDeviceTypes optional.Bool
    HasDevices optional.Bool
    HashingAlgorithm optional.Interface
    HashingAlgorithmIc optional.Interface
    HashingAlgorithmIe optional.Interface
    HashingAlgorithmIew optional.Interface
    HashingAlgorithmIre optional.Interface
    HashingAlgorithmIsw optional.Interface
    HashingAlgorithmN optional.Interface
    HashingAlgorithmNic optional.Interface
    HashingAlgorithmNie optional.Interface
    HashingAlgorithmNiew optional.Interface
    HashingAlgorithmNire optional.Interface
    HashingAlgorithmNisw optional.Interface
    HashingAlgorithmNre optional.Interface
    HashingAlgorithmRe optional.Interface
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    ImageFileChecksum optional.Interface
    ImageFileChecksumIc optional.Interface
    ImageFileChecksumIe optional.Interface
    ImageFileChecksumIew optional.Interface
    ImageFileChecksumIre optional.Interface
    ImageFileChecksumIsw optional.Interface
    ImageFileChecksumN optional.Interface
    ImageFileChecksumNic optional.Interface
    ImageFileChecksumNie optional.Interface
    ImageFileChecksumNiew optional.Interface
    ImageFileChecksumNire optional.Interface
    ImageFileChecksumNisw optional.Interface
    ImageFileChecksumNre optional.Interface
    ImageFileChecksumRe optional.Interface
    ImageFileName optional.Interface
    ImageFileNameIc optional.Interface
    ImageFileNameIe optional.Interface
    ImageFileNameIew optional.Interface
    ImageFileNameIre optional.Interface
    ImageFileNameIsw optional.Interface
    ImageFileNameN optional.Interface
    ImageFileNameNic optional.Interface
    ImageFileNameNie optional.Interface
    ImageFileNameNiew optional.Interface
    ImageFileNameNire optional.Interface
    ImageFileNameNisw optional.Interface
    ImageFileNameNre optional.Interface
    ImageFileNameRe optional.Interface
    ImageFileSize optional.Interface
    ImageFileSizeGt optional.Interface
    ImageFileSizeGte optional.Interface
    ImageFileSizeIsnull optional.Bool
    ImageFileSizeLt optional.Interface
    ImageFileSizeLte optional.Interface
    ImageFileSizeN optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    SoftwareVersion optional.Interface
    SoftwareVersionN optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimSoftwareImageFilesList(ctx context.Context, localVarOptionals *DcimApiDcimSoftwareImageFilesListOpts) (PaginatedSoftwareImageFileList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedSoftwareImageFileList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DefaultImage.IsSet() {
		localVarQueryParams.Add("default_image", parameterToString(localVarOptionals.DefaultImage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypes.IsSet() {
		localVarQueryParams.Add("device_types", parameterToString(localVarOptionals.DeviceTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypesIsnull.IsSet() {
		localVarQueryParams.Add("device_types__isnull", parameterToString(localVarOptionals.DeviceTypesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypesN.IsSet() {
		localVarQueryParams.Add("device_types__n", parameterToString(localVarOptionals.DeviceTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarQueryParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesIsnull.IsSet() {
		localVarQueryParams.Add("devices__isnull", parameterToString(localVarOptionals.DevicesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesN.IsSet() {
		localVarQueryParams.Add("devices__n", parameterToString(localVarOptionals.DevicesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrl.IsSet() {
		localVarQueryParams.Add("download_url", parameterToString(localVarOptionals.DownloadUrl.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlIc.IsSet() {
		localVarQueryParams.Add("download_url__ic", parameterToString(localVarOptionals.DownloadUrlIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlIe.IsSet() {
		localVarQueryParams.Add("download_url__ie", parameterToString(localVarOptionals.DownloadUrlIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlIew.IsSet() {
		localVarQueryParams.Add("download_url__iew", parameterToString(localVarOptionals.DownloadUrlIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlIre.IsSet() {
		localVarQueryParams.Add("download_url__ire", parameterToString(localVarOptionals.DownloadUrlIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlIsw.IsSet() {
		localVarQueryParams.Add("download_url__isw", parameterToString(localVarOptionals.DownloadUrlIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlN.IsSet() {
		localVarQueryParams.Add("download_url__n", parameterToString(localVarOptionals.DownloadUrlN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlNic.IsSet() {
		localVarQueryParams.Add("download_url__nic", parameterToString(localVarOptionals.DownloadUrlNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlNie.IsSet() {
		localVarQueryParams.Add("download_url__nie", parameterToString(localVarOptionals.DownloadUrlNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlNiew.IsSet() {
		localVarQueryParams.Add("download_url__niew", parameterToString(localVarOptionals.DownloadUrlNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlNire.IsSet() {
		localVarQueryParams.Add("download_url__nire", parameterToString(localVarOptionals.DownloadUrlNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlNisw.IsSet() {
		localVarQueryParams.Add("download_url__nisw", parameterToString(localVarOptionals.DownloadUrlNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlNre.IsSet() {
		localVarQueryParams.Add("download_url__nre", parameterToString(localVarOptionals.DownloadUrlNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DownloadUrlRe.IsSet() {
		localVarQueryParams.Add("download_url__re", parameterToString(localVarOptionals.DownloadUrlRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDeviceTypes.IsSet() {
		localVarQueryParams.Add("has_device_types", parameterToString(localVarOptionals.HasDeviceTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDevices.IsSet() {
		localVarQueryParams.Add("has_devices", parameterToString(localVarOptionals.HasDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithm.IsSet() {
		localVarQueryParams.Add("hashing_algorithm", parameterToString(localVarOptionals.HashingAlgorithm.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmIc.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__ic", parameterToString(localVarOptionals.HashingAlgorithmIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmIe.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__ie", parameterToString(localVarOptionals.HashingAlgorithmIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmIew.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__iew", parameterToString(localVarOptionals.HashingAlgorithmIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmIre.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__ire", parameterToString(localVarOptionals.HashingAlgorithmIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmIsw.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__isw", parameterToString(localVarOptionals.HashingAlgorithmIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmN.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__n", parameterToString(localVarOptionals.HashingAlgorithmN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmNic.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__nic", parameterToString(localVarOptionals.HashingAlgorithmNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmNie.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__nie", parameterToString(localVarOptionals.HashingAlgorithmNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmNiew.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__niew", parameterToString(localVarOptionals.HashingAlgorithmNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmNire.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__nire", parameterToString(localVarOptionals.HashingAlgorithmNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmNisw.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__nisw", parameterToString(localVarOptionals.HashingAlgorithmNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmNre.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__nre", parameterToString(localVarOptionals.HashingAlgorithmNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HashingAlgorithmRe.IsSet() {
		localVarQueryParams.Add("hashing_algorithm__re", parameterToString(localVarOptionals.HashingAlgorithmRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksum.IsSet() {
		localVarQueryParams.Add("image_file_checksum", parameterToString(localVarOptionals.ImageFileChecksum.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumIc.IsSet() {
		localVarQueryParams.Add("image_file_checksum__ic", parameterToString(localVarOptionals.ImageFileChecksumIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumIe.IsSet() {
		localVarQueryParams.Add("image_file_checksum__ie", parameterToString(localVarOptionals.ImageFileChecksumIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumIew.IsSet() {
		localVarQueryParams.Add("image_file_checksum__iew", parameterToString(localVarOptionals.ImageFileChecksumIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumIre.IsSet() {
		localVarQueryParams.Add("image_file_checksum__ire", parameterToString(localVarOptionals.ImageFileChecksumIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumIsw.IsSet() {
		localVarQueryParams.Add("image_file_checksum__isw", parameterToString(localVarOptionals.ImageFileChecksumIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumN.IsSet() {
		localVarQueryParams.Add("image_file_checksum__n", parameterToString(localVarOptionals.ImageFileChecksumN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumNic.IsSet() {
		localVarQueryParams.Add("image_file_checksum__nic", parameterToString(localVarOptionals.ImageFileChecksumNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumNie.IsSet() {
		localVarQueryParams.Add("image_file_checksum__nie", parameterToString(localVarOptionals.ImageFileChecksumNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumNiew.IsSet() {
		localVarQueryParams.Add("image_file_checksum__niew", parameterToString(localVarOptionals.ImageFileChecksumNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumNire.IsSet() {
		localVarQueryParams.Add("image_file_checksum__nire", parameterToString(localVarOptionals.ImageFileChecksumNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumNisw.IsSet() {
		localVarQueryParams.Add("image_file_checksum__nisw", parameterToString(localVarOptionals.ImageFileChecksumNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumNre.IsSet() {
		localVarQueryParams.Add("image_file_checksum__nre", parameterToString(localVarOptionals.ImageFileChecksumNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileChecksumRe.IsSet() {
		localVarQueryParams.Add("image_file_checksum__re", parameterToString(localVarOptionals.ImageFileChecksumRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileName.IsSet() {
		localVarQueryParams.Add("image_file_name", parameterToString(localVarOptionals.ImageFileName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameIc.IsSet() {
		localVarQueryParams.Add("image_file_name__ic", parameterToString(localVarOptionals.ImageFileNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameIe.IsSet() {
		localVarQueryParams.Add("image_file_name__ie", parameterToString(localVarOptionals.ImageFileNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameIew.IsSet() {
		localVarQueryParams.Add("image_file_name__iew", parameterToString(localVarOptionals.ImageFileNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameIre.IsSet() {
		localVarQueryParams.Add("image_file_name__ire", parameterToString(localVarOptionals.ImageFileNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameIsw.IsSet() {
		localVarQueryParams.Add("image_file_name__isw", parameterToString(localVarOptionals.ImageFileNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameN.IsSet() {
		localVarQueryParams.Add("image_file_name__n", parameterToString(localVarOptionals.ImageFileNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameNic.IsSet() {
		localVarQueryParams.Add("image_file_name__nic", parameterToString(localVarOptionals.ImageFileNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameNie.IsSet() {
		localVarQueryParams.Add("image_file_name__nie", parameterToString(localVarOptionals.ImageFileNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameNiew.IsSet() {
		localVarQueryParams.Add("image_file_name__niew", parameterToString(localVarOptionals.ImageFileNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameNire.IsSet() {
		localVarQueryParams.Add("image_file_name__nire", parameterToString(localVarOptionals.ImageFileNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameNisw.IsSet() {
		localVarQueryParams.Add("image_file_name__nisw", parameterToString(localVarOptionals.ImageFileNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameNre.IsSet() {
		localVarQueryParams.Add("image_file_name__nre", parameterToString(localVarOptionals.ImageFileNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileNameRe.IsSet() {
		localVarQueryParams.Add("image_file_name__re", parameterToString(localVarOptionals.ImageFileNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileSize.IsSet() {
		localVarQueryParams.Add("image_file_size", parameterToString(localVarOptionals.ImageFileSize.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileSizeGt.IsSet() {
		localVarQueryParams.Add("image_file_size__gt", parameterToString(localVarOptionals.ImageFileSizeGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileSizeGte.IsSet() {
		localVarQueryParams.Add("image_file_size__gte", parameterToString(localVarOptionals.ImageFileSizeGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileSizeIsnull.IsSet() {
		localVarQueryParams.Add("image_file_size__isnull", parameterToString(localVarOptionals.ImageFileSizeIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileSizeLt.IsSet() {
		localVarQueryParams.Add("image_file_size__lt", parameterToString(localVarOptionals.ImageFileSizeLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileSizeLte.IsSet() {
		localVarQueryParams.Add("image_file_size__lte", parameterToString(localVarOptionals.ImageFileSizeLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ImageFileSizeN.IsSet() {
		localVarQueryParams.Add("image_file_size__n", parameterToString(localVarOptionals.ImageFileSizeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareVersion.IsSet() {
		localVarQueryParams.Add("software_version", parameterToString(localVarOptionals.SoftwareVersion.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareVersionN.IsSet() {
		localVarQueryParams.Add("software_version__n", parameterToString(localVarOptionals.SoftwareVersionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedSoftwareImageFileList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this software image file.
 * @param optional nil or *DcimApiDcimSoftwareImageFilesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimSoftwareImageFilesNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareImageFilesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimSoftwareImageFilesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this software image file.
 * @param optional nil or *DcimApiDcimSoftwareImageFilesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimSoftwareImageFilesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimSoftwareImageFilesNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimSoftwareImageFilesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a software image file object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this software image file.
 * @param optional nil or *DcimApiDcimSoftwareImageFilesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedSoftwareImageFileRequest) - 
     * @param "Format" (optional.String) - 
@return SoftwareImageFile
*/

type DcimApiDcimSoftwareImageFilesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareImageFilesPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimSoftwareImageFilesPartialUpdateOpts) (SoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a software image file object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this software image file.
 * @param optional nil or *DcimApiDcimSoftwareImageFilesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return SoftwareImageFile
*/

type DcimApiDcimSoftwareImageFilesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimSoftwareImageFilesRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimSoftwareImageFilesRetrieveOpts) (SoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a software image file object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this software image file.
 * @param optional nil or *DcimApiDcimSoftwareImageFilesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return SoftwareImageFile
*/

type DcimApiDcimSoftwareImageFilesUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareImageFilesUpdate(ctx context.Context, body SoftwareImageFileRequest, id string, localVarOptionals *DcimApiDcimSoftwareImageFilesUpdateOpts) (SoftwareImageFile, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SoftwareImageFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-image-files/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SoftwareImageFile
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of software version objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimSoftwareVersionsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimSoftwareVersionsBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareVersionsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimSoftwareVersionsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of software version objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimSoftwareVersionsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []SoftwareVersion
*/

type DcimApiDcimSoftwareVersionsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareVersionsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableSoftwareVersionRequest, localVarOptionals *DcimApiDcimSoftwareVersionsBulkPartialUpdateOpts) ([]SoftwareVersion, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []SoftwareVersion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SoftwareVersion
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of software version objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimSoftwareVersionsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []SoftwareVersion
*/

type DcimApiDcimSoftwareVersionsBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareVersionsBulkUpdate(ctx context.Context, body []BulkWritableSoftwareVersionRequest, localVarOptionals *DcimApiDcimSoftwareVersionsBulkUpdateOpts) ([]SoftwareVersion, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []SoftwareVersion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SoftwareVersion
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more software version objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimSoftwareVersionsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return SoftwareVersion
*/

type DcimApiDcimSoftwareVersionsCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareVersionsCreate(ctx context.Context, body SoftwareVersionRequest, localVarOptionals *DcimApiDcimSoftwareVersionsCreateOpts) (SoftwareVersion, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SoftwareVersion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v SoftwareVersion
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a software version object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this software version.
 * @param optional nil or *DcimApiDcimSoftwareVersionsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimSoftwareVersionsDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareVersionsDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimSoftwareVersionsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of software version objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimSoftwareVersionsListOpts - Optional Parameters:
     * @param "Alias" (optional.Interface of []string) - 
     * @param "AliasIc" (optional.Interface of []string) - 
     * @param "AliasIe" (optional.Interface of []string) - 
     * @param "AliasIew" (optional.Interface of []string) - 
     * @param "AliasIre" (optional.Interface of []string) - 
     * @param "AliasIsw" (optional.Interface of []string) - 
     * @param "AliasN" (optional.Interface of []string) - 
     * @param "AliasNic" (optional.Interface of []string) - 
     * @param "AliasNie" (optional.Interface of []string) - 
     * @param "AliasNiew" (optional.Interface of []string) - 
     * @param "AliasNire" (optional.Interface of []string) - 
     * @param "AliasNisw" (optional.Interface of []string) - 
     * @param "AliasNre" (optional.Interface of []string) - 
     * @param "AliasRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "DeviceTypes" (optional.Interface of []string) - 
     * @param "DeviceTypesIsnull" (optional.Bool) - 
     * @param "DeviceTypesN" (optional.Interface of []string) - 
     * @param "Devices" (optional.Interface of []string) - 
     * @param "DevicesIsnull" (optional.Bool) - 
     * @param "DevicesN" (optional.Interface of []string) - 
     * @param "DocumentationUrl" (optional.Interface of []string) - 
     * @param "DocumentationUrlIc" (optional.Interface of []string) - 
     * @param "DocumentationUrlIe" (optional.Interface of []string) - 
     * @param "DocumentationUrlIew" (optional.Interface of []string) - 
     * @param "DocumentationUrlIre" (optional.Interface of []string) - 
     * @param "DocumentationUrlIsw" (optional.Interface of []string) - 
     * @param "DocumentationUrlN" (optional.Interface of []string) - 
     * @param "DocumentationUrlNic" (optional.Interface of []string) - 
     * @param "DocumentationUrlNie" (optional.Interface of []string) - 
     * @param "DocumentationUrlNiew" (optional.Interface of []string) - 
     * @param "DocumentationUrlNire" (optional.Interface of []string) - 
     * @param "DocumentationUrlNisw" (optional.Interface of []string) - 
     * @param "DocumentationUrlNre" (optional.Interface of []string) - 
     * @param "DocumentationUrlRe" (optional.Interface of []string) - 
     * @param "EndOfSupportDate" (optional.Interface of []string) - 
     * @param "EndOfSupportDateGt" (optional.Interface of []string) - 
     * @param "EndOfSupportDateGte" (optional.Interface of []string) - 
     * @param "EndOfSupportDateIsnull" (optional.Bool) - 
     * @param "EndOfSupportDateLt" (optional.Interface of []string) - 
     * @param "EndOfSupportDateLte" (optional.Interface of []string) - 
     * @param "EndOfSupportDateN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasDevices" (optional.Bool) -  Has devices
     * @param "HasInventoryItems" (optional.Bool) -  Has inventory items
     * @param "HasSoftwareImageFiles" (optional.Bool) -  Has software image files
     * @param "HasVirtualMachines" (optional.Bool) -  Has virtual machines
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "InventoryItems" (optional.Interface of []string) - 
     * @param "InventoryItemsIsnull" (optional.Bool) - 
     * @param "InventoryItemsN" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "LongTermSupport" (optional.Bool) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Platform" (optional.Interface of []string) - 
     * @param "PlatformN" (optional.Interface of []string) - 
     * @param "PreRelease" (optional.Bool) - 
     * @param "Q" (optional.String) -  Search
     * @param "ReleaseDate" (optional.Interface of []string) - 
     * @param "ReleaseDateGt" (optional.Interface of []string) - 
     * @param "ReleaseDateGte" (optional.Interface of []string) - 
     * @param "ReleaseDateIsnull" (optional.Bool) - 
     * @param "ReleaseDateLt" (optional.Interface of []string) - 
     * @param "ReleaseDateLte" (optional.Interface of []string) - 
     * @param "ReleaseDateN" (optional.Interface of []string) - 
     * @param "SoftwareImageFiles" (optional.Interface of []string) - 
     * @param "SoftwareImageFilesIsnull" (optional.Bool) - 
     * @param "SoftwareImageFilesN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Version" (optional.Interface of []string) - 
     * @param "VersionIc" (optional.Interface of []string) - 
     * @param "VersionIe" (optional.Interface of []string) - 
     * @param "VersionIew" (optional.Interface of []string) - 
     * @param "VersionIre" (optional.Interface of []string) - 
     * @param "VersionIsw" (optional.Interface of []string) - 
     * @param "VersionN" (optional.Interface of []string) - 
     * @param "VersionNic" (optional.Interface of []string) - 
     * @param "VersionNie" (optional.Interface of []string) - 
     * @param "VersionNiew" (optional.Interface of []string) - 
     * @param "VersionNire" (optional.Interface of []string) - 
     * @param "VersionNisw" (optional.Interface of []string) - 
     * @param "VersionNre" (optional.Interface of []string) - 
     * @param "VersionRe" (optional.Interface of []string) - 
     * @param "VirtualMachines" (optional.Interface of []string) - 
     * @param "VirtualMachinesIsnull" (optional.Bool) - 
     * @param "VirtualMachinesN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedSoftwareVersionList
*/

type DcimApiDcimSoftwareVersionsListOpts struct {
    Alias optional.Interface
    AliasIc optional.Interface
    AliasIe optional.Interface
    AliasIew optional.Interface
    AliasIre optional.Interface
    AliasIsw optional.Interface
    AliasN optional.Interface
    AliasNic optional.Interface
    AliasNie optional.Interface
    AliasNiew optional.Interface
    AliasNire optional.Interface
    AliasNisw optional.Interface
    AliasNre optional.Interface
    AliasRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    DeviceTypes optional.Interface
    DeviceTypesIsnull optional.Bool
    DeviceTypesN optional.Interface
    Devices optional.Interface
    DevicesIsnull optional.Bool
    DevicesN optional.Interface
    DocumentationUrl optional.Interface
    DocumentationUrlIc optional.Interface
    DocumentationUrlIe optional.Interface
    DocumentationUrlIew optional.Interface
    DocumentationUrlIre optional.Interface
    DocumentationUrlIsw optional.Interface
    DocumentationUrlN optional.Interface
    DocumentationUrlNic optional.Interface
    DocumentationUrlNie optional.Interface
    DocumentationUrlNiew optional.Interface
    DocumentationUrlNire optional.Interface
    DocumentationUrlNisw optional.Interface
    DocumentationUrlNre optional.Interface
    DocumentationUrlRe optional.Interface
    EndOfSupportDate optional.Interface
    EndOfSupportDateGt optional.Interface
    EndOfSupportDateGte optional.Interface
    EndOfSupportDateIsnull optional.Bool
    EndOfSupportDateLt optional.Interface
    EndOfSupportDateLte optional.Interface
    EndOfSupportDateN optional.Interface
    Format optional.String
    HasDevices optional.Bool
    HasInventoryItems optional.Bool
    HasSoftwareImageFiles optional.Bool
    HasVirtualMachines optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    InventoryItems optional.Interface
    InventoryItemsIsnull optional.Bool
    InventoryItemsN optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    LongTermSupport optional.Bool
    Offset optional.Int32
    Platform optional.Interface
    PlatformN optional.Interface
    PreRelease optional.Bool
    Q optional.String
    ReleaseDate optional.Interface
    ReleaseDateGt optional.Interface
    ReleaseDateGte optional.Interface
    ReleaseDateIsnull optional.Bool
    ReleaseDateLt optional.Interface
    ReleaseDateLte optional.Interface
    ReleaseDateN optional.Interface
    SoftwareImageFiles optional.Interface
    SoftwareImageFilesIsnull optional.Bool
    SoftwareImageFilesN optional.Interface
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Version optional.Interface
    VersionIc optional.Interface
    VersionIe optional.Interface
    VersionIew optional.Interface
    VersionIre optional.Interface
    VersionIsw optional.Interface
    VersionN optional.Interface
    VersionNic optional.Interface
    VersionNie optional.Interface
    VersionNiew optional.Interface
    VersionNire optional.Interface
    VersionNisw optional.Interface
    VersionNre optional.Interface
    VersionRe optional.Interface
    VirtualMachines optional.Interface
    VirtualMachinesIsnull optional.Bool
    VirtualMachinesN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimSoftwareVersionsList(ctx context.Context, localVarOptionals *DcimApiDcimSoftwareVersionsListOpts) (PaginatedSoftwareVersionList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedSoftwareVersionList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Alias.IsSet() {
		localVarQueryParams.Add("alias", parameterToString(localVarOptionals.Alias.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasIc.IsSet() {
		localVarQueryParams.Add("alias__ic", parameterToString(localVarOptionals.AliasIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasIe.IsSet() {
		localVarQueryParams.Add("alias__ie", parameterToString(localVarOptionals.AliasIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasIew.IsSet() {
		localVarQueryParams.Add("alias__iew", parameterToString(localVarOptionals.AliasIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasIre.IsSet() {
		localVarQueryParams.Add("alias__ire", parameterToString(localVarOptionals.AliasIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasIsw.IsSet() {
		localVarQueryParams.Add("alias__isw", parameterToString(localVarOptionals.AliasIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasN.IsSet() {
		localVarQueryParams.Add("alias__n", parameterToString(localVarOptionals.AliasN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasNic.IsSet() {
		localVarQueryParams.Add("alias__nic", parameterToString(localVarOptionals.AliasNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasNie.IsSet() {
		localVarQueryParams.Add("alias__nie", parameterToString(localVarOptionals.AliasNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasNiew.IsSet() {
		localVarQueryParams.Add("alias__niew", parameterToString(localVarOptionals.AliasNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasNire.IsSet() {
		localVarQueryParams.Add("alias__nire", parameterToString(localVarOptionals.AliasNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasNisw.IsSet() {
		localVarQueryParams.Add("alias__nisw", parameterToString(localVarOptionals.AliasNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasNre.IsSet() {
		localVarQueryParams.Add("alias__nre", parameterToString(localVarOptionals.AliasNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AliasRe.IsSet() {
		localVarQueryParams.Add("alias__re", parameterToString(localVarOptionals.AliasRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypes.IsSet() {
		localVarQueryParams.Add("device_types", parameterToString(localVarOptionals.DeviceTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypesIsnull.IsSet() {
		localVarQueryParams.Add("device_types__isnull", parameterToString(localVarOptionals.DeviceTypesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceTypesN.IsSet() {
		localVarQueryParams.Add("device_types__n", parameterToString(localVarOptionals.DeviceTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarQueryParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesIsnull.IsSet() {
		localVarQueryParams.Add("devices__isnull", parameterToString(localVarOptionals.DevicesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesN.IsSet() {
		localVarQueryParams.Add("devices__n", parameterToString(localVarOptionals.DevicesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrl.IsSet() {
		localVarQueryParams.Add("documentation_url", parameterToString(localVarOptionals.DocumentationUrl.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlIc.IsSet() {
		localVarQueryParams.Add("documentation_url__ic", parameterToString(localVarOptionals.DocumentationUrlIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlIe.IsSet() {
		localVarQueryParams.Add("documentation_url__ie", parameterToString(localVarOptionals.DocumentationUrlIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlIew.IsSet() {
		localVarQueryParams.Add("documentation_url__iew", parameterToString(localVarOptionals.DocumentationUrlIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlIre.IsSet() {
		localVarQueryParams.Add("documentation_url__ire", parameterToString(localVarOptionals.DocumentationUrlIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlIsw.IsSet() {
		localVarQueryParams.Add("documentation_url__isw", parameterToString(localVarOptionals.DocumentationUrlIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlN.IsSet() {
		localVarQueryParams.Add("documentation_url__n", parameterToString(localVarOptionals.DocumentationUrlN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlNic.IsSet() {
		localVarQueryParams.Add("documentation_url__nic", parameterToString(localVarOptionals.DocumentationUrlNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlNie.IsSet() {
		localVarQueryParams.Add("documentation_url__nie", parameterToString(localVarOptionals.DocumentationUrlNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlNiew.IsSet() {
		localVarQueryParams.Add("documentation_url__niew", parameterToString(localVarOptionals.DocumentationUrlNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlNire.IsSet() {
		localVarQueryParams.Add("documentation_url__nire", parameterToString(localVarOptionals.DocumentationUrlNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlNisw.IsSet() {
		localVarQueryParams.Add("documentation_url__nisw", parameterToString(localVarOptionals.DocumentationUrlNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlNre.IsSet() {
		localVarQueryParams.Add("documentation_url__nre", parameterToString(localVarOptionals.DocumentationUrlNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentationUrlRe.IsSet() {
		localVarQueryParams.Add("documentation_url__re", parameterToString(localVarOptionals.DocumentationUrlRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EndOfSupportDate.IsSet() {
		localVarQueryParams.Add("end_of_support_date", parameterToString(localVarOptionals.EndOfSupportDate.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EndOfSupportDateGt.IsSet() {
		localVarQueryParams.Add("end_of_support_date__gt", parameterToString(localVarOptionals.EndOfSupportDateGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EndOfSupportDateGte.IsSet() {
		localVarQueryParams.Add("end_of_support_date__gte", parameterToString(localVarOptionals.EndOfSupportDateGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EndOfSupportDateIsnull.IsSet() {
		localVarQueryParams.Add("end_of_support_date__isnull", parameterToString(localVarOptionals.EndOfSupportDateIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndOfSupportDateLt.IsSet() {
		localVarQueryParams.Add("end_of_support_date__lt", parameterToString(localVarOptionals.EndOfSupportDateLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EndOfSupportDateLte.IsSet() {
		localVarQueryParams.Add("end_of_support_date__lte", parameterToString(localVarOptionals.EndOfSupportDateLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EndOfSupportDateN.IsSet() {
		localVarQueryParams.Add("end_of_support_date__n", parameterToString(localVarOptionals.EndOfSupportDateN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDevices.IsSet() {
		localVarQueryParams.Add("has_devices", parameterToString(localVarOptionals.HasDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasInventoryItems.IsSet() {
		localVarQueryParams.Add("has_inventory_items", parameterToString(localVarOptionals.HasInventoryItems.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasSoftwareImageFiles.IsSet() {
		localVarQueryParams.Add("has_software_image_files", parameterToString(localVarOptionals.HasSoftwareImageFiles.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasVirtualMachines.IsSet() {
		localVarQueryParams.Add("has_virtual_machines", parameterToString(localVarOptionals.HasVirtualMachines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InventoryItems.IsSet() {
		localVarQueryParams.Add("inventory_items", parameterToString(localVarOptionals.InventoryItems.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InventoryItemsIsnull.IsSet() {
		localVarQueryParams.Add("inventory_items__isnull", parameterToString(localVarOptionals.InventoryItemsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InventoryItemsN.IsSet() {
		localVarQueryParams.Add("inventory_items__n", parameterToString(localVarOptionals.InventoryItemsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LongTermSupport.IsSet() {
		localVarQueryParams.Add("long_term_support", parameterToString(localVarOptionals.LongTermSupport.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Platform.IsSet() {
		localVarQueryParams.Add("platform", parameterToString(localVarOptionals.Platform.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformN.IsSet() {
		localVarQueryParams.Add("platform__n", parameterToString(localVarOptionals.PlatformN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PreRelease.IsSet() {
		localVarQueryParams.Add("pre_release", parameterToString(localVarOptionals.PreRelease.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReleaseDate.IsSet() {
		localVarQueryParams.Add("release_date", parameterToString(localVarOptionals.ReleaseDate.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReleaseDateGt.IsSet() {
		localVarQueryParams.Add("release_date__gt", parameterToString(localVarOptionals.ReleaseDateGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReleaseDateGte.IsSet() {
		localVarQueryParams.Add("release_date__gte", parameterToString(localVarOptionals.ReleaseDateGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReleaseDateIsnull.IsSet() {
		localVarQueryParams.Add("release_date__isnull", parameterToString(localVarOptionals.ReleaseDateIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReleaseDateLt.IsSet() {
		localVarQueryParams.Add("release_date__lt", parameterToString(localVarOptionals.ReleaseDateLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReleaseDateLte.IsSet() {
		localVarQueryParams.Add("release_date__lte", parameterToString(localVarOptionals.ReleaseDateLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReleaseDateN.IsSet() {
		localVarQueryParams.Add("release_date__n", parameterToString(localVarOptionals.ReleaseDateN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFiles.IsSet() {
		localVarQueryParams.Add("software_image_files", parameterToString(localVarOptionals.SoftwareImageFiles.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFilesIsnull.IsSet() {
		localVarQueryParams.Add("software_image_files__isnull", parameterToString(localVarOptionals.SoftwareImageFilesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SoftwareImageFilesN.IsSet() {
		localVarQueryParams.Add("software_image_files__n", parameterToString(localVarOptionals.SoftwareImageFilesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Version.IsSet() {
		localVarQueryParams.Add("version", parameterToString(localVarOptionals.Version.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionIc.IsSet() {
		localVarQueryParams.Add("version__ic", parameterToString(localVarOptionals.VersionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionIe.IsSet() {
		localVarQueryParams.Add("version__ie", parameterToString(localVarOptionals.VersionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionIew.IsSet() {
		localVarQueryParams.Add("version__iew", parameterToString(localVarOptionals.VersionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionIre.IsSet() {
		localVarQueryParams.Add("version__ire", parameterToString(localVarOptionals.VersionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionIsw.IsSet() {
		localVarQueryParams.Add("version__isw", parameterToString(localVarOptionals.VersionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionN.IsSet() {
		localVarQueryParams.Add("version__n", parameterToString(localVarOptionals.VersionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionNic.IsSet() {
		localVarQueryParams.Add("version__nic", parameterToString(localVarOptionals.VersionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionNie.IsSet() {
		localVarQueryParams.Add("version__nie", parameterToString(localVarOptionals.VersionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionNiew.IsSet() {
		localVarQueryParams.Add("version__niew", parameterToString(localVarOptionals.VersionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionNire.IsSet() {
		localVarQueryParams.Add("version__nire", parameterToString(localVarOptionals.VersionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionNisw.IsSet() {
		localVarQueryParams.Add("version__nisw", parameterToString(localVarOptionals.VersionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionNre.IsSet() {
		localVarQueryParams.Add("version__nre", parameterToString(localVarOptionals.VersionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VersionRe.IsSet() {
		localVarQueryParams.Add("version__re", parameterToString(localVarOptionals.VersionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachines.IsSet() {
		localVarQueryParams.Add("virtual_machines", parameterToString(localVarOptionals.VirtualMachines.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachinesIsnull.IsSet() {
		localVarQueryParams.Add("virtual_machines__isnull", parameterToString(localVarOptionals.VirtualMachinesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachinesN.IsSet() {
		localVarQueryParams.Add("virtual_machines__n", parameterToString(localVarOptionals.VirtualMachinesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedSoftwareVersionList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this software version.
 * @param optional nil or *DcimApiDcimSoftwareVersionsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimSoftwareVersionsNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareVersionsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimSoftwareVersionsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this software version.
 * @param optional nil or *DcimApiDcimSoftwareVersionsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimSoftwareVersionsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimSoftwareVersionsNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimSoftwareVersionsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a software version object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this software version.
 * @param optional nil or *DcimApiDcimSoftwareVersionsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedSoftwareVersionRequest) - 
     * @param "Format" (optional.String) - 
@return SoftwareVersion
*/

type DcimApiDcimSoftwareVersionsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareVersionsPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimSoftwareVersionsPartialUpdateOpts) (SoftwareVersion, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SoftwareVersion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SoftwareVersion
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a software version object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this software version.
 * @param optional nil or *DcimApiDcimSoftwareVersionsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return SoftwareVersion
*/

type DcimApiDcimSoftwareVersionsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimSoftwareVersionsRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimSoftwareVersionsRetrieveOpts) (SoftwareVersion, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SoftwareVersion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SoftwareVersion
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a software version object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this software version.
 * @param optional nil or *DcimApiDcimSoftwareVersionsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return SoftwareVersion
*/

type DcimApiDcimSoftwareVersionsUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimSoftwareVersionsUpdate(ctx context.Context, body SoftwareVersionRequest, id string, localVarOptionals *DcimApiDcimSoftwareVersionsUpdateOpts) (SoftwareVersion, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SoftwareVersion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/software-versions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SoftwareVersion
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a list of virtual chassis objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimVirtualChassisBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimVirtualChassisBulkDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimVirtualChassisBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *DcimApiDcimVirtualChassisBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a list of virtual chassis objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimVirtualChassisBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []VirtualChassis
*/

type DcimApiDcimVirtualChassisBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimVirtualChassisBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableVirtualChassisRequest, localVarOptionals *DcimApiDcimVirtualChassisBulkPartialUpdateOpts) ([]VirtualChassis, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []VirtualChassis
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []VirtualChassis
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a list of virtual chassis objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimVirtualChassisBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []VirtualChassis
*/

type DcimApiDcimVirtualChassisBulkUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimVirtualChassisBulkUpdate(ctx context.Context, body []BulkWritableVirtualChassisRequest, localVarOptionals *DcimApiDcimVirtualChassisBulkUpdateOpts) ([]VirtualChassis, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []VirtualChassis
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []VirtualChassis
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Create one or more virtual chassis objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DcimApiDcimVirtualChassisCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return VirtualChassis
*/

type DcimApiDcimVirtualChassisCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimVirtualChassisCreate(ctx context.Context, body VirtualChassisRequest, localVarOptionals *DcimApiDcimVirtualChassisCreateOpts) (VirtualChassis, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VirtualChassis
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v VirtualChassis
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Destroy a virtual chassis object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this virtual chassis.
 * @param optional nil or *DcimApiDcimVirtualChassisDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type DcimApiDcimVirtualChassisDestroyOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimVirtualChassisDestroy(ctx context.Context, id string, localVarOptionals *DcimApiDcimVirtualChassisDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a list of virtual chassis objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DcimApiDcimVirtualChassisListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Domain" (optional.Interface of []string) - 
     * @param "DomainIc" (optional.Interface of []string) - 
     * @param "DomainIe" (optional.Interface of []string) - 
     * @param "DomainIew" (optional.Interface of []string) - 
     * @param "DomainIre" (optional.Interface of []string) - 
     * @param "DomainIsw" (optional.Interface of []string) - 
     * @param "DomainN" (optional.Interface of []string) - 
     * @param "DomainNic" (optional.Interface of []string) - 
     * @param "DomainNie" (optional.Interface of []string) - 
     * @param "DomainNiew" (optional.Interface of []string) - 
     * @param "DomainNire" (optional.Interface of []string) - 
     * @param "DomainNisw" (optional.Interface of []string) - 
     * @param "DomainNre" (optional.Interface of []string) - 
     * @param "DomainRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasMembers" (optional.Bool) -  Has device members
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Master" (optional.Interface of []string) - 
     * @param "MasterIsnull" (optional.Bool) - 
     * @param "MasterN" (optional.Interface of []string) - 
     * @param "Members" (optional.Interface of []string) - 
     * @param "MembersIsnull" (optional.Bool) - 
     * @param "MembersN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Tenant" (optional.Interface of []string) - 
     * @param "TenantIsnull" (optional.Bool) - 
     * @param "TenantN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedVirtualChassisList
*/

type DcimApiDcimVirtualChassisListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Domain optional.Interface
    DomainIc optional.Interface
    DomainIe optional.Interface
    DomainIew optional.Interface
    DomainIre optional.Interface
    DomainIsw optional.Interface
    DomainN optional.Interface
    DomainNic optional.Interface
    DomainNie optional.Interface
    DomainNiew optional.Interface
    DomainNire optional.Interface
    DomainNisw optional.Interface
    DomainNre optional.Interface
    DomainRe optional.Interface
    Format optional.String
    HasMembers optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationN optional.Interface
    Master optional.Interface
    MasterIsnull optional.Bool
    MasterN optional.Interface
    Members optional.Interface
    MembersIsnull optional.Bool
    MembersN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Tenant optional.Interface
    TenantIsnull optional.Bool
    TenantN optional.Interface
    Depth optional.Int32
}

func (a *DcimApiService) DcimVirtualChassisList(ctx context.Context, localVarOptionals *DcimApiDcimVirtualChassisListOpts) (PaginatedVirtualChassisList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedVirtualChassisList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Domain.IsSet() {
		localVarQueryParams.Add("domain", parameterToString(localVarOptionals.Domain.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIc.IsSet() {
		localVarQueryParams.Add("domain__ic", parameterToString(localVarOptionals.DomainIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIe.IsSet() {
		localVarQueryParams.Add("domain__ie", parameterToString(localVarOptionals.DomainIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIew.IsSet() {
		localVarQueryParams.Add("domain__iew", parameterToString(localVarOptionals.DomainIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIre.IsSet() {
		localVarQueryParams.Add("domain__ire", parameterToString(localVarOptionals.DomainIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIsw.IsSet() {
		localVarQueryParams.Add("domain__isw", parameterToString(localVarOptionals.DomainIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainN.IsSet() {
		localVarQueryParams.Add("domain__n", parameterToString(localVarOptionals.DomainN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainNic.IsSet() {
		localVarQueryParams.Add("domain__nic", parameterToString(localVarOptionals.DomainNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainNie.IsSet() {
		localVarQueryParams.Add("domain__nie", parameterToString(localVarOptionals.DomainNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainNiew.IsSet() {
		localVarQueryParams.Add("domain__niew", parameterToString(localVarOptionals.DomainNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainNire.IsSet() {
		localVarQueryParams.Add("domain__nire", parameterToString(localVarOptionals.DomainNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainNisw.IsSet() {
		localVarQueryParams.Add("domain__nisw", parameterToString(localVarOptionals.DomainNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainNre.IsSet() {
		localVarQueryParams.Add("domain__nre", parameterToString(localVarOptionals.DomainNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainRe.IsSet() {
		localVarQueryParams.Add("domain__re", parameterToString(localVarOptionals.DomainRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasMembers.IsSet() {
		localVarQueryParams.Add("has_members", parameterToString(localVarOptionals.HasMembers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Master.IsSet() {
		localVarQueryParams.Add("master", parameterToString(localVarOptionals.Master.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MasterIsnull.IsSet() {
		localVarQueryParams.Add("master__isnull", parameterToString(localVarOptionals.MasterIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MasterN.IsSet() {
		localVarQueryParams.Add("master__n", parameterToString(localVarOptionals.MasterN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Members.IsSet() {
		localVarQueryParams.Add("members", parameterToString(localVarOptionals.Members.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.MembersIsnull.IsSet() {
		localVarQueryParams.Add("members__isnull", parameterToString(localVarOptionals.MembersIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MembersN.IsSet() {
		localVarQueryParams.Add("members__n", parameterToString(localVarOptionals.MembersN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIsnull.IsSet() {
		localVarQueryParams.Add("tenant__isnull", parameterToString(localVarOptionals.TenantIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedVirtualChassisList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this virtual chassis.
 * @param optional nil or *DcimApiDcimVirtualChassisNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type DcimApiDcimVirtualChassisNotesCreateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimVirtualChassisNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *DcimApiDcimVirtualChassisNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this virtual chassis.
 * @param optional nil or *DcimApiDcimVirtualChassisNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type DcimApiDcimVirtualChassisNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *DcimApiService) DcimVirtualChassisNotesList(ctx context.Context, id string, localVarOptionals *DcimApiDcimVirtualChassisNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Partial update a virtual chassis object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this virtual chassis.
 * @param optional nil or *DcimApiDcimVirtualChassisPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedVirtualChassisRequest) - 
     * @param "Format" (optional.String) - 
@return VirtualChassis
*/

type DcimApiDcimVirtualChassisPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *DcimApiService) DcimVirtualChassisPartialUpdate(ctx context.Context, id string, localVarOptionals *DcimApiDcimVirtualChassisPartialUpdateOpts) (VirtualChassis, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VirtualChassis
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v VirtualChassis
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Retrieve a virtual chassis object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this virtual chassis.
 * @param optional nil or *DcimApiDcimVirtualChassisRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return VirtualChassis
*/

type DcimApiDcimVirtualChassisRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *DcimApiService) DcimVirtualChassisRetrieve(ctx context.Context, id string, localVarOptionals *DcimApiDcimVirtualChassisRetrieveOpts) (VirtualChassis, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VirtualChassis
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v VirtualChassis
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
DcimApiService
Update a virtual chassis object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this virtual chassis.
 * @param optional nil or *DcimApiDcimVirtualChassisUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return VirtualChassis
*/

type DcimApiDcimVirtualChassisUpdateOpts struct {
    Format optional.String
}

func (a *DcimApiService) DcimVirtualChassisUpdate(ctx context.Context, body VirtualChassisRequest, id string, localVarOptionals *DcimApiDcimVirtualChassisUpdateOpts) (VirtualChassis, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VirtualChassis
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dcim/virtual-chassis/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v VirtualChassis
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
