
/*
 * API Documentation
 *
 * Source of truth and network automation platform
 *
 * API version: 2.2.5 (2.2)
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package go-nautobot

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type TenancyApiService service
/*
TenancyApiService
Destroy a list of tenant group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *TenancyApiTenancyTenantGroupsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type TenancyApiTenancyTenantGroupsBulkDestroyOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantGroupsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *TenancyApiTenancyTenantGroupsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
TenancyApiService
Partial update a list of tenant group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *TenancyApiTenancyTenantGroupsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []TenantGroup
*/

type TenancyApiTenancyTenantGroupsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantGroupsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableTenantGroupRequest, localVarOptionals *TenancyApiTenancyTenantGroupsBulkPartialUpdateOpts) ([]TenantGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []TenantGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []TenantGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Update a list of tenant group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *TenancyApiTenancyTenantGroupsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []TenantGroup
*/

type TenancyApiTenancyTenantGroupsBulkUpdateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantGroupsBulkUpdate(ctx context.Context, body []BulkWritableTenantGroupRequest, localVarOptionals *TenancyApiTenancyTenantGroupsBulkUpdateOpts) ([]TenantGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []TenantGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []TenantGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Create one or more tenant group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *TenancyApiTenancyTenantGroupsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return TenantGroup
*/

type TenancyApiTenancyTenantGroupsCreateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantGroupsCreate(ctx context.Context, body TenantGroupRequest, localVarOptionals *TenancyApiTenancyTenantGroupsCreateOpts) (TenantGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TenantGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v TenantGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Destroy a tenant group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tenant group.
 * @param optional nil or *TenancyApiTenancyTenantGroupsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type TenancyApiTenancyTenantGroupsDestroyOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantGroupsDestroy(ctx context.Context, id string, localVarOptionals *TenancyApiTenancyTenantGroupsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
TenancyApiService
Retrieve a list of tenant group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TenancyApiTenancyTenantGroupsListOpts - Optional Parameters:
     * @param "Children" (optional.Interface of []string) - 
     * @param "ChildrenIsnull" (optional.Bool) - 
     * @param "ChildrenN" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasChildren" (optional.Bool) -  Has children
     * @param "HasTenants" (optional.Bool) -  Has tenants
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Parent" (optional.Interface of []string) - 
     * @param "ParentIsnull" (optional.Bool) - 
     * @param "ParentN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tenants" (optional.Interface of []string) - 
     * @param "TenantsIsnull" (optional.Bool) - 
     * @param "TenantsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedTenantGroupList
*/

type TenancyApiTenancyTenantGroupsListOpts struct {
    Children optional.Interface
    ChildrenIsnull optional.Bool
    ChildrenN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    HasChildren optional.Bool
    HasTenants optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Parent optional.Interface
    ParentIsnull optional.Bool
    ParentN optional.Interface
    Q optional.String
    Sort optional.String
    Tenants optional.Interface
    TenantsIsnull optional.Bool
    TenantsN optional.Interface
    Depth optional.Int32
}

func (a *TenancyApiService) TenancyTenantGroupsList(ctx context.Context, localVarOptionals *TenancyApiTenancyTenantGroupsListOpts) (PaginatedTenantGroupList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedTenantGroupList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Children.IsSet() {
		localVarQueryParams.Add("children", parameterToString(localVarOptionals.Children.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ChildrenIsnull.IsSet() {
		localVarQueryParams.Add("children__isnull", parameterToString(localVarOptionals.ChildrenIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChildrenN.IsSet() {
		localVarQueryParams.Add("children__n", parameterToString(localVarOptionals.ChildrenN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasChildren.IsSet() {
		localVarQueryParams.Add("has_children", parameterToString(localVarOptionals.HasChildren.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasTenants.IsSet() {
		localVarQueryParams.Add("has_tenants", parameterToString(localVarOptionals.HasTenants.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parent.IsSet() {
		localVarQueryParams.Add("parent", parameterToString(localVarOptionals.Parent.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ParentIsnull.IsSet() {
		localVarQueryParams.Add("parent__isnull", parameterToString(localVarOptionals.ParentIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentN.IsSet() {
		localVarQueryParams.Add("parent__n", parameterToString(localVarOptionals.ParentN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tenants.IsSet() {
		localVarQueryParams.Add("tenants", parameterToString(localVarOptionals.Tenants.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantsIsnull.IsSet() {
		localVarQueryParams.Add("tenants__isnull", parameterToString(localVarOptionals.TenantsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantsN.IsSet() {
		localVarQueryParams.Add("tenants__n", parameterToString(localVarOptionals.TenantsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedTenantGroupList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this tenant group.
 * @param optional nil or *TenancyApiTenancyTenantGroupsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type TenancyApiTenancyTenantGroupsNotesCreateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantGroupsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *TenancyApiTenancyTenantGroupsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tenant group.
 * @param optional nil or *TenancyApiTenancyTenantGroupsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type TenancyApiTenancyTenantGroupsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *TenancyApiService) TenancyTenantGroupsNotesList(ctx context.Context, id string, localVarOptionals *TenancyApiTenancyTenantGroupsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Partial update a tenant group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tenant group.
 * @param optional nil or *TenancyApiTenancyTenantGroupsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedTenantGroupRequest) - 
     * @param "Format" (optional.String) - 
@return TenantGroup
*/

type TenancyApiTenancyTenantGroupsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantGroupsPartialUpdate(ctx context.Context, id string, localVarOptionals *TenancyApiTenancyTenantGroupsPartialUpdateOpts) (TenantGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TenantGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TenantGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Retrieve a tenant group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tenant group.
 * @param optional nil or *TenancyApiTenancyTenantGroupsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return TenantGroup
*/

type TenancyApiTenancyTenantGroupsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *TenancyApiService) TenancyTenantGroupsRetrieve(ctx context.Context, id string, localVarOptionals *TenancyApiTenancyTenantGroupsRetrieveOpts) (TenantGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TenantGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TenantGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Update a tenant group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this tenant group.
 * @param optional nil or *TenancyApiTenancyTenantGroupsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return TenantGroup
*/

type TenancyApiTenancyTenantGroupsUpdateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantGroupsUpdate(ctx context.Context, body TenantGroupRequest, id string, localVarOptionals *TenancyApiTenancyTenantGroupsUpdateOpts) (TenantGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TenantGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenant-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TenantGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Destroy a list of tenant objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *TenancyApiTenancyTenantsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type TenancyApiTenancyTenantsBulkDestroyOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *TenancyApiTenancyTenantsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
TenancyApiService
Partial update a list of tenant objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *TenancyApiTenancyTenantsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Tenant
*/

type TenancyApiTenancyTenantsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableTenantRequest, localVarOptionals *TenancyApiTenancyTenantsBulkPartialUpdateOpts) ([]Tenant, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Tenant
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Tenant
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Update a list of tenant objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *TenancyApiTenancyTenantsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Tenant
*/

type TenancyApiTenancyTenantsBulkUpdateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantsBulkUpdate(ctx context.Context, body []BulkWritableTenantRequest, localVarOptionals *TenancyApiTenancyTenantsBulkUpdateOpts) ([]Tenant, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Tenant
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Tenant
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Create one or more tenant objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *TenancyApiTenancyTenantsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Tenant
*/

type TenancyApiTenancyTenantsCreateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantsCreate(ctx context.Context, body TenantRequest, localVarOptionals *TenancyApiTenancyTenantsCreateOpts) (Tenant, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tenant
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Tenant
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Destroy a tenant object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tenant.
 * @param optional nil or *TenancyApiTenancyTenantsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type TenancyApiTenancyTenantsDestroyOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantsDestroy(ctx context.Context, id string, localVarOptionals *TenancyApiTenancyTenantsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
TenancyApiService
Retrieve a list of tenant objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TenancyApiTenancyTenantsListOpts - Optional Parameters:
     * @param "Circuits" (optional.Interface of []string) -  Circuits (ID)
     * @param "CircuitsIsnull" (optional.Bool) - 
     * @param "CircuitsN" (optional.Interface of []string) -  Circuits (ID)
     * @param "Clusters" (optional.Interface of []string) - 
     * @param "ClustersIsnull" (optional.Bool) - 
     * @param "ClustersN" (optional.Interface of []string) - 
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Devices" (optional.Interface of []string) - 
     * @param "DevicesIsnull" (optional.Bool) - 
     * @param "DevicesN" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCircuits" (optional.Bool) -  Has circuits
     * @param "HasClusters" (optional.Bool) -  Has clusters
     * @param "HasDevices" (optional.Bool) -  Has devices
     * @param "HasIpAddresses" (optional.Bool) -  Has IP addresses
     * @param "HasLocations" (optional.Bool) -  Has locations
     * @param "HasPrefixes" (optional.Bool) -  Has prefixes
     * @param "HasRackReservations" (optional.Bool) -  Has rack reservations
     * @param "HasRacks" (optional.Bool) -  Has racks
     * @param "HasRouteTargets" (optional.Bool) -  Has route targets
     * @param "HasVirtualMachines" (optional.Bool) -  Has virtual machines
     * @param "HasVlans" (optional.Bool) -  Has VLANs
     * @param "HasVrfs" (optional.Bool) -  Has VRFs
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "IpAddresses" (optional.Interface of []string) -  IP addresses (ID)
     * @param "IpAddressesIsnull" (optional.Bool) - 
     * @param "IpAddressesN" (optional.Interface of []string) -  IP addresses (ID)
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Locations" (optional.Interface of []string) - 
     * @param "LocationsIsnull" (optional.Bool) - 
     * @param "LocationsN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Prefixes" (optional.Interface of []string) -  Prefixes (ID)
     * @param "PrefixesIsnull" (optional.Bool) - 
     * @param "PrefixesN" (optional.Interface of []string) -  Prefixes (ID)
     * @param "Q" (optional.String) -  Search
     * @param "RackReservations" (optional.Interface of []string) -  Rack reservations (ID)
     * @param "RackReservationsIsnull" (optional.Bool) - 
     * @param "RackReservationsN" (optional.Interface of []string) -  Rack reservations (ID)
     * @param "Racks" (optional.Interface of []string) - 
     * @param "RacksIsnull" (optional.Bool) - 
     * @param "RacksN" (optional.Interface of []string) - 
     * @param "RouteTargets" (optional.Interface of []string) - 
     * @param "RouteTargetsIsnull" (optional.Bool) - 
     * @param "RouteTargetsN" (optional.Interface of []string) - 
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "TenantGroup" (optional.Interface of []string) - 
     * @param "TenantGroupIsnull" (optional.Bool) - 
     * @param "TenantGroupN" (optional.Interface of []string) - 
     * @param "VirtualMachines" (optional.Interface of []string) - 
     * @param "VirtualMachinesIsnull" (optional.Bool) - 
     * @param "VirtualMachinesN" (optional.Interface of []string) - 
     * @param "Vlans" (optional.Interface of []string) -  VLANs (ID)
     * @param "VlansIsnull" (optional.Bool) - 
     * @param "VlansN" (optional.Interface of []string) -  VLANs (ID)
     * @param "Vrfs" (optional.Interface of []string) - 
     * @param "VrfsIsnull" (optional.Bool) - 
     * @param "VrfsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedTenantList
*/

type TenancyApiTenancyTenantsListOpts struct {
    Circuits optional.Interface
    CircuitsIsnull optional.Bool
    CircuitsN optional.Interface
    Clusters optional.Interface
    ClustersIsnull optional.Bool
    ClustersN optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Devices optional.Interface
    DevicesIsnull optional.Bool
    DevicesN optional.Interface
    Format optional.String
    HasCircuits optional.Bool
    HasClusters optional.Bool
    HasDevices optional.Bool
    HasIpAddresses optional.Bool
    HasLocations optional.Bool
    HasPrefixes optional.Bool
    HasRackReservations optional.Bool
    HasRacks optional.Bool
    HasRouteTargets optional.Bool
    HasVirtualMachines optional.Bool
    HasVlans optional.Bool
    HasVrfs optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    IpAddresses optional.Interface
    IpAddressesIsnull optional.Bool
    IpAddressesN optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Locations optional.Interface
    LocationsIsnull optional.Bool
    LocationsN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Prefixes optional.Interface
    PrefixesIsnull optional.Bool
    PrefixesN optional.Interface
    Q optional.String
    RackReservations optional.Interface
    RackReservationsIsnull optional.Bool
    RackReservationsN optional.Interface
    Racks optional.Interface
    RacksIsnull optional.Bool
    RacksN optional.Interface
    RouteTargets optional.Interface
    RouteTargetsIsnull optional.Bool
    RouteTargetsN optional.Interface
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    TenantGroup optional.Interface
    TenantGroupIsnull optional.Bool
    TenantGroupN optional.Interface
    VirtualMachines optional.Interface
    VirtualMachinesIsnull optional.Bool
    VirtualMachinesN optional.Interface
    Vlans optional.Interface
    VlansIsnull optional.Bool
    VlansN optional.Interface
    Vrfs optional.Interface
    VrfsIsnull optional.Bool
    VrfsN optional.Interface
    Depth optional.Int32
}

func (a *TenancyApiService) TenancyTenantsList(ctx context.Context, localVarOptionals *TenancyApiTenancyTenantsListOpts) (PaginatedTenantList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedTenantList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Circuits.IsSet() {
		localVarQueryParams.Add("circuits", parameterToString(localVarOptionals.Circuits.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitsIsnull.IsSet() {
		localVarQueryParams.Add("circuits__isnull", parameterToString(localVarOptionals.CircuitsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitsN.IsSet() {
		localVarQueryParams.Add("circuits__n", parameterToString(localVarOptionals.CircuitsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Clusters.IsSet() {
		localVarQueryParams.Add("clusters", parameterToString(localVarOptionals.Clusters.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ClustersIsnull.IsSet() {
		localVarQueryParams.Add("clusters__isnull", parameterToString(localVarOptionals.ClustersIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClustersN.IsSet() {
		localVarQueryParams.Add("clusters__n", parameterToString(localVarOptionals.ClustersN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarQueryParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesIsnull.IsSet() {
		localVarQueryParams.Add("devices__isnull", parameterToString(localVarOptionals.DevicesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesN.IsSet() {
		localVarQueryParams.Add("devices__n", parameterToString(localVarOptionals.DevicesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCircuits.IsSet() {
		localVarQueryParams.Add("has_circuits", parameterToString(localVarOptionals.HasCircuits.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasClusters.IsSet() {
		localVarQueryParams.Add("has_clusters", parameterToString(localVarOptionals.HasClusters.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasDevices.IsSet() {
		localVarQueryParams.Add("has_devices", parameterToString(localVarOptionals.HasDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasIpAddresses.IsSet() {
		localVarQueryParams.Add("has_ip_addresses", parameterToString(localVarOptionals.HasIpAddresses.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasLocations.IsSet() {
		localVarQueryParams.Add("has_locations", parameterToString(localVarOptionals.HasLocations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasPrefixes.IsSet() {
		localVarQueryParams.Add("has_prefixes", parameterToString(localVarOptionals.HasPrefixes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRackReservations.IsSet() {
		localVarQueryParams.Add("has_rack_reservations", parameterToString(localVarOptionals.HasRackReservations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRacks.IsSet() {
		localVarQueryParams.Add("has_racks", parameterToString(localVarOptionals.HasRacks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRouteTargets.IsSet() {
		localVarQueryParams.Add("has_route_targets", parameterToString(localVarOptionals.HasRouteTargets.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasVirtualMachines.IsSet() {
		localVarQueryParams.Add("has_virtual_machines", parameterToString(localVarOptionals.HasVirtualMachines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasVlans.IsSet() {
		localVarQueryParams.Add("has_vlans", parameterToString(localVarOptionals.HasVlans.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasVrfs.IsSet() {
		localVarQueryParams.Add("has_vrfs", parameterToString(localVarOptionals.HasVrfs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IpAddresses.IsSet() {
		localVarQueryParams.Add("ip_addresses", parameterToString(localVarOptionals.IpAddresses.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IpAddressesIsnull.IsSet() {
		localVarQueryParams.Add("ip_addresses__isnull", parameterToString(localVarOptionals.IpAddressesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpAddressesN.IsSet() {
		localVarQueryParams.Add("ip_addresses__n", parameterToString(localVarOptionals.IpAddressesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Locations.IsSet() {
		localVarQueryParams.Add("locations", parameterToString(localVarOptionals.Locations.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationsIsnull.IsSet() {
		localVarQueryParams.Add("locations__isnull", parameterToString(localVarOptionals.LocationsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationsN.IsSet() {
		localVarQueryParams.Add("locations__n", parameterToString(localVarOptionals.LocationsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Prefixes.IsSet() {
		localVarQueryParams.Add("prefixes", parameterToString(localVarOptionals.Prefixes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PrefixesIsnull.IsSet() {
		localVarQueryParams.Add("prefixes__isnull", parameterToString(localVarOptionals.PrefixesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrefixesN.IsSet() {
		localVarQueryParams.Add("prefixes__n", parameterToString(localVarOptionals.PrefixesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservations.IsSet() {
		localVarQueryParams.Add("rack_reservations", parameterToString(localVarOptionals.RackReservations.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservationsIsnull.IsSet() {
		localVarQueryParams.Add("rack_reservations__isnull", parameterToString(localVarOptionals.RackReservationsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservationsN.IsSet() {
		localVarQueryParams.Add("rack_reservations__n", parameterToString(localVarOptionals.RackReservationsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Racks.IsSet() {
		localVarQueryParams.Add("racks", parameterToString(localVarOptionals.Racks.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RacksIsnull.IsSet() {
		localVarQueryParams.Add("racks__isnull", parameterToString(localVarOptionals.RacksIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RacksN.IsSet() {
		localVarQueryParams.Add("racks__n", parameterToString(localVarOptionals.RacksN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RouteTargets.IsSet() {
		localVarQueryParams.Add("route_targets", parameterToString(localVarOptionals.RouteTargets.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RouteTargetsIsnull.IsSet() {
		localVarQueryParams.Add("route_targets__isnull", parameterToString(localVarOptionals.RouteTargetsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RouteTargetsN.IsSet() {
		localVarQueryParams.Add("route_targets__n", parameterToString(localVarOptionals.RouteTargetsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIsnull.IsSet() {
		localVarQueryParams.Add("tenant_group__isnull", parameterToString(localVarOptionals.TenantGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachines.IsSet() {
		localVarQueryParams.Add("virtual_machines", parameterToString(localVarOptionals.VirtualMachines.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachinesIsnull.IsSet() {
		localVarQueryParams.Add("virtual_machines__isnull", parameterToString(localVarOptionals.VirtualMachinesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualMachinesN.IsSet() {
		localVarQueryParams.Add("virtual_machines__n", parameterToString(localVarOptionals.VirtualMachinesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Vlans.IsSet() {
		localVarQueryParams.Add("vlans", parameterToString(localVarOptionals.Vlans.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VlansIsnull.IsSet() {
		localVarQueryParams.Add("vlans__isnull", parameterToString(localVarOptionals.VlansIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlansN.IsSet() {
		localVarQueryParams.Add("vlans__n", parameterToString(localVarOptionals.VlansN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Vrfs.IsSet() {
		localVarQueryParams.Add("vrfs", parameterToString(localVarOptionals.Vrfs.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.VrfsIsnull.IsSet() {
		localVarQueryParams.Add("vrfs__isnull", parameterToString(localVarOptionals.VrfsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfsN.IsSet() {
		localVarQueryParams.Add("vrfs__n", parameterToString(localVarOptionals.VrfsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedTenantList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this tenant.
 * @param optional nil or *TenancyApiTenancyTenantsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type TenancyApiTenancyTenantsNotesCreateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *TenancyApiTenancyTenantsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tenant.
 * @param optional nil or *TenancyApiTenancyTenantsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type TenancyApiTenancyTenantsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *TenancyApiService) TenancyTenantsNotesList(ctx context.Context, id string, localVarOptionals *TenancyApiTenancyTenantsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Partial update a tenant object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tenant.
 * @param optional nil or *TenancyApiTenancyTenantsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedTenantRequest) - 
     * @param "Format" (optional.String) - 
@return Tenant
*/

type TenancyApiTenancyTenantsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantsPartialUpdate(ctx context.Context, id string, localVarOptionals *TenancyApiTenancyTenantsPartialUpdateOpts) (Tenant, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tenant
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Tenant
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Retrieve a tenant object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this tenant.
 * @param optional nil or *TenancyApiTenancyTenantsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Tenant
*/

type TenancyApiTenancyTenantsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *TenancyApiService) TenancyTenantsRetrieve(ctx context.Context, id string, localVarOptionals *TenancyApiTenancyTenantsRetrieveOpts) (Tenant, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tenant
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Tenant
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TenancyApiService
Update a tenant object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this tenant.
 * @param optional nil or *TenancyApiTenancyTenantsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Tenant
*/

type TenancyApiTenancyTenantsUpdateOpts struct {
    Format optional.String
}

func (a *TenancyApiService) TenancyTenantsUpdate(ctx context.Context, body TenantRequest, id string, localVarOptionals *TenancyApiTenancyTenantsUpdateOpts) (Tenant, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tenant
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tenancy/tenants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Tenant
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
