
/*
 * API Documentation
 *
 * Source of truth and network automation platform
 *
 * API version: 2.2.5 (2.2)
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package go-nautobot

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type UsersApiService service
/*
UsersApiService
Return the config_data for the currently authenticated User.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *UsersApiUsersConfigRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return map[string]Object
*/

type UsersApiUsersConfigRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *UsersApiService) UsersConfigRetrieve(ctx context.Context, localVarOptionals *UsersApiUsersConfigRetrieveOpts) (map[string]Object, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]Object
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/config/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]Object
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Destroy a list of group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersGroupsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type UsersApiUsersGroupsBulkDestroyOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersGroupsBulkDestroy(ctx context.Context, body []BulkOperationIntegerIdRequest, localVarOptionals *UsersApiUsersGroupsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
UsersApiService
Partial update a list of group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersGroupsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Group
*/

type UsersApiUsersGroupsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersGroupsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableGroupRequest, localVarOptionals *UsersApiUsersGroupsBulkPartialUpdateOpts) ([]Group, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Group
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Group
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Update a list of group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersGroupsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Group
*/

type UsersApiUsersGroupsBulkUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersGroupsBulkUpdate(ctx context.Context, body []BulkWritableGroupRequest, localVarOptionals *UsersApiUsersGroupsBulkUpdateOpts) ([]Group, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Group
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Group
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Create one or more group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersGroupsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Group
*/

type UsersApiUsersGroupsCreateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersGroupsCreate(ctx context.Context, body GroupRequest, localVarOptionals *UsersApiUsersGroupsCreateOpts) (Group, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Group
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Group
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Destroy a group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this group.
 * @param optional nil or *UsersApiUsersGroupsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type UsersApiUsersGroupsDestroyOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersGroupsDestroy(ctx context.Context, id int32, localVarOptionals *UsersApiUsersGroupsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
UsersApiService
Retrieve a list of group objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *UsersApiUsersGroupsListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []int32) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdGt" (optional.Interface of []int32) - 
     * @param "IdGte" (optional.Interface of []int32) - 
     * @param "IdLt" (optional.Interface of []int32) - 
     * @param "IdLte" (optional.Interface of []int32) - 
     * @param "IdN" (optional.Interface of []int32) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedGroupList
*/

type UsersApiUsersGroupsListOpts struct {
    Format optional.String
    Id optional.Interface
    IdGt optional.Interface
    IdGte optional.Interface
    IdLt optional.Interface
    IdLte optional.Interface
    IdN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *UsersApiService) UsersGroupsList(ctx context.Context, localVarOptionals *UsersApiUsersGroupsListOpts) (PaginatedGroupList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedGroupList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdGt.IsSet() {
		localVarQueryParams.Add("id__gt", parameterToString(localVarOptionals.IdGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdGte.IsSet() {
		localVarQueryParams.Add("id__gte", parameterToString(localVarOptionals.IdGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdLt.IsSet() {
		localVarQueryParams.Add("id__lt", parameterToString(localVarOptionals.IdLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdLte.IsSet() {
		localVarQueryParams.Add("id__lte", parameterToString(localVarOptionals.IdLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedGroupList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Partial update a group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this group.
 * @param optional nil or *UsersApiUsersGroupsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedGroupRequest) - 
     * @param "Format" (optional.String) - 
@return Group
*/

type UsersApiUsersGroupsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *UsersApiService) UsersGroupsPartialUpdate(ctx context.Context, id int32, localVarOptionals *UsersApiUsersGroupsPartialUpdateOpts) (Group, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Group
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Group
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Retrieve a group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this group.
 * @param optional nil or *UsersApiUsersGroupsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Group
*/

type UsersApiUsersGroupsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *UsersApiService) UsersGroupsRetrieve(ctx context.Context, id int32, localVarOptionals *UsersApiUsersGroupsRetrieveOpts) (Group, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Group
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Group
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Update a group object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A unique integer value identifying this group.
 * @param optional nil or *UsersApiUsersGroupsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Group
*/

type UsersApiUsersGroupsUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersGroupsUpdate(ctx context.Context, body GroupRequest, id int32, localVarOptionals *UsersApiUsersGroupsUpdateOpts) (Group, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Group
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Group
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Destroy a list of permission objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersPermissionsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type UsersApiUsersPermissionsBulkDestroyOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersPermissionsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *UsersApiUsersPermissionsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
UsersApiService
Partial update a list of permission objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersPermissionsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ObjectPermission
*/

type UsersApiUsersPermissionsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersPermissionsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableObjectPermissionRequest, localVarOptionals *UsersApiUsersPermissionsBulkPartialUpdateOpts) ([]ObjectPermission, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ObjectPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ObjectPermission
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Update a list of permission objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersPermissionsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ObjectPermission
*/

type UsersApiUsersPermissionsBulkUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersPermissionsBulkUpdate(ctx context.Context, body []BulkWritableObjectPermissionRequest, localVarOptionals *UsersApiUsersPermissionsBulkUpdateOpts) ([]ObjectPermission, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ObjectPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ObjectPermission
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Create one or more permission objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersPermissionsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ObjectPermission
*/

type UsersApiUsersPermissionsCreateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersPermissionsCreate(ctx context.Context, body ObjectPermissionRequest, localVarOptionals *UsersApiUsersPermissionsCreateOpts) (ObjectPermission, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ObjectPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ObjectPermission
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Destroy a permission object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this permission.
 * @param optional nil or *UsersApiUsersPermissionsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type UsersApiUsersPermissionsDestroyOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersPermissionsDestroy(ctx context.Context, id string, localVarOptionals *UsersApiUsersPermissionsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
UsersApiService
Retrieve a list of permission objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *UsersApiUsersPermissionsListOpts - Optional Parameters:
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Enabled" (optional.Bool) - 
     * @param "Format" (optional.String) - 
     * @param "Groups" (optional.Interface of []string) -  Group (name)
     * @param "GroupsN" (optional.Interface of []string) -  Group (name)
     * @param "GroupsId" (optional.Interface of []int32) -  Group (ID)
     * @param "GroupsIdN" (optional.Interface of []int32) -  Group (ID)
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "ObjectTypes" (optional.Interface of []int32) - 
     * @param "ObjectTypesN" (optional.Interface of []int32) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Users" (optional.Interface of []string) - 
     * @param "UsersN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedObjectPermissionList
*/

type UsersApiUsersPermissionsListOpts struct {
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Enabled optional.Bool
    Format optional.String
    Groups optional.Interface
    GroupsN optional.Interface
    GroupsId optional.Interface
    GroupsIdN optional.Interface
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    ObjectTypes optional.Interface
    ObjectTypesN optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Users optional.Interface
    UsersN optional.Interface
    Depth optional.Int32
}

func (a *UsersApiService) UsersPermissionsList(ctx context.Context, localVarOptionals *UsersApiUsersPermissionsListOpts) (PaginatedObjectPermissionList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedObjectPermissionList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarQueryParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupsN.IsSet() {
		localVarQueryParams.Add("groups__n", parameterToString(localVarOptionals.GroupsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupsId.IsSet() {
		localVarQueryParams.Add("groups_id", parameterToString(localVarOptionals.GroupsId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupsIdN.IsSet() {
		localVarQueryParams.Add("groups_id__n", parameterToString(localVarOptionals.GroupsIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectTypes.IsSet() {
		localVarQueryParams.Add("object_types", parameterToString(localVarOptionals.ObjectTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectTypesN.IsSet() {
		localVarQueryParams.Add("object_types__n", parameterToString(localVarOptionals.ObjectTypesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Users.IsSet() {
		localVarQueryParams.Add("users", parameterToString(localVarOptionals.Users.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsersN.IsSet() {
		localVarQueryParams.Add("users__n", parameterToString(localVarOptionals.UsersN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedObjectPermissionList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Partial update a permission object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this permission.
 * @param optional nil or *UsersApiUsersPermissionsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedObjectPermissionRequest) - 
     * @param "Format" (optional.String) - 
@return ObjectPermission
*/

type UsersApiUsersPermissionsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *UsersApiService) UsersPermissionsPartialUpdate(ctx context.Context, id string, localVarOptionals *UsersApiUsersPermissionsPartialUpdateOpts) (ObjectPermission, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ObjectPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ObjectPermission
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Retrieve a permission object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this permission.
 * @param optional nil or *UsersApiUsersPermissionsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ObjectPermission
*/

type UsersApiUsersPermissionsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *UsersApiService) UsersPermissionsRetrieve(ctx context.Context, id string, localVarOptionals *UsersApiUsersPermissionsRetrieveOpts) (ObjectPermission, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ObjectPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ObjectPermission
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Update a permission object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this permission.
 * @param optional nil or *UsersApiUsersPermissionsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ObjectPermission
*/

type UsersApiUsersPermissionsUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersPermissionsUpdate(ctx context.Context, body ObjectPermissionRequest, id string, localVarOptionals *UsersApiUsersPermissionsUpdateOpts) (ObjectPermission, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ObjectPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ObjectPermission
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Destroy a list of token objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersTokensBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type UsersApiUsersTokensBulkDestroyOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersTokensBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *UsersApiUsersTokensBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
UsersApiService
Partial update a list of token objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersTokensBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Token
*/

type UsersApiUsersTokensBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersTokensBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableTokenRequest, localVarOptionals *UsersApiUsersTokensBulkPartialUpdateOpts) ([]Token, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Token
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Token
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Update a list of token objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersTokensBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Token
*/

type UsersApiUsersTokensBulkUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersTokensBulkUpdate(ctx context.Context, body []BulkWritableTokenRequest, localVarOptionals *UsersApiUsersTokensBulkUpdateOpts) ([]Token, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Token
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Token
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Create one or more token objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *UsersApiUsersTokensCreateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of TokenRequest) - 
     * @param "Format" (optional.String) - 
@return Token
*/

type UsersApiUsersTokensCreateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *UsersApiService) UsersTokensCreate(ctx context.Context, localVarOptionals *UsersApiUsersTokensCreateOpts) (Token, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Token
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Token
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Destroy a token object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this token.
 * @param optional nil or *UsersApiUsersTokensDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type UsersApiUsersTokensDestroyOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersTokensDestroy(ctx context.Context, id string, localVarOptionals *UsersApiUsersTokensDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
UsersApiService
Retrieve a list of token objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *UsersApiUsersTokensListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Expires" (optional.Interface of []time.Time) - 
     * @param "ExpiresGt" (optional.Interface of []time.Time) - 
     * @param "ExpiresGte" (optional.Interface of []time.Time) - 
     * @param "ExpiresIsnull" (optional.Bool) - 
     * @param "ExpiresLt" (optional.Interface of []time.Time) - 
     * @param "ExpiresLte" (optional.Interface of []time.Time) - 
     * @param "ExpiresN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Key" (optional.Interface of []string) - 
     * @param "KeyIc" (optional.Interface of []string) - 
     * @param "KeyIe" (optional.Interface of []string) - 
     * @param "KeyIew" (optional.Interface of []string) - 
     * @param "KeyIre" (optional.Interface of []string) - 
     * @param "KeyIsw" (optional.Interface of []string) - 
     * @param "KeyN" (optional.Interface of []string) - 
     * @param "KeyNic" (optional.Interface of []string) - 
     * @param "KeyNie" (optional.Interface of []string) - 
     * @param "KeyNiew" (optional.Interface of []string) - 
     * @param "KeyNire" (optional.Interface of []string) - 
     * @param "KeyNisw" (optional.Interface of []string) - 
     * @param "KeyNre" (optional.Interface of []string) - 
     * @param "KeyRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "WriteEnabled" (optional.Bool) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedTokenList
*/

type UsersApiUsersTokensListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Expires optional.Interface
    ExpiresGt optional.Interface
    ExpiresGte optional.Interface
    ExpiresIsnull optional.Bool
    ExpiresLt optional.Interface
    ExpiresLte optional.Interface
    ExpiresN optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Key optional.Interface
    KeyIc optional.Interface
    KeyIe optional.Interface
    KeyIew optional.Interface
    KeyIre optional.Interface
    KeyIsw optional.Interface
    KeyN optional.Interface
    KeyNic optional.Interface
    KeyNie optional.Interface
    KeyNiew optional.Interface
    KeyNire optional.Interface
    KeyNisw optional.Interface
    KeyNre optional.Interface
    KeyRe optional.Interface
    Limit optional.Int32
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    WriteEnabled optional.Bool
    Depth optional.Int32
}

func (a *UsersApiService) UsersTokensList(ctx context.Context, localVarOptionals *UsersApiUsersTokensListOpts) (PaginatedTokenList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedTokenList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Expires.IsSet() {
		localVarQueryParams.Add("expires", parameterToString(localVarOptionals.Expires.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExpiresGt.IsSet() {
		localVarQueryParams.Add("expires__gt", parameterToString(localVarOptionals.ExpiresGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExpiresGte.IsSet() {
		localVarQueryParams.Add("expires__gte", parameterToString(localVarOptionals.ExpiresGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExpiresIsnull.IsSet() {
		localVarQueryParams.Add("expires__isnull", parameterToString(localVarOptionals.ExpiresIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExpiresLt.IsSet() {
		localVarQueryParams.Add("expires__lt", parameterToString(localVarOptionals.ExpiresLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExpiresLte.IsSet() {
		localVarQueryParams.Add("expires__lte", parameterToString(localVarOptionals.ExpiresLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExpiresN.IsSet() {
		localVarQueryParams.Add("expires__n", parameterToString(localVarOptionals.ExpiresN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Key.IsSet() {
		localVarQueryParams.Add("key", parameterToString(localVarOptionals.Key.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIc.IsSet() {
		localVarQueryParams.Add("key__ic", parameterToString(localVarOptionals.KeyIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIe.IsSet() {
		localVarQueryParams.Add("key__ie", parameterToString(localVarOptionals.KeyIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIew.IsSet() {
		localVarQueryParams.Add("key__iew", parameterToString(localVarOptionals.KeyIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIre.IsSet() {
		localVarQueryParams.Add("key__ire", parameterToString(localVarOptionals.KeyIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyIsw.IsSet() {
		localVarQueryParams.Add("key__isw", parameterToString(localVarOptionals.KeyIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyN.IsSet() {
		localVarQueryParams.Add("key__n", parameterToString(localVarOptionals.KeyN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNic.IsSet() {
		localVarQueryParams.Add("key__nic", parameterToString(localVarOptionals.KeyNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNie.IsSet() {
		localVarQueryParams.Add("key__nie", parameterToString(localVarOptionals.KeyNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNiew.IsSet() {
		localVarQueryParams.Add("key__niew", parameterToString(localVarOptionals.KeyNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNire.IsSet() {
		localVarQueryParams.Add("key__nire", parameterToString(localVarOptionals.KeyNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNisw.IsSet() {
		localVarQueryParams.Add("key__nisw", parameterToString(localVarOptionals.KeyNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyNre.IsSet() {
		localVarQueryParams.Add("key__nre", parameterToString(localVarOptionals.KeyNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.KeyRe.IsSet() {
		localVarQueryParams.Add("key__re", parameterToString(localVarOptionals.KeyRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WriteEnabled.IsSet() {
		localVarQueryParams.Add("write_enabled", parameterToString(localVarOptionals.WriteEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedTokenList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Partial update a token object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this token.
 * @param optional nil or *UsersApiUsersTokensPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedTokenRequest) - 
     * @param "Format" (optional.String) - 
@return Token
*/

type UsersApiUsersTokensPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *UsersApiService) UsersTokensPartialUpdate(ctx context.Context, id string, localVarOptionals *UsersApiUsersTokensPartialUpdateOpts) (Token, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Token
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Token
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Retrieve a token object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this token.
 * @param optional nil or *UsersApiUsersTokensRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Token
*/

type UsersApiUsersTokensRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *UsersApiService) UsersTokensRetrieve(ctx context.Context, id string, localVarOptionals *UsersApiUsersTokensRetrieveOpts) (Token, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Token
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Token
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Update a token object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this token.
 * @param optional nil or *UsersApiUsersTokensUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of TokenRequest) - 
     * @param "Format" (optional.String) - 
@return Token
*/

type UsersApiUsersTokensUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *UsersApiService) UsersTokensUpdate(ctx context.Context, id string, localVarOptionals *UsersApiUsersTokensUpdateOpts) (Token, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Token
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Token
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Destroy a list of user objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersUsersBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type UsersApiUsersUsersBulkDestroyOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersUsersBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *UsersApiUsersUsersBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
UsersApiService
Partial update a list of user objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersUsersBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []User
*/

type UsersApiUsersUsersBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersUsersBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableUserRequest, localVarOptionals *UsersApiUsersUsersBulkPartialUpdateOpts) ([]User, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []User
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []User
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Update a list of user objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersUsersBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []User
*/

type UsersApiUsersUsersBulkUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersUsersBulkUpdate(ctx context.Context, body []BulkWritableUserRequest, localVarOptionals *UsersApiUsersUsersBulkUpdateOpts) ([]User, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []User
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []User
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Create one or more user objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *UsersApiUsersUsersCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return User
*/

type UsersApiUsersUsersCreateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersUsersCreate(ctx context.Context, body UserRequest, localVarOptionals *UsersApiUsersUsersCreateOpts) (User, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue User
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v User
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Destroy a user object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this user.
 * @param optional nil or *UsersApiUsersUsersDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type UsersApiUsersUsersDestroyOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersUsersDestroy(ctx context.Context, id string, localVarOptionals *UsersApiUsersUsersDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
UsersApiService
Retrieve a list of user objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *UsersApiUsersUsersListOpts - Optional Parameters:
     * @param "Email" (optional.Interface of []string) - 
     * @param "EmailIc" (optional.Interface of []string) - 
     * @param "EmailIe" (optional.Interface of []string) - 
     * @param "EmailIew" (optional.Interface of []string) - 
     * @param "EmailIre" (optional.Interface of []string) - 
     * @param "EmailIsw" (optional.Interface of []string) - 
     * @param "EmailN" (optional.Interface of []string) - 
     * @param "EmailNic" (optional.Interface of []string) - 
     * @param "EmailNie" (optional.Interface of []string) - 
     * @param "EmailNiew" (optional.Interface of []string) - 
     * @param "EmailNire" (optional.Interface of []string) - 
     * @param "EmailNisw" (optional.Interface of []string) - 
     * @param "EmailNre" (optional.Interface of []string) - 
     * @param "EmailRe" (optional.Interface of []string) - 
     * @param "FirstName" (optional.Interface of []string) - 
     * @param "FirstNameIc" (optional.Interface of []string) - 
     * @param "FirstNameIe" (optional.Interface of []string) - 
     * @param "FirstNameIew" (optional.Interface of []string) - 
     * @param "FirstNameIre" (optional.Interface of []string) - 
     * @param "FirstNameIsw" (optional.Interface of []string) - 
     * @param "FirstNameN" (optional.Interface of []string) - 
     * @param "FirstNameNic" (optional.Interface of []string) - 
     * @param "FirstNameNie" (optional.Interface of []string) - 
     * @param "FirstNameNiew" (optional.Interface of []string) - 
     * @param "FirstNameNire" (optional.Interface of []string) - 
     * @param "FirstNameNisw" (optional.Interface of []string) - 
     * @param "FirstNameNre" (optional.Interface of []string) - 
     * @param "FirstNameRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Groups" (optional.Interface of []string) -  Group (name)
     * @param "GroupsN" (optional.Interface of []string) -  Group (name)
     * @param "GroupsId" (optional.Interface of []int32) -  Group (ID)
     * @param "GroupsIdN" (optional.Interface of []int32) -  Group (ID)
     * @param "HasObjectChanges" (optional.Bool) -  Has Changes
     * @param "HasObjectPermissions" (optional.Bool) -  Has object permissions
     * @param "HasRackReservations" (optional.Bool) -  Has Rack Reservations
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "IsActive" (optional.Bool) - 
     * @param "IsStaff" (optional.Bool) - 
     * @param "LastName" (optional.Interface of []string) - 
     * @param "LastNameIc" (optional.Interface of []string) - 
     * @param "LastNameIe" (optional.Interface of []string) - 
     * @param "LastNameIew" (optional.Interface of []string) - 
     * @param "LastNameIre" (optional.Interface of []string) - 
     * @param "LastNameIsw" (optional.Interface of []string) - 
     * @param "LastNameN" (optional.Interface of []string) - 
     * @param "LastNameNic" (optional.Interface of []string) - 
     * @param "LastNameNie" (optional.Interface of []string) - 
     * @param "LastNameNiew" (optional.Interface of []string) - 
     * @param "LastNameNire" (optional.Interface of []string) - 
     * @param "LastNameNisw" (optional.Interface of []string) - 
     * @param "LastNameNre" (optional.Interface of []string) - 
     * @param "LastNameRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "ObjectChanges" (optional.Interface of []string) -  Object Changes (ID)
     * @param "ObjectChangesIsnull" (optional.Bool) - 
     * @param "ObjectChangesN" (optional.Interface of []string) -  Object Changes (ID)
     * @param "ObjectPermissions" (optional.Interface of []string) - 
     * @param "ObjectPermissionsIsnull" (optional.Bool) - 
     * @param "ObjectPermissionsN" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "RackReservationsId" (optional.Interface of []string) -  Rack Reservation (ID)
     * @param "RackReservationsIdIsnull" (optional.Bool) - 
     * @param "RackReservationsIdN" (optional.Interface of []string) -  Rack Reservation (ID)
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Username" (optional.Interface of []string) - 
     * @param "UsernameIc" (optional.Interface of []string) - 
     * @param "UsernameIe" (optional.Interface of []string) - 
     * @param "UsernameIew" (optional.Interface of []string) - 
     * @param "UsernameIre" (optional.Interface of []string) - 
     * @param "UsernameIsw" (optional.Interface of []string) - 
     * @param "UsernameN" (optional.Interface of []string) - 
     * @param "UsernameNic" (optional.Interface of []string) - 
     * @param "UsernameNie" (optional.Interface of []string) - 
     * @param "UsernameNiew" (optional.Interface of []string) - 
     * @param "UsernameNire" (optional.Interface of []string) - 
     * @param "UsernameNisw" (optional.Interface of []string) - 
     * @param "UsernameNre" (optional.Interface of []string) - 
     * @param "UsernameRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedUserList
*/

type UsersApiUsersUsersListOpts struct {
    Email optional.Interface
    EmailIc optional.Interface
    EmailIe optional.Interface
    EmailIew optional.Interface
    EmailIre optional.Interface
    EmailIsw optional.Interface
    EmailN optional.Interface
    EmailNic optional.Interface
    EmailNie optional.Interface
    EmailNiew optional.Interface
    EmailNire optional.Interface
    EmailNisw optional.Interface
    EmailNre optional.Interface
    EmailRe optional.Interface
    FirstName optional.Interface
    FirstNameIc optional.Interface
    FirstNameIe optional.Interface
    FirstNameIew optional.Interface
    FirstNameIre optional.Interface
    FirstNameIsw optional.Interface
    FirstNameN optional.Interface
    FirstNameNic optional.Interface
    FirstNameNie optional.Interface
    FirstNameNiew optional.Interface
    FirstNameNire optional.Interface
    FirstNameNisw optional.Interface
    FirstNameNre optional.Interface
    FirstNameRe optional.Interface
    Format optional.String
    Groups optional.Interface
    GroupsN optional.Interface
    GroupsId optional.Interface
    GroupsIdN optional.Interface
    HasObjectChanges optional.Bool
    HasObjectPermissions optional.Bool
    HasRackReservations optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    IsActive optional.Bool
    IsStaff optional.Bool
    LastName optional.Interface
    LastNameIc optional.Interface
    LastNameIe optional.Interface
    LastNameIew optional.Interface
    LastNameIre optional.Interface
    LastNameIsw optional.Interface
    LastNameN optional.Interface
    LastNameNic optional.Interface
    LastNameNie optional.Interface
    LastNameNiew optional.Interface
    LastNameNire optional.Interface
    LastNameNisw optional.Interface
    LastNameNre optional.Interface
    LastNameRe optional.Interface
    Limit optional.Int32
    ObjectChanges optional.Interface
    ObjectChangesIsnull optional.Bool
    ObjectChangesN optional.Interface
    ObjectPermissions optional.Interface
    ObjectPermissionsIsnull optional.Bool
    ObjectPermissionsN optional.Interface
    Offset optional.Int32
    Q optional.String
    RackReservationsId optional.Interface
    RackReservationsIdIsnull optional.Bool
    RackReservationsIdN optional.Interface
    Sort optional.String
    Username optional.Interface
    UsernameIc optional.Interface
    UsernameIe optional.Interface
    UsernameIew optional.Interface
    UsernameIre optional.Interface
    UsernameIsw optional.Interface
    UsernameN optional.Interface
    UsernameNic optional.Interface
    UsernameNie optional.Interface
    UsernameNiew optional.Interface
    UsernameNire optional.Interface
    UsernameNisw optional.Interface
    UsernameNre optional.Interface
    UsernameRe optional.Interface
    Depth optional.Int32
}

func (a *UsersApiService) UsersUsersList(ctx context.Context, localVarOptionals *UsersApiUsersUsersListOpts) (PaginatedUserList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedUserList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarQueryParams.Add("email", parameterToString(localVarOptionals.Email.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIc.IsSet() {
		localVarQueryParams.Add("email__ic", parameterToString(localVarOptionals.EmailIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIe.IsSet() {
		localVarQueryParams.Add("email__ie", parameterToString(localVarOptionals.EmailIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIew.IsSet() {
		localVarQueryParams.Add("email__iew", parameterToString(localVarOptionals.EmailIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIre.IsSet() {
		localVarQueryParams.Add("email__ire", parameterToString(localVarOptionals.EmailIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailIsw.IsSet() {
		localVarQueryParams.Add("email__isw", parameterToString(localVarOptionals.EmailIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailN.IsSet() {
		localVarQueryParams.Add("email__n", parameterToString(localVarOptionals.EmailN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNic.IsSet() {
		localVarQueryParams.Add("email__nic", parameterToString(localVarOptionals.EmailNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNie.IsSet() {
		localVarQueryParams.Add("email__nie", parameterToString(localVarOptionals.EmailNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNiew.IsSet() {
		localVarQueryParams.Add("email__niew", parameterToString(localVarOptionals.EmailNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNire.IsSet() {
		localVarQueryParams.Add("email__nire", parameterToString(localVarOptionals.EmailNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNisw.IsSet() {
		localVarQueryParams.Add("email__nisw", parameterToString(localVarOptionals.EmailNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailNre.IsSet() {
		localVarQueryParams.Add("email__nre", parameterToString(localVarOptionals.EmailNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.EmailRe.IsSet() {
		localVarQueryParams.Add("email__re", parameterToString(localVarOptionals.EmailRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstName.IsSet() {
		localVarQueryParams.Add("first_name", parameterToString(localVarOptionals.FirstName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameIc.IsSet() {
		localVarQueryParams.Add("first_name__ic", parameterToString(localVarOptionals.FirstNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameIe.IsSet() {
		localVarQueryParams.Add("first_name__ie", parameterToString(localVarOptionals.FirstNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameIew.IsSet() {
		localVarQueryParams.Add("first_name__iew", parameterToString(localVarOptionals.FirstNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameIre.IsSet() {
		localVarQueryParams.Add("first_name__ire", parameterToString(localVarOptionals.FirstNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameIsw.IsSet() {
		localVarQueryParams.Add("first_name__isw", parameterToString(localVarOptionals.FirstNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameN.IsSet() {
		localVarQueryParams.Add("first_name__n", parameterToString(localVarOptionals.FirstNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameNic.IsSet() {
		localVarQueryParams.Add("first_name__nic", parameterToString(localVarOptionals.FirstNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameNie.IsSet() {
		localVarQueryParams.Add("first_name__nie", parameterToString(localVarOptionals.FirstNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameNiew.IsSet() {
		localVarQueryParams.Add("first_name__niew", parameterToString(localVarOptionals.FirstNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameNire.IsSet() {
		localVarQueryParams.Add("first_name__nire", parameterToString(localVarOptionals.FirstNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameNisw.IsSet() {
		localVarQueryParams.Add("first_name__nisw", parameterToString(localVarOptionals.FirstNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameNre.IsSet() {
		localVarQueryParams.Add("first_name__nre", parameterToString(localVarOptionals.FirstNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.FirstNameRe.IsSet() {
		localVarQueryParams.Add("first_name__re", parameterToString(localVarOptionals.FirstNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarQueryParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupsN.IsSet() {
		localVarQueryParams.Add("groups__n", parameterToString(localVarOptionals.GroupsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupsId.IsSet() {
		localVarQueryParams.Add("groups_id", parameterToString(localVarOptionals.GroupsId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.GroupsIdN.IsSet() {
		localVarQueryParams.Add("groups_id__n", parameterToString(localVarOptionals.GroupsIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.HasObjectChanges.IsSet() {
		localVarQueryParams.Add("has_object_changes", parameterToString(localVarOptionals.HasObjectChanges.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasObjectPermissions.IsSet() {
		localVarQueryParams.Add("has_object_permissions", parameterToString(localVarOptionals.HasObjectPermissions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasRackReservations.IsSet() {
		localVarQueryParams.Add("has_rack_reservations", parameterToString(localVarOptionals.HasRackReservations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsActive.IsSet() {
		localVarQueryParams.Add("is_active", parameterToString(localVarOptionals.IsActive.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsStaff.IsSet() {
		localVarQueryParams.Add("is_staff", parameterToString(localVarOptionals.IsStaff.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastName.IsSet() {
		localVarQueryParams.Add("last_name", parameterToString(localVarOptionals.LastName.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameIc.IsSet() {
		localVarQueryParams.Add("last_name__ic", parameterToString(localVarOptionals.LastNameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameIe.IsSet() {
		localVarQueryParams.Add("last_name__ie", parameterToString(localVarOptionals.LastNameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameIew.IsSet() {
		localVarQueryParams.Add("last_name__iew", parameterToString(localVarOptionals.LastNameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameIre.IsSet() {
		localVarQueryParams.Add("last_name__ire", parameterToString(localVarOptionals.LastNameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameIsw.IsSet() {
		localVarQueryParams.Add("last_name__isw", parameterToString(localVarOptionals.LastNameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameN.IsSet() {
		localVarQueryParams.Add("last_name__n", parameterToString(localVarOptionals.LastNameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameNic.IsSet() {
		localVarQueryParams.Add("last_name__nic", parameterToString(localVarOptionals.LastNameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameNie.IsSet() {
		localVarQueryParams.Add("last_name__nie", parameterToString(localVarOptionals.LastNameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameNiew.IsSet() {
		localVarQueryParams.Add("last_name__niew", parameterToString(localVarOptionals.LastNameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameNire.IsSet() {
		localVarQueryParams.Add("last_name__nire", parameterToString(localVarOptionals.LastNameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameNisw.IsSet() {
		localVarQueryParams.Add("last_name__nisw", parameterToString(localVarOptionals.LastNameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameNre.IsSet() {
		localVarQueryParams.Add("last_name__nre", parameterToString(localVarOptionals.LastNameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastNameRe.IsSet() {
		localVarQueryParams.Add("last_name__re", parameterToString(localVarOptionals.LastNameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectChanges.IsSet() {
		localVarQueryParams.Add("object_changes", parameterToString(localVarOptionals.ObjectChanges.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectChangesIsnull.IsSet() {
		localVarQueryParams.Add("object_changes__isnull", parameterToString(localVarOptionals.ObjectChangesIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectChangesN.IsSet() {
		localVarQueryParams.Add("object_changes__n", parameterToString(localVarOptionals.ObjectChangesN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectPermissions.IsSet() {
		localVarQueryParams.Add("object_permissions", parameterToString(localVarOptionals.ObjectPermissions.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectPermissionsIsnull.IsSet() {
		localVarQueryParams.Add("object_permissions__isnull", parameterToString(localVarOptionals.ObjectPermissionsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectPermissionsN.IsSet() {
		localVarQueryParams.Add("object_permissions__n", parameterToString(localVarOptionals.ObjectPermissionsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservationsId.IsSet() {
		localVarQueryParams.Add("rack_reservations_id", parameterToString(localVarOptionals.RackReservationsId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservationsIdIsnull.IsSet() {
		localVarQueryParams.Add("rack_reservations_id__isnull", parameterToString(localVarOptionals.RackReservationsIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackReservationsIdN.IsSet() {
		localVarQueryParams.Add("rack_reservations_id__n", parameterToString(localVarOptionals.RackReservationsIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Username.IsSet() {
		localVarQueryParams.Add("username", parameterToString(localVarOptionals.Username.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameIc.IsSet() {
		localVarQueryParams.Add("username__ic", parameterToString(localVarOptionals.UsernameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameIe.IsSet() {
		localVarQueryParams.Add("username__ie", parameterToString(localVarOptionals.UsernameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameIew.IsSet() {
		localVarQueryParams.Add("username__iew", parameterToString(localVarOptionals.UsernameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameIre.IsSet() {
		localVarQueryParams.Add("username__ire", parameterToString(localVarOptionals.UsernameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameIsw.IsSet() {
		localVarQueryParams.Add("username__isw", parameterToString(localVarOptionals.UsernameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameN.IsSet() {
		localVarQueryParams.Add("username__n", parameterToString(localVarOptionals.UsernameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameNic.IsSet() {
		localVarQueryParams.Add("username__nic", parameterToString(localVarOptionals.UsernameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameNie.IsSet() {
		localVarQueryParams.Add("username__nie", parameterToString(localVarOptionals.UsernameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameNiew.IsSet() {
		localVarQueryParams.Add("username__niew", parameterToString(localVarOptionals.UsernameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameNire.IsSet() {
		localVarQueryParams.Add("username__nire", parameterToString(localVarOptionals.UsernameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameNisw.IsSet() {
		localVarQueryParams.Add("username__nisw", parameterToString(localVarOptionals.UsernameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameNre.IsSet() {
		localVarQueryParams.Add("username__nre", parameterToString(localVarOptionals.UsernameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UsernameRe.IsSet() {
		localVarQueryParams.Add("username__re", parameterToString(localVarOptionals.UsernameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedUserList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Partial update a user object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this user.
 * @param optional nil or *UsersApiUsersUsersPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedUserRequest) - 
     * @param "Format" (optional.String) - 
@return User
*/

type UsersApiUsersUsersPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *UsersApiService) UsersUsersPartialUpdate(ctx context.Context, id string, localVarOptionals *UsersApiUsersUsersPartialUpdateOpts) (User, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue User
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v User
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Retrieve a user object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this user.
 * @param optional nil or *UsersApiUsersUsersRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return User
*/

type UsersApiUsersUsersRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *UsersApiService) UsersUsersRetrieve(ctx context.Context, id string, localVarOptionals *UsersApiUsersUsersRetrieveOpts) (User, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue User
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v User
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
UsersApiService
Update a user object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this user.
 * @param optional nil or *UsersApiUsersUsersUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return User
*/

type UsersApiUsersUsersUpdateOpts struct {
    Format optional.String
}

func (a *UsersApiService) UsersUsersUpdate(ctx context.Context, body UserRequest, id string, localVarOptionals *UsersApiUsersUsersUpdateOpts) (User, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue User
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v User
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
